var data = new Array(`1984`,`20240307183503-书摘 他把日记收在抽屉里。要想把它藏起来是没有用的，但是他至少要明确知道，它的存在是否被发现了。夹一根头发太明显了。于是他用手指尖蘸起一粒看不出的白色尘土来，放在日记本的封面上，如果有人挪动这个本子，这粒尘土一定会掉下来的。 她们是在下面地下的一个地方――比如说在一个井底里，或者在一个很深很深的坟墓里――但是这个地方虽然在他下面很深的地方，却还在下沉。她们是在一艘沉船的客厅里，通过越来越发黑的海水抬头看着他。客厅里仍有些空气，她们仍旧能看见他，他也仍旧能看见她们，但是她们一直在往下沉，下沉到绿色的海水中，再过一会儿就会把她们永远淹没不见了。 这是一片古老的、被兔子啃掉的草地，中间有一条足迹踩踏出来的小径，到处有田鼠打的洞。在草地那边的灌木丛中，榆树枝在微风中轻轻摇晃，簇簇树叶微微颤动，好象女人的头发一样。手边近处，虽然没有看见，却有一条清澈的缓慢的溪流，有小鲤鱼在柳树下的水潭中游弋。 脸上表情凄惨，好象一条沉船上不能得救的乘客一样。 "我对下一代没有兴趣，亲爱的。我只对我们自己有兴趣。" "你只是一个腰部以下的叛逆，"他对她说。 没有人会为了废除权力而夺取权力。权力不是手段，权力是目的。建立专政不是为了保卫革命；反过来进行革命是为了建立专政。`,``,`html`,`2503`,`20250327191348-日记 30 夜空飘着毛毛雨, 路灯照耀下如同星之尘埃 29 天又变冷了, 一冷就冒出一股子悲凉, 悲从何来, 悲将安去 28 现代的生活节奏很快, 许多事情不及细思就被带了过去, 难再有鲜明深刻的感情, 唯有教自己从容, 不致求盈余, 或可得真意 27 气量小则烦恼生, 这就是为什么最近得整天的空就去爬山, 面对眼前的庞然大物, 方寸间那点脾气还屑一提吗, 敬山必法山 南方的蚊子够毒, 夜半梦熟之际在耳边雷鼓聒噪, 晴天静坐依然豪饮不辍, 真枭雌也 26 今起写日记, 涂抹出自己的影子, 就像用铅笔和白纸给硬币拓印一样, 然而刚开始一定会对事实弯曲逃避, 刻意掩饰心底的污浊跟卑劣, 自愧心甚重, 但我期待接下来的慢慢改变, 将这些毒疮逐个挤出流脓, 这是痊愈的必经阶段`,``,`html`,`2504`,`20250419095003-日记 . 18 典故辞典看到q段, 过了一半, 从中见识到许多新鲜人文, 也细搜了相关的事件人物全貌, 不得不叹服, 古历史真是精彩 13 中国的井盖永远修不平, 驶过去总要狠狠颠你一下, 避之不及 11 住在二楼, 西窗外是一畦菜园, 搭着攀缘架, 有三棵番木瓜, 还有个一米见方的积水池, 晚间有蛙叫, 可谓水底笙歌蛙两部, 雅事, 不知鸣者为官乎私乎 07 处境像是波澜江心的破船一样, 东摇西晃, 我努力靠近岸边, 一边摇桨还要一边往外舀水 02 打坦克世界到凌晨四点, 越打越精神, 也不知长期心跳加速会怎样, 它确实能够振奋情绪, 但有点勒不住缰的样子, 通宵伤身, 诫勉`,``,`html`,`2505`,`20250501094628-日记 1 01 婚姻是正常人生命中的一个典型任务, 它藏于巫者手里抱着的那只抽奖箱, 幸运或厄运, 快来抽奖吧单身的男女们他兜售着, 我也想凑热闹抽一把, 但是作罢, 因为发现根本买不起抽奖券`,``,`html`,`abstract`,`20240616183123-_java 抽象类不能被实例化 抽象类可以没有抽象方法 抽象类可以包含构造方法,但不能被声明为抽象,在子类中通过super调用 抽象方法不包含方法体 包含抽象方法的类一定是抽象类 抽象类实现接口,接口中的方法在抽象类中可以不实现 继承抽象类的非抽象类,需要将抽象类中的抽象方法和接口中的方法全部实现,否则子类也应设为抽象类 调用抽象类中的静态方法,抽象类名.方法 调用抽象类中的非静态方法,需要一个继承该抽象类的非抽象类实例来调用该方法 static与abstract： abstract关键字用于定义抽象类和抽象方法。抽象方法是没有实现的方法，必须在子类中实现。 static关键字用于定义类级别的变量和方法。static方法是属于类本身的方法，而不是某个具体对象的方法。 由于abstract方法需要在子类中实现，而static方法不能被子类重写，因此abstract和static是相互冲突的，不能同时使用。 final与abstract： final关键字用于定义不可更改的类、方法和变量。final方法不能被子类重写。 abstract方法需要在子类中实现，因此abstract方法不能是final的，因为这会阻止子类提供实现。 private与abstract： private关键字用于定义私有成员，私有成员只能在它们所属的类中访问。 abstract方法必须由子类实现，因此abstract方法不能是private的，因为这会阻止子类访问和实现该方法。`,``,`html`,`AJAX`,`20240521124656-_前端 Asynchronous Javascript And XML AJAX 是一种技术组合：它结合了 JavaScript、HTTP 请求、服务器端处理和数据格式（如 JSON 或 XML） AJAX 使用 JavaScript 来发起异步 HTTP 请求，这意味着请求在后台进行，不会阻塞用户界面的更新或其他操作, 因此可以在不刷新页面的前提下进行局部更新 AJAX 本身不是 JavaScript, 但它依赖于 JavaScript 进行操作 它不是W3C的标准 XMLHttpRequest对象的方法属性 20240702140343.webp 三种请求方式 <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Title</title> <script src="js/jquery-1.11.1.min.js"></script> <script> //使用 XMLHttpRequest 进行 AJAX 请求 function postData() { var name = encodeURIComponent(document.getElementById("name").value); var age = encodeURIComponent(document.getElementById("age").value); var url = "/page24"; if (window.XMLHttpRequest) xhr = new XMLHttpRequest();//IE7+等现代浏览器 else xhr = new ActiveXObject(Microsoft.XMLHTTP);//IE5,6 //第三个参数决定在发送的过程中,程序是否继续向下执行, true异步请求, false同步请求(如果数据没有返回,则send()一直处于阻塞状态) xhr.open("POST", url, true); xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xhr.onreadystatechange = function() { if (xhr.readyState === 4 && xhr.status === 200) { document.getElementById("result").innerHTML = xhr.responseText + "XMLHttpRequest"; } }; var data = "name=" + name + "&age=" + age; xhr.send(data); // 同步请求时 /* xhr.open("POST", url, false); xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); var data = "name=" + name + "&age=" + age; xhr.send(data); // 直接在 send() 之后检查 readyState 和 status 并处理响应 if (xhr.readyState === 4) { // 请求已完成 if (xhr.status === 200) { console.log(xhr.responseText); } else { console.error("Error:", xhr.status, xhr.statusText); } } */ } //使用 fetch API 进行 AJAX 请求 //fetch方法是JavaScript内置的一个现代API，用于进行网络请求。它是XMLHttpRequest的现代替代品，提供了一种更简单、更强大的方式来发起HTTP请求 function postData2() { var name = encodeURIComponent(document.getElementById("name").value); var age = encodeURIComponent(document.getElementById("age").value); var url = "/page24"; fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: "name=" + name + "&age=" + age }) .then(response => response.text()) .then(data => { document.getElementById("result").innerHTML = data + "fetch"; }) .catch(error => console.error('Error:', error)); } //使用 jQuery 简化 AJAX 请求的编写 $(document).ready(function() { $('#submitBtn').click(function() { var name = $('#name').val(); var age = $('#age').val(); $.ajax({ type: 'POST', url: '/page24', //data: "name=" + name + "&age=" + age, data: { name: name, age:age }, //如果后端返回的是纯文本而不是 JSON 数据，dataType 应该省略或设置为 "text" //dataType: 'json', success: function(response) { $('#result').html(response + "jquery"); }, //xhr:XMLHttpRequest 对象, status:表示错误类型的字符串如"timeout", error：表示错误信息的字符串 //error: function(xhr, status) { //两参 error: function(xhr, status, error) { //三参 $('#result').html('Error: ' + error); switch(xhr.status){ case "405" : console.log("无效的请求方式");break; //例如type为post,但servlet中未写doPost方法 case "404" : console.log("未找到url资源");break; case "500" : console.log("服务器内部错误");break; default : console.log("error"); } } }); }); }); //------------------------------------------------------------------ function getData() { var name = encodeURIComponent(document.getElementById("name2").value); var age = encodeURIComponent(document.getElementById("age2").value) var url = "/page25?name=" + name + "&age=" + age; if (window.XMLHttpRequest) xhr = new XMLHttpRequest();//IE7+等现代浏览器 else xhr = new ActiveXObject(Microsoft.XMLHTTP);//IE5,6 //GET方式可能得到的是缓存的结果, 可以在url后添加一个唯一的查询参数来防止缓存,如随机数或当前时间戳 //xhr.open("GET", url + "&timestamp=" + Math.random(), true); xhr.open("GET", url + "&random=" + new Date().getTime(), true); xhr.onreadystatechange = function() { if (xhr.readyState === 4 && xhr.status === 200) { document.getElementById("result2").innerHTML = xhr.responseText + "XMLHttpRequest"; } }; xhr.send(); } function getData2() { var name = encodeURIComponent(document.getElementById("name2").value); var age = encodeURIComponent(document.getElementById("age2").value); var url = "/page25?name=" + name + "&age=" + age; fetch(url) .then(response => { if (!response.ok) { throw new Error('Network response was not ok ' + response.statusText); } return response.text(); }) .then(data => { document.getElementById("result2").innerHTML = data + "fetch"; }) .catch(error => { console.error('There has been a problem with your fetch operation:', error); }); } $(document).ready(function() { $("#submitBtn2").click(function() { var name = $("#name2").val(); var age = $("#age2").val(); $.ajax({ type: 'GET', cache: false, // 设置为 false 以防止缓存 url: '/page25', data: { name: name, age:age }, success: function(response) { $("#result2").html(response + "jquery"); }, error: function(xhr, status, error) { console.error("There was an error with your request:", status, error); } }); }); }); </script> </head> <body> <form> <label for="name">Name:</label> <input type="text" id="name" name="name"><br> <label for="age">Age:</label> <input type="text" id="age" name="age"><br> <button type="button" onclick="postData()">post_XMLHttpRequest</button><br> <button type="button" onclick="postData2()">post_fetch</button><br> <button type="button" id="submitBtn">post_jquery</button> </form> <div id="result"></div><br> <form> <label for="name2">Name2:</label> <input type="text" id="name2" name="name2"><br> <label for="age2">Age2:</label> <input type="text" id="age2" name="age2"><br> <button type="button" onclick="getData()">get_XMLHttpRequest</button><br> <button type="button" onclick="getData2()">get_fetch</button><br> <button type="button" id="submitBtn2">get_jquery</button> </form> <div id="result2"></div> </body> </html> public class AjaxTest { @WebServlet("/page24") public static class Ajax1 extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { String name = req.getParameter("name"); String age = req.getParameter("age"); resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/plain"); resp.getWriter().write("[POST] hello," + name + ":" + age + " "); } } @WebServlet("/page25") public static class Ajax2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { String name = req.getParameter("name"); String age = req.getParameter("age"); resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/plain"); resp.getWriter().write("[GET] hello," + name + ":" + age + " "); } } } 例 轮播新闻 <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Title</title> <script src="js/jquery-1.11.1.min.js"></script> <script> var interval = null; function getData() { var xhr; var news; var current = 0; if (window.XMLHttpRequest) xhr = new XMLHttpRequest(); else xhr = new ActiveXObject("Microsoft.XMLHTTP"); xhr.open("GET", "/page26?random=" + new Date().getTime(), true); xhr.onreadystatechange = function() { if (xhr.readyState === 4 && xhr.status === 200) { news = JSON.parse(xhr.responseText); clearInterval(interval); interval = setInterval(function() { if (current === news.length) current = 0; document.getElementById('content').innerHTML = "<h1>XMLHttpRequest</h1>" + "<h1>" + news[current].title + "</h1>" + "<span>" + news[current].date + " " + news[current].category + "</span><br>" + "<p>" + news[current].content + "</p>"; current++; }, 3000); } }; xhr.send(); } function getData2() { var news; var current = 0; fetch("/page26?random=" + new Date().getTime()) .then(response => { if (!response.ok) { throw new Error('Network response was not ok ' + response.statusText); } return response.json(); }) .then(data => { news = data; clearInterval(interval); interval = setInterval(function() { if (current === news.length) current = 0; document.getElementById('content').innerHTML = "<h1>fetch</h1>" + "<h1>" + news[current].title + "</h1>" + "<span>" + news[current].date + " " + news[current].category + "</span><br>" + "<p>" + news[current].content + "</p>"; current++; }, 3000); }) .catch(error => { console.error('There has been a problem with your fetch operation:', error); }); } $(document).ready(function() { $("#submitBtn").click(function() { var current = 0; $.ajax({ type: 'GET', cache: false, url: '/page26', dataType: 'json', success: function(news) { clearInterval(interval); interval = setInterval(function() { if (current === news.length) current = 0; $("#content").html( "<h1>jquery</h1>" + "<h1>" + news[current].title + "</h1>" + "<span>" + news[current].date + " " + news[current].category + "</span><br>" + "<p>" + news[current].content + "</p>" ); current++; }, 3000); }, error: function(xhr, status, error) { console.error("There was an error with your request:", status, error); } }); }); }); </script> </head> <body> <form> <button type="button" onclick="getData()">get_XMLHttpRequest</button> <button type="button" onclick="getData2()">get_fetch</button> <button type="button" id="submitBtn">get_jquery</button> </form> <br> <div id="content"></div> </body> </html> @WebServlet("/page26") public class NewsServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { List<News> list = new ArrayList(); list.add(new News("标题1","2024-1","分类1","今天天气真晴朗")); list.add(new News("标题2","2024-2","分类2","今天天气好晴朗")); list.add(new News("标题3","2024-3","分类3","今天天气很晴朗")); String jsonString = JSON.toJSONString(list); resp.setCharacterEncoding("UTF-8"); resp.getWriter().println(jsonString); } } 例 二级菜单联动 @WebServlet("/page29") public class MenuLinkageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String level = req.getParameter("level"); String subTitle = req.getParameter("subTitle"); List<Category> list = new ArrayList<>(); if (level.equals("1")) { list.add(new Category("AI","人工智能")); list.add(new Category("Web","网络应用")); } else if (level.equals("2")) { if (subTitle.equals("AI")) { list.add(new Category("Arithmetic","算法")); list.add(new Category("BlockChain","区块链")); } else if (subTitle.equals("Web")) { list.add(new Category("HTML", "超文本标记语言")); list.add(new Category("CSS", "样式表")); } } Gson gson = new Gson(); String json = gson.toJson(list); resp.setContentType("text/html;charset=UTF-8"); resp.getWriter().write(json); } } <html> <head> <title>Title</title> <script src="js/jquery-1.11.1.min.js"></script> <script> $(function () { $.ajax({ url: "/page29", type: "get", data: {"level": "1"}, dataType: "json", success: function (data) { for (let i = 0; i < data.length; i++) { $("#level1").append("<option value='" + data[i].name + "'>" + data[i].description + "</option>"); } } }) $("#level1").on("change", function () { $.ajax({ url: "/page29", type: "get", data: {"level": "2", "subTitle": $(this).val()}, dataType: "json", success: function (data) { // document.getElementById("lv2").options.length=0; // $("#lv2>option").remove(); $("#level2").empty(); for (let i = 0; i < data.length; i++) { $("#level2").append("<option value='" + data[i].name + "'>" + data[i].description + "</option>"); } } }) }) }) </script> </head> <body> <select id="level1"> <option selected="selected">请选择</option> </select> <select id="level2"></select> </body> </html>`,``,`html`,`Animal Farm`,`20240307183503-双语`,``,`html`,`Apache虚拟域名的使用`,`20250210222831-_工具使用 下载解压(c盘根下为例)，管理员命令窗 https://www.apachelounge.com/download/ cd \Apache24\bin httpd -k install -n Apache httpd -v httpd.conf C:\Apache24\conf\httpd.conf # 根目录 DocumentRoot "E:/Dropbox/life" <Directory "E:/Dropbox/life"> Options Indexes FollowSymLinks AllowOverride None Require all granted </Directory> # 启用 LoadModule headers_module modules/mod_headers.so # 末尾添加 <IfModule mod_headers.c> Header Set Access-Control-Allow-Origin "*" </IfModule> 加入自启 C:\Apache24\bin\ApacheMonitor.exe # win + r shell:startup`,``,`html`,`bat范例`,`20240307183503-_工具使用 batch对空格缩进要求不严格, 可以缩进排版增加易读性 常用命令 //中止正在执行的命令, 手势右键上滑 Ctrl+C //命令详细参数 /? //补全 tab //清屏 cls //历史 up/down xcopy之排除 //要排除的文件清单.txt, 含中文以ANSI编码 .hg\ css .bat .hgignore exclude.txt //txt含义如下: 排除了2个文件夹： .hg css 排除了2种类型的文件： .bat .hgignore 排除了1个文件： exclude.txt robocopy多线程复制 /MAXAGE:n 最长的文件存在时间 - 排除早于 n 天/日期的文件。 /XF 文件[文件]... 排除与给定名称/路径/通配符匹配的文件。 /XD 目录[目录]... 排除与给定名称/路径匹配的目录。 /MIR 镜像目录树(等同于 /E 加 /PURGE)。 /NOCOPY 不复制任何文件信息(与 /PURGE 一起使用)。 /MT[:n] 使用 n 个线程进行多线程复制(默认值为 8)。n 必须至少为 1，但不得大于 128。该选项与 /IPG 和 /EFSRAW 选项不兼容。使用 /LOG 选项重定向输出以便获得最佳性能。 将文件或文件夹复制到另一个驱动器时，通常都使用（GUI 中）标准的选择、复制和粘贴操作。虽然默认的批量文件复制和移动功能在 Windows 10 操作系统中已经历经过微软多次优化，已经能够工作得很好，但当尝试传输大批量文件（特别是大量小文件）时，还是需要很长时间，速度就成了一个瓶颈。 robocopy最为特殊也经常被忽略的是其支持多线程的能力，允许我们同时复制多个文件，而不像在「文件管理器」中复制文件时只能一次一个（移动多个文件时也只是列队之后一个一个移动）。 镜像 #&@cls&echo off&powershell -c "type %~0|out-string|iex"&pause&exit robocopy D:\Dropbox E:\Dropbox_mirror /mir /MT:100 在Windows默认的复制粘贴下，如果已存在一个同名文件夹，系统会进行增量复制，而不会进行文件夹的替换操作。 "/mir"的作用等同于"/purge /e"，"/purge"表示清理目标文件夹内有而源文件夹里没有的文件和文件夹。通过这个命令，能保证源文件夹和目标文件夹在结构与内容上完全相同。此参数对于创建镜像备份时是非常有用的。 按文件的修改日期生成日期文件夹,将文件分散其中 @ECHO OFF&setlocal enabledelayedexpansion set "SrcDir=C:\Users\ida\Desktop\test" cd /d "%SrcDir%" for /f "tokens=1-3 delims=" %%a in ('dir /a-d/b') do ( set "write_date=%%~ta" set "write_date=!write_date:/=!" set "write_date=!write_date:~0,4!!write_date:~4,4!" if not exist !write_date! md "!write_date!" move /y "%%a" "!write_date!" ) 批量修改文件/文件夹的创建时间与修改时间 @ECHO OFF powershell.exe -command "Get-Childitem -path 'C:\Users\ida\Desktop\test' -Recurse | foreach-object { $_.LastWriteTime = '02/12/2023 22:13:36'; $_.CreationTime = '02/12/2023 22:13:36' }" PAUSE 查看wifi密码 netsh wlan show profiles netsh wlan show profiles name="WiFi_NAME" key=clear 按名称升序合并txt章节小说 type *.txt>>all.txt`,``,`html`,`bitlocker`,`20240307183503-_工具使用 全盘加密后,设置TPM+PIN, 此后无法对移动硬盘加密, 先禁用附加身份验证, 加密完成后再启用 验证方式 仅TPM验证： 这是一种透明运行模式：此模式使用TPM芯片硬件的功能来提供透明的用户体验 – 如果没有意外，用户可以像正常时一样启动并登录到Windows。用于全盘加密的密钥由TPM芯片存储，且在未检测到有对早期启动组件的修改的情况下才会释放到OS加载代码中。这是默认的验证模式，但这种模式无法防范诸如笔记本整体被盗之类的物理攻击。 仅口令（PIN）： 类似于 Windows 的登陆密码，输入正确的 PIN 后会解密磁盘并启动，可以防范物理攻击，但由于缺乏硬件安全能力，仅靠软件无法实现对 BIOS 和 MBR 的早期检查功能。 仅USB-Key： 使用这个方式则会在设置 Bitlocker 时要求你选择一个 U盘 用于存储验证密钥，此后每次启动都需要插入这个 U盘 ，待系统验证密钥后可正常启动。同样仅靠软件无法实现对 BIOS 和 MBR 的早期检查功能，并且注意如果你的 U盘 和电脑一起被盗则无法发挥保护效果。 TPM+PIN（推荐）： 启动系统时首先由 TPM 对系统底层和启动组件进行检查和验证，若正常则要求用户输入 PIN ，两项验证均通过后释放密钥并开始启动系统。这种验证方式能够提供完整的保护能力也可防御物理攻击。 TPM+USB-Key： 与上一种类似，只不过是把手动输入的 PIN 换成了U盘中的密钥。有完整保护能力，但同样需要注意如果你的 U盘 和电脑一起被盗则无法发挥保护效果。 TPM+PIN+USB-Key： 究极保护方式，有三重验证，不过一般真用不着，而且可能会带来麻烦（尤其是我这种喜欢丢U盘的）。启动时需要 3 个验证均通过才会释放密钥。这种验证方式能够提供完整的保护能力也可防御物理攻击。 TPM+PIN 1：启用BitLocker(如果您尚未启用)，如果没有移动硬盘，选择打印，从pdf上复制密钥文本 2：在组策略编辑器中打开“计算机配置”>“管理模板”>“Windows组件”>“BitLocker驱动器加密”>“操作系统驱动器”>“启动时需要附加身份验证”>切换为“已启用”，关闭“没有兼容的TPM时允许Bitlocker”功能，选择“允许TPM”，“有TPM时需要启动PIN”，保存更改。 3：将PIN密码添加到您的驱动器，以管理员身份运行以下命令。下面的命令适用于您的C：驱动器，系统将提示您在此处输入PIN。输入过程不可见。 manage-bde -protectors -add c: -TPMAndPIN 要再次检查是否添加了TPMAndPIN保护器，可以直接运行以下命令： manage-bde -status 要在将来更改PIN，请以管理员身份打开命令提示符窗口，然后运行以下命令： manage-bde -changepin c: 在继续之前，您需要键入并确认您的新PIN	 如果您改变主意并希望以后停止使用PIN，您可以撤消此更改。 首先，您需要转到“组策略”窗口，并将选项改回“允许使用TPM启动PIN”。您不能将该选项设置为“要求使用TPM启动PIN”，否则Windows将不允许您删除PIN。 接下来，以管理员身份打开命令提示符窗口，然后运行以下命令： manage-bde -protectors -add c: -TPM 这将用“TPM”要求替换“TPMandPIN”要求，删除PIN。启动时，BitLocker驱动器将通过计算机的TPM自动解锁。	 要检查此操作是否成功完成，请再次运行status命令： manage-bde -status c: https://blog.nannan.cool/archives/279/`,``,`html`,`DNS`,`20240307183503-_工具使用 8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8888 dns.google 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001 dns.cloudflare.com 1dot1dot1dot1.cloudflare-dns.com`,``,`html`,`Docker`,`20240601141418-_环境容器 Docker是一个用来装程序及其环境的容器,属于Linux容器的一种封装,提供简单易用的容器使用接口 Docker 和分布式系统有密切的关系，Docker 作为容器化平台，为构建、部署和管理分布式系统提供了重要的支持和便利 提供统一的环境,可以确保应用程序在不同的环境中（如开发、测试、生产）具有一致的运行环境，从而减少由于环境差异导致的问题 隔离的运行环境，确保不同服务或微服务在同一台主机上运行时不会互相干扰 使用 Docker 和容器编排工具（如 Kubernetes），可以动态地扩展或缩减服务实例的数量，以应对不同的负载需求 减少了传统虚拟化技术的资源开销。容器可以在同一台主机上运行多个实例，提高了资源利用率 20240601152214.webp 将镜像推到仓库, 各种测试都针对的是相同的镜像 20240601152215.webp Docker与虚拟机的区别 20240601151254.webp UnionFS UnionFS（联合文件系统）是一种文件系统服务，可以将多个目录合并成一个文件系统。它通常用于 Linux 容器环境，如 Docker 和 Kubernetes，以实现层级存储和文件系统的快照功能 关键特性 将多个目录或文件系统层级合并成一个统一的文件系统视图。 每个层可以是只读或读写。 可以创建文件系统的快照和增量快照，方便版本控制和回滚。 通过共享未修改的层，实现高效的存储利用率。 只有修改的层需要额外的存储空间。 UnionFS 在 Docker 中的应用 镜像层： Docker 镜像由多个只读层组成，每层代表镜像的一次变更（如安装软件包、修改配置等）。 这些层按照顺序叠加，形成完整的文件系统视图。 20240812202341.webp 容器层： 当容器启动时，Docker 在镜像层之上添加一个可写层，称为容器层。 容器运行时的所有修改（新增文件、修改文件等）都发生在这个可写层。 容器的这一层是可以修改的,而镜像是不可以修改的 例如镜像内有一个apache的配置文件, 在容器层对其进行修改, 因为镜像是只读的, 因此实际上是将其复制一份到容器层进行修改, 文件查找时从最上层向下找 20240812202734.webp 镜像和容器的共享： 不同的容器可以共享相同的镜像层，提高存储效率。 只有容器层是独立的，确保容器之间的隔离。 同一个镜像可以生成多个容器独立运行,而他们之间没有任何的干扰, 生成一个容器,就会产生一个容器文件, 不会因容器的关闭而被删除 仓库 hub.docker.com 20240601170504.webp client 提供给用户一个终端,用户输入Docker提供的命令来管理本地或远程的服务器 deamon 服务端守护进程, 接收client发送的命令并执行相应的操作 安装docker #查看centOS版本信息 cat /etc/redhat-release #如果没有代理, 配置境内yum源 #wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo #yum clean all #yum makecache #如果之前安装过docker, 卸载旧版本,较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项 #使用空格加一个反斜杠来表示命令在下一行继续，以便使长命令在编写脚本时更易读。直到输入完成并按回车键结束整条命令，系统才会执行命令 yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine #检查更新 yum check-update #安装更新 yum update #安装所需的软件包, 这些包允许 yum 使用 yum-config-manager #安装 yum-utils、device-mapper-persistent-data 和 lvm2 三个包。 #yum install -y yum-utils device-mapper-persistent-data lvm2 yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 #添加 Docker 的官方仓库 #如果没有代理, 境内yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo #查看docker版本 yum list docker-ce --showduplicates | sort -r #安装指定的版本 yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io #装完成后，运行下面的命令，验证是否安装成功。 docker version #查看docker状态 docker info #Docker 是服务器-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启停和确认状态 systemctl start docker systemctl stop docker systemctl status docker docker容器操作 #查看本机有哪些镜像 docker images #拉取测试镜像, 默认目录为library可不写, 默认tag为latest #docker pull library/hello-world:latest docker pull hello-world #运行测试镜像, docker run [OPTIONS] IMAGE [COMMAND] [ARG...] docker run hello-world #为了生成这条信息，Docker 采取了以下步骤： # 1. Docker 客户端连上 Docker 守护进程(服务端)。 # 2. Docker 守护进程从 Docker Hub 提取 “hello-world ”镜像。 # 3. Docker 守护进程从该镜像文件中创建了一个新容器，该容器运行的可执行文件，产生你正在阅读的输出结果。 # 4. Docker 守护进程将输出流式传输到 Docker 客户端，然后将其发送到你的终端。 #搜索镜像 docker search nginx #拉取nginx镜像 docker pull nginx:1.13.0 #前台运行, ctrl+c停止 docker run nginx:1.13.0 #使用 docker run 命令创建一个新的容器时，可以使用 --name 选项指定容器名称。例如，创建一个名为 my_nginx 的 Nginx 容器, -d后台运行并打印出容器id #重命名容器 docker rename old_name new_nam 这不会停止或重新启动容器，容器会继续运行，只是名称会被更改 docker run --name my_nginx -d nginx #列出所有容器，-a包括已停止的容器 docker ps -a #停止一个运行中的 Docker 容器, 容器id不必写完整,写出开头字符确保能惟一识别即可 docker stop container_id_or_name #恢复运行已停止的容器 docker start container_id_or_name #删除容器 docker rm container_id_or_name #进入运行中的容器内部 #-i, 交互式 STDIN 即使未连接也保持打开状态, STDIN（标准输入）是计算机程序从外部获取输入数据的默认通道 #-t, 分配伪TTY, TTY（伪终端）指的是计算机终端，"teletypewriter"（电传打字机）的缩写 #-i 和 -t 选项一起使用，以交互方式运行命令并获得一个伪终端 #调用容器内部的bash命令, 容器id不必写完整,写出开头字符确保能惟一识别即可 docker exec -it 83c bash pwd ls #touch 命令用于更新文件的访问和修改时间戳。如果文件不存在，touch 会创建一个空文件 touch a.txt ls rm a.txt #查找 nginx 可执行文件的路径 which nginx #从 Docker 容器内部退出, 输入 exit 或按 Ctrl + D exit #宿主机端口映射到容器内端口, 宿主机端口:容器内端口 #端口映射是在容器创建时指定的，所以如果你想要修改端口映射，就需要重新创建容器, 大写P表示docker会随机选择一个宿主机端口映射到容器内部开放的网络端口上 docker run --name my_nginx2 -d -p 8080:80 nginx:1.13.0 #显示容器的IP地址 docker inspect my_nginx2 docker inspect my_nginx2|grep IPAddress 网络模式 Docker 提供了三种主要的网络模式（网络驱动）来管理容器之间以及容器与外部世界之间的网络连接。 Bridge 网络（桥接网络） 桥接网络是 Docker 的默认网络模式。在这种模式下，每个容器都会连接到一个虚拟桥接器（docker0），并且每个容器都会获得一个独立的 IP 地址。 容器之间可以通过 IP 地址或容器名称通信。 宿主机可以通过桥接网络访问容器。 可以通过 docker network create 创建自定义的桥接网络，并通过 docker run --network 指定容器使用哪个网络。 Host 网络（主机网络） 在主机网络模式下，容器共享宿主机的网络栈。容器不会获得独立的 IP 地址，而是使用宿主机的 IP 地址。 容器中的应用程序将直接使用宿主机的网络接口。 性能较高，因为减少了网络虚拟化的开销。 可能会导致端口冲突，因为容器和宿主机共享同一组端口。 None 网络（无网络） 无网络模式下，容器没有任何网络接口。通常用于对网络隔离要求非常高的情况。 容器之间以及容器与宿主机之间不能通过网络通信。 适用于不需要网络功能的应用程序或严格的安全需求。 Docker的端口映射是通过网络地址转换（NAT）实现的。当容器启动时，Docker会在宿主机上创建一个iptables规则，将容器内部的应用服务端口映射到宿主机上的一个随机可用端口。这样，当外部请求访问宿主机的映射端口时，iptables规则会将请求转发到容器内部的应用服务端口。 当在 Docker 中进行端口映射时，即使宿主机没有开放任何端口，Docker 仍会在宿主机上创建相应的 iptables 规则。这是因为 Docker 使用 iptables 来管理流量的转发规则 Dockerfile Dockerfile 是用来定义一个 Docker 镜像的文件，通过一系列指令描述如何构建镜像 每条指令会在镜像构建时创建一个新的层。 Dockerfile 通常包括基础镜像的选择、依赖项的安装、文件的复制、命令的执行等步骤 通过这个文件可以直观的了解到镜像的组成结构 #FROM指定基础镜像。所有的 Dockerfile 都必须以 FROM 指令开始。 #alpine是一个轻量级的 Linux 发行版，特别适合用于 Docker 镜像中，因为它的体积非常小，可以显著减少镜像的大小。通常，Alpine 镜像用于创建更精简、更高效的 Docker 镜像 #maintainer维护者 #构建镜像: 在包含 Dockerfile 的目录中运行以下命令，指定镜像名称和标签（可选）, -t 给镜像命名, 点（.）使用当前目录中的 Dockerfile 和所有相关文件来构建镜像 cd /root cat > Dockerfile << EOF > FROM alpine:lasted > MAINTAINER ida > CMD echo 'ok, bro' > EOF docker build -t first_docker_image . docker images docker run first_docker_image`,``,`html`,`dropbox`,`20240307183503-_工具使用 同步忽略 # PowerShell # 忽略 Set-Content -Path 'D:\Dropbox\workspace\idea\practice\out' -Stream com.dropbox.ignored -Value 1 Set-Content -Path 'D:\Dropbox\workspace\idea\practice\target' -Stream com.dropbox.ignored -Value 1 # 取消忽略 Clear-Content -Path 'D:\Dropbox\workspace\idea\practice\out' -Stream com.dropbox.ignored Clear-Content -Path 'D:\Dropbox\workspace\idea\practice\target' -Stream com.dropbox.ignored 收集邮件的图片附件 忽略邮件正文,仅收集附件,存到网盘中名为Email Attachments的文件夹 单封邮件附件数量上限100,总体积20MB以内`,``,`html`,`Dubbo`,`20240615135002-_微服务 20240821133460.webp 服务容器： 负责启动、加载和运行服务提供者。服务容器可以是一种轻量级的容器，如Docker，也可以是一个运行时环境，如Java的Spring框架。 服务提供者： 在启动时，向注册中心注册自己提供的服务。服务提供者可以是一个独立的服务实例，也可以是一个部署在容器中的服务。 服务消费者： 在启动时，向注册中心订阅自己所需的服务。消费者可以是一个应用程序、一个服务网关或者一个负载均衡器。 监控中心: 两者都需要定期发送一次统计数据到监控中心`,``,`html`,`Dubbo课程查询`,`20240615135002-_项目例 生产者的职责：生产者主要负责将服务注册到注册中心，而不是从注册中心获取服务信息或进行服务调用。因此，它不需要关注连接超时的问题。 消费者的职责：消费者则需要从注册中心获取服务信息，并与服务进行调用，这些操作需要超时控制以防止连接或请求过长时间挂起 结构 demo21 producer consumer pom demo21 <groupId>com.ida.demo21</groupId> <artifactId>demo21</artifactId> <version>1.0-SNAPSHOT</version> <packaging>pom</packaging> <modules> <module>producer</module> <module>consumer</module> </modules> <properties> <!-- .. --> <spring-boot.version>2.3.12.RELEASE</spring-boot.version> <dubbo.version>2.7.4.1</dubbo.version> </properties> <dependencyManagement> <dependencies> <!-- boot --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>&#36;{spring-boot.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!-- dubbo --> <dependency> <groupId>org.apache.dubbo</groupId> <artifactId>dubbo-dependencies-bom</artifactId> <version>&#36;{dubbo.version}</version> <type>pom</type> <scope>import</scope> </dependency> <dependency> <groupId>org.apache.dubbo</groupId> <artifactId>dubbo</artifactId> <version>&#36;{dubbo.version}</version> <exclusions> <exclusion> <groupId>org.springframework</groupId> <artifactId>spring</artifactId> </exclusion> <exclusion> <groupId>javax.servlet</groupId> <artifactId>servlet-api</artifactId> </exclusion> <exclusion> <groupId>log4j</groupId> <artifactId>log4j</artifactId> </exclusion> </exclusions> </dependency> </dependencies> </dependencyManagement> producer <!-- 父模块 --> <parent> <groupId>com.ida.demo21</groupId> <artifactId>demo21</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>producer</artifactId> <dependencies> <!-- boot依赖 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!-- mysql,mybatis --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>2.1.1</version> </dependency> <!-- dubbo --> <dependency> <groupId>org.apache.dubbo</groupId> <!-- 这是 Dubbo 提供的 Spring Boot 启动器，旨在简化 Dubbo 与 Spring Boot 的集成 --> <artifactId>dubbo-spring-boot-starter</artifactId> <version>&#36;{dubbo.version}</version> </dependency> <dependency> <groupId>org.apache.dubbo</groupId> <!-- 这是 Dubbo 的核心库，包含了 Dubbo 框架的主要实现和功能。它包括了 Dubbo 的协议、通信、负载均衡等核心功能 --> <artifactId>dubbo</artifactId> </dependency> <!-- zookeeper --> <dependency> <groupId>org.apache.dubbo</groupId> <artifactId>dubbo-dependencies-zookeeper</artifactId> <version>&#36;{dubbo.version}</version> <type>pom</type> <exclusions> <exclusion> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> </exclusion> </exclusions> </dependency> </dependencies> consumer <!-- 父模块 --> demo21 <artifactId>consumer</artifactId> <dependencies> <!-- boot依赖 --> spring-boot-starter-web <!-- mysql,mybatis --> mysql-connector-java mybatis-spring-boot-starter <!-- dubbo --> dubbo-spring-boot-starter dubbo <!-- zookeeper --> dubbo-dependencies-zookeeper <!-- 模块依赖 --> <dependency> <groupId>com.ida.demo21</groupId> <artifactId>producer</artifactId> <version>1.0-SNAPSHOT</version> <scope>compile</scope> </dependency> </dependencies> properties producer # dubbo dubbo.registry.address=zookeeper://192.168.149.136:2181 dubbo.config-center.timeout=30000 dubbo.application.name=course-list producer.service.version=1.0.0 dubbo.scan.base-packages=com.ida.demo21.producer.service.impl dubbo.protocol.host=192.168.149.1 dubbo.protocol.port=-1 dubbo.protocol.name=dubbo dubbo.registry.file=/usr/local/zookeeper/reg.cache spring.application.name=course-list # datasource spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/course?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true spring.datasource.username=root spring.datasource.password=root # mybatis mybatis.mapper-locations=classpath:mappers/*.xml mybatis.configuration.map-underscore-to-camel-case=true # logback logging.pattern.console=%clr(%d{&#36;{LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS}}){faint} %clr(&#36;{LOG_LEVEL_PATTERN:-%5p}) %clr(&#36;{PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n&#36;{LOG_EXCEPTION_CONVERSION_WORD:%wEx} # 使用位于 192.168.149.136、端口为 2181 的 ZooKeeper 进行服务注册和发现 dubbo.registry.address=zookeeper://192.168.149.136:2181 # 与配置中心交互时的超时时间, 例如连接zkl默认5秒, 超过则zookeeper not connected dubbo.config-center.timeout=30000 # 在服务注册、发现和调用过程中进行标识和管理 dubbo.application.name=course-list # 服务版本 producer.service.version=1.0.0 # 在指定的包中查找服务实现，并将其注册以进行 RPC 通信 dubbo.scan.base-packages=com.ida.demo21.producer.service.impl # 服务暴露的主机地址, 帮助在多网卡环境或特定网络配置下明确服务的绑定地址, 如果不设置通常会自动选择本地的网络接口地址 dubbo.protocol.host=192.168.149.1 # 服务暴露时使用的端口号, -1表示随机可用的端口, 未声明此属性时随机选择一个可用端口来暴露服务 # 注册中心（如 ZooKeeper）会记录生产者暴露服务时所使用的随机端口号，并将其注册在注册中心中。消费者在调用服务时，会从注册中心获取到生产者的服务地址（包括随机分配的端口号) dubbo.protocol.port=-1 # 服务暴露时使用的协议 [dubbo,rest,hessian,rmi,webservice], 未声明此属性时默认dubbo, 消费者会自动从注册中心获取到服务提供者的协议信息，并根据提供者使用的协议来调用服务 dubbo.protocol.name=dubbo # 在服务注册时，生产者会将服务信息缓存到这个文件中, 在注册中心不可用时，提供一定程度的服务容错能力 dubbo.registry.file=/usr/local/zookeeper/reg.cache # server.port 服务间调用时不对外开放 spring.application.name=course-list consumer # dubbo dubbo.registry.address=zookeeper://192.168.149.136:2181 dubbo.config-center.timeout=30000 dubbo.application.name=course-price dubbo.consumer.timeout=10000 dubbo.registry.timeout=10000 dubbo.registry.file=D:\\mess\\zk\\producer.cache producer.service.version=1.0.0 server.port=9021 spring.application.name=course-price # datasource # mybatis # logback # 使用位于 192.168.149.136、端口为 2181 的 ZooKeeper 进行服务注册和发现 dubbo.registry.address=zookeeper://192.168.149.136:2181 # 与配置中心交互时的超时时间, 例如连接zk默认5秒, 超过则zookeeper not connected dubbo.config-center.timeout=30000 # 在服务注册、发现和调用过程中进行标识和管理 dubbo.application.name=course-price # 消费者模块等待提供者响应的最长时间 dubbo.consumer.timeout=10000 # 消费者在与注册中心建立连接、发送请求或获取服务列表时的最大等待时间 dubbo.registry.timeout=10000 # 在服务订阅时，消费者会将服务的注册信息缓存到这个文件中,在注册中心不可用时，提供一定程度的服务容错能力 dubbo.registry.file=D:\\mess\\zk\\consumer.cache # 所订阅服务的版本 producer.service.version=1.0.0 # consumer在从producer处拿数据后对外服务因此需要暴露端口 server.port=9021 差异 producer 生产者不提供控制器类, 不需要对外暴露 方法签名涉及的实体类需标记Serializable 服务类 //@Service为org.apache.dubbo包下的注解, 版本号必需 @Service(version = "&#36;{producer.service.version}") public class CourseListServiceImpl implements CourseListService { @Resource private CourseMapper courseMapper; @Override public List<Course> getCourseList(){ return courseMapper.selectList(); } } 启动类 @EnableAutoConfiguration //替代@SpringBootApplication注解 @MapperScan(basePackages = "com.ida.demo21.producer.dao") public class ProducerApplication { public static void main(String[] args) { SpringApplication.run(ProducerApplication.class,args); } } consumer 消费者调用生产者服务取得数据, 通过控制器类正常向外暴露 服务类 @Service("courseService") public class CoursePriceServiceImpl implements CoursePriceService { @Resource private CoursePriceMapper coursePriceMapper; // 调用时使用此处注解, 版本号必需, org.apache.dubbo包下 @Reference(version = "&#36;{producer.service.version}") private CourseListService courseListService; @Override public List<CourseAndPriceVO> getCourseAndPrice() { //.. List<Course> courseList = courseListService.getCourseList(); //.. } } docker中部署zookeeper 镜像拉取和容器创建 systemctl start docker docker search zookeeper docker pull zookeeper:3.7.2 docker images docker run --name zk01 -d -p 2181:2181 zookeeper:3.7.2 docker ps -a docker exec -t zk01 bash cd / ll cd apache-zookeeper-3.7.2-bin cd bin find / -name "*.cfg" cat /conf/zoo.cfg zkServer.sh start powershell连通性测试 PS C:\Users\ida> Test-NetConnection -ComputerName 192.168.149.135 -Port 2181 ComputerName : 192.168.149.135 RemoteAddress : 192.168.149.135 RemotePort : 2181 InterfaceAlias : VMware Network Adapter VMnet8 SourceAddress : 192.168.149.1 TcpTestSucceeded : True`,``,`html`,`final`,`20240616183123-_java final线程安全不需要额外的同步开销 static和final组合,通常用来存储配置信息 修饰类防止被继承 修饰方法防止被重写 被final修饰的方法,JVM会尝试将其内联,以提高运行效率 修饰引用,表示引用不可变,引用指向的内容可变. 修饰变量防止被修改 被final修饰的常量,在编译阶段会存入常量池中. 三种变量 只能被赋值一次,之后不能被改变 类中的final属性 在声明变量时直接赋值 在构造函数中赋值 在类的初始代码块中赋值 类中static final属性 在声明变量时直接赋值 在static初始代码块中赋值 方法中的final变量 在使用前必须赋值`,``,`html`,`FreeMarker`,`20240521124656-_视图 在 Java Web 开发中，一些主流的模板引擎包括： Thymeleaf： 高度集成于 Spring Framework 中，支持 HTML5，具有优雅的模板语法和强大的功能，如表达式求值、国际化等。 FreeMarker： 轻量级模板引擎，广泛用于生成 HTML、XML、JSON 等文档格式，支持宏、条件判断、循环等模板语法。 Velocity： Apache Velocity 是一个基于文本的模板引擎，使用简单，适合生成 HTML 和 XML 等文本格式的内容。 JSP： 虽然不是专门的模板引擎，但在 Java Web 开发中被广泛使用，允许在 HTML 页面中嵌入 Java 代码，适合简单的动态页面生成。 Handlebars： JavaScript 模板引擎，但也有 Java 的实现版本，支持基于 Mustache 模板语法，适合前后端分离应用中的模板渲染。 Pebble： 类似于 Django 模板语法的 Java 模板引擎，支持继承、布局、条件判断等功能，用于生成动态内容。 Groovy Template Engine： 使用 Groovy 语言编写的模板引擎，结合 Groovy 的强大特性，支持嵌入 Groovy 脚本生成动态内容。 jsp与freemarker区别 20240330212357.webp 代入三位以上或可能超过三位的数字属性注意加上?c, 否则会加入逗号分隔导致后台解析失败 依赖 <dependency> <groupId>org.freemarker</groupId> <artifactId>freemarker</artifactId> <version>2.3.30</version> </dependency> 基于配置文件 <?xml version="1.0" encoding="UTF-8"?> <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"> <servlet> <!-- 处理类 --> <servlet-name>freemarker</servlet-name> <servlet-class>freemarker.ext.servlet.FreemarkerServlet</servlet-class> <init-param> <!-- 模板文件的存放路径 --> <param-name>TemplatePath</param-name> <param-value>/WEB-INF/classes/templates</param-value> </init-param> <init-param> <!-- 以指定编码读取模板文件 --> <param-name>default_encoding</param-name> <param-value>UTF-8</param-value> </init-param> </servlet> <servlet-mapping> <servlet-name>freemarker</servlet-name> <!-- 拦截处理.ftl结尾的url --> <url-pattern>*.ftl</url-pattern> </servlet-mapping> </web-app> 基于配置对象 @WebServlet("/page30") public class FreeMarkerServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Configuration cfg = new Configuration(Configuration.VERSION_2_3_30); //注意Configuration是freemarker里的类, 版本号与依赖一致 try { String path = FreeMarkerServlet.class.getClassLoader().getResource("templates").getPath(); cfg.setDirectoryForTemplateLoading(new File(path)); cfg.setDefaultEncoding("UTF-8"); // 设置读取.ftl文件时的编码 cfg.setOutputEncoding("UTF-8"); // 设置 FreeMarker 的输出编码 Template template = cfg.getTemplate("example.ftl"); //加载模板 //创建数据模型 Map<String, Object> data = new HashMap<>(); Map<String, String> info = new HashMap<>(); info.put("cpu", "AMD7"); Computer computer = new Computer( "002", "dy", 2, null, new Date(2024 - 1900, 3 - 1, 30),//2024年3月30号, 年份减1900, 月分减1 12345.6f, info ); data.put("title", "示例页面"); data.put("items", Arrays.asList("项目1", "项目2", "项目3")); data.put("date", new Date()); data.put("num", 1234567.0678); data.put("num2", 1234567); data.put("computer", computer); // 输出到控制台 Writer out = new BufferedWriter(new OutputStreamWriter(System.out, "UTF-8")); template.process(data, out); //合并数据模型和模板 out.flush(); // 写入文件 String outputPath = path+File.separator+"output.html"; try (Writer fileOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputPath), "UTF-8"))) { template.process(data, fileOut); } // 响应 HTTP 请求 template.process(data, resp.getWriter()); } catch (IOException | TemplateException e) { e.printStackTrace(); } } } public class Computer{ private String sn; private String model; private int state; private String user; private Date date; private Float price; private Map<String,String> info; } 模板语法 <!DOCTYPE html> <html lang="en" > <head> <meta charset="UTF-8"> <title>&#36;{title}</title> </head> <body> <#-- 遍历List, Array --> <ul> <#list items as item> <li>&#36;{item_index+1} &#36;{item}</li><#-- 后缀_index,索引的语法规则 --> <#if item_has_next> | </#if> </#list> </ul> <#list computers_map?keys as key><#-- ?keys 语法规则,按健值遍历map --> &#36;{key}-&#36;{computers_map[key].model} </#list> <#-- 默认值 --> &#36;{not_exist!"N/A"}<br> <#-- ?string() 格式化输出 --> &#36;{date?string("yyyy-MM-dd HH:mm:ss SSS")}<br> &#36;{num}<br> &#36;{num?c}<br><#-- 原样 --> &#36;{num?string("0.00")}<br> &#36;{num2}<br> &#36;{num2?c}<br> &#36;{num2?string("0.00")}<br> &#36;{num?string('#.##')}<br><#-- #表示不强制 --> &#36;{num?string(',###.00')}<br><#--整数部分每三位分割--> &#36;{num?string(',###.##')}<br><#--小数点后多余两位就只保留两位，不足两位就取实际位数--> &#36;{num?string('000000000000.00')}<br><#-- 0补齐 --> <#-- 对象 不支持非公共类--> <#if computer.sn=="002"> 重要设备 </#if><br> SN:&#36;{computer.sn}<br> model:&#36;{computer.model}<br> <#-- 条件分支 --> <#if computer.state==1> 使用中 <#elseif computer.state==2> 闲置 <#else> 淘汰 </#if><br> <#-- 选择分支 注意break --> <#switch computer.state> <#case 1> 使用中 <#break> <#case 2> 闲置 <#break> <#default> 作废 </#switch><br> <#-- ?? 不为null时 --> <#if computer.user??> 用户:&#36;{computer.user} </#if><br> date:&#36;{computer.date?string("yyyy-MM")}<br> price:&#36;{computer.price}<br><#-- 12345.6f 会自动变 12,345.6 当进行回显时后台将无法作为数字处理 --> price:&#36;{computer.price?c}<br><#-- 12345.599609375 --> <#-- 点和方括号--> cpu:&#36;{computer.info.cpu}<br> cpu:&#36;{computer.info["cpu"]}<br> <#-- memory:&#36;{computer.info[memory]!"N/A"} 无此key时,方括号写法报错--> memory:&#36;{computer.info.memory!"N/A"} </body> </html> 内建函数 20240331111706.webp 自定义指令 public class UpperDirective implements TemplateDirectiveModel { @Override public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body ) throws TemplateException, IOException { if (body != null) { StringWriter sw = new StringWriter(); body.render(sw); env.getOut().write(sw.toString().toUpperCase()); } } } @WebServlet("/page31") public class CustomCommand extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Configuration cfg = new Configuration(Configuration.VERSION_2_3_30); try { String path = CustomCommand.class.getClassLoader().getResource("templates").getPath(); cfg.setDirectoryForTemplateLoading(new File(path)); cfg.setDefaultEncoding("UTF-8"); cfg.setOutputEncoding("UTF-8"); Template template = cfg.getTemplate( "custom-command.ftl"); Map<String, Object> data = new HashMap<>(); data.put("title", "自定义指令"); //将自定义指令注册到 FreeMarker 的数据模型中 data.put("upper", new UpperDirective()); template.process(data, resp.getWriter()); } catch (IOException | TemplateException e) { throw new RuntimeException(e); } } } <html lang="en" > <head> <meta charset="UTF-8"> <title>&#36;{title}</title> </head> <body> <@upper>abc</@upper> <@upper>123</@upper> <@upper>啊</@upper> </body> </html> spring boot中使用 通过 spring-boot-starter-freemarker 与 Spring Boot 集成 spring.freemarker.template-loader-path=classpath:/templates/ spring.freemarker.suffix=.ftl spring.freemarker.charset=UTF-8 spring.freemarker.cache=false 如果 request、session 和 application 都有名为 current_employee 的属性，并且在 Freemarker 模板中使用 &#36;{current_employee.name} 在开发环境中，你可以关闭 Freemarker 模板缓存，以便每次修改模板后都能立即看到效果。在生产环境中，建议开启缓存以提高性能。 选择 Freemarker：如果你需要生成多种格式的文件（如 XML、JSON）、处理复杂的逻辑，或者在项目中需要大量的动态内容生成，Freemarker 是一个强大的选择。 选择 Thymeleaf：如果你的项目主要是 Web 应用，尤其是基于 Spring 的项目，并且你希望模板文件在未渲染时仍能作为有效的 HTML 文件查看，Thymeleaf 是一个非常适合的选择。它的自然模板和与 Spring 的深度集成使得开发体验更为流畅。`,``,`html`,`Git`,`20240828181658-_工具使用 Git 是一个分布式版本控制系统，用于跟踪代码变化并协作开发 20240828210542.webp 术语概念 仓库（Repository, Repo）, 一个 Git 仓库是一个项目的代码库，包含了项目的所有文件及其历史记录 分支（Branch）是代码开发的并行路径, 主分支通常被称为 main 或 master, 开发分支常用于实验性功能开发 列出分支：git branch 当前所在的分支会用 * 标记, git status第一行也会显示当前分支名称 切换分支：git checkout branch_name 创建分支: git branch branch_name 创建并切换到新分支：git checkout -b branch_name 提交（Commit）是对代码库的一次快照，记录了当前所有文件的状态。每次提交都有唯一的哈希值（SHA） 创建提交：git commit -m "message" 查看提交历史：git log 暂存区（Staging Area, Index）是一个中间区域，在提交前暂存修改。你可以选择性地将修改加入暂存区，决定哪些内容会包含在下一次提交中 添加文件到暂存区：git add file 添加所有更改：git add . 将当前目录及其子目录下的更改（新文件和修改文件）添加到暂存区 git add -A 将所有更改（包括新文件、修改文件和删除文件）添加到暂存区。它会跟踪所有文件的状态变化，包括那些被删除的文件 git commit -am "xxxx" 是一个快捷方式，用于同时添加文件和提交更改 -a: 自动将所有已跟踪的文件中的更改添加到暂存区，但不会包括新创建的文件 如果你只修改了已跟踪的文件，-am 可以快速提交这些更改。但是，如果有新文件，记得先用 git add 添加它们，因为 -a 不会处理新文件 工作区（Working Directory）是你当前正在开发的目录。包含了你所有的文件以及你正在进行的修改。未提交的更改都在这里 查看状态：git status 将指定的文件恢复到最近一次提交的状态：git checkout -- file 任何自上次提交以来对该文件的未保存更改都会被永久丢弃 -- 的作用：在 Git 中，-- 用于分隔命令的参数和文件名，明确告诉 Git 你要操作的是文件，而不是分支或其他对象。它帮助避免歧义。 如果你对某个文件进行了修改，但不小心修改错了，可以用这个命令恢复到上次提交的状态，重新开始 恢复工作区的所有更改 git checkout . 远程仓库（Remote Repository）是托管在服务器上的 Git 仓库，便于多个开发者协作。常用的平台有 GitHub、GitLab 等 查看远程仓库：git remote -v -v 显示每个远程仓库的详细信息 拉取远程更新：git pull 推送本地更改：git push 克隆（Clone）将远程仓库复制到本地，包括所有文件和提交历史。 克隆仓库：git clone repository-url 合并（Merge）将另一个分支的更改应用到当前分支，常用于将开发分支的修改合并到主分支 合并分支：git merge branch_name 变基（Rebase）将一组提交移动到另一条分支之上，重新整理提交历史。用于保持提交历史的线性。 变基到分支：git rebase branch_name 使用变基可以避免分叉历史和不必要的合并提交，使代码历史更易于理解和维护 20240828224030.webp 当你在一个分支（如 feature-branch）上进行开发时，其他人可能在 main 分支上也进行了提交 将两个分支的历史结合在一起，通常会生成一个合并提交（merge commit） 将两个分支的历史保留在一起。这样会产生一个分叉的提交历史 变基将 feature-branch 分支上的提交（如 D 和 E）重新应用到 main 分支的最新提交（如 C）之上。这样，会“移动” feature-branch 的历史，使其看起来像是基于 main 分支的最新状态进行的开发 标签（Tag）是对特定提交的标记，常用于标识版本发布（如 v1.0.0） 为当前分支的最新提交创建一个标签：git tag tagname 为指定的提交创建标签：git tag tagname commit-hash 查看标签：git tag HEAD 是指向当前分支的最新提交的指针。通常指向当前分支的最后一次提交 查看 HEAD：git log --oneline -1 HEAD 是一个非常重要的概念，它指向你当前正在工作的“位置”或“状态” 当你在一个分支上工作时，HEAD 会指向这个分支，并且随着你在该分支上进行新的提交，HEAD 会移动到最新的提交 当使用 git checkout commit-hash 检出某个历史提交，此时 HEAD 就指向该提交而不是某个分支, 这个状态称为“分离头指针状态”（detached HEAD state） 进入分离头指针状态后，你所做的任何新的提交都不会关联到任何现有分支，除非你创建一个新的分支来接收这些提交 20240828230025.webp 冲突（Conflict）发生在 Git 无法自动合并更改时，通常是因为多个分支修改了同一行代码。需要手动解决冲突。 查看冲突：git status 解决冲突后标记为已解决：git add file 当 Git 合并或拉取操作产生冲突时，Git 会在有冲突的文件中插入冲突标记（如 <<<<<<<, =======, >>>>>>>） 20240828230714.webp 你需要决定最终的内容是 内容 A、内容 B 还是它们的结合，并删除冲突标记, 然后将冲突已解决的文件添加到暂存区 一旦所有冲突文件都被标记为已解决，你可以继续合并操作或完成变基操作 对于合并操作，使用 git commit 完成合并并创建一个合并提交 对于变基操作，使用 git rebase --continue 完成变基 在变基过程中，如果遇到冲突，Git 会暂停变基操作，并提示你解决冲突。 --continue 命令继续变基过程。此命令告诉 Git 你已解决所有冲突，并准备好继续变基操作。Git 会继续应用剩下的提交，直到完成变基过程。如果在后续步骤中再次遇到冲突，你将重复解决冲突和使用 --continue 过程 回滚（Revert）通过创建新的提交来实现撤销，而不会影响现有的提交历史(不会删除提交历史), 它保持了提交历史的完整性, 所以在公共分支上使用 revert 是安全的 撤销单个提交：git revert commit-hash 你可以依次对多个提交使用 revert，也可以使用范围(..)来批量撤销 git revert a1b2c3d4..e5f6g7h8 这将生成一系列新提交，依次撤销从 a1b2c3d4 到 e5f6g7h8 的所有更改 20240828233534.webp 其中，A 是最早的提交，E 是最新的提交, 我们希望撤销提交 C 的更改, git revert commit-hash-of-C 提交 F 是由 git revert 创建的，用于撤销提交 C 的更改。这个新提交 F 会包括与 C 相反的更改，从而将 C 引入的修改回滚 重置（Reset）将当前分支回退到某个指定的提交，可以选择是否保留更改 git reset --hard commit-hash --soft：保留工作目录和暂存区中的更改，将 HEAD 移动到指定提交。 当你想回退到某个提交，并重新提交所有自那个提交以来的更改（例如，修改提交历史）时使用。 --mixed：重置暂存区到指定提交的状态，保留工作目录中的更改。 当你想丢弃暂存区中的更改，但保留工作目录中的更改时使用（例如，取消暂存已暂存的更改） --hard：完全重置工作目录和暂存区到指定提交的状态，丢弃所有更改。 当你想完全回退到某个提交，丢弃所有自那个提交以来的更改时使用（例如，重置整个工作目录）。 在 Git 中，空目录（没有任何文件的目录）是不能被直接跟踪或记录的。Git 只跟踪文件和目录中包含的文件，不跟踪空目录。 因此，当你修改一个空目录的名称时，Git 实际上并不会记录这个更改 如果希望 Git 跟踪一个目录，即使该目录当前为空，可以在该目录中添加一个占位符文件（例如 .gitkeep 或 .gitignore） git add path/to/directory/.gitkeep git commit -m "Add placeholder file to keep the directory" .gitignore .git同级目录中创建.gitignore文件,配置忽略条件 在 Git 中，隐藏文件和目录的忽略规则和普通文件和目录的规则处理方式略有不同 在 .gitignore 文件中，书写顺序是很重要的，因为 Git 会按顺序应用忽略规则。规则的先后顺序决定了哪些内容会被忽略，哪些会被取消忽略 先忽略，再取消忽略, 更具体的规则应放在更通用规则之后 在 .gitignore 文件中，使用 # 开头的行即为注释 /directory/ 根目录下的 directory 目录及其所有内容（包括文件和子目录）, 但不包括 directory 内的隐藏文件（以 . 开头的文件） /directory/** 更加全面地忽略 directory 及其所有层级的内容, 包括隐藏文件, 这是最保险的选择 等同 directory/** directory/ 所有层级下的 directory 目录及其所有内容（包括文件和子目录） directory/* 所有层级下的 directory 目录中的所有文件, 但不忽略 directory 目录本身和其子目录（子目录中的文件会被忽略） /directory/* 根目录下的 directory 目录中的所有文件，但不忽略 directory 目录本身和其子目录（子目录中的文件会被忽略） logs/ !/logs/keep.log 忽略所有 logs 目录及其子目录下的内容，但 logs/keep.log 除外 !.mvn/wrapper/maven-wrapper.jar 确保 maven-wrapper.jar 文件被跟踪，即使其所在的目录被忽略 不忽略 maven-wrapper.jar 文件，即使它在一个被忽略的目录中 ! 符号表示取消忽略的规则，这使得 Git 会跟踪这个特定的文件，即使其他规则忽略了它所在的目录 !**/src/main/**/target/ 确保所有 src/main 目录下的 target 目录被跟踪，即使通常情况下 target 目录会被忽略 不忽略所有 src/main 目录下的 target/ 目录 ** 表示匹配所有层级的子目录 *~ 忽略所有的临时文件 a.txt 任意位置的名为a.txt的文件 *.log 忽略某种类型的文件 例如, 要忽略根目录下除 demo0 之外的所有内容，同时忽略 demo0 中任意位置的 target 文件夹，你可以在 .gitignore 文件中使用以下规则 忽略所有内容, 包括隐藏文件和文件夹 /** 取消忽略 demo0 文件夹本身 !demo0/ 取消忽略 demo0 文件夹中的所有文件和子目录, 分两步是因为 Git 的忽略机制是逐级处理的, 如果你首先忽略了一个文件夹，那么这个文件夹及其所有内容都会被忽略。要重新包括某个文件夹中的内容，必须先取 消对该文件夹的忽略，然后再取消对该文件夹中内容的忽略。 !demo0/** 但忽略demo0中任意位置的target demo0/**/target/ 当你在一个已经被 Git 跟踪的项目中修改忽略规则时, 如果你添加了新的忽略规则, 导致某些以前没有被忽略的文件或目录现在被忽略 如果这些文件已经被 Git 跟踪（即已经被 git add 并提交），Git 会继续跟踪它们，即使它们现在符合 .gitignore 的新规则。 这意味着这些文件仍会出现在未来的提交中，除非你明确地将它们从 Git 的版本控制中移除 将已经被 Git 跟踪的文件从版本控制中移除，并且使这些文件遵循 .gitignore 规则 git rm --cached logs/ 命令移除文件或目录的跟踪状态 这将从 Git 的索引中移除文件，但文件本身仍然保留在你的工作目录中。之后，Git 将忽略这些文件 git commit -m "Remove logs and log files from version control" 提交这个更改，以便 Git 记录下这些文件不再被跟踪的状态 提交完成后，可以运行 git status 来确认这些文件或目录现在被 Git 忽略 git add -p 允许你在添加修改到暂存区（staging area）时进行更细粒度的控制。使用这个命令，你可以选择性地将某些修改部分添加到暂存区，而忽略其他部分。 Git 会逐块（hunk）显示你所做的修改，并让你对每一块修改做出决定。你可以选择将这一块修改添加到暂存区，还是暂时忽略它 在 git add -p 的交互过程中，Git 会向你显示一个修改块，并提供以下选项： y：将当前块的修改添加到暂存区。 n：不添加当前块的修改到暂存区（忽略）。 s：分割当前块的修改，让你可以进一步细分和选择。 e：手动编辑当前块的修改，选择具体要添加的行。 q：退出 git add -p，不再处理剩下的修改。 a：将当前块以及后续的所有修改都添加到暂存区。 d：跳过当前块以及后续的所有修改，不添加到暂存区。 Cherry-picking git cherry-pick commit-hash 允许你从一个分支中选择特定的提交并应用到当前分支，而无需合并整个分支。这对你只想引入某个特定变更，而不想合并整个分支的情况非常有用 在某个分支（例如 feature-branch）上进行了几个提交，但你只想将其中一个或几个提交应用到另一个分支（例如 main） 在修复某个错误后，想把该修复提交到其他分支 如果你在 cherry-pick 操作中遇到了冲突，并且尚未完成 cherry-pick（即你还没有提交变更），你可以通过以下步骤取消 cherry-pick 恢复到 cherry-pick 开始之前的状态 git cherry-pick --abort 在已完成 cherry-pick 时：使用 git reset --hard 来撤销最近的提交，或者使用 git revert 创建一个新提交来撤销指定提交的变更 git checkout 恢复工作区的所有内容为最近一次提交的状态，即丢弃(不可逆)工作区中的所有未提交的修改 git checkout . 恢复单个文件 git checkout -- a.txt 切换到历史版本并查看、调试或基于该版本进行开发 git checkout 907d3ba 取出最后提交为 commit id 为 907d3ba 这个版本,HEAD 转到 907d3ba，和 master 分离。 在“分离 HEAD”状态下的更改，如果没有提交到一个分支上，将会丢失。因此，如果你在分离状态下做了修改并且想要保留它们，应该创建一个新分支 git checkout -b my-feature-branch 如果要开发新功能，直接在某个提交上打分支即可，为什么要分离 HEAD？原因是这样比较轻量。 比如你现在想开发一个功能，但不知道是否可行，所以先试验一下，确认好了再打分支。如果直接打分支，觉得不合适还得删除。因为分支没有合并，还删不掉，删除还得加强制删除参数。 删除本地的指定分支 git branch -d branch-name 如果分支的更改没有被合并，Git 会拒绝删除操作并给出提示，避免你意外丢失更改 git branch -D branch-name 强制删除本地分支，无论它是否已经被合并, 删除后这些更改将无法恢复 删除远程分支 git push origin --delete branch-name 强制拉分支, 如果并行的只有一个任务，可以每次都用 dev 分支开发 git checkout -B dev 如果 dev 分支不存在，这个命令会创建 dev 分支并切换到它 如果 dev 分支已经存在，这个命令会将 dev 分支重置为当前工作目录的状态，丢弃该分支上的任何历史提交。 这会使 dev 分支指向当前 HEAD，并覆盖该分支上之前的内容。 如果没有 -B 参数，会报错 在历史提交的基础上创建新分支 如果没有指定一个起始点（提交哈希值或分支名），Git 会默认从当前 HEAD 所指向的提交创建新分支 git checkout -b dev F123456 基于提交 F123456 创建一个名为 dev 的新分支 孤立分支 新项目或版本的开发: 当你想在现有的仓库中创建一个全新的项目或版本，不继承之前的提交历史，可以使用孤立分支。 文档分支: 创建一个没有代码历史的分支，专门用于存放文档、设计文件或其他非代码内容。 git checkout --orphan doc 创建一个没有父提交的新分支并切换到这个新分支。新分支和其它分支是平行的永远不会相交 当前工作目录中的所有文件将保持不变，但 Git 会将它们标记为未跟踪 可以通过 git rm -rf . 删除当前目录下的所有文件 选择合并 git checkout master git merge dev 将 dev 分支的工作合并到 master 分支，从而将 dev 上的更改引入到 master Git 会尝试自动合并 dev 分支的内容到 master 分支。如果两个分支有不冲突的更改，Git 会直接合并生成一个新的合并提交 如果有冲突（即相同的文件在两个分支中都被修改过），手动解决冲突后, git merge --continue 继续合并 git merge --abort 取消合并，恢复到合并前的状态 暂存区 查看暂存区 git status 查看整体状态，包括暂存区的文件。 git diff --cached 查看暂存区中文件的具体差异。 git ls-files -s 查看暂存区中文件的详细信息。 git diff --name-only --cached 查看暂存区中文件的名称列表 清空 Git 暂存区 git reset 所有已暂存的文件将被移回工作区 git reset file 清空特定文件的暂存状态 git restore --staged . git restore --staged file Git 2.23+新命令，提供与 git reset 类似的功能，适合移除特定文件或全部文件 删除旧的提交历史 git checkout --orphan latest_branch git add -A git commit -m "init" git branch -D master git branch -m master git push -f origin master Idea中使用Git version control 指定git.exe地址,测试一下 新建项目基体, 菜单栏VCS启用版本控制,选择git 绿色：新文件：文件已被添加到版本控制，但尚未提交（staged for commit）。 蓝色：已修改：文件内容已被修改，但修改还未被提交（modified but not committed）。 红色：未版本控制的文件：文件存在于项目中，但尚未被添加到版本控制系统中（unversioned files）。 Alt + 9 打开 Git 工具窗口 在 IntelliJ IDEA 中，你可以通过集成的 Git 命令行窗口执行 Git 命令 Changelists 允许你将不同的更改分组，并有选择地提交它们。这样可以帮助你将不同的变更逻辑上分开，使提交历史更清晰易读 将与特定功能相关的更改分配到一个 Changelist，以便可以单独提交和管理这些更改 创建一个专门的 Changelist 用于错误修复，确保错误修复提交与功能开发分开 在提交之前整理未提交的更改，将它们分组到合适的 Changelist 中，确保每个提交都有明确的目的和内容 多人协作 管理员 完成项目基体搭建 为当前项目创建本地版本库 add到暂存区 commit到版本库 创建远程版本库 添加开发者 将本地仓库push到远程仓库 设置远程仓库中主分支为保护分支 在本地创建dev分支 将本地dev分支push到远程仓库，新建远程仓库的dev分支 开发者 从管理员提供的远程仓库pull项目到本地 开发步骤 进行修改操作 测试本地修改 add到暂存区 commit到本地版本库 push到远程仓库（dev） 在pull之后，push之前被其他开发者push过, 需要再次pull到本地, 选择产生冲突的文件, 手动合并（和其他开发者沟通合并方案）,然后添加提交后push 20240829101108.webp ## 管理员 echo "# test" >> README.md git init git add README.md git commit -m "init" git branch -M main ## 这会将当前分支（如 master）重命名为 main, -M 选项用于强制重命名分支, 即使已经存在名为 main 的分支，也会覆盖原有的分支名, 原来的 main 分支会被删除 git remote add origin https://github.com/ida/test.git git push -u origin main ## -u 将当前分支与远程分支关联。这样以后在执行 git push 或 git pull 时，无需指定远程和分支名 git checkout -b dev echo dev >readme.md git add readme.md git commit -m 'dev created readme.md' git push origin dev ## 开发者1 ## 建个新目录 git init git remote add origin https://gihub.com/ida/test.git git remote set-url origin https://github.com/ida/test.git ## 修改url git fetch origin ## 获取远程仓库所有分支信息 git checkout -b dev origin/dev ## (上一步必需) 创建并切换到新的本地 dev 分支，该分支基于远程 origin/dev 分支 ## git init之后默认分支是 master ## git pull origin dev ## 拉取远程 dev 分支的内容并将其合并到当前的 master 分支 ## 计划在 dev 分支上工作，因此在合并后要切换到 dev 分支 ## git checkout -b dev ## 本地存在了master, dev两个分支 cd demo1 echo 你好世界 >>readme.md git add readme.md git commit -m '向readme.md文件追加了新内容' git push origin dev ## 开发者2 git init git remote add origin https://github.com/ida/test.git git fetch origin git checkout -b dev origin/dev ## 开发者1 echo cover >readme.md git add . git commit -m 'cover readme.md' git push origin dev ## 开发者2 cd demo1/ echo conflict_test >readme.md git add . git commit -m 'conflict_test' git push origin dev ! [rejected] dev -> dev (fetch first) error: failed to push some refs to 'https://github.com/ida/test.git' hint: Updates were rejected because the remote contains work that you do not hint: have locally. This is usually caused by another repository pushing to hint: the same ref. If you want to integrate the remote changes, use hint: 'git pull' before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. git pull origin dev cat readme.md <<<<<<< HEAD conflict_test ======= cover >>>>>>> a674ea3d75bd504b46b9ce89328a4ffe4990965c ## 手动修改readme.md文件, 删除冲突标记 git add . ## Git 需要知道你已经解决了冲突，所以你需要将修改后的文件重新添加到暂存区 git commit -m 'conflict_resovled' git push origin dev 命令测试 git --version ## git版本 ## 设置用户信息 git config --global user.name 'ida' git config --global user.email 'ida@gmail.com' ## 查看 Git 全局配置的用户信息 git config --global user.name git config --global user.email git config --list ## 查看 Git 配置文件的完整内容 git status ## 版本库状态 ## /d/mess/test 右键git bash git init ## 在当前目录初始化一个新的 Git 仓库 ## 新建note.txt文件 git add note.txt ## 只将工作空间中的某个文件add到暂存区 ## git add . 将工作空间中所有文件都add暂存区 git status git commit --help ## 查看commit命令手册 git commit -m '新建note.txt' ## 将暂存区内容提交到版本库（仓库） -m 消息 ## 查看版本库中的历史版本 git log --oneline ## 每个版本信息只显示一行 git log ## 显示每个版本的详细信息 ## 如果xxx是一个标签,将工作目录切换到该标签对应的提交版本; 如果xxx是一个分支,切换到该分支，使其成为当前活动分支 ## git checkout xxx git tag ## 查看所有的标签 git branch -a ## 查看所有分支 -a 本地和远程 ## 添加远程仓库为当前本地 Git 仓库的远程仓库，并命名为 origin。之后可以通过引用 origin 来与这个远程仓库进行交互 git remote add origin htps://xxx.git git remote -v ## 列出每个远程仓库的名称，以及用于 fetch（拉取）和 push（推送）操作的 URL ## 将本地 master 分支的更改推送到远程仓库 origin 的 master 分支, 如果远程的 master 分支上有本地没有的提交，推送可能会失败，提示你先拉取（git pull）并解决冲突 git push origin master ## -u 选项用于设置上游（upstream）分支。它会将本地分支与远程分支关联起来，之后可以使用简化的命令（如 git push 和 git pull），而不需要每次都指定远程仓库和分支名称 git push -u origin master git init ## 创建本地版本库 ## 从指定的远程仓库的 master 分支拉取最新的更改，并将这些更改合并到当前本地分支 ## 通常情况下，远程仓库是通过 git remote add 来添加的，并且你会使用类似 git pull origin master 的命令来拉取更改 , 直接使用远程仓库的 URL 是少见的情况，可能适用于临时拉取某个远程仓库的更改，而不将其添加为远程仓库 git pull htps://xxx.git master ## 基于指定的历史版本创建一个新的分支并切换到这个新分支 git checkout commit-hash -b branch-name`,``,`html`,`github空间域名绑定`,`20240307183503-_工具使用 升级为github基础订阅 repo设private,开通page主页 github添加购买的godaddy域名 将github提供的txt记录添加至godaddy domain dns 返回github验证domain godaddy domain dns添加4条github的A记录 A @ 185.199.108.153 A @ 185.199.109.153 A @ 185.199.110.153 A @ 185.199.111.153 godaddy domain dns中修改 [cName www yourdomain.com.] 为 repo.github.io. repo/settings/pages, custom domain www.yourdomain.com 启用https https://github.com/settings/pages_verified_domains/new`,``,`html`,`Google Apps Script`,`20250424001258-_工具使用 google apps script是一个由google drive中的apps script编辑器开发的javascript,用于建立各种应用程式。它执行在google cloud platform上的平台, 可以直接与Google产品互动, 执行定制化操作 https://developers.google.com/apps-script/reference?authuser=0&hl=zh-cn 谷歌日历 删除指定日期及其以前的全部事件 function clearEventsBeforeDate() { // Define your parameters const calendarId = 'futarinoida@gmail.com'; // Replace with your Google Calendar ID const cutoffDateStr = '04/23/2025'; // 包括该日期 // const searchString = '关键词'; // Convert the date string to a Date object const cutoffDate = new Date(cutoffDateStr); // Get all events in the calendar const events = CalendarApp.getCalendarById(calendarId).getEvents(new Date(1970, 0, 1), new Date(2099, 11, 31)); // Get all events // Iterate through the events and delete those before the cutoff date for (const event of events) { const eventStartDate = event.getStartTime(); // Get the start time of the event if (eventStartDate < cutoffDate) { // 仅删除匹配关键词的事件 // if (event.getTitle().toLowerCase().includes(searchString.toLowerCase()) || event.getDescription().toLowerCase().includes(searchString.toLowerCase())) { event.deleteEvent(); Logger.log(&#715;Deleted event: &#36;{event.getTitle()}&#715;); // } } } } 列出即将到来的下一批事件 /** * Lists the next 10 upcoming events in the user's default calendar. * @see https://developers.google.com/calendar/api/v3/reference/events/list */ function listNext10Events() { const calendarId = 'primary'; const now = new Date(); const events = Calendar.Events.list(calendarId, { timeMin: now.toISOString(), singleEvents: true, orderBy: 'startTime', maxResults: 10 }); if (!events.items || events.items.length === 0) { console.log('No events found.'); return; } for (const event of events.items) { if (event.start.date) { // All-day event. const start = new Date(event.start.date); console.log('%s (%s)', event.summary, start.toLocaleDateString()); continue; } const start = new Date(event.start.dateTime); console.log('%s (%s)', event.summary, start.toLocaleString()); } } fetch加工回传 https://medium.com/@Hsu.Yang-Min/apps-script-%E9%96%8B%E7%99%BC%E7%9A%84%E5%B0%8F%E5%B9%AB%E6%89%8B-cd1f15eb722b\ 简单爬虫`,``,`html`,`Hibernate`,`20240616183123-_数据库 JDBC 是底层 API，操作较为繁琐。 为了简化数据库操作，通常使用 ORM 框架（如 Hibernate、MyBatis），它们基于 JDBC 实现了更高级别的抽象。 commons DButils: 是对jdbc进行了相对简单的包装, 主要就是能自动封装查询结构 集, 需要在代码中写 sql 语句 Mybatis: 进一步封装 jdbc, Sql 语句写在配置文件中, 面向对象操作, 有一 二级缓存功能 Apache Commons DbUtils 适合简化 JDBC 操作，特别是当你只需要执行简单的 SQL 查询和更新时。它轻量级且易于使用，没有复杂的配置。 MyBatis 适合需要高级映射和动态 SQL 支持的场景，尤其是当你需要处理复杂的查询和结果映射时。它提供了丰富的功能，但也需要更多的配置 Hibernate: 对 jdbc 封装得最彻底的框架, 纯面向对象, 可以不用写 SQL Java Persistence API (JPA) 是一个 Java 的持久化标准，提供了一个更高层次的抽象，用于在 Java 对象和数据库表之间自动进行对象关系映射。 JPA 实现了 ORM（对象关系映射）机制，允许开发者通过注解或 XML 配置来定义实体类与数据库表之间的映射关系 MyBatis 不属于 JPA（Java Persistence API）,MyBatis 和 JPA 都可以用于数据库持久化操作，但它们各自有不同的设计目标和适用场景 JPA 规范的框架（如 Hibernate, EclipseLink) JPA注解 @Entity：将类标记为实体类。 @Id：标记实体类的主键字段。 @GeneratedValue：指定主键生成策略。 @Column：映射实体类字段到数据库列。 @Table：指定实体类对应的数据库表。 @OneToOne、@OneToMany、@ManyToOne、@ManyToMany：定义实体间的关系。 @JoinColumn、@JoinTable：定义关系中的连接列或连接表。 JPQL：是 JPA 标准的一部分，适用于所有 JPA 提供者。 如果你的应用程序使用 JPA 标准，并且希望保持实现的灵活性和可移植性，可以使用 JPQL。 HQL：是 Hibernate 特有的，虽然与 JPQL 类似，但包含一些特定于 Hibernate 的扩展。 如果你使用的是 Hibernate 并且需要一些 Hibernate 特定的功能，可以使用 HQL。 两者在语法上非常相似，因此在 Hibernate 中使用 JPQL 和 HQL 之间的切换相对简单 Hibernate 对比 MyBatis hibernate对数据库结构提供了较为完整的封装。简单来说，hibernate就是将对象数据保存到数据库，将数据库数据读入到对象中, 不适合多表关联查询, 难以调优, 对大批量数据更新存在问题 mybatis主要着力点在于java对象与SQL之间的映射关系。适合高级查询, 可以sql调优 hibernate与数据库管联只需在xml文件中配置即可，通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性, 所有的HQL语句都与具体使用的数据库无关，移植性很好 mybatis所有的sql都是依赖所用数据库的，仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理, 所以不能更换数据库，与数据库的耦合性直接取决于程序员写sql的方法, 移植性差 hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等 mybatis则除了基本记录功能外，功能薄弱很多 Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。 MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。 依赖 Hibernate 5.x 开始, hibernate-entitymanager 被合并进 hibernate-core 中 只需要依赖 hibernate-core 模块，不再需要单独添加 hibernate-entitymanager 模块 hibernate-core Hibernate 的核心模块, 主要包含 Hibernate 的核心 API 和实现，例如 Session、Transaction、Query 等类 <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-core</artifactId> <version>5.6.7.Final</version> </dependency> hibernate-entitymanager Hibernate 4.x 的一个模块，主要提供 JPA 规范的实现，包含了与 JPA 相关的功能和接口，如 EntityManager、EntityManagerFactory 依赖于 hibernate-core，因为它实现了 Hibernate 的持久化机制。 <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-entitymanager</artifactId> <version>5.6.7.Final</version> </dependency> 配置文件形式 当同时存在 hibernate.cfg.xml、hibernate.properties 和 persistence.xml 时 如果你使用的是 JPA (Java Persistence API)，persistence.xml 是 JPA 的配置文件。JPA 实现（如 Hibernate）会从这个文件中读取配置信息。 persistence.xml 的配置会覆盖 hibernate.cfg.xml 和 hibernate.properties 中的相应配置。 如果你使用的是 Hibernate（而非 JPA），则 hibernate.cfg.xml 是主要的配置文件。 如果 persistence.xml 不存在，Hibernate 会优先加载 hibernate.cfg.xml 中的配置。 hibernate.cfg.xml 的配置优先于 hibernate.properties 当 persistence.xml 和 hibernate.cfg.xml 都存在时，hibernate.properties 的配置会被忽略。 如果只存在 hibernate.properties，则 Hibernate 会从这个文件中加载配置 hibernate.cfg.xml 这是 Hibernate 的传统配置文件形式 <!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"> <hibernate-configuration> <session-factory> <!-- 数据库连接信息 --> <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property> <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/testdb?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true</property> <property name="hibernate.connection.username">root</property> <property name="hibernate.connection.password">root</property> <!-- 物理命名策略, 将逻辑名称（例如实体类中的属性名或表名）转换为物理名称（数据库中的列名或表名）注解形式 @Column(name = "first_name") --> <property name="hibernate.physical_naming_strategy">org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</property> <!-- 隐式命名策略, 当你没有在实体类中使用 @Table 或 @Column 注解指定表名或列名时, 它会根据你的 Java 类名和属性名推断出默认的表名和列名 --> <property name="hibernate.implicit_naming_strategy">org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy</property> <!-- 连接池配置 --> <property name="hibernate.hikari.minimumIdle">5</property> <property name="hibernate.hikari.maximumPoolSize">20</property> <property name="hibernate.hikari.idleTimeout">30000</property> <property name="hibernate.hikari.connectionTimeout">30000</property> <property name="hibernate.hikari.maxLifetime">1800000</property> <!-- 方言告诉 Hibernate 如何生成特定数据库的 SQL 语句。MySQL8Dialect 表示使用 MySQL 8 的 SQL 语法和特性 --> <property name="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</property> <!-- 如何管理当前的会话上下文, thread 表示每个线程有自己的会话，这在多线程环境下非常有用。managed（由容器管理）, jta（用于事务管理器） --> <property name="hibernate.current_session_context_class">thread</property> <!-- 启用 SQL 日志输出, 在控制台输出执行的 SQL 语句 --> <property name="hibernate.show_sql">true</property> <property name="hibernate.format_sql">true</property> <property name="hibernate.use_sql_comments">true</property> <!-- 配置 Hibernate 在启动时如何处理数据库模式（Schema）, 未明确配置时默认行为 none 开发阶段，通常设置为 update 或 create 来便于快速迭代和测试 生产环境中，推荐设置为 validate 或 none，以避免自动更改数据库模式，防止意外的数据丢失或模式不一致问题 update: 如果你对实体类进行了更改（如添加或删除列），尝试相应地更新数据库表结构，不会删除现有数据。这适用于开发阶段，但不推荐在生产环境中使用。 create: 每次启动应用程序时删除现有的数据库表和数据，然后重新创建表。这会丢失现有数据。 create-drop: 每次启动应用程序时删除现有表并重新创建, 应用关闭时，表和数据也会被删除, 适用于测试环境在每次测试后清理数据库 validate: 验证数据库数据库表结构是否与 Hibernate 实体匹配，不做任何修改。 none: 不做任何模式相关的操作。 --> <property name="hibernate.hbm2ddl.auto">update</property> <!-- 使用注解映射实体类时的包扫描路径 --> <mapping package="com.ida.demo0.entity"/> </session-factory> </hibernate-configuration> hibernate.properties 这种方式适合喜欢使用属性文件而不是 XML 文件的用户 # 数据库连接信息 hibernate.connection.driver_class=com.mysql.cj.jdbc.Driver hibernate.connection.url=jdbc:mysql://localhost:3306/testdb?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true hibernate.connection.username=root hibernate.connection.password=root # 物理命名策略 hibernate.physical_naming_strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy # 隐式命名策略 hibernate.implicit_naming_strategy=org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy # 连接池配置 hibernate.hikari.minimumIdle=5 hibernate.hikari.maximumPoolSize=20 hibernate.hikari.idleTimeout=30000 hibernate.hikari.connectionTimeout=30000 hibernate.hikari.maxLifetime=1800000 # 方言 hibernate.dialect=org.hibernate.dialect.MySQL8Dialect # 会话上下文管理 hibernate.current_session_context_class=thread # SQL 日志输出 hibernate.show_sql=true hibernate.format_sql=true hibernate.use_sql_comments=true # 数据库模式处理 hibernate.hbm2ddl.auto=update # 包扫描路径, 其值的选项包括 class, hbm, 和 all，以及这些值的组合 # 在 Spring Boot 应用程序中，通常不需要手动设置此属性，因为自动配置已经处理了实体扫描和映射设置。如果你使用注解来定义实体类，Spring Boot 会自动扫描类路径中的所有实体类 hibernate.archive.autodetection=class persistence.xml 这是 JPA 的标准配置文件，用于 JPA 实现（如 Hibernate）时使用。它在 META-INF 目录下，并使用 XML 格式配置 <persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd" version="2.1"> <persistence-unit name="yourPersistenceUnit"> <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider> <!-- JDBC connection settings --> <properties> <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/> <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/yourdb"/> <property name="javax.persistence.jdbc.user" value="yourusername"/> <property name="javax.persistence.jdbc.password" value="yourpassword"/> <!-- Specify dialect --> <property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect"/> <!-- Specify connection pool settings (HikariCP in this example) --> <property name="hibernate.hikari.minimumIdle" value="5"/> <property name="hibernate.hikari.maximumPoolSize" value="20"/> <property name="hibernate.hikari.idleTimeout" value="30000"/> <property name="hibernate.hikari.connectionTimeout" value="30000"/> <property name="hibernate.hikari.maxLifetime" value="1800000"/> <!-- Specify schema handling --> <property name="hibernate.hbm2ddl.auto" value="update"/> <!-- Specify whether to show SQL queries --> <property name="hibernate.show_sql" value="true"/> </properties> </persistence-unit> </persistence> Java Config 对于现代 Java 应用，使用 Java 配置类进行 Hibernate 配置是一个较为流行的方式，尤其是在 Spring 框架中。这种方式提供了更强的类型安全和编译时检查 Configuration configuration = new Configuration() .setProperty("hibernate.connection.driver_class", "com.mysql.cj.jdbc.Driver") .setProperty("hibernate.connection.url", "jdbc:mysql://localhost:3306/yourdb") .setProperty("hibernate.connection.username", "yourusername") .setProperty("hibernate.connection.password", "yourpassword") .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect") .setProperty("hibernate.hbm2ddl.auto", "update") .setProperty("hibernate.show_sql", "true") .setProperty("hibernate.hikari.minimumIdle", "5") .setProperty("hibernate.hikari.maximumPoolSize", "20") .setProperty("hibernate.hikari.idleTimeout", "30000") .setProperty("hibernate.hikari.connectionTimeout", "30000") .setProperty("hibernate.hikari.maxLifetime", "1800000"); sessionFactory = configuration.buildSessionFactory(); 实体类的映射 xml方式 <mapping class="com.example.User"/> <mapping resource="mappings/Order.hbm.xml"/> resource属性指定了映射文件的位置(resources目录下)，这些文件包含了实体类的映射信息。例如，这些文件定义了表名、列名以及类与表之间的字段映射关系 resource 属性不能直接指定为文件夹。你需要为每个映射文件指定具体的文件路径 也可以使用代码从文件夹中动态加载所有映射文件, 从而替代此属性 class属性用于指定实体类的全限定名。这种方式通常在以下几种场景下使用 同时使用注解和 XML 映射文件来定义实体类的映射时, class用于指定那些你希望通过 XML 映射配置的类(例如包含某些复杂的映射情况) 在大型项目中，你可能会使用 XML 配置文件来集中管理所有实体类。这样做可以将实体类与 Hibernate 的配置分离，使项目的配置和实体类管理更加有序 在一些情况下，实体类的配置可能是动态的，或者是由代码生成工具自动生成的。在这种情况下，你可以通过代码动态地添加实体类配置 Configuration configuration = new Configuration().configure(); configuration.addAnnotatedClass(User.class); configuration.addAnnotatedClass(Order.class); SessionFactory sessionFactory = configuration.buildSessionFactory(); 映射文件.hbm.xml <!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"> <hibernate-mapping> <class name="com.example.User" table="user"> <id name="id" column="id"> <generator class="native"/> </id> <property name="name" column="name"/> <property name="createTime" column="create_time"/> </class> </hibernate-mapping> 从文件夹中动态加载所有映射文件 使用自定义代码来扫描目录，并将文件添加到 Hibernate 的配置中 Configuration configuration = new Configuration().configure(); URL mappingsUrl = HibernateUtil.class.getClassLoader().getResource("mappings"); if (mappingsUrl != null) { File mappingsDir = new File(mappingsUrl.toURI()); if (mappingsDir.exists() && mappingsDir.isDirectory()) { for (File file : Objects.requireNonNull(mappingsDir.listFiles())) { if (file.getName().endsWith(".hbm.xml")) { configuration.addResource("mappings/" + file.getName()); } } } } sessionFactory = configuration.buildSessionFactory(); 注解方式 使用 JPA 注解（如 @Entity、@Table、@Id 等）直接在实体类中定义映射, 配置文件中指定扫描的包路径，自动识别带注解的实体类 <!-- xml配置包扫描会出现Unable to locate persister的问题, 而指定class却正常 --> <mapping package="com.ida.demo0.entity"/> Spring Boot中使用 @EntityScan 注解来自动扫描实体类 事务 在 Hibernate 中事务是必需的：无论是读取还是写入操作，事务都是保证数据一致性和隔离性的关键机制。 即使是只进行查询（读取操作），在 Hibernate 中也应该开启事务 事务隔离级别决定了一个事务中读取的数据在多大程度上不受其他事务的影响。没有事务，读取的数据可能会出现脏读、不可重复读等问题 Hibernate 底层使用 JDBC 进行数据库操作。JDBC 要求所有数据库操作都在事务中进行，即使是只读查询。某些数据库在没有事务的情况下执行查询可能会抛出异常或导致不可预测的行为。 会话管理：Hibernate 的 Session 需要在事务中进行管理。即使是读取操作，Hibernate 也需要在事务中跟踪实体的状态和缓存 自动脏检查：Hibernate 会在事务提交时自动检测并同步实体的状态到数据库。如果没有事务，可能无法正确执行这些操作 只读事务：对于只读查询，可以将事务标记为只读，这样数据库可以进行相应的优化。例如，在某些数据库中，只读事务可能会使用更低的隔离级别或减少锁的使用，从而提高查询性能。 只读优化：对于只读查询，可以将事务标记为只读，以提高性能。 使用框架简化：考虑使用事务管理框架（如 Spring）来简化事务管理，减少样板代码。 配置连接池 在早期版本的 Hibernate（如 Hibernate 3 和 Hibernate 4），默认的连接池是 C3P0。然而，从 Hibernate 4.3.0 开始，默认的连接池变为 Hibernate 内部的一个非常简单的内置连接池。这个内置连接池适合开发和测试环境，但不建议在生产环境中使用。 在 Hibernate 5.x 中，HikariCP 是默认的连接池，因此不需要显式地设置 hibernate.connection.provider_class, 仍然需要显式地添加 HikariCP 的依赖 在 Spring Boot 中，HikariCP 作为默认的连接池实现，不需要显式引入依赖 HikariCP HikariCP以其高效和低延迟著称，适合需要高并发和低延迟的场景 <dependency> <groupId>com.zaxxer</groupId> <artifactId>HikariCP</artifactId> <version>5.0.1</version> </dependency> <!-- hibernate.cfg.xml --> <hibernate-configuration> <session-factory> <!-- JDBC Database connection settings --> <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property> <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/yourdb</property> <property name="hibernate.connection.username">yourusername</property> <property name="hibernate.connection.password">yourpassword</property> <!-- HikariCP settings --> <property name="hibernate.hikari.minimumIdle">5</property> <property name="hibernate.hikari.maximumPoolSize">20</property> <property name="hibernate.hikari.idleTimeout">30000</property> <property name="hibernate.hikari.connectionTimeout">30000</property> <property name="hibernate.hikari.maxLifetime">1800000</property> .. </session-factory> </hibernate-configuration> hibernate.properties形式 hibernate.connection.driver_class=com.mysql.jdbc.Driver hibernate.connection.url=jdbc:mysql://localhost:3306/yourdb hibernate.connection.username=yourusername hibernate.connection.password=yourpassword hibernate.hikari.minimumIdle=5 hibernate.hikari.maximumPoolSize=20 hibernate.hikari.idleTimeout=30000 hibernate.hikari.connectionTimeout=30000 hibernate.hikari.maxLifetime=1800000 hibernate.connection.provider_class=com.zaxxer.hikari.hibernate.HikariConnectionProvider c3p0 <dependency> <groupId>com.mchange</groupId> <artifactId>c3p0</artifactId> <version>0.9.5.5</version> </dependency> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-c3p0</artifactId> <version>5.6.7.Final</version> </dependency> <!-- hibernate.cfg.xml --> .. <!-- C3P0 connection pool settings --> <property name="hibernate.c3p0.min_size">5</property> <property name="hibernate.c3p0.max_size">20</property> <property name="hibernate.c3p0.timeout">300</property> <property name="hibernate.c3p0.max_statements">50</property> <property name="hibernate.c3p0.idle_test_period">3000</property> <!-- Specify the connection pool provider --> <property name="hibernate.connection.provider_class">org.hibernate.connection.C3P0ConnectionProvider</property> .. druid <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.2.16</version> </dependency> <!-- hibernate.cfg.xml --> .. <!-- Druid connection pool settings --> <property name="hibernate.connection.provider_class">org.hibernate.connection.DatasourceConnectionProviderImpl</property> <property name="hibernate.connection.datasource">java:comp/env/jdbc/druid</property> <!-- Additional Druid specific properties --> <property name="druid.initialSize">5</property> <property name="druid.minIdle">5</property> <property name="druid.maxActive">20</property> <property name="druid.timeBetweenEvictionRunsMillis">60000</property> <property name="druid.minEvictableIdleTimeMillis">300000</property> <property name="druid.validationQuery">SELECT 1</property> <property name="druid.testWhileIdle">true</property> <property name="druid.testOnBorrow">false</property> <property name="druid.testOnReturn">false</property> <property name="druid.poolPreparedStatements">true</property> .. 缓存 一级缓存 一级缓存是 Hibernate 的基础缓存机制，默认开启且不需要额外配置 每个 Hibernate Session 对象都有独立的一级缓存。这个缓存仅在当前会话范围内有效，当会话关闭时，缓存中的数据也会被清除 如果在同一个会话中多次查询相同的实体，Hibernate 会从缓存中返回数据，而不会多次访问数据库 执行 CRUD 操作时，Hibernate 会首先检查一级缓存，如果实体已经存在缓存中，则直接返回，不会查询数据库 验证一级缓存, 同一个session内查询 比较两者的内存地址, 或看是否生成了sql语句 @Test public void query() { HibernateUtil.excute(session -> { User user = session.get(User.class, 11L); System.out.println(user); User user2 = session.get(User.class, 11L); System.out.println(user2); return null; }); } 二级缓存 二级缓存是一个跨会话的缓存，它适用于多个 Session 对象共享的数据。 与一级缓存不同，二级缓存需要显式配置 对于常用且不经常变化的数据（如应用中的字典表数据），使用二级缓存可以显著提高性能 配置 Hibernate 的缓存提供者（例如 Ehcache、Hazelcast、Infinispan）依赖。 Ehcache支持分布式缓存 <!-- Hibernate Ehcache --> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-ehcache</artifactId> <version>5.6.7.Final</version> </dependency> <dependency> <groupId>net.sf.ehcache</groupId> <artifactId>ehcache</artifactId> <version>2.10.6</version> </dependency> 配置启用二级缓存，策略只读、非严格读写、读写等。 <!-- 允许二级缓存,查询缓存 --> <property name="hibernate.cache.use_second_level_cache">true</property> <property name="hibernate.cache.use_query_cache">true</property> <!-- 统计功能会记录有关会话、查询、缓存命中率等信息,会消耗资源,默认禁用, 适用于开发环境 --> <property name="hibernate.generate_statistics">true</property> <!-- 使用Ehcache作为缓存提供者 --> <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property> <!-- Ehcache缓存配置文件 --> <property name="net.sf.ehcache.configurationResourceName">ehcache.xml</property> <!-- 使用配置形式为指定类启用二级缓存, 使用读写策略; 等效于在实体类上使用 @Cache(usage = CacheConcurrencyStrategy.READ_WRITE) --> <class-cache class="com.example.User" usage="read-write"/> 或 Configuration configuration = new Configuration(); configuration.setProperty("hibernate.cache.use_query_cache", "true"); configuration.setProperty("hibernate.cache.region.factory_class", "org.hibernate.cache.ehcache.EhCacheRegionFactory"); configuration.setProperty("hibernate.cache.use_second_level_cache", "true"); configuration.setProperty("hibernate.generate_statistics", "true"); SessionFactory sessionFactory = configuration.buildSessionFactory(); ehcache.xml配置, 放置在 src/main/resources 目录下 <ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd" updateCheck="false" monitoring="autodetect"> <!-- 外置缓存的物理介质可以是内存也可以是硬盘 --> <diskStore path="java.io.tmpdir/ehcache" /> <defaultCache maxEntriesLocalHeap="1000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="false" statistics="true"/> </ehcache> 验证二级缓存, 为实体类启用二级缓存, 跨session查询 不能通过比较两者的内存地址来判断 因为即使 Hibernate 使用了二级缓存来避免重复的数据库查询，每个 Session 仍然会创建新的对象实例，因此对象的内存地址不同。 这是 Hibernate 管理对象状态、持久化和事务的一部分，确保每个 Session 中的对象是独立的。 查看是否生成的sql语句, 或输出缓存命中率(启用generate_statistics统计功能后通过sessionFactory.getStatistics()获取) @Test public void query2() { // 第一次加载，应该从数据库加载 HibernateUtil.excute(session -> { User user = session.get(User.class, 11L); System.out.println(user); return null; }); // 第二次加载，使用新的Session，应该从二级缓存加载 HibernateUtil.excute(session -> { User user2 = session.get(User.class, 11L); System.out.println(user2); return null; }); } //..excute } finally { // 输出缓存命中率 Statistics stats = sessionFactory.getStatistics(); System.out.println("Second Level Cache Hit Count: " + stats.getSecondLevelCacheHitCount()); System.out.println("Second Level Cache Miss Count: " + stats.getSecondLevelCacheMissCount()); System.out.println("Second Level Cache Put Count: " + stats.getSecondLevelCachePutCount()); session.close(); } 查询缓存 查询缓存依赖二级缓存来存储查询结果, 启用查询缓存时，也需要配置二级缓存 使用查询缓存时，在查询对象中明确启用缓存 @Test public void query3() { // 第一次使用查询缓存 HibernateUtil.excute(session -> { Query query = session.createQuery("FROM User WHERE name = :name"); //HQL query.setParameter("name", "杰克"); query.setCacheable(true); List<User> users = query.list(); users.forEach(System.out::println); return null; }); // 第二次使用相同的查询，检查是否命中查询缓存 HibernateUtil.excute(session -> { Query query = session.createQuery("FROM User WHERE name = :name"); query.setParameter("name", "杰克"); query.setCacheable(true); List<User> users = query.list(); users.forEach(System.out::println); return null; }); } CRUD简易封装(Hibernate API) 工具类 public class HibernateUtil { public static final SessionFactory sessionFactory; static { try { sessionFactory = new Configuration().configure().buildSessionFactory(); } catch (Exception e){ throw new ExceptionInInitializerError(e); } } //public static Object excute(Function<Session, Object> func) { //将 Object 改为泛型类型，这样可以避免类型转换，增强代码的类型安全性 public static <T> T excute(Function<Session, T> func) { Session session = sessionFactory.openSession(); Transaction transaction = session.beginTransaction(); try { T object = func.apply(session); transaction.commit(); return object; } catch(RuntimeException e){ if (transaction != null) { transaction.rollback(); } throw e; } finally { session.close(); } } } 测试类 public class HibernateTest { @Test public void insert() { HibernateUtil.excute(session -> { User user = new User(); user.setName("杰克"); user.setCreatTime(new Date()); session.save(user); return null; }); } @Test public void query() { HibernateUtil.excute(session -> { User user = session.get(User.class, 10L); System.out.println(user); return null; }); } @Test public void update() { HibernateUtil.excute(session -> { User user = session.get(User.class, 10L); user.setName("Updated Name"); session.update(user); return null; }); } @Test public void delete() { HibernateUtil.excute(session -> { User user = session.get(User.class, 10L); session.delete(user); return null; }); } } 查询 在 Hibernate 中，使用 session.get(entityClass, id) 方法获取实体时，不需要手动指定查询条件，因为它是通过主键（即实体的标识符 id）来直接查找实体的, 适用于通过主键获取单个实体的场景 在这种情况下，id 就是查询条件，因此你不需要手动编写 SQL 或 HQL 查询 当你使用 session.get 方法时，Hibernate 首先会检查一级缓存（即当前 Session 中是否已经存在该实体），如果存在则直接返回，不会再次查询数据库。 如果一级缓存中不存在，Hibernate 会向数据库发送查询，获取实体数据并将其放入一级缓存。 session.get 是一个立即加载方法，意味着它会立即访问数据库并返回完整的实体。如果实体不存在，返回 null。 另一个类似的方法是 session.load(entityClass, id)，它使用延迟加载策略，如果访问的实体不存在，会抛出异常 ObjectNotFoundException。 如果你需要基于其他字段进行查询，或者想要更加灵活的查询条件，可以使用 HQL 或 Criteria API 查询多个实体对象 HQL HQL 是专为 Hibernate 设计的，操作起来类似于 SQL，但针对的是实体类。它支持丰富的查询功能，如关联查询、聚合等，并且可以通过面向对象的方式进行查询 @Test public void hqlMultiQuery() { HibernateUtil.excute(session -> { String hql = "FROM User"; List<User> users = session.createQuery(hql, User.class).list(); users.forEach(System.out::println); return null; }); } Criteria API Criteria API 提供了类型安全和动态查询构建的能力。它允许你在代码中构建复杂的查询，避免了硬编码查询字符串的问题, 在 Hibernate 5.x 及 JPA 中广泛使用，尤其是在需要动态构建查询的情况下 Native SQL 对于复杂的查询，特别是那些 HQL 或 Criteria API 无法实现的查询，使用原生 SQL 查询是一个强大的工具。它允许你直接使用数据库的原生 SQL 功能 @Test public void nativeMultiQuery() { HibernateUtil.excute(session -> { //适用于只查询一个实体表的情况 String sql = "SELECT * FROM testdb.user"; List<User> users = session.createNativeQuery(sql, User.class).getResultList(); users.forEach(System.out::println); //将复杂的结果集映射为对象 String sql2 = "SELECT id, name, creatTime FROM testdb.user"; List<User> users2 = session.createNativeQuery(sql2) .addScalar("id", StandardBasicTypes.LONG) .addScalar("name", StandardBasicTypes.STRING) .addScalar("creatTime", StandardBasicTypes.TIMESTAMP) .setResultTransformer(Transformers.aliasToBean(User.class)) .list(); users2.forEach(System.out::println); return null; }); } 实体类关联关系 一对一 有两个实体类：User 和 Address，并且每个 User 关联一个 Address，这是一个一对一的关系 一对多 一个用户可以有多个订单 多对一 多个订单属于一个用户 多对多 一个学生可以选修多门课程，一门课程也可以有多个学生选修 外键 外键字段是数据库表设计的核心部分，它们定义了表之间的关系。 在 JPA/Hibernate 中，实体类的映射关系需要与数据库表结构一致。 即使 Hibernate 可以根据实体类生成表结构，通常仍然建议在数据库表创建时明确地定义外键字段 数据库设计工具和迁移工具（如 Flyway 或 Liquibase）可以帮助管理和更新数据库结构。 如果在应用开发过程中依赖 Hibernate 自动更新表结构，可能会遇到不一致或无法预见的情况。 使用迁移工具可以提供更好的控制和透明度 虽然 Hibernate 提供了 hibernate.hbm2ddl.auto 配置选项来自动更新数据库表结构，但在生产环境中，动态生成外键字段并不是最佳实践 在开发阶段，可以使用 Hibernate 的自动更新功能来快速迭代，但在生产环境中，依赖数据库迁移工具和手动管理的方式更为稳妥 一对一 CascadeType.ALL: 表示对 User 实体的所有操作（如保存、删除）都会级联到关联的 Address 实体 例如在删除 User 时一并删除其关联的 Address @JoinColumn: 在 User 实体类中指定了 address_id 作为外键，这个外键关联到 Address 实体的 id 字段 User 表中的 address_id 是外键，指向 Address 表中的 id 字段 作为外键的主要作用是建立和维护 User 和 Address 实体之间的一对一关联关系，确保数据的完整性，简化复杂数据模型的操作，并避免数据冗余 hibernate.hbm2ddl.auto属性配置为update、create等, 启用了自动创建表结构的功能时, Hibernate会自动处理外键字段的创建 如果没有启用自动生成，需要手动在数据库中添加外键字段 从数据库中读取 User 实体时，Hibernate 会自动加载并填充与之关联的 Address 实体 Hibernate 对于 @OneToOne 关系会使用 FetchType.LAZY 懒加载策略，这意味着只有在你显式访问 user.getAddress() 时，Hibernate 才会查询并加载 Address 实体。 如果希望在加载 User 时立即加载 Address，可以将 fetch 属性设为 FetchType.EAGER @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.EAGER) @JoinColumn(name = "address_id", referencedColumnName = "id") private Address address; // getters and setters } @Entity public class Address { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String street; private String city; private String country; // getters and setters } 通过这种配置，可以在创建 User 实体时，直接包含 Address 实体 User user = new User(); user.setName("John Doe"); Address address = new Address(); address.setStreet("123 Main St"); user.setAddress(address); session.save(user); hbm.xml形式 如果你的实体类的主键属性已经在 Java 类中明确声明了类型（如 Long id;），Hibernate 可以自动推断出该字段的类型，因此在 .hbm.xml 文件中通常不需要显式指定 type 属性 <!-- User.hbm.xml --> <hibernate-mapping> <class name="com.example.User" table="user"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="name" column="name" type="string"/> <one-to-one name="address" class="com.example.Address" cascade="all" fetch="eager"> <column name="address_id"/> </one-to-one> </class> </hibernate-mapping> <!-- Address.hbm.xml --> <hibernate-mapping> <class name="com.example.Address" table="address"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="street" column="street" type="string"/> <property name="city" column="city" type="string"/> <property name="country" column="country" type="string"/> </class> </hibernate-mapping> 一对多 @Entity @Table(name = "user") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; //mappedBy = "user" 表示 User 实体类的一对多关系由 Order 实体类中的 user 字段映射 //当删除用户时,一并删除该用户的所有订单 //从 User 的 orders 集合中移除了某个 Order, 那么该 Order 实体会自动从数据库中删除, 避免数据库中遗留无效数据 @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true) private List<Order> orders = new ArrayList<>(); // Getters and Setters } @Entity @Table(name = "orders") public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String orderDetails; //当加载 Order 实体时，不会立即加载与之关联的 User 实体。只有当你实际访问 Order 实体的 getUser() 方法时，Hibernate 才会发送一条额外的 SQL 查询来获取 User 实体的数据 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = "user_id") //在 orders 表中将创建一个名为 user_id 的列，用于存储 User 实体的外键。 private User user; //它只是用来在 Java 代码中表示 Order 实体与 User 实体的关联, 不需要在数据库表中创建user列 // Getters and Setters } 获取用户的订单列表 当从数据库中读取User对象时，如果你配置了@OneToMany和@ManyToOne的关系，并且设置了正确的抓取策略和级联操作，Hibernate会自动将Order列表还原到User对象中 User user = session.get(User.class, userId); List<Order> orders = user.getOrders(); Order对象成员使用 private User user 而不是 private Long userId 的原因 在 Hibernate 中，使用实体类之间的关系映射（如 @ManyToOne）时，推荐直接使用实体对象而不是仅仅使用外键字段（如 userId）。原因如下： 自动管理外键： 使用实体对象（如 User）时，Hibernate 会自动管理外键字段的设置，确保数据库中的数据一致性。这意味着在保存或更新 Order 时，Hibernate 会自动设置 user_id 外键字段。 面向对象的设计： 直接使用 User 对象遵循面向对象编程的原则，使代码更加直观和易于维护。通过对象的关系直接导航（如 order.getUser().getName()），避免手动管理外键字段的复杂性。 延迟加载： 使用实体对象可以利用延迟加载功能，只在需要时才加载相关数据，这在性能优化上有优势。 级联操作： 通过实体对象可以方便地配置级联操作，如删除用户时自动删除其相关的订单。 虽然可以在 Order 类中只使用 userId，但这会让 Hibernate 失去对这些功能的支持，并且需要手动管理更多的逻辑。因此，一般推荐使用实体对象而非外键字段来表示关系。 hbm.xml形式 <!-- User.hbm.xml --> <hibernate-mapping> <class name="com.example.User" table="user"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="name" column="name" type="string"/> <set name="orders" inverse="true" cascade="all,delete-orphan"> <key column="user_id"/> <one-to-many class="com.example.Order"/> </set> </class> </hibernate-mapping> <!-- Order.hbm.xml --> <hibernate-mapping> <class name="com.example.Order" table="orders"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="orderDetails" column="orderDetails" type="string"/> <many-to-one name="user" class="com.example.User" fetch="select"> <column name="user_id" not-null="false"/> </many-to-one> </class> </hibernate-mapping> 多对一 @Entity @Table(name = "orders") public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String productName; @ManyToOne @JoinColumn(name = "user_id") //orders 表将创建 user_id 外键列存储User对象的主键 private User user; // Getters and Setters } @Entity @Table(name = "users") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; // Getters and Setters } 查询订单并获取其用户信息 Session session = HibernateUtil.getSessionFactory().openSession(); Order order = session.get(Order.class, 1L); System.out.println("Product: " + order.getProductName()); System.out.println("Ordered by: " + order.getUser().getName()); session.close(); hbm.xml形式 <!-- Order.hbm.xml --> <hibernate-mapping> <class name="com.example.Order" table="orders"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="productName" column="product_name" type="string"/> <many-to-one name="user" class="com.example.User" fetch="select"> <column name="user_id" not-null="true"/> </many-to-one> </class> </hibernate-mapping> <!-- User.hbm.xml --> <hibernate-mapping> <class name="com.example.User" table="users"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="name" column="name" type="string"/> </class> </hibernate-mapping> 多对多 @Entity @Table(name = "student") public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; //创建中间表student_course //joinColumns 指定了当前实体的主键在中间表中的列名 //inverseJoinColumns 指定了关联实体（Course）的主键在中间表中的列名 @ManyToMany(cascade = { CascadeType.ALL }) @JoinTable( name = "student_course", joinColumns = { @JoinColumn(name = "student_id") }, inverseJoinColumns = { @JoinColumn(name = "course_id") } ) private Set<Course> courses = new HashSet<>(); // getters and setters } @Entity @Table(name = "course") public class Course { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; @ManyToMany(mappedBy = "courses") //多对多关系由Stutdent类中的courses来映射 private Set<Student> students = new HashSet<>(); // getters and setters } hbm.xml形式 <!-- Student.hbm.xml --> <hibernate-mapping> <class name="com.example.Student" table="student"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="name" column="name" type="string"/> <set name="courses" table="student_course" cascade="all"> <key column="student_id"/> <many-to-many column="course_id" class="com.example.Course"/> </set> </class> </hibernate-mapping> <!-- Course.hbm.xml --> <hibernate-mapping> <class name="com.example.Course" table="course"> <id name="id" column="id"> <generator class="identity"/> </id> <property name="name" column="name" type="string"/> <set name="students" table="student_course" inverse="true"> <key column="course_id"/> <many-to-many column="student_id" class="com.example.Student"/> </set> </class> </hibernate-mapping> Hibernate Validator Hibernate Validator 是 Hibernate 框架的一部分，它实现了 Java Bean Validation 规范（JSR 303 和 JSR 380） 如果你使用的是 Spring Boot 的 starter-validation，已经包含了 Hibernate Validato 在传统的 Spring 项目和非 Spring 项目中，需要显式添加 Hibernate Validator 的依赖 jakarta.el 是 Hibernate Validator 依赖的表达式语言库，用于解析注解中的表达式 <dependency> <groupId>org.hibernate.validator</groupId> <artifactId>hibernate-validator</artifactId> <version>8.0.0.Final</version> </dependency> <dependency> <groupId>org.glassfish</groupId> <artifactId>jakarta.el</artifactId> <version>4.0.2</version> </dependency> 日期类型的处理 对于 java.util.Date和java.util.Calendar ，Hibernate将其映射为数据库中的 TIMESTAMP 类型。 @Temporal 注解在 Hibernate 中用于指定如何将 Java 的日期或时间类型映射到数据库的日期或时间字段 只能用于 java.util.Date 和 java.util.Calendar 类型，用于明确地告诉 Hibernate 在数据库中使用哪种时间类型, 因为java.util.Date 和 java.util.Calendar 同时包含日期和时间 @Temporal(TemporalType.DATE) 映射为数据库中的 DATE 类型 @Temporal(TemporalType.TIME) 映射为数据库中的 TIME 类型 @Temporal(TemporalType.TIMESTAMP) 映射为数据库中的 TIMESTAMP 类型 无论是写入还是读取，@Temporal 注解都会确保 Java 中的 java.util.Date 或 java.util.Calendar 类型与数据库的日期时间类型之间的正确映射 对于 LocalDate 映射为数据库中的 DATE 类型 对于 LocalDateTime映射为数据库中的 TIMESTAMP 类型 自定义日期格式 @Converter(autoApply = true) public class LocalDateAttributeConverter implements AttributeConverter<LocalDate, String> { private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); @Override public String convertToDatabaseColumn(LocalDate attribute) { return attribute != null ? attribute.format(formatter) : null; } @Override public LocalDate convertToEntityAttribute(String dbData) { return dbData != null ? LocalDate.parse(dbData, formatter) : null; } } @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Convert(converter = LocalDateAttributeConverter.class) private LocalDate birthDate; // getters and setters } 序列化问题 实体类需要标记 Serializable 代理对象的序列化 Hibernate 使用代理（proxy）来延迟加载实体（Lazy Loading）。这些代理对象通常不应该被序列化 如果某些属性不应参与序列化（如与 Hibernate 相关的内部状态），可以将这些属性标记为 transient 关联的序列化 一对一和多对一关联: 这些通常没有特别的问题，但确保相关的实体类也实现了 Serializable 接口 一对多和多对多关联: 这些关联可能包含大量数据。如果这些数据被序列化，可能会导致性能问题。 使用 transient 关键字来避免序列化不必要的关联数据，或者通过配置映射文件来控制数据的序列化行为 与spring整合 pom.xml <dependencies> <!-- Spring Core --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>5.3.21</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.3.21</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>5.3.21</version> </dependency> <!-- Spring ORM --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-orm</artifactId> <version>5.3.21</version> </dependency> <!-- Hibernate --> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-core</artifactId> <version>5.6.14.Final</version> </dependency> <!-- Database Driver --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.26</version> </dependency> </dependencies> applicationContext.xml <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"> <!-- 数据源配置 --> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/your_database"/> <property name="username" value="your_username"/> <property name="password" value="your_password"/> </bean> <!-- Hibernate 配置 --> <bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"> <property name="dataSource" ref="dataSource"/> <property name="packagesToScan" value="com.example.entity"/> <property name="hibernateProperties"> <props> <prop key="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</prop> <prop key="hibernate.show_sql">true</prop> <prop key="hibernate.hbm2ddl.auto">update</prop> </props> </property> </bean> <!-- 事务管理器配置 --> <bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"> <property name="sessionFactory" ref="sessionFactory"/> </bean> <!-- 启用注解驱动的事务管理 --> <tx:annotation-driven transaction-manager="transactionManager"/> </beans> dao @Repository public class UserDao { @Resource private SessionFactory sessionFactory; public User getUserById(Long id) { Session session = sessionFactory.getCurrentSession(); return session.get(User.class, id); } public void saveUser(User user) { Session session = sessionFactory.getCurrentSession(); session.save(user); } } service @Service public class UserService { @Autowired private UserDao userDao; @Transactional public User getUserById(Long id) { return userDao.getUserById(id); } @Transactional public void saveUser(User user) { userDao.saveUser(user); } } 与spring boot整合 在 Spring Boot 项目中，Hibernate 通常作为 spring-boot-starter-data-jpa 依赖的一部分 pom.xml <dependencies> <!-- Spring Boot Starter Data JPA --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <!-- MySQL Connector --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <!-- Ehcache --> <dependency> <groupId>net.sf.ehcache</groupId> <artifactId>ehcache</artifactId> <version>2.10.6</version> </dependency> </dependencies> application.properties # 数据库连接配置 spring.datasource.url=jdbc:mysql://localhost:3306/yourdatabase spring.datasource.username=root spring.datasource.password=yourpassword # Hibernate 配置 spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect # 物理命名, 隐式命名策略 spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy spring.jpa.hibernate.naming.implicit-strategy=org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy # 使用 HikariCP 连接池 (Spring Boot 默认) spring.datasource.hikari.maximum-pool-size=10 # Hibernate 二级缓存配置 spring.jpa.properties.hibernate.cache.use_second_level_cache=true spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory`,``,`html`,`HTML&CSS`,`20240328220321-_前端 html seo一个页面h1只有一个且靠近body name="", 锚点跳转, name可重复 table ul无序列表,ol有序 caption表格名,th列名 合并行列,colspan, rowspan 如第四行与第五行的第一列内容相同, 则在第四行的第一个td里写上rowspan='2',删除第五行的第一个td 如将某一行的4个td合为一块,则在第一个td里写上colspan='4',删除后面3个td 范围标签,caption表名,thead用来包<tr><th>,tbody用来包th以下的,tfoot用来包最后一行 bgcolor,写在table里的cellpadding,cellspace格间距,frame外边框,rules格边框 表单 单选radio和复选框checkbox中name相同才能表示为同一组 表单中的value值都是传递给后台用的 css 颜色表16进制前两位R,次两位G,#ff0000对应255,0,0 红 对齐方式justify两端对齐 选择器 ::first-line,::first-letter *星号选择器选择所有内容,#div1+p,选择选择div1所有兄弟元素中的p元素 css选择器的优先级 !important>style>id>class>标签>*>浏览器默认属性 box-sizing设置为border-box时,padding的宽度从内容宽度里扣除 定位 使用margin:0px auto的时候对象一定设置宽度,否则没有居中效果,上下,左右,上,右,下,左 清除浮动: 为了父元素不会出现"高度崩塌" 如果强制规定外层容器的尺寸,则显得就那么灵活了,高度就不能自动适应了 从某个元素开始,不再需要浮动效果了 #clearDiv::after{ content:""; visibility:hidden; height:0px; display:block; clear:both; } #clearDiv{ zoom:1; /*针对IE*/ } line-height与height设置一样时可达到垂直居中效果 通常情况下相对定位作为绝对定位的父一级元素来使用,不用设置top位置等,仅是给绝对定位提供一个参照点 这样当相对定位整体移动时不会破坏子一级的绝对定位 相对定位参照点是自身,偏移之位原位置不会被占用依然被保留 绝对定位参照点是父一级元素 绝对会忽略原位置,浮动会绕过原位置,绝对和浮动组合时可兼具偏移微调和绕过原位置的特点 伪类控制元素隐藏和显示 <div class="header"> <div class="menu"> <ul> <li></li> <li></li> </ul> </div> </div> .header .menu ul{ display:none; } .header .menu:hover ul{ display:block; }`,``,`html`,`IDEA`,`20240322141708-_工具使用 简中乱码 appearence 字体改支持中文的ms yahei ui setting, editor, file encodings global encoding utf8 project encoding utf8 defaupt encoding for properties files utf8 transparent native-to-ascli conversion tomcat目录下/conf/logging.properties中的日志编码改UTF-8 实现了多个监听器接口，可能在Tomcat启动过程中执行的时机不同，导致编码环境不同 尝试在println之前手动设置编码 System.setProperty("file.encoding", "UTF-8"); Tomcat的启动参数中包含以下设置 -Dfile.encoding=UTF-8 集成的powershell终端输出乱码, 就地输入 $OutputEncoding = [Console]::OutputEncoding = [Text.UTF8Encoding]::new() 全局修改 System Settings取消Reopen关闭再次打开 customize,all settings maven的config目录下setting.xml中localRepository中指定新的本地仓库路径 idea构建工具maven设置中指定maven的安装目录,应用setting.xml文件地址和仓库新地址 修改默认工程目录apperance system settings use complier eclipse build project automatically(停止状态或debug状态) compile independent modules inparallel share build process heap size 8192 Edit Custom VM Options… -Xms8192m -Xmx8192m -XX:ReservedCodeCacheSize=2048m -Dfile.encoding=UTF-8 -Deditable.java.test.console=true 标签页设双层, editor,general,editor tabs multple rows 集成终端首选bash tools, terminal, shell path选择bash.exe路径例如E:\Git\bin\bash.exe, 命名为bash 重装 导出设置,关闭 删除C:\Users\ida\AppData\Roaming\JetBrains 删除\HKEY_CURRENT_USER\Software\JavaSoft 卸载,重启,重装 运行选项 1. Update Resources 资源文件（如 HTML、CSS、JS 文件）直接更新到服务器, 不包括 JSP 文件，因为它们需要编译为 Servlet 类 不重新编译 Java 类 2. Update Classes and Resources 更新或增加了Java 类jsp文件和资源文件 3. Redeploy 当进行了较大改动或需要重新部署整个应用时 4. Restart Server 进行了一些需要服务器重启才能生效的配置更改时使用此选项 在运行模式和调试模式下，各种操作的行为基本相同，主要是更新的内容和是否导致中断。调试模式下，通常会尽量避免中断，以便继续调试工作。 同时运行多个类实例 Allow multiple instances 重置 双shift搜索Reset all settings Live Temmpates 预设 表达式.if:生成if块 fori: inn:如果不为null iter:增强for itit:for list.size() itm:遍历map kv thr:throw new 自定义 20240629043009.webp --------------------------------------------------------------- xml --------------------------------------------------------------- cm <!-- $END$ --> --------------------------------------------------------------- java --------------------------------------------------------------- lb private static final Logger logger = LoggerFactory.getLogger($CLASS_NAME$.class); lbp import org.slf4j.Logger; import org.slf4j.LoggerFactory; lj private static final Logger logger = LogManager.getLogger($CLASS_NAME$.class); ljp import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; tc "text/html;charset=UTF-8" sa System.out.println(Arrays.toString(new Object[]{$END$})); 手动加包 通常创建一个与src同级的lib,本地包放进lib,模块f4,依赖,指定jar包 服务分组 services, add Service, Run Configuration Type, SPring Boot 快捷键 ctrl + alt + N : 变量内联 ctrl + alt + C : 引入常量, F字段, P方法形参 ctrl + N : 搜索类 ctrl + shift + space : 再次显示提示, 各种补全 ctrl + p : 形参提示 ctrl + W : 渐扩选区 ctrl + alt + T : 包围 ctrl + shift + del : 解包 .if 键入if, 按自动补全, 输入条件, 按自动补全, 输入动作, 按自动补全 修改历史, 可以保留一些现状,同时恢复之前的片断 ctrl + Q : 泡窗文档 ctrl + shift + i : 泡窗方法定义速览 F2定位到警告, Ctrl + F1 展开警告说明 ctrl + shift + f7 : 高亮笔刷 ctrl + shift + f/r : 文件查替窗口, 输入apple, 会找到app的字符串, 但也包含了一些类似apple的字符串, 按alt + m将范围缩小到一个完整的单词, 可以选择替换作用域 光标 多行末尾放置光标：Alt + Shift + G：先选后按 多处光标：Alt + Shift + 左击：复点取消所置光标 多处光标：按Ctrl键两次不松开的情况下按向上下左右 同名处放置光标：Ctrl + Alt + Shift + J：同时擦写所有同名位置 同名渐选：Alt + J：Alt + Shift + J取消末次选择 同名词间切换：Ctrl + F3 词间定位：Ctrl + 左右 定位行号：Ctrl + G 定位到最近的编辑位置：Ctrl + Shift + Backspace 定位到前后方法名处：Alt + 上下 定位到所属大括号外侧首尾：Ctrl + Shift +M 定位到所属大括号内侧首尾：Ctrl + 中括号 复按扩区 行 移动行：Alt + Shift + 上下 左右移动元素：Ctrl + Alt + Shift + 左右：比如对调比较符两边的元素,对调形参 规范缩进行：Ctrl + Alt + I：光标置于缩进不规范的行后按此 向上新行：Ctrl + Alt + Enter 向下新行：Shift + Enter 向下克隆行：Ctrl + D 删除行：Ctrl + Y 折叠 移动块方法：Ctrl + Shift + 上下 折叠/展开：Ctrl + 减/加 全折叠/展开：Ctrl + Shift + 减/加 选取 矩形选区：Alt + 框选：垂直移动等同于多处光标 多个矩形选区：Ctrl + Alt + Shift + 多处框选 选取整词：Ctrl + Shift + 左右 选取块内容：先Ctrl+[定位到所属大括号内侧首,然后Ctrl+Shift+[选取块内容 渐扩选区：Ctrl + W：渐缩Ctrl + Shift + W 辅助 建议：Alt + Enter 形参提示：Ctrl + P 方法文档泡窗：Ctrl + Q 语句补全：Ctrl + Shift + Enter 基本补全：Ctrl +Space：输入字母列出匹配的词组 智能补全：Ctrl + Shift + Space：列出与预期类型一致的方法或变量 补全类名：Ctrl + Alt + Space 生成语句：Alt + Insert：比如构造,getter,toString等 包裹标签：Ctrl + Alt + T 重写：Ctrl + O 显示错误描述：Ctrl + F1 下一处错误：F2 当前文件的问题栏嵌：Alt + 6 查找用法弹窗：Ctrl + Alt + F7：Alt + F7 栏嵌 跳转到父类：Ctrl + U 跳转到声明处：Ctrl + B 跳转到声明类处：Ctrl + Shift + B 视图 方法列表: Alt + 7 只读：右下锁 切窗：Ctrl + Tab：按所选 切窗：Alt + 左右：按标签栏顺序 切窗：Ctrl + Alt + 左右：按文件打开历史 最近文件：Ctrl + E：弹窗 文件结构：Ctrl + F12：弹窗 在新窗口打开当前文件：Shift + F4 窗口高度调整：Ctrl + Alt + Shift + 上下：比如调整debug栏窗高度 隐藏活动的工具窗口：Shift + Escape 隐藏所有工具窗口：Ctrl + Shift + F12 匿名书签：F11 数字标签：Ctrl + Shift + 数字 数字标签跳转：Ctrl + 数字 助词书签：Ctrl + F11 显示所有书签：Shift + F11 查替 任意查找：双击Shift 当前文件内查找：Ctrl + F：F3 下一处 Shift + F3上一处 所有文件内查找：Ctrl + Shift + F 当前文件内替换：Ctrl + R 所有文件内替换：Ctrl + Shift + R 重构 重构列表：Ctrl + Alt + Shift + T 修改名称：Shift + F6 修改签名：Ctrl + F6 内联：Ctrl + Alt + N 移动：F6 提取方法：Ctrl + Alt + M 引入域：Ctrl + Alt + F 引入参数：Ctrl + Alt + P 引入变量：Ctrl + Alt + V 安全删除：Alt + Delete 其它 复制文件路径：Ctrl + Shift + C 复制包路径或者类名称：Ctrl + Alt + Shift + C：在项目列表中选中某中后按此 大小写转换：Ctrl + Shift + U：仅光标未选中字符时对整词进行转换 格式化代码：Ctrl + Alt + L 行注释：Ctrl + /：// 块注释：Ctrl + Shift + /：/**/ 创建临时文件：Ctrl + Alt + Shift + Insert：可跨项目访问,不会保存到项目中,可在Scratches中新建 控制台停止：Ctrl + F2 重做：Ctrl + Shift + Z 从历史选择粘贴：Ctrl + Shift + V 基本补全：ctrl + space：与语言快捷键的冲突, win系统语言添加英语首选, 徵标 + space 切换语言 任意查找：双shift：与语言快捷键的冲突, win系统语言添加英语首选, 徵标 + space 切换语言`,``,`html`,`interface`,`20240616183123-_java 定义某一批类必须提供的某些方法, 通过接口引用指向实现类的方式, 描述不同的类型所具有的相似行为 接口中的方法 接口中的方法会被隐式的指定为 public abstract 当类实现接口时,需要去实现接口中的所有抽象方法,否则需要将该类设置为抽象类 接口中的默认方法 接口中可以有default修饰的带方法体的默认方法,子类不必强制实现 通过接口引用指向实现类来调用,子类可以重写该方法,修饰符将改为public, 重写方法中若要调用父类版本,方式为接口名.super.方法名 接口中的静态方法 接口名.静态方法名 不可以在实现类中重写 接口中的常量 接口中的变量会被隐式的指定为 public static final 接口名.常量 子类中有同名常量时,若为接口引用指向实现类,则依旧调用接口常量 一个接口实现多个父接口 如果子接口的多个父接口中有同名的default修饰的带方法体的默认方法,子接口必须提供自己独有的默认方法 一个类实现多个接口 如果多个接口中有同名的default修饰的带方法体的默认方法,实现类需要重写自己的默认方法 如果多个接口中有同名变量,必须以接口名.变量的方式明确调用 一个类继承一个唯一父类同时实现多个接口 如果父类和接口中有同名方法时,接口引用指向实现类时默认调用父类的方法,子类也可以重写该方法 如果父类和接口中有同名变量常量时,子类必须提供自己独有的同名变量常量 或接口名.变量,或静态方法中new 父类().变量,或非静态方法中super.变量`,``,`html`,`IO`,`20240307183503-_java IO的分类 20240619185632.webp 字节流（Byte Streams） 处理二进制数据，如图像、音频、视频文件 字符流（Character Streams） 处理文本数据，如文本文件 缓冲流（Buffered Streams） 提高IO操作的效率，减少对底层设备的读写次数 数据流（Data Streams） 读写基本数据类型和字符串。 对象流（Object Streams） 读写Java对象，实现对象的序列化和反序列化。 文件流（File IO） 读写文件，提供对文件和目录的操作。 管道（Pipes） 用于线程之间的通信。 序列流（Sequence Streams） 用于将多个输入流串联成一个输入流。 特殊用途的流（Specialized Streams） 推回输入流 字节流和字符流及转换器 字节流可以处理任何类型的数据，如图片、avi等，基本以Stream结尾 字符流只能处理字符类型的数据,都以Reader或Writer结尾 InputStreamReader(OutputStreamWriter同理) InputStreamReader是将字节流转换为字符流的桥梁 InputStreamReader封裝了InputStream类,一次读取一个字符 而BufferedReader进一步封裝了InputStreamReader类,一次读取一行字符 例:BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); //public final static InputStream in 未被包装过的InputStream 在使用System.in（标准输入流）时，需要将其转换为字符流并加上缓冲区,因此使用BufferedReader来包装InputStreamReader BufferedReader的最大特点就是缓冲区的设置。 通常Reader 所作的每个读取请求都会导致对底层字符或字节流进行相应的读取请求 如果没有缓冲，则每次调用 read() 或 readLine() 都会导致从文件中读取字节，并将其转换为字符后返回，而这是极其低效的。 使用BufferedReader可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 因此，建议用 BufferedReader 包装所有其 read() 操作可能开销很高的 Reader（如 FileReader 和InputStreamReader）。 在使用字符流读取文本文件时(且不使用包装流时),有两种类提供读取文件方法,分别是InputStreamReader和FileReader,后者为前者子类。 InputStreamReader是用来读取原始字节流, 以二进制方式处理，不会出现乱码现象,可指定编码格式 FileReader类的构造函数假定默认字符编码和默认字节缓冲区大小是适当的 当文本文件编码与编译工具默认编码不同时,读取文件会出现乱码的情况 大多数情况下，Java 编译器（如 javac）会使用操作系统的默认编码方式来解析源代码文件。 例如，Windows 系统通常使用 GBK 或 UTF-8（最新版本），而 macOS 和大多数 Linux 发行版通常使用 UTF-8。 在开发中统一使用 UTF-8 编码，因为它支持几乎所有的字符和语言，并且是互联网标准中广泛使用的编码方式 如果需要，可以通过 -encoding 参数显式地告知编译工具使用特定的编码方式进行编译 javac -encoding UTF-8 MyClass.java 在使用文本编辑器编写代码时，可以检查编辑器的默认编码设置，并确保与预期的编码方式一致。 // 方法1 File file = new File("info.txt"); FileInputStream fis = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(fis, "UTF-8"); BufferedReader br = new BufferedReader(isr); //方法2 //对于不需要编码设置时推荐使用Files.newBufferedReader() 方法，它更简洁和高效 //Paths.get() 方法是 Java NIO 中用于获取 Path 对象的工厂方法,Files 是 Java NIO 中的一个实用类，提供了一系列对文件系统进行操作的静态方法 //Files.newBufferedReader(Path path) 方法用于从指定的文件路径 (Path 对象)创建一个 BufferedReader 对象 BufferedReader br = Files.newBufferedReader(Paths.get("info.txt")); // 方法3 File file = new File("info.txt"); FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr); File类 File 类不仅仅表示一个文件，它也可以表示一个目录或文件路径 关于路径 Windows中分割符是“\”，Linux是“/”,因此平时在代码中不要使用诸如“\”这种代表路径，可能造成Linux平台下代码执行错误 而File类给我们提供了抽象的表示File.separator，屏蔽了系统层的差异。 String filePath = "folder" + File.separator + "subFolder" + File.separator + "file.txt"; String filePath = String.join(File.separator, "folder", "subFolder", "file.txt"); FileSystems.getDefault()返回一个表示默认文件系统的 FileSystem 对象, 在 Windows 上是 NTFS，而在 Unix 或 Linux 上是 Ext4 // getPath(String first, String... more) 参数会合成一个路径，路径的分隔符（如斜杠 / 或反斜杠 \）会根据操作系统自动调整 Path path = FileSystems.getDefault().getPath("d:", "mess", "a.png"); //"d:\mess\a.png" Path path = FileSystems.getDefault().getPath(filePath, etc); 路径的解码 String path = Demo.class.getResource("../../../config.properties").getPath(); //getPath() 返回的路径可能会被编码，特别是当路径中包含特殊字符或空格时 path = URLDecoder.decode(path,"UTF-8"); File类常用方法 class FileExample { public static void main(String[] args) { try { // 创建新文件 File file = new File("example.txt"); if (file.createNewFile()) { System.out.println("File created: " + file.getName()); } else { System.out.println("File already exists"); } // 创建新目录 File directory = new File("exampleDir"); if (directory.mkdir()) { System.out.println("Directory created: " + directory.getName()); } else { System.out.println("Directory already exists or failed to create"); } //if (!dir.exists()) dir.mkdirs(); //if (!dir.exist()) dir.mkdir(); // 获取绝对路径 System.out.println("Absolute path: " + file.getAbsolutePath()); // 获取文件名 System.out.println("File name: " + file.getName()); // 获取父目录路径 File nestedFile = new File("exampleDir" + File.separator + "nested.txt"); System.out.println("Parent directory: " + nestedFile.getParent()); // 获取文件长度 System.out.println("File length: " + file.length() + " bytes"); // 重命名文件 File newFile = new File("renamed_example.txt"); if (file.renameTo(newFile)) { System.out.println("File renamed successfully"); } else { System.out.println("Failed to rename file"); } // 列出目录内容 File[] filesAndDirs = directory.listFiles(); if (filesAndDirs != null) { System.out.println("Files in directory " + directory.getName() + ":"); for (File f : filesAndDirs) { System.out.println(f.getName()); } } // 删除文件和目录 if (newFile.delete()) { System.out.println("File deleted"); } if (directory.delete()) { System.out.println("Directory deleted"); } } catch (IOException e) { e.printStackTrace(); } } } 根据传入的规则，遍历得到目录中所有的文件构成的File对象数组 public class FileExample { //将 regex 声明为 final 是为了保证匿名内部类 FilenameFilter 能够访问它，同时确保它的值在方法执行期间保持不变。 //这是一种常见的编程习惯，特别是在处理匿名内部类时，以确保代码的安全性和正确性。 public static File[] getLocalFiles(File dir, final String regex){ return dir.listFiles(new FilenameFilter() { private final Pattern pattern = Pattern.compile(regex); @Override public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } }); } // 重载方法 public static File[] getLocalFiles(String path, final String regex){ return getLocalFiles(new File(path),regex); } public static void main(String[] args) { String dir = String.join(File.separator, "D:", "Dropbox", "ebook","2__古典文学","诸子百家"); File[] files = FileExample.getLocalFiles(dir,".*\\.txt"); for(File file : files){ System.out.println(file.getAbsolutePath()); } } } flush和close flush() 将缓冲区中的数据强制写出，但不会关闭流 强制将缓冲区中的内容写入底层输出流 fos，确保所有数据都写入文件中。 因为缓冲区可能还没有满，所以需要调用 flush() 以确保数据被写入文件。 close() 关闭输出流。close() 方法会先调用 flush()，确保所有数据都写入文件，然后释放资源。 关闭流的顺序 在写操作中，使用缓冲流时需要先关闭缓冲流，再关闭底层的输出流 缓冲流会将数据先写入内部缓冲区，而不是立即写入底层输出流。只有当缓冲区满了或者显式调用 flush() 方法时，数据才会被写入底层输出流。 调用缓冲流的 close() 方法时，会先调用 flush() 方法将缓冲区中的所有数据写入底层输出流，然后再关闭缓冲流本身。 如果先关闭了底层输出流，缓冲流将无法再将数据写入已关闭的底层输出流，从而导致数据丢失。 在读操作中，关闭流的顺序可以是任意的 缓冲流会先从底层输入流读取数据到缓冲区，然后再从缓冲区读取数据。即使底层输入流被关闭，已经读取到缓冲区的数据仍然可用 显式调用 flush()的原因 确保及时写出数据：如果你希望在程序运行期间多次写出数据，并且希望这些数据及时写入文件而不是在缓冲区中等待，可以显式调用 flush()。 如果写操作和关闭流之间有大量其他操作，显式调用 flush() 可以确保数据在这些操作之前被写入文件 在调试和测试过程中，显式调用 flush() 可以确保数据写入文件，这样可以查看中间结果而不必关闭流 如果确定在每次写操作之后不需要立即将数据写入文件，并且可以等到流关闭时再写入，那么显式调用 flush() 是不必要的 缓冲区 自定义缓冲区 public class FileCopyExample {//文件拷贝 public static void main(String[] args) { try (FileInputStream fis = new FileInputStream("happy.gif"); FileOutputStream fos = new FileOutputStream("happy(1).gif")) { int n; byte[] buffer = new byte[1024]; // 读取并写入数据 // 尝试从 fis 输入流中读取数据到字节数组 b 中，并将实际读取的字节数赋给 n, 到达文件末尾时返回 -1 while ((n = fis.read(buffer)) != -1) { //fos.write(b) 方法将整个字节数组写入到输出流中，不会考虑数组中实际有效数据的长度 n，而是将整个数组长度的数据写入 // 当写到最后时实际内容不够1024,但还是用掉了1024的空间,导致新生成的文件比原文件大 //fos.write(b, 0, n) 方法用于将字节数组 b 中从索引 0 开始，长度为 n 的实际字节数据写入到输出流中。 //在文件复制或数据传输过程中，应该始终使用 fos.write(b, 0, n) 这种形式，以确保只写入实际读取的数据长度 fos.write(buffer, 0, n); } } catch (IOException e) { e.printStackTrace(); } } } 自动管理缓冲区 BufferedInputStream/BufferedOutputStream 不需要手动创建和管理 byte[] buffer 数组。 默认缓冲区大小通常为 8192 字节,也可以指定大小BufferedOutputStream(OutputStream out, int size) 文件复制 如果处理的是小文件或者对复制速度要求不是非常高的情况下，使用 BufferedInputStream 和 BufferedOutputStream 可以简单快速地完成任务。缺点是对于大文件，由于数据是逐字节传输的，可能效率较低，特别是在网络文件系统或远程位置时。 对于需要高性能和大文件处理的场景，特别是需要考虑到文件系统的效率和零拷贝技术的情况，使用 FileChannel 和 ByteBuffer 更为合适, 它能够提供更高的吞吐量和更低的 CPU 使用率，尤其在处理大文件时表现更为明显 参见IO模型中NIO复制例 public class BufferedFileCopySimplified { public static void main(String[] args) { try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("happy.gif")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("happy(1).gif"))) { int data; while ((data = bis.read()) != -1) { bos.write(data); } } catch (IOException e) { e.printStackTrace(); } } } 文件复制改名例 /** * 编写一个程序，将java目录下的所有.java文件复制到jad目录下，并将原来文件的扩展名从.java改为.jad */ public class 文件复制和改扩展名 { public static void main(String[] args) { File srcDir = new File(String.join(File.separator, "D:", "Dropbox", "workspace", "idea", "try", "java")); File destDir = new File(String.join(File.separator, "D:", "Dropbox", "workspace", "idea", "try", "jad")); if (!destDir.exists()) destDir.mkdirs(); File[] files = getLocalFiles(srcDir, "^.*\\.java$"); for (File file : files) { String newName = file.getName().replace(".java", ".jad"); File destFile = new File(destDir, newName);//表示复制后的文件, 第一个参数是目录路径，第二个参数是文件名 fastCopy(file, destFile); } System.out.println("复制和改名完成！"); } public static File[] getLocalFiles(File dir, final String regex) { return dir.listFiles(new FilenameFilter() { private final Pattern pattern = Pattern.compile(regex); @Override public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } }); } public static File[] getLocalFiles(String path, final String regex) { return getLocalFiles(new File(path), regex); } public static void fastCopy(File file, File destFile) { try (FileInputStream fis = new FileInputStream(file); FileChannel fisChannel = fis.getChannel(); FileOutputStream fos = new FileOutputStream(destFile); FileChannel fosChannel = fos.getChannel()) { ByteBuffer buffer = ByteBuffer.allocate(1024); while (fisChannel.read(buffer) != -1) { buffer.flip(); fosChannel.write(buffer); buffer.clear(); } } catch (IOException e) { e.printStackTrace(); } } } BufferedReader 和 BufferedInputStream BufferedReader read(): 读取单个字符。 readLine(): 读取一行文本。 在处理文本文件时效率更高，因为它针对字符数据进行了优化。 BufferedInputStream read(): 读取单个字节。 在处理二进制文件时效率更高，因为它针对字节数据进行了优化 写文件时追加和覆盖 public class FileOutputStreamExample { public static void main(String[] args) { FileOutputStream fos = null; try { // 使用追加模式,（覆盖模式: 第二个参数为 false 或不提供） // 如果提供的是一个相对路径，文件将被创建或写入到当前工作目录中 // System.out.println("Current working directory: " + System.getProperty("user.dir")); fos = new FileOutputStream("1.txt", true); fos.write(50); // 写入字符 '2' 的 ASCII 码 fos.write('a'); // 写入字符 'a' } catch (IOException e) { e.printStackTrace(); } finally { try { if (fos != null) { fos.close(); } } catch (IOException ex) { ex.printStackTrace(); } } /* //try-with-resources 语句来简化代码, 使用缓冲流 try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("1.txt", true)))) { writer.write("Hello, World!\n"); writer.write("This is a test.\n"); } catch (IOException e) { e.printStackTrace(); } */ } } 读写例 传统写法 public class Demo { public static void main(String[] args) throws Exception { // 写入文件 BufferedWriter bw = null; OutputStreamWriter osw = null; FileOutputStream fos = null; try { File file = new File("output.txt"); fos = new FileOutputStream(file); osw = new OutputStreamWriter(fos, "UTF-8"); bw = new BufferedWriter(osw); bw.write("Hello, World!\n"); bw.write("你好，世界！\n"); } catch (IOException e) { e.printStackTrace(); } finally { try { if (bw != null) { bw.close(); } if (osw != null) { osw.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } } // 读取文件 BufferedReader br = null; FileInputStream fis = null; InputStreamReader isr = null; try { fis = new FileInputStream("output.txt"); isr = new InputStreamReader(fis, "UTF-8"); br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (br != null) { br.close(); // 关闭 BufferedReader } if (isr != null) { isr.close(); // 关闭 InputStreamReader } if (fis != null) { fis.close(); // 关闭 FileInputStream } } catch (IOException e) { e.printStackTrace(); } } } } 简化写法 public class Demo { public static void main(String[] args) { // 写入文件 try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("output.txt"), "UTF-8"))) { bw.write("Hello, World!\n"); bw.write("你好，世界！\n"); } catch (IOException e) { e.printStackTrace(); } // 读取文件 try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("output.txt"), "UTF-8"))) { String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } } } 对象流 ObjectInputStream 使用ObjectInputStream对象的readObject方法读入对象、ObjectOutputStream的writeObject方法写入对象到流中 public class Apple implements Serializable { private static final long serialVersionUID = -4251269726946099535L; private int x; private String y; transient private String z; static String staticField = "I am static"; Apple(int x, String y) { this.x = x; this.y = y; this.z = "z"; } @Override public String toString() { return "x = " + x + " " + "y = " + y + " " + "z = " + z + " " + "staticField = " + staticField; } public static void main(String[] args) { String objFile = "Apple.txt"; Apple apple = new Apple(1, "apple"); try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(objFile))){ oos.writeObject(apple); } catch (IOException e) { throw new RuntimeException(e); } Apple.staticField = "Changed static field"; Apple appleRead = null; try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(objFile))){ appleRead = (Apple) ois.readObject(); } catch (IOException | ClassNotFoundException e) { throw new RuntimeException(e); } System.out.println(appleRead);// x = 1 y = apple z = null staticField = Changed static field } } 数据流 DataInputStream public class DataIODemo { public static void main(String[] args) { try { // 将内存中的基本数据类型和字符串写入文件 try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("out.txt"))) { // writeUTF将字符串以修改过的 UTF-8 编码写入输出流中。 // 这种编码在写入时会在前面加上两个字节的表示长度的值。这样，readUTF 方法就可以准确地读取这些字符串，无论其长度如何。 dos.writeUTF("你好"); dos.writeBoolean(false); dos.writeDouble(6.9); dos.writeInt(82); } catch (IOException e) { System.err.println("Error writing to file: " + e.getMessage()); } // 将文件中的数据读取回内存中的变量 try (DataInputStream dis = new DataInputStream(new FileInputStream("out.txt"))) { System.out.println(dis.readUTF()); System.out.println(dis.readBoolean()); System.out.println(dis.readDouble()); System.out.println(dis.readInt()); } catch (IOException e) { System.err.println("Error reading from file: " + e.getMessage()); } } catch (Exception e) { System.err.println("Unexpected error: " + e.getMessage()); } } } 推回流 PushbackInputStream 在JAVA IO中所有的数据都是采用顺序的读取方式，即对于一个输入流来讲都是采用从头到尾的顺序读取的，如果在输入流中某个不需要的内容被读取进来，则只能通过程序将这些不需要的内容处理掉 为了解决这样的处理问题，在JAVA中提供了一种推回流，可以在读取数据后将数据“推回”到流中，以便后续读取。 这在某些情况下很有用，例如在读取数据时，需要查看数据的一部分，然后决定如何继续读取 回退流同样分为字节流和字符流（PushbackInputStream 和 PushbackReader） public class Demo { public static void main(String[] args) { // eg1---------------------------------------------- String file = "out.txt"; try (FileInputStream fis = new FileInputStream(file); PushbackInputStream pbis = new PushbackInputStream(fis)) { int data = pbis.read(); System.out.println("Read: " + (char)data); // Push back the data pbis.unread(data); // Read the data again data = pbis.read(); System.out.println("Read again: " + (char)data); } catch (IOException e) { e.printStackTrace(); } // eg2---------------------------------------------- String str = "www.google.com"; try(//ByteArrayInputStream 是一个输入流，这种方法的好处是你可以在内存中操作字节数组，而不必将字符串写入文件 //另一种方法是直接使用 StringReader，这样可以将字符串作为字符流直接处理，而无需转换为字节数组 //ByteArrayInputStream bai = new ByteArrayInputStream(str.getBytes()); //PushbackInputStream pis = new PushbackInputStream(bai) StringReader sr = new StringReader(str); PushbackReader pr = new PushbackReader(sr)) { int temp; while ((temp = pr.read()) != -1) { if (temp == '.') {//判断是否读取到了字符“.” pr.unread(temp);//放回到缓冲区之中 temp = pr.read();//再读一遍 System.out.print("[" + (char) temp + "]");//包装一下 } else { System.out.print((char) temp); } } } catch (IOException e) { throw new RuntimeException(e); } //www[.]google[.]com // eg3---------------------------------------------- String htmlContent = "<html>\n" + "<body>\n" + "<!-- This is a comment -->\n" + "<!-0 This is not a comment -->\n" + "<h1>Hello, World!</h1>\n" + "</body>\n" + "</html>"; //使用 PushbackReader 读取每个字符，并检查是否是注释的开头 <!--。如果是，我们将 <!-- 替换为 ***，然后继续读取下一个字符。 //否则，我们将字符写入到 StringWriter 中 try (StringReader stringReader = new StringReader(htmlContent); //PushbackReader 可以接收一个可选的整数参数，用于指定推回缓冲区的大小。 //如果推回的字符数超过了指定的大小，将会抛出 IOException。 //在这里，我们使用 htmlContent.length() 作为推回缓冲区的大小，因为我们知道字符串的长度就是我们要处理的字符数量 PushbackReader pushbackReader = new PushbackReader(stringReader, htmlContent.length())) { StringWriter stringWriter = new StringWriter(); int c; while ((c = pushbackReader.read()) != -1) { if (c == '<') { int nextChar = pushbackReader.read(); if (nextChar == '!') { int thirdChar = pushbackReader.read(); if (thirdChar == '-') { int fourthChar = pushbackReader.read(); if (fourthChar == '-') { stringWriter.write("***"); continue; } else { pushbackReader.unread(fourthChar); pushbackReader.unread(thirdChar); } } else { pushbackReader.unread(thirdChar); } } pushbackReader.unread(nextChar); } stringWriter.write(c); } System.out.println("\nModified HTML:"); System.out.println(stringWriter); } catch (IOException e) { e.printStackTrace(); } //*** This is a comment --> //<!-0 This is not a comment --> } } System标准流 标准输入（System.in）：通常用于从控制台或其他标准输入设备读取用户输入。在命令行程序和交互式应用程序中经常使用。 标准输出（System.out）：通常用于向控制台或其他标准输出设备打印程序输出。在命令行程序和控制台应用程序中经常使用。 标准错误（System.err）：通常用于输出错误消息和异常信息，这些信息需要与标准输出分开显示，以便用户或开发人员能够更容易地识别和处理错误。 //将输出写入文件 try(PrintStream printOut = new PrintStream(new FileOutputStream("out.txt"))) { System.setOut(printOut);//使用setIn(InputStream)、setOut(PrintStream)、setErr(PrintStream)进行重定向 System.out.println("Hello, World!"); System.out.println("This is a test message."); System.out.println("Standard output redirected to file successfully."); } catch (IOException e) { System.err.println("Error redirecting standard output: " + e.getMessage()); } //将输入追加到文件 try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter writer = new BufferedWriter(new FileWriter("out.txt", true))) { String line; while ((line = reader.readLine()) != null && !line.equals("exit")) { System.out.println(line);//跟随输入输出 writer.write(line); writer.newLine(); } } catch (IOException e) { e.printStackTrace(); } public class Demo { public static void main(String[] args) { try { // 创建一个文件作为标准输入流 FileInputStream fis = new FileInputStream("input.txt"); System.setIn(fis); // 创建一个文件作为标准输出流 FileOutputStream fos = new FileOutputStream("output.txt"); System.setOut(new PrintStream(fos)); // 创建一个文件作为标准错误流 FileOutputStream errfos = new FileOutputStream("error.txt"); System.setErr(new PrintStream(errfos)); // 从标准输入读取并写入标准输出 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out)); String line; while ((line = reader.readLine()) != null && !line.equals("exit")) { writer.write(line); writer.newLine(); writer.flush(); } // 输出错误消息到标准错误流 System.err.println("This is an error message."); // 关闭资源 fis.close(); fos.close(); errfos.close(); reader.close(); writer.close(); } catch (IOException e) { e.printStackTrace(); } } } zip解压缩 Java 内置的 java.util.zip 包; 只支持 ZIP 文件格式 //使用字节流以便可以压缩任意类型的文件 //压缩文件的过程不涉及文件内容的编码转换 public class ZipFileUtils { public static void compressFiles(File[] files, String zipPath) throws IOException { try (FileOutputStream fos = new FileOutputStream(zipPath); // 使用装饰器模式在给流添加校验功能 CheckedOutputStream checkedOs = new CheckedOutputStream(fos, new Adler32()); // ZipOutputStream 也是从FilterOutputStream 继承下来的 ZipOutputStream zipOut = new ZipOutputStream(checkedOs)) { // 使用装饰器模式在给流添加缓冲功能 BufferedOutputStream buffOut = new BufferedOutputStream(zipOut); // 对于压缩输出流我们可以设置个注释 zipOut.setComment("zip test"); // 从Files[] 数组中读入一批文件，然后写入zip包的过程 for (File file : files) { try (FileInputStream fis = new FileInputStream(file)) { // 一个文件对象在zip流中用一个ZipEntry表示，使用putNextEntry添加到zip流中 zipOut.putNextEntry(new ZipEntry(file.getName())); byte[] buffer = new byte[1024]; int length; while ((length = fis.read(buffer)) != -1) { buffOut.write(buffer, 0, length); } buffOut.flush(); } } } } public static void main(String[] args) throws IOException { String dir = "d:/test"; String zipPath = "d:/test.zip"; File[] files = new File(dir).listFiles(); if (files != null && files.length > 0) { ZipFileUtils.compressFiles(files, zipPath); System.out.println("Files compressed successfully."); } else { System.out.println("No files to compress."); } } } public class UnzipFileUtils { public static void decompressFiles(String zipPath, String destDir) throws IOException { File dir = new File(destDir); if (!dir.exists()) dir.mkdirs(); try (FileInputStream fis = new FileInputStream(zipPath); CheckedInputStream checkedIs = new CheckedInputStream(fis, new Adler32()); ZipInputStream zipIn = new ZipInputStream(checkedIs)) { // 遍历ZIP文件中的每个条目 ZipEntry entry; while ((entry = zipIn.getNextEntry()) != null) { String filePath = destDir + File.separator + entry.getName(); if (!entry.isDirectory()) { // 如果条目不是目录，则解压文件 extractFile(zipIn, filePath); } else { // 如果条目是目录，则创建目录 File dirEntry = new File(filePath); dirEntry.mkdirs(); } zipIn.closeEntry(); } } } private static void extractFile(ZipInputStream zipIn, String filePath) throws IOException { try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath))) { byte[] buffer = new byte[1024]; int read; while ((read = zipIn.read(buffer)) != -1) { bos.write(buffer, 0, read); } bos.flush(); } } public static void main(String[] args) throws IOException { String zipPath = "d:/test.zip"; String destDir = "d:/test_unzipped"; UnzipFileUtils.decompressFiles(zipPath, destDir); System.out.println("Files decompressed successfully."); } } Scanner Scanner类通常被用于从输入流中扫描并解析基本类型和字符串。 虽然Scanner可以使用System.in作为输入源，但它更通用的用法是处理各种类型的输入，包括文件、字符串等。因此，尽管Scanner用于处理输入，但它不属于Java IO包的一部分。 Scanner的构造器支持多种方式，可以从字符串（Readable）、输入流、文件等等来直接构建Scanner对象 //Scanner默认分隔符Pattern为"\p{javaWhitespace}",一个或多个连续的Java空白字符(包括空格、制表符、换行符等) Scanner s = new Scanner("123 asdf。。。hjksdfojk----634345664，erg"); s.useDelimiter("[ ,.]");// 设置新的分割符 使用空格或逗号或点号作为分隔符 System.out.println(s.delimiter());//返回此 Scanner 当前正在用于匹配分隔符的Pattern public class Demo { public static void main(String[] args) { String filePath = "out.txt"; try(Scanner scanner = new Scanner(new File(filePath))) { while (scanner.hasNextLine()) { //nextLine()方法是读取一整行，以一个回车符作为结束标记停止扫描,当下一个要接收数字类型时,需要scanner.nextLine() 来消费掉换行符 //next() / nextInt() / nextDouble()等方法是，读取到第一个结束符【空格、回车、Tab键】作为结束标记停止扫描 String line = scanner.nextLine(); System.out.println(line); } } catch (FileNotFoundException e) { System.err.println("File not found: " + e.getMessage()); } //早晨跨得雕鞍去 //日暮归来红粉香 } } RandomAccessFile RandomAccessFile是Java中用于对文件进行随机读写的类，可以用于直接访问这些文件，以读取或修改特定的记录，而不必加载整个文件到内存中。 与常规的输入流（FileInputStream等）不同，RandomAccessFile可以在任意位置读写数据，而不必从文件的开头开始 日志文件处理： 在处理日志文件时，可能需要定位到文件的特定位置来查找或修改日志记录。RandomAccessFile可以让你直接跳转到日志文件中的特定位置，而不必逐行读取。 //log.txt //2024-06-19|Error: Something went wrong //2024-06-20|Info: Process completed successfully //2024-06-21|Warning: Potential performance issue //假设log文件体积很大,同时需要频繁查找, 其中的RandomAccessFile类在上面的代码中是否充分发挥了它自身的设计目标, 避免加载整个文件到内存,只找有用的 //RandomAccessFile 被用来逐行读取文件内容，并在找到匹配的日期时立即停止读取。 //这种方式确实避免了将整个文件加载到内存中，并充分利用了 RandomAccessFile 的随机访问能力。这是一个高效的查找方式，尤其适合处理大型文件。 public class Demo { public static void main(String[] args) { String filePath = "log.txt"; String targetDate = "2024-06-20"; try (RandomAccessFile raf = new RandomAccessFile(filePath, "r")) {//只读 String line; boolean recordFound = false; // 标记是否找到记录 while ((line = raf.readLine()) != null) { String[] parts = line.split("\\|"); String logDate = parts[0]; if (logDate.equals(targetDate)) { System.out.println("Found log record for date: " + targetDate); System.out.println("Log message: " + parts[1]); recordFound = true; // 记录已找到 break; } } // 如果没有找到目标日期的日志记录，则打印消息 if (!recordFound) { System.out.println("No log record found for date: " + targetDate); } } catch (IOException e) { e.printStackTrace(); } } } 数据库文件处理： 对于一些简单的数据库系统，数据通常存储在文件中。RandomAccessFile可以用于直接访问数据库文件的特定记录或数据块，而不必加载整个文件到内存中。 网络编程： 在网络编程中，RandomAccessFile可以用于处理文件下载或上传的断点续传功能。它允许你在文件中定位并继续读取或写入数据，而无需重新开始。 大文件上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可 分片（先将文件切分成多个文件分片）上传是断点续传的基础,RandomAccessFile 可以帮助我们合并文件分片 配置文件管理： 有时候需要从配置文件中读取或修改特定的配置项。RandomAccessFile可以让你定位到配置文件中的特定位置，并读取或修改相应的配置项，而不必读取整个文件。 /* spring.datasource.an=110000 spring.datasource.n=11222 spring.datasource.name=111 spring.datasource.nae=1119999 spring.datasource.username=222 spring.datasource.password=asd!123A spring.datasource.url=jdbc:mysql://localhost:3306/mall?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true 在你的代码中，RandomAccessFile 类的确充分发挥了它的设计目标，避免了加载整个文件到内存中，可以区域性地针对性地查找或修改文件的内容。这种方式适合处理大文件，可以有效地节省内存和提高性能 */ public class ConfigFileExample { public static void modifyPropertyValue(String filePath, String propertyName, String newValue) { File file = new File(filePath); File tempFile = new File(file.getAbsolutePath() + ".tmp"); try (RandomAccessFile raf = new RandomAccessFile(file, "rw");//可读可写 BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) { String line; boolean propertyFound = false; String oldValue = null; while ((line = raf.readLine()) != null) { int index = line.indexOf('='); if (index != -1) { String key = line.substring(0, index).trim(); if (key.equals(propertyName)) { oldValue = line.substring(index + 1).trim(); line = key + "=" + newValue; propertyFound = true; } } writer.write(line); writer.newLine(); } writer.flush(); raf.close(); writer.close(); if (file.delete()) { if (!tempFile.renameTo(file)) { throw new IOException("Could not rename temp file to original file name."); } } else { throw new IOException("Could not delete the original file."); } if (propertyFound) { System.out.println("Updated property: " + propertyName + " from: " + filePath); System.out.println("Old Value: " + oldValue); System.out.println("New Value: " + newValue); } else { System.out.println("Property not found: " + propertyName); } } catch (IOException e) { throw new RuntimeException(e); } } public static String getPropertyValue(String filePath, String propertyName) { File file = new File(filePath); try (RandomAccessFile raf = new RandomAccessFile(file, "r")) { String line; while ((line = raf.readLine()) != null) { int index = line.indexOf('='); if (index != -1) { String key = line.substring(0, index).trim(); if (key.equals(propertyName)) { return "Query property: " + propertyName + "="+line.substring(index + 1).trim()+" from: " + filePath; } } } } catch (IOException e) { throw new RuntimeException(e); } return "property: " + propertyName + " not found from: " + filePath; } public static void main(String[] args) { try { modifyPropertyValue("src/main/resources/application.properties", "spring.datasource.name", "my_datasource"); modifyPropertyValue("src/main/resources/application.properties", "spring.datasource.username", "admin"); System.out.println(getPropertyValue("src/main/resources/application.properties", "spring.datasource.password")); } catch (Exception e) { e.printStackTrace(); } } } 文件索引： 在某些应用中，可能需要维护文件的索引信息以加快文件的查找速度。RandomAccessFile可以用于读取或更新文件的索引信息，从而实现快速的文件查找。`,``,`html`,`IoC容器`,`20240501094304-_java web Spring Framework 核心特性 依赖注入（DI）： Ioc是设计理念,是现代程序设计遵循的标准,是宏观目标 Inverse of Control,是一种设计理念, 从主动创建管理改为由代理人来创建与管理对象,消费者通过代理人来获取对象 DI(Dependency Injection)是具体技术实现,是微观实现 DI在java中利用反射技术实现对象注入(injection),通过配置xml改变对象,避免因为改写代码导致重新编译, 以此降低对象之间的直接耦合 面向切面编程）： 支持将横切关注点（如事务管理、日志记录、安全）从业务逻辑中分离出来，使代码更加模块化和可维护。 数据访问支持： 提供了对不同数据访问技术（如 JDBC、JPA、Hibernate）的支持，简化了数据库操作和事务管理。 声明式事务管理： 允许通过配置文件或注解来声明事务管理，从而避免了在业务逻辑中显式编写事务处理代码。 模块化设计： 包含多个模块（如 Spring Core, Spring AOP, Spring Data, Spring Security），可以根据需要选择和组合这些模块。 Spring Core Container： 提供了 IoC 容器的实现，支持 Bean 的创建、配置和生命周期管理。 Spring AOP： 提供了对面向切面编程的支持，使得在应用程序中能够方便地实现横切关注点（如事务管理、日志记录）。 Spring Data Access/Integration： 包括对 JDBC、ORM、消息队列等数据访问技术的支持，简化了数据访问层的开发。 Spring Web： 包括 Spring MVC（用于构建 Web 应用的模型-视图-控制器框架）和 Spring WebFlux（用于响应式编程的 Web 框架）。 Spring Security： 提供了安全框架，支持认证、授权、加密等安全功能。 Spring Test： 提供了对 Spring 应用程序的测试支持，包括对 Spring Context 的集成测试。 生态系统 Spring Framework 的生态系统非常丰富，包括多个子项目和扩展，如： Spring Boot： 简化了 Spring 应用程序的创建和配置，提供了开箱即用的配置和默认设置。 Spring Cloud： 用于构建分布式系统中的微服务，提供了服务注册与发现、配置管理、断路器等功能。 Spring Data： 简化了数据访问层的开发，提供了对各种数据存储技术的支持。 IoC容器初始化 IoC容器的三种配置方法 基于xml配置文件,适合大型模块 基于注解 基于java config,适合敏捷开发 依赖 <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.3.19</version> </dependency> 基于xml配置文件 property 当 bean 使用无参构造函数创建时，可以使用property标签来设置属性值 运行时自动调用setxxx方法为属性赋值, 不是直接赋值, 以确保在注入属性时能够进行必要的校验和处理 id和name bean元素的id属性和name属性都用于标识bean, 两者在同一个配置文件中都不允许出现重复 如果bean元素既没有id属性也没有name属性, 在获取该bean时需要以类全限定名作为标识 id属性用于定义bean的唯一标识符，而name属性允许为bean定义多个别名,用逗号、分号或空格分隔 如果多个配置文件中存在重复标识, 将按照配置文件的加载顺序, 使用最后出现的那个 value属性的字符串值会自动转换为目标类型 <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"> <bean id="sweetApple" class="com.ida.demo10.ioc.entity.Apple"> <property name="title" value="红富士"/> </bean> <!-- ref关联对象, 通过配置文件维护,构造新对象或调整关联对象,不用改变源码和重新编译,以此减少对象之间的耦合 --> <bean id="lily" class="com.ida.demo10.ioc.entity.Child"> <property name="name" value="莉莉"/> <property name="apple" ref="sweetApple2"/> </bean> <bean id="andy" class="com.ida.demo10.ioc.entity.Child"> <constructor-arg name="name" value="安迪"/> <constructor-arg name="apple" ref="sweetApple2"/> </bean> <!-- 使用无参构造对象 --> <bean id="sweetApple1" class="com.ida.demo10.ioc.entity.Apple"/> <!-- 使用带参构造对象 --> <bean id="sweetApple2" class="com.ida.demo10.ioc.entity.Apple"> <constructor-arg name="title" value="红富士"/> <!-- 也可以按参数顺序赋值(不推荐),0起 --> <constructor-arg index="1" value="red"/> <constructor-arg name="origin" value="欧洲"/> </bean> <!-- 使用静态工厂获取对象, 通过这种方式可以在容器之外以程序的方式组织对象例如增加额外的行为(而ioc难以实现) public class AppleStaticFactory {//工厂类隐藏创建对象的细节 public static Apple createSweetApple() { return new Apple("红富士","红色","欧洲"); } } --> <bean id="sweetApple3" class="com.ida.demo10.ioc.factory.AppleStaticFactory" factory-method="createSweetApple"/> <!-- 通过工厂实例中的方法创建对象, ioc对工厂类进行实例化后调用其中方法创建对象 相较于使用静态工厂方法 实例工厂方法允许工厂类持有状态，可以在创建对象时依据这些状态或配置来生成不同的对象 工厂类本身可以作为Spring容器中的一个bean，通过依赖注入的方式为其注入其他依赖 可以更容易地对工厂类进行扩展和修改，而不需要修改调用静态方法的代码 可以利用接口或抽象类来定义工厂行为，从而实现多态性 public class AppleFactoryInstance { public Apple createSweetApple() { return new Apple("红富士","红色","欧洲"); } } --> <bean id="factoryInstance" class="com.ida.demo10.ioc.factory.AppleFactoryInstance"/> <bean id="sweetApple4" factory-bean="factoryInstance" factory-method="createSweetApple"/> </beans> 从IoC容器获取bean public class SpringApplication { public static void main(String[] args) { //加载 Spring 配置文件并初始化 IoC 容器 ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); //加载多个配置文件 String[] configLocations = new String[]{ "classpath:ApplicationContext.xml", "classpath:ApplicationContext2.xml" }; //ApplicationContext context = new ClassPathXmlApplicationContext(configLocations); //从容器中获取 bean //Apple sweetApple = (Apple) context.getBean("sweetApple2"); Apple sweetApple = context.getBean("sweetApple2", Apple.class); } } classpath:路径表达式 20240501155812.webp IoC实现团队工作解耦 20240728142013.webp dao和service(包括配置文件)分别由两个人维护,两人只须约定好dao实现类的bean标识, 不用了解对方如何实现 当数据库从mysql迁移到oracle时 service维护者无须任何感知或更改 dao维护者只须新增一个dao接口实现类, 替换自己维护的配置文件中的bean类路径即可 dao维护 public interface BookDao { void insert(); } public class BookDaoImpl implements BookDao{ @Override public void insert() { System.out.println("向mysql插入一条图书数据"); } } public class BookDaoOracleImpl implements BookDao{ @Override public void insert() { System.out.println("向oracle插入一条图书数据"); } } <!-- applicationContext-bookDao.xml --> <bean id="bookDao" class="com.ida.demo10.ioc.bookshop.dao.BookDaoOracleImpl"/> service维护 public class BookService { private BookDao bookDao; //getter,setter public void purchase() { System.out.println("采购了一本书"); bookDao.insert(); } } <!-- applicationContext-bookService.xml --> <bean id="bookService" class="com.ida.demo10.ioc.bookshop.service.BookService"> <property name="bookDao" ref="bookDao"/> </bean> 入口类 public class BookShopApplication { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext-book*.xml"); BookService bookService = context.getBean("bookService",BookService.class); bookService.purchase(); } } 注入集合对象和Properties 例公司资产配置清单 public class Company { private List<String> rooms; private Set<String> employees; private Map<String,Computer> computers; private Properties info; //getter,setter } public class Computer { private String brand; private String type; private String sn; private Float price; //getter,setter,constructor } <bean id="c1" class="com.ida.demo10.ioc.assets.entity.Computer"> <constructor-arg name="brand" value="HP"/> <constructor-arg name="type" value="台式机"/> <constructor-arg name="sn" value="001"/> <constructor-arg name="price" value="11000"/> </bean> <bean id="company" class="com.ida.demo10.ioc.assets.entity.Company"> <property name="rooms"> <list> <value>201-总裁办</value> <value>202-会议室</value> <value>203-休息室</value> <!-- <ref bean="beanId"/>--> </list> </property> <property name="employees"> <!-- 底层是LinkedHashSet类型 --> <set> <value>Tom</value> <value>Jerry</value> <value>Tom</value> <!-- <ref bean="beanId"/>--> </set> </property> <property name="computers"> <!-- 底层是LinkedHashMap类型 --> <map> <!-- <entry key="k1" value="v1"/> --> <entry key="dev-1" value-ref="c1"/> <entry key="dev-2"> <!-- 可以创建无标识的内部bean, 只为当前键值对服务,外部无法获取,也不会出现在getBeanDefinitionNames()中 --> <bean class="com.ida.demo10.ioc.assets.entity.Computer"> <constructor-arg name="brand" value="MSI"/> <constructor-arg name="type" value="笔记本"/> <constructor-arg name="sn" value="002"/> <constructor-arg name="price" value="13000"/> </bean> </entry> </map> </property> <property name="info"> <!-- 只允许字符串,可以保存连接字符串用户名密码等信息 --> <!-- company.getInfo().getProperty("website"); --> <props> <prop key="phone">65-8888</prop> <prop key="address">xxx</prop> <prop key="website">http://xxx</prop> </props> </property> </bean> <!-- 当出现多个无标识同类型的bean时,getBeanDefinitionNames()得到的bean标识是全限定类名#出现的顺序(0起) 获取时要书写全限定类名#出现的顺序,不写#序号时默认为#0 context.getBean("com.ida.demo10.ioc.assets.entity.Computer#1",Computer.class) --> <bean class="com.ida.demo10.ioc.assets.entity.Computer"/> <bean class="com.ida.demo10.ioc.assets.entity.Computer"/> <bean name="n1,n2,n3" class="com.ida.demo10.ioc.assets.entity.Computer"/> 获取容器内的对象清单 getBeanDefinitionNames()方法只会返回bean的id，而不会返回其所有别名 如果需要获取bean的所有别名，可以使用getAliases()方法 如果只使用name属性来定义bean，且指定了多个别名 Spring将使用第一个别名作为这个bean的主名称（实际bean的唯一标识符），而其他别名将作为该bean的别名 for (String beanId : context.getBeanDefinitionNames()) { System.out.println("标识:"+beanId); //获取所有别名 for (String alias : context.getAliases(beanId)) { System.out.println("别名:" + alias); } System.out.println("类型:"+context.getBean(beanId).getClass().getName()); System.out.println("---------------------"); } /* 标识:c1 类型:com.ida.demo10.ioc.assets.entity.Computer --------------------- 标识:company 类型:com.ida.demo10.ioc.assets.entity.Company --------------------- 标识:com.ida.demo10.ioc.assets.entity.Computer#0 别名:com.ida.demo10.ioc.assets.entity.Computer 类型:com.ida.demo10.ioc.assets.entity.Computer --------------------- 标识:com.ida.demo10.ioc.assets.entity.Computer#1 类型:com.ida.demo10.ioc.assets.entity.Computer --------------------- 标识:n1 别名:n2 别名:n3 类型:com.ida.demo10.ioc.assets.entity.Computer --------------------- */ bean的scope属性 20240502085735.webp 20240502090743.webp singleton在容器中是单例多线程执行,不会出现阻塞因此高效, 但存在并发问题, b1,b2,b3各自持有的是同一个dao的引用 singleton的实例化时机是在IoC容器启动时 prototpype在容器中多实例,占用更多资源,不存在并发问题, b1,b2,b3各自持有的是独立的dao引用 prototype的实例化时机是在getBean()时或对象注入时 如果对象的属性是恒定不变的则适合使用singleton, 如果在程序的运行过程中不断地发生变化则应使用prototype 容器的生命周期 init-method 指定了一个在 Spring Bean 完成依赖注入之后、在 Bean 被使用之前调用的方法 destroy-method 指定了一个方法，当容器关闭或 Bean 被销毁时调用，用于执行资源的释放或清理工作 当 Spring 容器关闭时（例如在应用程序停止时），容器会开始销毁所有单例作用域的 Bean。 对于非单例作用域的 Bean（如 prototype），destroy-method 不会被自动调用，因为容器不会管理这些 Bean 的生命周期 <bean id="order" class="com.ida.demo10.ioc.life.entity.Order" init-method="init" destroy-method="destroy"> <property name="price" value="19.8"/> <property name="quantity" value="1000"/> <!-- total属性由price和quantity计算而来,利用容器的生命周期中的init-method --> </bean> public class Order { private Float price; private Integer quantity; private Float total; //getter,setter public Order() { System.out.println("调用了Order的默认构造方法"); } public void pay() { System.out.println("调用了Order的pay()方法,订单金额为:" + total); } public void setPrice(Float price) { System.out.println("调用了Order的setPrice()方法"); this.price = price; } public void setQuantity(Integer quantity) { System.out.println("调用了Order的setQuantity()方法"); this.quantity = quantity; } public void init() { System.out.println("调用了Order的init()方法"); total = quantity * price; } public void destroy() { System.out.println("调用了Order的destroy()方法"); } } public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext-life.xml"); System.out.println("容器初始化完毕"); Order order = context.getBean("order", Order.class); order.pay(); //销毁容器时,调用bean中destroy-method属性所指的方法(释放io资源) ((ClassPathXmlApplicationContext)context).registerShutdownHook(); } /* 调用了Order的默认构造方法 调用了Order的setPrice()方法 调用了Order的setQuantity()方法 调用了Order的init()方法 容器初始化完毕 调用了Order的pay()方法,订单金额为:19800.0 调用了Order的destroy()方法 */ 手写简易IoC容器 20240728182938.webp <?xml version="1.0" encoding="UTF-8"?> <!-- applicationContext-simple_ioc.xml --> <beans> <bean id="sweetApple" class="com.ida.demo10.ioc.simple_ioc.entity.Apple"> <property name="title" value="红富士"/> <property name="color" value="红色"/> <property name="origin" value="欧洲"/> </bean> </beans> public interface ApplicationContext { Object getBean(String beanId); } public class ClassPathXmlApplicationContext implements ApplicationContext { private Map<String, Object> iocContainer = new HashMap<>(); public ClassPathXmlApplicationContext(String xmlName) { //引入dom4j和jaxen(Xpath表达式解释器) InputStream file = ClassPathXmlApplicationContext.class.getClassLoader().getResourceAsStream(xmlName); SAXReader saxReader = new SAXReader(); try { Document doc = saxReader.read(file); List<Node> beans = doc.selectNodes("//bean"); for (Node bean : beans) { Element element = (Element) bean; String id = element.attributeValue("id"); Class<?> clz = Class.forName(element.attributeValue("class")); Object obj = clz.newInstance(); for (Node property : bean.selectNodes("//property")) { Element element1 = (Element) property; String name = element1.attributeValue("name"); String value = element1.attributeValue("value"); String methodName = "set" + name.substring(0,1).toUpperCase() + name.substring(1); Method method = clz.getDeclaredMethod(methodName, String.class); method.invoke(obj,value); } iocContainer.put(id, obj); } } catch (Exception e) { throw new RuntimeException(e); } } @Override public Object getBean(String beanId) { return iocContainer.get(beanId); } } public class Application { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext-simple_ioc.xml"); Apple sweetApple = (Apple) context.getBean("sweetApple"); System.out.println(sweetApple); } } //Apple{title='红富士', color='红色', origin='欧洲'} 基于注解配置IoC容器 相比于xml配置形式,注解形式的xml增加了context命名空间 https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd "> <!-- 在IoC容器初始化时根据指定的包地址自动扫描四种组件类型注解并完成实例化(单例) @Repository @Service @Controller @Component --> <context:component-scan base-package="com.ida.demo10.ioc.annotation"> <!-- 用正则表达式排除某些类 --> <context:exclude-filter type="regex" expression="com.ida.demo10.ioc.annotation.exl.*"/> </context:component-scan> </beans> 组件类型注解 组件类型注解默认beanId为类名首字母小写, 也可以手动指定,@xxx("xxx") @Component 组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化 后面三个注解是此注解的细化,当不确定归于哪一类时,可以选择此注解 @Controller 语义注解,说明当前类是MVC应用中的控制器类 @Service 语义注解,说明当前类是Service业务服务类 @Respository (仓库) 语义注解,说明当前类用于业务持久层,通常描述对应Dao类 自动装配注解 20240502141654.webp 将@Autowired注解放在成员属性(字段)上,通常为此种做法,不依赖setter 反射将属性的私有修饰符改为public，直接进行赋值不经过setter, 赋值完成后再改为private, @Resource同理 将@Autowired注解放在set方法上 这种方式会在bean初始化时自动按类型或者名称对set方法的参数进行注入, Spring会自动调用这个set方法，并将符合类型或者名称的bean作为参数传入执行 当属性是接口类型,此接口下有多个实现类时，@Autowired就会报错, 除非使用 @Primary 注解标注其中一个实现类，优先选择注入该实现类的 Bean @Resource设置name属性,则按name在IoC容器中进行匹配注入 @Resource未设置name属性时 以属性名作为bean标识在IoC容器中进行匹配注入 如按属性名未匹配到,再按类型进行匹配,同@Autowired,需加入@Primary解决接口下有多个实现类时的情况 在使用@Resource时推荐设置name或保证属性名与bean名称一致(类名首字母小写) 元数据注解 20240502155859.webp @Value 注解用来注入外部配置中的值，它支持两种语法：$ 和 # &#36;{} (Property Placeholder) &#36;{} 语法用于占位符，它会从Spring的环境中解析属性。这些属性可以来源于属性文件（如 .properties 文件），系统环境变量，或者通过 @PropertySource 注解定义的其他属性源 在非 Spring Boot 项目中，@PropertySource 是主要的方式来加载自定义的 .properties 文件，因为这些项目没有 application.properties 的自动加载机制 在Windows中，你可以通过命令行设置环境变量 set MY_ENV_VAR=some_value 在Unix/Linux/MacOS中，你可以通过终端设置环境变量 export MY_ENV_VAR=some_value 通过@Value("&#36;{MY_ENV_VAR}")注入 #{} (SpEL: Spring Expression Language) 允许在表达式中使用Spring bean的属性、方法调用以及其他复杂的表达式计算。 @Value为静态变量注入值,需要标记在它的setter方法(非static)上 <?xml version="1.0" encoding="UTF-8"?> <beans ..> <!-- 通知容器初始化时加载属性文件 引入多个文件时location="classpath:aop-config.properties, classpath:another-config.properties" 属性可以直接在xml中以&#36;{}方式引用 --> <context:property-placeholder location="classpath:config.properties"/> .. </beans> config.properties info=ida connection.driver=jdbcxxxx connection.url=xxx connection.username=xxx connection.password=xxx @Service @Scope("prototype") //与xml配置bean scope相同 public class UserService { //注入静态数据, 用在字段上时不经过setter,改private为public赋值然后改回private, 用在setter上则经setter注入 //@Value("ida") //注入config.properties中的metaData属性值 @Value("&#36;{info}") private String metaData; @Value("&#36;{connection.driver}") private String driver; @PostConstruct //与xml配置bean init-method相同 public void init(){ System.out.println(metaData);//ida } } 基于Java Config配置IoC容器 使用独立的Java类集中管理对象与依赖, 可以在编译期进行依赖检查, 不易出错 java config利用方法创建对象,并将方法返回的对象放入容器,方法名会作为beanId 20240502170707.webp @ImportResource 可以同时使用XML配置的现有定义,Spring会读取这些XML文件，并将其中定义的bean和配置加载到应用上下文中 @ComponentScan 可以同时从其它路径中扫描Spring组件（如 @Component等） 例如UserDao类存在于annotation包, 该包的维护者习惯基于注解方式配置ioc @PropertySource 加载外部属性文件，并将这些属性文件中的值注入到Spring应用中 例如外部XML配置了 context:property-placeholder location="classpath:config.properties" 时 @Value("&#36;{info}") 例如获取外部XML配置文件(前例公司资产配置清单)中 prop 标签定义的属性值 @Value("#{company.info['phone']}") //Spring表达式语言（SpEL） @Configuration @ComponentScan(basePackages = {"com.ida.demo10.ioc.annotation.dao", "com.another.project"}) //@PropertySource("classpath:application.properties") //@ImportResource({"classpath:applicationContext.xml", "classpath:anotherContext.xml"}) public class Config { @Bean public UserDao userDao(){ UserDao userDao = new UserDao(); System.out.println("方法名userDao:"+userDao); return userDao; } @Bean @Primary public UserDao userDao1(){ UserDao userDao = new UserDao(); System.out.println("方法名userDao1:"+userDao); return userDao; } @Bean //容器内的对象关联, 向参数注入userDao,再set进去; 先按name注入,不存在则按类型注入(如果存在多个相同类型的对象,使用Primary指定) public UserService userService(UserDao userDao1){ UserService userService = new UserService(); userService.setUserDao(userDao1); System.out.println(userDao1); return userService; } @Bean @Scope("prototype") public UserController userController(UserService userService) { UserController userController = new UserController(); userController.setUserService(userService); return userController; } } public class Application { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); for (String beanId : context.getBeanDefinitionNames()) { System.out.println(beanId); } } } Spring Test与Junit4整合 除了spring-context之外还需要引用spring-test, junit <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>5.3.19</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> @Repository public class UserDao { public void insert() { System.out.println("插入了一条数据"); } } @Service public class UserService { //ctrl+shift+t 生成测试 @Resource private UserDao userDao; public void createUser(){ System.out.println("创建一个用户"); userDao.insert(); } } @RunWith(SpringJUnit4ClassRunner.class) //将Junit4的执行权交由Spring Test @ContextConfiguration(locations = {"classpath:applicationContext-spring_test.xml"}) //在测试用例执行前加载配置文件初始化IoC容器 public class UserServiceTest { @Resource private UserService userService; @Test public void createUser() { userService.createUser(); } }`,``,`html`,`IO模型`,`20240307183503-_java java.io包基于流模型实现，提供File抽象、输入输出流等IO的功能。 交互方式是同步、阻塞的方式，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞。 好处是代码比较简单、直观 缺点则是IO效率和扩展性存在局限性，容易成为应用性能的瓶颈。 java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection 也时常被归类到同步阻塞IO类库，因为网络通信同样是IO行为。 在Java 1.4中引入了NIO框架(java.nio 包) 提供了Channel、Selector、Buffer等新的抽象，可以构建多路复用IO程序，同时提供更接近操作系统底层的高性能数据操作方式。 在Java7中，NIO有了进一步的改进，也就是NIO2 引入了异步非阻塞IO方式，也被称为AIO(Asynchronous IO)，异步IO操作基于事件和回调机制。 同步和异步是针对应用程序和内核的交互而言的。 同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。 异步指的是用户进程触发IO操作以后便开始做其他的事情，而当IO操作已经完成的时候会得到IO完成的通知。 阻塞和非阻塞是针对进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式。 阻塞指的是如果当时没有东西可读，或暂时不可写，程序就进入等待状态，直到有东西可读或可写为止。 非阻塞指的是如果没有东西可读，或不可写，读写函数马上返回，而不会等待。 BIO 同步阻塞 (Blocking IO)通常是在JDK1.4版本之前常用的编程方式。传统的服务器端同步阻塞的经典编程模型。 适用于单个或客户端数量较少且可预见的应用场景。例如，传统的C/S架构应用、管理工具和后台系统。 服务器实现模式一个连接一个线程 即客户端有连接请求时服务器端就需要启动一个线程进行处理， 如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 之所以使用多线程, 主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的。 在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞。 实现过程 首先在服务端启动一个ServerSocket来监听网络请求， 客户端启动Socket发起网络请求， 默认情况下ServerSocket会建立一个线程来处理此请求， 如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。 建立好的连接，在通讯过程中，是同步的。在并发处理效率上比较低。 import java.io.*; import java.net.*; public class Server { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10);//创建一个线程池限制同时运行的线程数，提高并发处理的效率 try (ServerSocket serverSocket = new ServerSocket(12345)) {//服务端启动一个ServerSocket来监听特定端口上的网络请求 System.out.println("正在监听12345端口"); while (true) { Socket socket = serverSocket.accept();//每当有一个客户端连接时 System.out.println("已连接上一个新的客户端"); executor.submit(new ServerThread(socket));//线程池处理这个连接 } } catch (IOException ex) { ex.printStackTrace(); } finally { executor.shutdown(); } } } class ServerThread extends Thread { private Socket socket; public ServerThread(Socket socket) { this.socket = socket; } public void run() { try (InputStream input = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(input)); OutputStream output = socket.getOutputStream(); PrintWriter writer = new PrintWriter(output, true)) { String text; while ((text = reader.readLine()) != null) { System.out.println("[客户端消息]: " + text); writer.println("我是来自server的答复"); } } catch (IOException ex) { ex.printStackTrace(); } } } import java.io.*; import java.net.*; public class Client { public static void main(String[] args) { String hostname = "localhost"; int port = 12345; try (Socket socket = new Socket(hostname, port);//创建一个Socket并连接到服务端 OutputStream output = socket.getOutputStream(); PrintWriter writer = new PrintWriter(output, true); InputStream input = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(input)); BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in))) { String text; while (true) { System.out.print("Enter message: "); text = consoleReader.readLine(); writer.println(text);//向服务端发送消息 String response = reader.readLine(); System.out.println(response);//接收服务端的响应 } } catch (UnknownHostException ex) { System.out.println("Server not found: " + ex.getMessage()); } catch (IOException ex) { System.out.println("I/O error: " + ex.getMessage()); } } } public class Client2 { //.. } 这个模型严重依赖于线程，但线程是很”贵”的资源，主要表现在： 线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。 线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，占用的内存将非常惊人。 线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高(超过20%以上)，导致系统几乎陷入不可用的状态。 容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高而且外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。 所以，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的 NIO 同步非阻塞 (Non-blocking IO)Java NIO主要由Channel,Buffer,Selector三个核心部分组成 适用于连接数目多且连接比较短（轻操作）的架构，如聊天室、实时游戏服务器,大型应用服务器等 Java NIO和BIO之间第一个最大的区别是，BIO是面向流的，NIO是面向缓冲区的。 NIO 模型中通常会有两个线程分别绑定一个轮询器selector ,一个轮询是否有新的连接，一个轮询连接是否有数据可读 NIO也是I/O多路复用的基础 Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或write()时，该线程被阻塞，直到有数据被读取或者数据写入。该线程在阻塞期间不能做其他事情。 而Java NIO的非阻塞模式，如果通道没有东西可读，或不可写，读写函数马上返回，而不会阻塞，这个线程可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程可以管理多个输入和输出通道（channel），即IO多路复用的原理。 文件IO操作 在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数read()、write() ，此时调用此函数的进程（在JAVA中即java进程）由当前的用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。 而NIO的零拷贝与传统的文件IO操作最大的不同之处就在于它虽然也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，这样直接从内存中读写文件，速度大幅度提升。 通道 channel 通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。通道包括以下类型： FileChannel：从文件中读写数据 DatagramChannel：通过 UDP 读写网络中数据 SocketChannel：通过 TCP 读写网络中数据 ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel 文件复制 如果处理的是小文件或者对复制速度要求不是非常高的情况下，使用 BufferedInputStream 和 BufferedOutputStream 可以简单快速地完成任务。缺点是对于大文件，由于数据是逐字节传输的，可能效率较低，特别是在网络文件系统或远程位置时。 对于需要高性能和大文件处理的场景，特别是需要考虑到文件系统的效率和零拷贝技术的情况，使用 FileChannel 和 ByteBuffer 更为合适, 它能够提供更高的吞吐量和更低的 CPU 使用率，尤其在处理大文件时表现更为明显 参见IO中复制例 public class fastCopy { public static void main(String[] args) { String src = "out.txt"; String dst = "test/out.txt"; fastCopy(src,dst); } public static void fastCopy(String src,String dst) { try (FileInputStream fis = new FileInputStream(src); FileChannel fileInputChannel = fis.getChannel(); FileOutputStream fos = new FileOutputStream(dst); FileChannel fileOutChannel = fos.getChannel()) { ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while (fileInputChannel.read(buffer) != -1) {//从 fileInputChannel 读取数据到 buffer 中，此时 buffer 处于写模式。 buffer.flip();//切换到读模式 fileOutChannel.write(buffer);//从 buffer 读取数据并写入到 fileOutChannel，此时缓冲区的数据从位置 0 到 limit 被读取。 buffer.clear(); } System.out.println("复制完毕"); } catch (IOException e) { e.printStackTrace(); } } } import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.*; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.Iterator; import java.util.Set; public class NIOServer { public static void main(String[] args) { try { // 打开服务器套接字通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 绑定到特定端口 serverSocketChannel.socket().bind(new InetSocketAddress(8080)); System.out.println("Server started on port 8080"); // 设置为非阻塞模式 serverSocketChannel.configureBlocking(false); // 打开Selector Selector selector = Selector.open(); // 将ServerSocketChannel注册到Selector，并指定关注事件为接收操作 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) { // 等待需要处理的事件发生 selector.select(); // 获取所有触发的事件的SelectionKey Set<SelectionKey> selectedKeys = selector.selectedKeys(); Iterator<SelectionKey> keyIterator = selectedKeys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { // 有新的连接 ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel clientSocketChannel = server.accept(); clientSocketChannel.configureBlocking(false); // 将新的SocketChannel注册到Selector，并指定关注事件为读操作 clientSocketChannel.register(selector, SelectionKey.OP_READ); System.out.println("Connection established with " + clientSocketChannel.getRemoteAddress()); } else if (key.isReadable()) { // 有可读数据 SocketChannel clientSocketChannel = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = clientSocketChannel.read(buffer);//此处将读到内容写进buffer,即处于buffer的写模式 if (bytesRead == -1) { // 客户端断开连接 clientSocketChannel.close(); key.cancel(); System.out.println("Connection closed by client: " + clientSocketChannel.getRemoteAddress()); } else { buffer.flip();// 切换到读模式(从buffer中读取) Charset charset = StandardCharsets.UTF_8; String message = charset.decode(buffer).toString().trim(); System.out.println("Message from client " + clientSocketChannel.getRemoteAddress() + ": " + message); // 回复消息给客户端 String response = "我是来自服务端的答复"; ByteBuffer responseBuffer = charset.encode(response); clientSocketChannel.write(responseBuffer); } } keyIterator.remove(); } } } catch (IOException e) { e.printStackTrace(); } } } public class NIOClient { public static void main(String[] args) { try { // 打开客户端套接字通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("localhost", 8080)); String message = "我是来自客户端的消息"; Charset charset = StandardCharsets.UTF_8; ByteBuffer buffer = charset.encode(message); socketChannel.write(buffer); // 发送消息到服务器 // 接收服务器的回复 ByteBuffer responseBuffer = ByteBuffer.allocate(1024); int bytesRead = socketChannel.read(responseBuffer); while (bytesRead != -1) { responseBuffer.flip(); // 切换到读模式 // 解码服务器的回复 CharBuffer charBuffer = charset.decode(responseBuffer); System.out.println("Response from server: " + charBuffer.toString()); responseBuffer.clear(); // 清空缓冲区，准备下一次读取 bytesRead = socketChannel.read(responseBuffer); } socketChannel.close(); // 关闭连接 } catch (IOException e) { e.printStackTrace(); } } } public class NIOClient2 { //.. String message = "我是来自客户端2的消息"; //.. } AIO 异步非阻塞 Asynchronous IO 在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道 AsynchronousSocketChannel AsynchronousServerSocketChannel AsynchronousFileChannel AsynchronousDatagramChannel 基于事件驱动和回调机制，适用于高延迟I/O操作和高并发、高吞吐量要求的场景，编程最为复杂，但性能最好 public class AsyncServer { public static void main(String[] args) { try { //使用AsynchronousServerSocketChannel来监听连接请求，并使用回调方法处理每个连接 AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open(); serverChannel.bind(new InetSocketAddress("localhost", 12345)); System.out.println("正在监听12345端口"); //使用CompletionHandler来处理连接和读写操作。通过回调方法处理每个客户端的请求而不阻塞主线程 serverChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Void>() { @Override public void completed(AsynchronousSocketChannel socketChannel, Void attachment) { // 当一个客户端连接被接受后，serverChannel.accept(null, this)会准备接受下一个连接 serverChannel.accept(null, this); // 处理当前连接 ByteBuffer buffer = ByteBuffer.allocate(1024); socketChannel.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer buffer) { buffer.flip(); String message = StandardCharsets.UTF_8.decode(buffer).toString(); System.out.println("[客户端消息]:" + message); buffer.clear(); buffer.put(("我是来自server的答复").getBytes(StandardCharsets.UTF_8)); buffer.flip(); socketChannel.write(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer buffer) { if (buffer.hasRemaining()) { socketChannel.write(buffer, buffer, this); } else { buffer.compact(); socketChannel.read(buffer, buffer, this); } } @Override public void failed(Throwable exc, ByteBuffer buffer) { exc.printStackTrace(); } }); } @Override public void failed(Throwable exc, ByteBuffer buffer) { exc.printStackTrace(); } }); } @Override public void failed(Throwable exc, Void attachment) { exc.printStackTrace(); } }); // 防止主线程退出 System.in.read(); } catch (IOException ex) { ex.printStackTrace(); } } } public class AsyncClient { public static void main(String[] args) { try (AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open()) { InetSocketAddress hostAddress = new InetSocketAddress("localhost", 12345); Future<Void> future = clientChannel.connect(hostAddress); future.get(); System.out.println("已连接到服务器"); ByteBuffer buffer = ByteBuffer.allocate(1024); String message = "Hello, Server!"; buffer.put(message.getBytes(StandardCharsets.UTF_8)); buffer.flip(); clientChannel.write(buffer).get(); buffer.clear(); clientChannel.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer buffer) { buffer.flip(); String response = StandardCharsets.UTF_8.decode(buffer).toString(); System.out.println("[服务端消息]:" + response); } @Override public void failed(Throwable exc, ByteBuffer buffer) { exc.printStackTrace(); } }); // 防止主线程退出 System.in.read(); } catch (IOException | InterruptedException | ExecutionException ex) { ex.printStackTrace(); } } } public class AsyncClient2 { //.. String message = "Hello, Server!,我是AsyncClient2"; //.. }`,``,`html`,`JavaScript`,`20240328220321-_前端 在JavaScript中，如果一个函数定义了参数但在调用时没有传递参数，通常不会导致错误。相反，未传递的参数会被视为undefined。 js 弱数据类型,变量在创建的时候不区分类型,而在赋值的时候区分,赋了什么类型的值即为什么类型的变量 方法的声明方式 //1 function fun1(){} //2,函数表达式,先定义后使用 var fun1=function(){} 数据类型 number: 数字类型,整浮都包括 string: 字符串 boolean: 布尔类型 undefined: 已声明未赋值 null: 空对象 object: 对象类型 NaN: 是Number的一种特殊类型,isNaN(str)数字返回false,非数字返回true 字符和数值的转换 //隐式自动转换 var str="123"; console.log(str*1+1); //124 //字母结尾,parseInt和parseFloat忽略字母后缀 str="123a"; console.log(parseInt(str)); //123 console.log(parseFloat(str)); //123 console.log(Number(str)); //NaN //0开头时 str="0123.456"; console.log(parseInt(str)); //123 console.log(parseFloat(str)); //123.456 console.log(Number(str)); //123.456 //null或空双引号时情况一致 str=null; console.log(parseInt(str)); //NaN console.log(parseFloat(str)); //NaN console.log(Number(str)); //0 布尔值的转换 //为字符串时空双引为false //为对象时null为false //为数值时0为false,也即布尔值false可简写为!1,true简写为!0 var str; console.log(Boolean(str)); 运算符优先级 没有小括号加持的情况下先与后或 名称:排名 小括号:1 自增自减:2 乘除取模:3 加减:4 大于,小于,大于等于,小于等于:5 等于不等于:6 与:7 或:8 三目运算符:9 赋值:10 内置函数 substr(startIndex, length) 返回从起始索引开始的指定长度的子字符串。 如果 startIndex 是负数，则它将从字符串的末尾倒数计算。例如，substr(-3, 2) 表示从倒数第三个字符开始，截取长度为 2 的子字符串。 substring(startIndex, endIndex) 返回从起始索引到结束索引之间的子字符串，不包括结束索引位置的字符。 如果传入的 startIndex 大于 endIndex，则自动交换这两个参数的值。此外，如果 startIndex 或 endIndex 是负数，则这两个参数将被视为0。 var str = "abcd"; console.log(str.substr(-3,4)); //bcd console.log(str.substring(3,0)); //abc indexOf(target) 返回从索引0开始第一次出现目标时的索引位置,-1为不存在 indexOf(target,n) 返回从索引n开始第一次出现目标时的索引位置,-1为不存在 var str = "abcdabcd"; console.log(str.indexOf("bc"));//1 console.log(str.indexOf("bc",2));//5 concat()可以连接字符串也可以连接数组 var d1 = new Date(); var d2 = new Date("2024-5-5 19:10:01"); console.log(d1.getMonth()+1);//月份从0开始,0-11 var diff = d2.getTime()-d1.getTime(); console.log(parseInt(diff/(24*3600*1000))); function fmtDate(){ var now = new Date(); var year = now.getFullYear(); var mon = now.getMonth()+1; var day = now.getDate(); var hour = now.getHours(); var min = now.getMinutes(); var sec = now.getSeconds(); return year+"-"+mon+"-"+day+" "+hour+":"+min+":"+sec; } console.log(fmtDate()); var n=3.456; console.log(Math.round(n));//3 console.log(n.toFixed(0));//3 console.log(n.toFixed(1));//3.5 console.log(Math.min(1,2,3));//1 console.log(Math.max(1,2,3));//3 console.log(Math.abs(-1));//1 数组 用于遍历数组元素使用：for()，forEach()，map()，for...of 。 用于循环对象属性使用：for...in。for....in 是es5标准， 此方法遍历数组效率低，主要是用来循环遍历对象的属性, 不能保证以任何特定的顺序返回索引 在 forEach、map、filter、reduce、every、some 函数中 break 和 continue 关键词都会不生效，因为是在function中，但function解决了闭包陷阱的问题。要想使用 break、continue 可以使用 for、for...in、for...of、while。 forEach：用来遍历数组中的每一项，这个方法执行没有返回值，不影响原数组 map：支持return，相当与原数组克隆了一份，把克隆的每项改变了，也不影响原数组 遍历方式一 let arr = ['a','b','c','d','e']; for (let i = 0, len = arr.length; i < len; i++) { console.log(i); // 0 1 2 3 4 console.log(arr[i]); //a b c d e } 遍历方式二 1st：数组元素(必选) 2nd：数组元素索引值(可选) 3rd：数组本身(可选) let arr = ['a','b','c','d','e']; arr.forEach((item,index,arr)=> { console.log(item); // a b c d e console.log(index); // 0 1 2 3 4 console.log(arr); // ['a','b','c','d','e'] }) 遍历方式三 var arr = [ {name:'a',age:'18'}, {name:'b',age:'19'}, {name:'c',age:'20'} ]; arr.map(function(item,index) { if(item.name == 'b') { console.log(index) // 1 } }) 遍历方式四,推荐用于循环对象,也可以用来遍历json let obj = { name: '王大锤', age: '18', weight: '70kg' } for(var key in obj) { console.log(key); // name age weight console.log(obj[key]); // 王大锤 18 70kg } ---------------------------- let arr = ['a','b','c','d','e']; for(var key in arr) { console.log(key); // 0 1 2 3 4 返回数组索引 console.log(arr[key]) // a b c d e } 遍历方式五,可循环数组和对象，推荐用于遍历数组。 for…of提供了三个新方法： key()是对键名的遍历； value()是对键值的遍历； entries()是对键值对的遍历； let arr = ['科大讯飞', '政法BG', '前端开发']; for (let item of arr) { console.log(item); // 科大讯飞 政法BG 前端开发 } // 输出数组索引 for (let item of arr.keys()) { console.log(item); // 0 1 2 } // 输出内容和索引 for (let [item, val] of arr.entries()) { console.log(item + ':' + val); // 0:科大讯飞 1：政法BG 2：前端开发 } let和var https://www.jb51.net/article/231406.htm for(var i=0;i<5;i++){ setTimeout(function(){ console.log(i) },1000) } for(let i=0;i<5;i++){ setTimeout(function(){ console.log(i) },1000) } //第一处代码运行完毕的结果是1s后顺序打印5个5；第二处代码运行完毕的结果是1s后顺序打印0,1,2,3,4。 //因为第一处代码的变量i由var关键字声明，不存在关键性死区，即你在1s后setTimeout中访问到的变量i是全局上下文中for循环运行完毕之后的i,所以打印的结果全是5； //而第二处代码的变量i由let关键字声明，产生了关键性死区，存在setTimeout中的i变量是你当时存储时的i的值，这个存储区间的i不会因为外面有相同的i变量且赋了不同的值而改变，他依旧是之前存储进去的值，这就是暂时性死区的表现，也是为什么第二处代码运行完毕是顺序打印0,1,2,3,4的原因。 var是ES5标准中声明变量的方式，而let是ES6标准中新增的声明变量的方式。 var声明的变量是函数作用域或全局作用域，而let声明的变量是块级作用域。 var声明的变量在变量声明之前就可以使用，而let声明的变量只有在变量声明之后才能使用。 如果在同一个作用域内，使用var关键字声明一个已经存在的变量，那么会覆盖之前的变量；但如果使用let声明已存在的变量，则会抛出一个错误。 在for循环中使用var声明的循环计数器变量存在变量提升，可能会导致意外的行为，而使用let声明的循环计数器变量则不存在这个问题。 因此，一般来说，建议使用let来声明变量，因为它可以避免一些常见的错误和块级作用域更符合人们的直觉。但在一些特定的情况下，如在全局作用域中声明变量，或者需要在多个函数中共享变量时，可以使用var声明变量。 radio选择 <form> <input type="radio" name="sex" value="1" checked="checked">男 <input type="radio" name="sex" value="0">女<br> <input type="button" value="btn" onclick="fun1()"> </form> function fun1() { var sex = document.getElementsByName('sex'); var result; if (sex[0].checked) { result=sex[0].value; }else{ result=sex[1].value; } console.log(result); } select赋值 select移除连续元素options.length=0或者倒序遍历remove <form> <select id="year"></select>年 <select id="month"></select>月 <select id="day"></select>日 </form> function initSelect() { var nowYear=parseInt(new Date().getFullYear()); var year=document.getElementById("year"); year.onchange=changeDays; var month=document.getElementById("month"); month.onchange=changeDays; var day=document.getElementById("day"); fillOption(year,1990,nowYear); fillOption(month,1,12); fillOption(day,1,31); } function fillOption(o,s,e){ for (var i=s; i <=e; i++) { o.options.add(new Option(i,i)) } } function changeDays(){ var year=parseInt(document.getElementById("year").value); var month=parseInt(document.getElementById("month").value); var day=document.getElementById("day"); var e; if(month==4 || month==6 || month==9 || month==11){ e=30 }else if(month==2){ if(year%4==0 && year%100!=0 || year%400==0) e=29 else e=28 }else{ e=31 } day.options.length=0; fillOption(day,1,e); } window.onload=function(){ initSelect(); } checkbox <form> <input type="checkbox" name="interest" value="1"><label>游泳</label> <input type="checkbox" name="interest" value="2"><label>爬山</label> <input type="checkbox" name="interest" value="3"><label>看书</label> <input type="checkbox" name="interest" value="4"><label>听歌</label> <input type="button" name="" id="btn1" value="全选"> <input type="button" name="" id="btn2" value="反选"> </form> flag=false; function selectAll() { var btn1=document.getElementById("btn1"); var interest=document.getElementsByName("interest"); for (var i = interest.length - 1; i >= 0; i--) { interest[i].checked=flag; console.log(interest[i].value) } if (flag) btn1.value="全不选"; else btn1.value="全选"; flag=!flag; } function reverseSelect() { var interest=document.getElementsByName("interest"); for (var i = interest.length - 1; i >= 0; i--) { interest[i].checked=!interest[i].checked; console.log(interest[i].value); } } window.onload=function(){ var btn1=document.getElementById("btn1"); var btn2=document.getElementById("btn2"); btn1.onclick=selectAll; btn2.onclick=reverseSelect; } 计算器例 <div id="calc"> <div id="screen"> <input type="text" name="" id="input_screen" disabled="disabled"> </div> <div id="button"> <input type="button" name="btn" value="c"> <input type="button" name="btn" value="del"> <input type="button" name="btn" value="+/-"> <input type="button" name="btn" value="/"> <input type="button" name="btn" value="7"> <input type="button" name="btn" value="8"> <input type="button" name="btn" value="9"> <input type="button" name="btn" value="*"> <input type="button" name="btn" value="4"> <input type="button" name="btn" value="5"> <input type="button" name="btn" value="6"> <input type="button" name="btn" value="-"> <input type="button" name="btn" value="1"> <input type="button" name="btn" value="2"> <input type="button" name="btn" value="3"> <input type="button" name="btn" value="+" id="plus"> <input type="button" name="btn" value="0"> <input type="button" name="btn" value="."> <input type="button" name="btn" value="="> </div> </div> #calc { background: blanchedalmond; padding: 5px; width: 150px; top: 200px; left: 400px; position: absolute; } input[type="text"]{ width: 125px; background: #fff; text-align: right; } input[type="button"]{ width: 30px; } input[type="button"]:hover{ background: yellow; border: #000 solid 1px; } #plus { margin: 2px 16px 0 0; float: right; position: relative; padding: 12px 0px 13px 0px; } function init(){ var screen= document.getElementById("input_screen"); screen.value="0"; var buttons=document.getElementsByName("btn"); var temp; var method; var error=false; for (var i = buttons.length - 1; i >= 0; i--) { buttons[i].onclick=function(){ if(!isNaN(Number(this.value))){ error=false; if(screen.value=="0") screen.value=this.value; else if(screen.value=="Error") screen.value=this.value; else screen.value+=this.value; }else{ if(!error){ switch(this.value){ case "c": screen.value="0"; temp=0; method=""; break; case "del": if (screen.value.length>1) screen.value=screen.value.substring(0,screen.value.length-1); else screen.value="0"; break; case "+/-": screen.value*=-1; break; case "/": case "*": case "-": case "+": temp=screen.value; method=this.value; screen.value="0"; break; case ".": if (screen.value.indexOf(".")==-1) screen.value+="."; break; case "=": switch(method){ case "/": if(screen.value!="0") screen.value=(temp*1)/(screen.value*1); else{ screen.value="Error"; error=true; temp=0; method=""; } break; case "*": screen.value=(temp*1)*(screen.value*1); break; case "-": screen.value=temp*1-screen.value*1; break; case "+": screen.value=temp*1+screen.value*1; break; } break; } } } } } } window.onload=function(){ init(); }`,``,`html`,`JDBC`,`20240503234929-_数据库 Java DataBase Connectivity Java数据库连接 Java通过JDBC API定义驱动标准,数据库厂商自己提供符合标准的数据库驱动程序 JDBC通过与数据库驱动程序的交互实现与关系型数据库的连接与操作 JDBC 是底层 API，操作较为繁琐。 为了简化数据库操作，通常使用 ORM 框架（如 Hibernate、MyBatis），它们基于 JDBC 实现了更高级别的抽象。 commons DButils 是对jdbc进行了相对简单的包装, 适合简化 JDBC 操作，特别是当你只需要执行简单的 SQL 查询和更新时。它轻量级且易于使用，没有复杂的配置。 MyBatis 进一步封装 jdbc, 适合需要高级映射和动态 SQL 支持的场景，尤其是当你需要处理复杂的查询和结果映射时。它提供了丰富的功能，但也需要更多的配置 Hibernate: 对 jdbc 封装得最彻底的框架, 纯面向对象, 可以不用写 SQL 为了提高数据库连接的效率和性能，通常使用连接池（如 HikariCP、C3P0、DBCP）。 连接池通过重用数据库连接来减少连接创建和关闭的开销。 连接池负责创建和回收连接,程序只负责取用与归还 不使用数据库连接池的步骤 TCP建立连接的三次握手 MySQL认证的三次握手 真正的SQL执行 MySQL的关闭 TCP的四次挥手关闭 使用数据库连接池的步骤： 第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。 20240411131832.webp jdbc与mysql的交互 mysql驱动类 mysql5 com.mysql.jdbc.Driver mysql8 com.mysql.cj.jdbc.Driver mysql连接字符串 jdbc:mysql://主机ip(默认127.0.0.1)[:端口(默认3306)]/数据库名?参数1=值1&参数2=值2&.. 所有未指定的属性都会使用其默认值。 对于特定的应用场景，显式指定属性值可能更安全和高效 serverTimezone 数据库服务器时区与应用程序不一致时使用，例如：serverTimezone=UTC 默认值: 服务器时区 (server default timezone) useSSL 是否使用SSL加密连接,true或false 默认值: true（在某些 MySQL 版本中，如果服务器支持 SSL） autoReconnect 连接断开后是否自动重新连接 长时间运行的应用程序或不稳定的网络环境中使用，值为true或false 默认值: false characterEncoding 设置字符编码 需要指定连接使用的字符编码时，例如：characterEncoding=UTF-8 默认值: utf8 connectTimeout 连接超时时间（毫秒） 默认值: 0（表示不超时） socketTimeout 套接字超时时间（毫秒） 默认值: 0（表示不超时） useUnicode 需要处理Unicode字符时使用，值为true或false, 如果启用，characterEncoding 将被用作编码 默认值: true allowPublicKeyRetrieval 允许通过公钥检索用户认证 服务器配置要求通过公钥检索认证时使用，值为true或false 默认值: false rewriteBatchedStatements 批量处理时重写SQL语句 提高批量插入或更新操作性能时使用，值为true或false 默认值: false zeroDateTimeBehavior 处理数据库中“0000-00-00”日期的行为 可以设置为CONVERT_TO_NULL、THROW或ROUND，处理无效日期数据时使用 默认值: exception useLegacyDatetimeCode 是否使用旧的日期时间处理代码 兼容旧版本JDBC驱动的日期时间处理方式时使用，值为true或false 默认值: true allowMultiQueries 是否允许多条SQL语句一起执行 需要在一个执行中运行多条SQL语句时使用，值为true或false 默认值: false cachePrepStmts 是否缓存预编译语句 提高预编译语句性能时使用，值为true或false 默认值: false prepStmtCacheSize 预编译语句缓存大小 设置预编译语句缓存数量时使用，需配合cachePrepStmts参数，例如：prepStmtCacheSize=250 默认值: 25 prepStmtCacheSqlLimit 预编译语句缓存SQL大小限制 设置预编译语句缓存SQL的最大长度，需配合cachePrepStmts参数，例如：prepStmtCacheSqlLimit=2048 默认值: 256 依赖 <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.33</version> </dependency> <!-- 新版id --> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <version>8.4.0</version> </dependency> 原生示例 查询 public class StandardJDBC { public static void main(String[] args) { String dbDriver = "com.mysql.cj.jdbc.Driver"; String dbURL = "jdbc:mysql://localhost:3306/testdb" + "?useSSL=true" + "&useUnicode=true" + "&characterEncoding=UTF-8" + "&serverTimezone=Asia/Shanghai"; String dbUsername = "root"; String dbPassword = "root"; String sql = "select * from testdb.employee where dname=?"; Connection conn = null; //java.sql.Connection是一个接口, 具体由驱动厂商实现(如mysql-connector-java) //Statement statement = null; PreparedStatement pstmt = null; ResultSet rs = null; try { Class.forName(dbDriver);//加载驱动类字节码 //创建数据库连接 //DriverManager用于注册/管理jdbc驱动程序,getConnection返回对应数据库的物理网络连接 conn = DriverManager.getConnection(dbURL,dbUsername,dbPassword); //创建Statement对象 //stmt = conn.createStatement(); //rs = stmt.executeQuery("select * from testdb.employee where dname='研发部'"); //创建PreparedStatement对象 pstmt = conn.prepareStatement(sql); pstmt.setString(1,"研发部"); //第一个问号所指 rs = pstmt.executeQuery(); //数据操作 while (rs.next()) { //每次返回一条记录 Integer eno = rs.getInt(1);//按字段位置, 本条记录的第一列数据 String name = rs.getString("ename");//也可以按字段名称 Float salary = rs.getFloat("salary"); System.out.println(Arrays.toString(new Object[]{eno, name, salary})); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { try { if (rs != null && !rs.isClosed()) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } try { //if (stmt != null && !stmt.isClosed()) { // stmt.close(); //} if (pstmt != null && !pstmt.isClosed()) { pstmt.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (conn !=null && !conn.isClosed()){ conn.close(); } } catch (SQLException e) { throw new RuntimeException(e); } } } } 写操作 简易封装连接的创建和关闭 public class DbUtils { public static Connection getConnection() { String dbDriver = "com.mysql.cj.jdbc.Driver"; String dbURL = "jdbc:mysql://localhost:3306/testdb" + "?useSSL=true" + "&useUnicode=true" + "&characterEncoding=UTF-8" + "&serverTimezone=Asia/Shanghai"; String dbUsername = "root"; String dbPassword = "root"; try { Class.forName(dbDriver); return DriverManager.getConnection(dbURL,dbUsername,dbPassword); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } catch (SQLException e) { throw new RuntimeException(e); } } public static void closeConnection(ResultSet rs, PreparedStatement pstmt, Connection conn) { try { if (rs != null && !rs.isClosed()) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (pstmt != null && !pstmt.isClosed()) { pstmt.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (conn !=null && !conn.isClosed()){ conn.close(); } } catch (SQLException e) { throw new RuntimeException(e); } } } 增改删 public static void main(String[] args) { System.out.println("1:查询"); System.out.println("2:新增"); System.out.println("3:更新"); System.out.println("4:删除"); System.out.println("请选择功能:"); Scanner sc = new Scanner(System.in); int cmd = sc.nextInt(); Command command; switch (cmd) { case 1: command = new Query(); command.execute(); break; case 2: command = new Insert(); command.execute(); break; case 3: command = new Update(); command.execute(); break; case 4: command = new Delete(); command.execute(); break; } } public class Insert implements Command { @Override public void execute() { Scanner sc = new Scanner(System.in); System.out.println("编号:"); int eno = sc.nextInt(); System.out.println("姓名:"); String ename = sc.next(); System.out.println("佣金:"); float salary = sc.nextFloat(); System.out.println("部门:"); String dname = sc.next(); Connection conn = null; PreparedStatement pstmt = null; try { conn = DbUtils.getConnection(); String sql = "insert into employee(eno,ename,salary,dname) values(?,?,?,?)"; pstmt = conn.prepareStatement(sql); pstmt.setInt(1, eno); pstmt.setString(2, ename); pstmt.setFloat(3, salary); pstmt.setString(4, dname); int cnt = pstmt.executeUpdate();// 所有写操作都是这个方法,返回写操作所影响到的总行数 } catch (SQLException e) { throw new RuntimeException(e); } finally { DbUtils.closeConnection(null, pstmt, conn); } } } //.. String sql = "update employee set salary=? where eno=?"; pstmt = conn.prepareStatement(sql); pstmt.setFloat(1, salary); pstmt.setInt(2, eno); if (pstmt.executeUpdate() == 0) { System.out.println("未找到编号为"+eno+"的员工"); } //.. //.. String sql = "delete from employee where eno=?"; pstmt = conn.prepareStatement(sql); pstmt.setInt(1, eno); if (pstmt.executeUpdate() == 0) { System.out.println("未找到编号为"+eno+"的员工"); } //.. 日期类型的转换 MySQL 中的 DATE 类型数据在 Java 中通常会映射为 java.sql.Date MySQL 中的 TIME 类型数据在 Java 中通常会映射为 java.sql.Time MySQL 中的 DATETIME 和 TIMESTAMP 类型数据在 Java 中通常会映射为 java.sql.Timestamp //写表时要求为sql包下的日期类型 String _hiredate = sc.next(); java.sql.Date hiredate = null; try { hiredate = new java.sql.Date(new SimpleDateFormat("yyyy-MM-dd").parse(_hiredate).getTime()); } catch (ParseException e) { throw new RuntimeException(e); } //读表时接收到的日期类型也是sql包下的, 可以不转换,因为sql.Date继承自util.Date java.sql.Date sqlDate = rs.getDate("event_date"); java.util.Date utilDate = new java.util.Date(sqlDate.getTime()); //utilDate 包含的日期部分会是1970年1月1日，因为 java.sql.Time 仅包含时间部分 java.sql.Time sqlTime = rs.getTime("event_time"); java.util.Date utilDate = new java.util.Date(sqlTime.getTime()); 与日期时间相关的包和类 java.util包 Date: 表示特定的瞬间，精确到毫秒。 Calendar: 提供了操作日期和时间的方法和字段，可以处理复杂的日期时间计算。 TimeZone: 表示时区的类，用于计算时区偏移量。 GregorianCalendar: Calendar的具体子类，提供了标准日历系统。 java.sql包 Date: 仅表示日期（年、月、日），不包含时间部分。 Time: 仅表示时间（小时、分钟、秒）。 Timestamp: 表示日期和时间。提供了纳秒级的时间精度（9 位数字），它不仅包含毫秒级精度，还可以扩展到纳秒级别 // 设置毫秒级时间 (例如: 2024-08-25 12:30:15.123) long milliseconds = 1724525415123L; // 这是从1970-01-01 00:00:00 GMT开始的毫秒数 Timestamp timestampMillis = new Timestamp(milliseconds); // 设置纳秒级时间 (例如在原来的基础上增加456789纳秒) Timestamp timestampNanos = new Timestamp(milliseconds); // 仍然是上面的毫秒时间基础 timestampNanos.setNanos(123456789); // 设置纳秒部分, 注意123是毫秒数, 后面的456789才是设置的纳秒数 java.text包 DateFormat: 抽象类，用于格式化和解析日期或时间。 SimpleDateFormat: DateFormat的具体子类，允许格式化和解析日期字符串。 java.time包（Java 8及以上版本） LocalDate: 表示日期（年、月、日），不包含时间和时区信息。 LocalTime: 表示时间（时、分、秒、纳秒），不包含日期和时区信息。 LocalTime.of(12, 30, 15, 123000000); 12:30:15.123, 123000000 表示纳秒（相当于 123 毫秒） LocalDateTime: 表示日期和时间，不包含时区信息。 ZonedDateTime: 表示带时区的日期和时间。 OffsetDateTime: 表示带偏移量的日期和时间。 Instant: 表示时间线上的一个瞬间，精确到纳秒 主要子包及其类： java.time.format: 提供了格式化和解析日期时间的类。 DateTimeFormatter: 用于格式化和解析日期时间的类。 java.time.temporal: 提供了访问日期和时间的工具类。 ChronoUnit: 时间单位枚举，比如天、小时、分钟等。 TemporalAdjusters: 用于日期调整的常用方法，比如下一个工作日。 java.time.zone: 提供了与时区相关的类。 ZoneId: 表示时区标识符。 ZoneOffset: 表示与UTC的时间偏移量。 java.util.concurrent包 TimeUnit: 时间单位枚举，用于指定时间间隔的单位，如秒、分钟、小时等。 事务管理和批处理 自动提交模式指每执行一次写操作sql,自动提交事务 conn.setAutoCommit(true); 自动事务是jdbc默认行为, 不能保证多数据写时的一致性, 比如A向B转账分先后两步操作, A-100提交后B没有有同一时刻+100 手动提交模式指显式调用commit()和rollback()方法管理事务 conn.setAutoCommit(false); 手动事务可以保证多数据写时的一致性,但必须手动调用提交/回滚方法 批处理 executeBatch 和 addBatch 是处理批量操作的两个关键方法。它们通常用于在单个数据库操作中执行多个SQL语句，以提高性能 每次单独的SQL操作都会涉及一次数据库的网络往返，而批处理可以将多条SQL语句一次性发送到数据库服务器 每次执行SQL语句时，数据库需要对SQL语句进行解析、优化和生成执行计划。批处理可以将多条语句合并成一个请求，减少了解析和优化的次数 public class Transaction { public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt = null; try { conn = DbUtils.getConnection(); conn.setAutoCommit(false); pstmt = conn.prepareStatement("insert into employee(eno,ename,salary,dname) values (?,?,?,?)"); for (int i = 0; i < 1000; i++) { //if (i == 2) // throw new RuntimeException("opps"); pstmt.setInt(1, i); pstmt.setString(2, "员工" + i); pstmt.setFloat(3, 1000f); pstmt.setString(4, "市场部"); //pstmt.executeUpdate(); pstmt.addBatch(); //添加到批处理 } int[] results = pstmt.executeBatch(); //一次性执行, 返回一个int数组中的每个元素代表相应命令执行后受影响的行数 conn.commit(); } catch (SQLException e) { throw new RuntimeException(e); } catch (RuntimeException e) { e.printStackTrace(); try { if(conn!=null && !conn.isClosed()) //检查连接的有效性是一个良好的编程习惯，可以避免由于空指针或关闭连接导致的异常 conn.rollback(); System.out.println("异常已回滚"); } catch (SQLException ex) { throw new RuntimeException(ex); } } finally { DbUtils.closeConnection(null, pstmt, conn); } } } 连接池 druid <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.2.23</version> </dependency> driverClassName=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/testdb?useSSL=true&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai username=root password=root initialSize=10 maxActive=20 public class DruidTest { public static void main(String[] args) { Properties properties = new Properties(); try { properties.load(DruidTest.class.getResourceAsStream("/druid-config.properties")); } catch (IOException e) { throw new RuntimeException(e); } Connection conn = null; PreparedStatement pstmt =null; ResultSet rs = null; try { //创建数据源对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); //创建数据库连接 for (int i = 0; i < 20; i++) { conn = dataSource.getConnection(); } pstmt = conn.prepareStatement("select * from employee limit 0,10"); rs = pstmt.executeQuery(); while (rs.next()) { int eno = rs.getInt("eno"); String ename = rs.getString("ename"); float salary = rs.getFloat("salary"); System.out.println(Arrays.toString(new Object[]{eno,ename,salary})); } } catch (Exception e) { throw new RuntimeException(e); } finally { //不使用连接池: conn.close() 关闭连接 //使用连接池: conn.close() 将连接回收至连接池 DbUtils.closeConnection(rs,pstmt,conn); } } } C3P0 <dependency> <groupId>com.mchange</groupId> <artifactId>c3p0</artifactId> <version>0.9.5.5</version> </dependency> <dependency> <groupId>com.mchange</groupId> <artifactId>mchange-commons-java</artifactId> <version>0.2.19</version> </dependency> 文件名称固定为c3p0-config.xml,且文件位于根路径上,注意xml文件中&转义 <?xml version="1.0" encoding="utf-8" ?> <c3p0-config> <default-config> <property name="driverClass">com.mysql.cj.jdbc.Driver</property> <property name="jdbcUrl">jdbc:mysql://localhost:3306/testdb?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</property> <property name="user">root</property> <property name="password">root</property> <property name="initialPoolSize">10</property> <property name="maxPoolSize">20</property> </default-config> </c3p0-config> public class C3P0Test { public static void main(String[] args) { //直接创建DataSource, 因为配置文件名和文件地址是固定的 DataSource dataSource = new ComboPooledDataSource(); Connection conn = null; PreparedStatement pstmt =null; ResultSet rs = null; try { for (int i = 0; i < 20; i++) { conn = dataSource.getConnection(); } pstmt = conn.prepareStatement("select * from employee limit 0,10"); rs = pstmt.executeQuery(); while (rs.next()) { int eno = rs.getInt("eno"); String ename = rs.getString("ename"); float salary = rs.getFloat("salary"); System.out.println(Arrays.toString(new Object[]{eno,ename,salary})); } } catch (Exception e) { throw new RuntimeException(e); } finally { DbUtils.closeConnection(rs,pstmt,conn); } } } Apache Commons DbUtils <dependency> <groupId>commons-dbutils</groupId> <artifactId>commons-dbutils</artifactId> <version>1.8.1</version> </dependency> public class DbUtilsTest { @Test public void query() { Properties properties = new Properties(); try { //与Druid联用 properties.load(DbUtilsTest.class.getResourceAsStream("/druid-config.properties")); DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); //简化提取过程 //使用 QueryRunner 的构造函数传入 DataSource 时，QueryRunner 会自动管理 Connection 的生命周期 QueryRunner qr = new QueryRunner(dataSource); List<Employee> employees = qr.query( "select * from employee limit ?,10", new BeanListHandler<>(Employee.class), //将结果包装为实体类并存入List 5 //第三个参数为可变数组(Object... params), 按序对应sql中的问号 ); employees.forEach(System.out::println); } catch (Exception e) { throw new RuntimeException(e); } } @Test public void update() { //与c3p0联用 DataSource dataSource = new ComboPooledDataSource(); Connection conn = null; try { conn = dataSource.getConnection(); conn.setAutoCommit(false); //手动事务 String sql1 = "update employee set salary=salary+1000 where eno=?"; String sql2 = "update employee set salary=salary-500 where eno=?"; QueryRunner qr = new QueryRunner(); //空参 //update()适用增改删 //当手动传入 Connection 对象时，QueryRunner 不会管理连接的关闭，你需要在操作完成后手动关闭连接 qr.update(conn, sql1, 1000); //手动传入了一个从 dataSource 获取的连接 conn,sql语句,可变长参数 qr.update(conn, sql2, 1001); conn.commit(); //手动提交 } catch (SQLException e) { e.printStackTrace(); try { if(conn !=null && !conn.isClosed()){ conn.rollback(); //手动回滚 }; } catch (SQLException ex) { throw new RuntimeException(ex); } } finally { try { if (conn != null && !conn.isClosed()) { conn.close(); } } catch (SQLException e) { throw new RuntimeException(e); } } } }`,``,`html`,`JDK8新增特性`,`20240413150540-_java 函数式接口 函数式编程理念 是将代码作为可重用数据代入到程序运行中 强调平铺直叙"你想做什么" 而不是"为了使用这个功能要做哪些准备工作" 函数式接口 只包含一个抽象方法的接口 但是可以包含默认方法（default method）、静态方法（static method）和Object类中的方法（如equals，hashCode等），因为它们不是抽象方法 函数式接口是支持Lambda表达式的基础 因为只有一个抽象方法, 编译器可以推断出Lambda表达式所实现的函数式接口类型, 在编译时，Lambda表达式会被转换为一个实现了目标函数式接口的匿名类的实例 //自定义函数式接口 @FunctionalInterface //检查注解 interface MyFuncInterface { void myMethod(); default void defaultMethod() {System.out.println("默认方法");}//Java 8引入了接口默认方法 static void staticMethod() {System.out.println("静态方法");}//Java 8引入了接口静态方法 } public class Main { public static void main(String[] args) { MyFuncInterface obj = () -> System.out.println("hello");//创建函数式接口的实例,使用Lambda表达式实现myMethod()方法 //使用函数式接口的实例调用Lambda表达式所实现myMethod()方法 obj.myMethod(); //hello //obj.defaultMethod(); //MyFuncInterface.staticMethod(); } } 内置的函数式接口 函数式接口名:参数:返回值:说明 Function<T, R>:T:R:接受一个输入参数并返回结果 BiFunction<T, U, R>:T, U:R:接受两个输入参数并返回结果 IntFunction<R>:int:R:接受一个int类型输入并返回结果 LongFunction<R>:long:R:接受一个long类型输入并返回结果 DoubleFunction<R>:double:R:接受一个double类型输入并返回结果 ToIntFunction<T>:T:int:接受一个输入参数并返回int类型结果 ToLongFunction<T>:T:long:接受一个输入参数并返回long类型结果 ToDoubleFunction<T>:T:double:接受一个输入参数并返回double类型结果 函数式接口名:参数:返回值:说明 Supplier<T>:无:T:提供一个结果，不接受参数 IntSupplier:无:int:提供一个int类型结果，不接受参数 LongSupplier:无:long:提供一个long类型结果，不接受参数 DoubleSupplier:无:double:提供一个double类型结果，不接受参数 函数式接口名:参数:返回值:说明 Consumer<T>:T:void:接受一个输入参数并进行操作，无返回值 BiConsumer<T, U>:T, U:void:接受两个输入参数并进行操作，无返回值 IntConsumer:int:void:接受一个int类型输入并进行操作，无返回值 LongConsumer:long:void:接受一个long类型输入并进行操作，无返回值 DoubleConsumer:double:void:接受一个double类型输入并进行操作，无返回值 ObjIntConsumer<T>:T, int:void:接受一个对象和一个int类型输入并进行操作，无返回值 ObjLongConsumer<T>:T, long:void:接受一个对象和一个long类型输入并进行操作，无返回值 ObjDoubleConsumer<T>:T, double:void:接受一个对象和一个double类型输入并进行操作，无返回值 函数式接口名:参数:返回值:说明 Predicate<T>:T:boolean:接受一个输入参数并返回布尔值 BiPredicate<T, U>:T, U:boolean:接受两个输入参数并返回布尔值 函数式接口名:参数:返回值:说明 UnaryOperator<T>:T:T:接受一个参数并返回同类型结果（Function的特殊化） IntUnaryOperator:int:int:接受一个int类型输入并返回相同类型的结果 LongUnaryOperator:long:long:接受一个long类型输入并返回相同类型的结果 DoubleUnaryOperator:double:double:接受一个double类型输入并返回相同类型的结果 函数式接口名:参数:返回值:说明 BinaryOperator<T>:T, T:T:接受两个同类型参数并返回同类型结果（BiFunction的特殊化） IntBinaryOperator:int, int:int:接受两个int类型输入并返回相同类型的结果 LongBinaryOperator:long, long:long:接受两个long类型输入并返回相同类型的结果 DoubleBinaryOperator:double, double:double:接受两个double类型输入并返回相同类型的结果 // Function apply() Function<String, Integer> lengthFunction = String::length; System.out.println("Length: " + lengthFunction.apply("Hello")); // BiFunction BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b; System.out.println("Sum: " + add.apply(2, 3)); // Consumer accept() Consumer<String> printConsumer = System.out::println; printConsumer.accept("Hello, World!"); // BiConsumer BiConsumer<String, Integer> printBiConsumer = (s, i) -> System.out.println(s + ": " + i); printBiConsumer.accept("Age", 30); // Supplier get() Supplier<String> stringSupplier = () -> "Hello, Supplier!"; System.out.println("Supplied: " + stringSupplier.get()); // Predicate test() 谓词 Predicate<String> isEmpty = String::isEmpty; System.out.println("Is empty: " + isEmpty.test("")); // BiPredicate BiPredicate<String, String> equals = String::equals; System.out.println("Are equal: " + equals.test("hello", "hello")); // UnaryOperator apply() UnaryOperator<String> toUpperCase = String::toUpperCase; System.out.println("Upper case: " + toUpperCase.apply("hello")); // BinaryOperator BinaryOperator<Integer> multiply = (a, b) -> a * b; System.out.println("Product: " + multiply.apply(2, 3)); 接口的默认方法 Predicate,BiPredicate and,or,negate Function andThen 先应用当前函数，再应用 andThen 中的函数。 compose 先应用 compose 中的函数，再应用当前函数。 Function<Integer, Integer> times2 = x -> x * 2; Function<Integer, Integer> square = x -> x * x; Function<Integer, Integer> times2ThenSquare = times2.andThen(square); Function<Integer, Integer> squareThenTimes2 = times2.compose(square);//先square后times2 BiFunction andThen Consumer,BiConsumer andThen UnaryOperator andThen compose BinaryOperator andThen Comparator reversed 返回一个比较器，表示当前比较器的顺序相反 thenComparing(Comparator) 先应用当前比较器，再应用参数中的比较器 Comparator<Person> byName = Comparator.comparing(Person::getName); Comparator<Person> byAge = Comparator.comparingInt(Person::getAge); Comparator<Person> byNameThenAge = byName.thenComparing(byAge); thenComparing(Function keyExtractor, Comparator keyComparator) keyExtractor: 一个函数，用于从对象中提取用于比较的键。 keyComparator: 一个比较器，用于比较提取出来的键。 先使用当前比较器对两个对象进行比较，如果比较结果相等，再使用提供的 keyExtractor 和 keyComparator 对提取出来的键进行比较 // 先按名字排序，如果名字相同再按年龄排序（降序） Comparator<Person> byNameThenAgeDescending = Comparator .comparing(Person::getName) .thenComparing(Person::getAge, Comparator.reverseOrder()); List<Person> sortedPeople = people.stream() .sorted(byNameThenAgeDescending) .collect(Collectors.toList()); thenComparing(Function keyExtractor) 如果比较结果相等，再使用 keyExtractor 提取出的键进行比较，且使用键的自然顺序进行比较。 自然顺序（Natural Order）是指对象的默认排序顺序，它通常是根据对象实现的 Comparable 接口中的 compareTo 方法定义的。 在 Java 中，许多基本类型和标准库中的类都实现了 Comparable 接口，从而定义了它们的自然顺序。 // 先按名字排序，如果名字相同再按年龄排序（升序，自然顺序） Comparator<Person> byNameThenAge = Comparator .comparing(Person::getName) .thenComparing(Person::getAge); 应用例 @Test public void case2() { Predicate<Integer> predicate1 = n -> n > 5; Predicate<Integer> predicate2 = n -> n % 2 == 0; boolean test1 = predicate1.and(predicate2).test(6);//true boolean test2 = predicate1.and(predicate2).test(7);//false List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); for (Integer a : list) { if (predicate1.test(a)) { System.out.print(a + " "); } } //不需要调整filter方法而实现各种逻辑 filter(list, a -> a > 5 && a % 2 == 0); } public void filter(List<Integer> list, Predicate<Integer> predicate) { for (Integer a : list) { if (predicate.test(a)) { System.out.print(a + " "); } } } @Test public void case3() { String s = "信息文本"; //向控制台输出 output(s, str -> System.out.println(str)); output(s, str -> { //向网络地址输出.. }); } public static void output(String s, Consumer<String> consumer) { consumer.accept(s); } @Test public void case4(){ //生成随机定长字符串,通常用于安全领域中的加密和解密 Function<Integer,String> randomStr = len -> { String chars = "abcdefghigklmnopqrstuvwxyz0123456789"; Random random = new Random(); StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i < len; i++) { int pos = random.nextInt(chars.length()); stringBuffer.append(chars.charAt(pos)); } return stringBuffer.toString(); }; System.out.println(randomStr.apply(10)); } Lambda表达式 通常用于函数式接口的实例化，使得代码简洁易读 方法引用 方法引用是 Lambda 表达式的一种更简洁的形式，可以直接引用现有的方法 不需要为了实现一个函数式接口而额外编写代码 静态方法引用 格式： ClassName::staticMethodName 示例： Integer::parseInt，String::valueOf 用途： 引用静态方法 Function<Integer, String> intToString = String::valueOf; //Lambda写法 Function<Integer, String> intToString = x -> String.valueOf(x); //匿名类写法 Function<Integer, String> intToString = new Function<Integer, String>() { @Override public String apply(Integer x) { return String.valueOf(x); } }; 实例方法引用 格式： 对象引用::实例方法名 类名::实例方法名 示例： System.out::println，String::length 用途： 引用对象的实例方法或类的实例方法。 List<String> list = Arrays.asList("a", "b", "c"); list.forEach(System.out::println); //Lambda写法 List<String> list = Arrays.asList("a", "b", "c"); list.forEach(s -> System.out.println(s)); //匿名类写法 List<String> list = Arrays.asList("a", "b", "c"); list.forEach(new Consumer<String>() { @Override public void accept(String s) { System.out.println(s); } }); Function<String, Integer> strLength = String::length; //Lambda写法 Function<String, Integer> strLength = s -> s.length(); //匿名类写法 Function<String, Integer> strLength = new Function<String, Integer>() { @Override public Integer apply(String s) { return s.length(); } }; String str = "hello"; Function<String, String> toUpperCaseFunction = str::toUpperCase; //Lambda写法 Function<String, String> toUpperCaseFunction = s -> s.toUpperCase(); //匿名类写法 Function<String, String> toUpperCaseFunction = new Function<String, String>() { @Override public String apply(String s) { return s.toUpperCase(); } }; 构造方法引用 格式： ClassName::new 示例： ArrayList::new，String::new 用途： 引用构造方法，用于创建对象实例。 Supplier<List<String>> listSupplier = ArrayList::new; List<String> list = listSupplier.get(); //Lambda写法 Supplier<List<String>> listSupplier = () -> new ArrayList<>(); List<String> list = listSupplier.get(); //匿名类写法 Supplier<List<String>> listSupplier = new Supplier<List<String>>() { @Override public List<String> get() { return new ArrayList<>(); } }; List<String> list = listSupplier.get(); 数组构造方法引用 格式： TypeName[]::new 示例： int[]::new，String[]::new 用途： 引用数组的构造方法，用于创建数组实例。 Supplier<String[]> arraySupplier = String[]::new //Lambda写法 Supplier<String[]> arraySupplier = () -> new String[10]; //匿名类写法 Supplier<String[]> arraySupplier = new Supplier<String[]>() { @Override public String[] get() { return new String[10]; } }; Optional 用来表示一个可能包含也可能不包含非空值的对象。 主要用于返回类型, 避免显式的 null 检查，可以在不引发 NullPointerException 的情况下处理缺失值。 //创建一个包含非 null 值的 Optional 对象。如果传入了null,则报空指针, 通常与 get() 或 ifPresent() 搭配使用 Optional<String> optional1 = Optional.of("Hello, World!"); //创建一个可能包含 null 值的 Optional 对象。通常与 orElse() 或 orElseGet() 搭配使用 Optional<String> optional2 = Optional.ofNullable(null); System.out.println(Optional.ofNullable(null));//Optional.empty System.out.println(Optional.ofNullable(null).get());//报错No value present //创建一个空的 Optional 对象。表示没有找到值或没有结果的情况, 判断是否返回了一个Optional.empty(),isPresent Optional<String> optional3 = Optional.empty(); System.out.println(Optional.empty());//Optional.empty System.out.println(Optional.empty().get());//报错No value present public Optional<User> findUserByUsername(String username) { User user = userDatabase.get(username); return user != null ? Optional.of(user) : Optional.empty(); } //检查 Optional 对象 看清楚iS iF isPresent() //如果值存在，返回 true，否则返回 false。 ifPresent(Consumer<? super T> consumer) //如果值存在，执行给定的代码块。 //获取值 get() //如果值存在，返回值，否则抛出 NoSuchElementException。 orElse(T other) //如果值存在，返回值，否则返回 other。 orElseGet(Supplier<? extends T> other) //如果值存在，返回值，否则返回由 Supplier 提供的值。 orElseThrow(Supplier<? extends X> exceptionSupplier): //如果值存在，返回值，否则抛出由 Supplier 提供的异常。 //转换值 map(Function<? super T, ? extends U> mapper) //如果值存在，应用 Function 转换值并返回一个新的 Optional。 flatMap(Function<? super T, Optional<U>> mapper) //如果值存在，应用 Function 返回一个新的 Optional，不会对结果进行包装。 filter(Predicate<? super T> predicate) //如果值存在并满足给定的 Predicate，返回包含该值的 Optional，否则返回一个空的 Optional。 新的日期与时间API Java 8 引入了全新的日期和时间 API，称为 java.time 包，提供了一套更现代、更易用的日期和时间类, 它们是不可变的线程安全对象, 解决了旧版 java.util.Date 和 java.util.Calendar 的诸多问题 LocalDate：表示日期（年、月、日），无时间部分。 LocalTime：表示时间（时、分、秒、纳秒），无日期部分。 LocalDateTime：表示日期和时间，无时区信息。 ZonedDateTime：表示日期和时间，有时区信息。 Instant：表示时间戳（自1970-01-01T00:00:00Z起的秒数），通常用于机器时间戳。 Duration：表示时间段，以秒和纳秒为单位。 Period：表示日期间隔，以年、月、日为单位。 DateTimeFormatter：用于解析和格式化日期时间对象。 ZoneId：表示时区。 LocalDate today = LocalDate.now();//2024-06-02 LocalDate specificDate = LocalDate.of(2024, 6, 22); LocalDate parsedDate = LocalDate.parse("2024-06-02"); LocalDate tomorrow = today.plusDays(1); LocalTime now = LocalTime.now();//10:22:46.067 LocalTime specificTime = LocalTime.of(10, 9);//10:09 LocalTime specificTime2 = LocalTime.of(10, 9,8,7);//10:09:08.000000007 LocalTime parsedTime = LocalTime.parse("10:30"); LocalTime parsedTime2 = LocalTime.parse("10:30:20"); LocalTime nextHour = now.plusHours(1);//11:22:46.067 LocalDateTime now2 = LocalDateTime.now();//2024-06-23T10:30:45.896 LocalDateTime specificDateTime = LocalDateTime.of(2024, 6, 22, 10, 30);//2024-06-22T10:30 LocalDateTime parsedDateTime = LocalDateTime.parse("2024-06-22T10:30:00"); LocalDateTime nextDaySameTime = now2.plusDays(1); ZonedDateTime now3 = ZonedDateTime.now();//2024-06-23T10:32:23.397+08:00[Asia/Shanghai] ZonedDateTime specificZonedDateTime = ZonedDateTime.of(2024, 6, 22, 10, 30, 50, 0, ZoneId.of("America/New_York"));//2024-06-22T10:30:50-04:00[America/New_York] ZonedDateTime parsedZonedDateTime = ZonedDateTime.parse("2024-06-22T10:30:00-04:00[America/New_York]"); ZonedDateTime nextHourSameZone = now3.plusHours(1); Instant now4 = Instant.now();//2024-06-23T02:36:41.362Z Instant specificInstant = Instant.ofEpochSecond(1624380000);//2021-06-22T16:40:00Z Instant parsedInstant = Instant.parse("2024-06-22T14:00:00Z"); Instant nextSecond = now4.plusSeconds(1);//2024-06-23T02:36:42.362Z LocalTime start = LocalTime.of(10, 30); LocalTime end = LocalTime.of(12, 0); //Duration 计算时间间隔时并不会自动转换不同单位之间的关系 Duration duration = Duration.between(start, end); System.out.println(duration.toHours());//1 返回的是整个时间间隔的小时部分 System.out.println(duration.toMinutes());//90 返回的是整个时间间隔的分钟部分，包括小时转换成的分钟 //要得到小时和剩余的分钟，可以通过以下方法计算 Duration duration2 = Duration.between(start, end); long hours = duration2.toHours(); long minutes = duration2.toMinutes() % 60; System.out.println("Duration: " + hours + " hours " + minutes + " minutes"); LocalDate startDate = LocalDate.of(2023, 1, 1); LocalDate endDate = LocalDate.of(2024, 6, 22); //Period 计算日期间隔时会自动处理不同单位之间的关系 Period period = Period.between(startDate, endDate); System.out.println("Period: " + period.getYears() + " years " + period.getMonths() + " months " + period.getDays() + " days");//Period: 1 years 5 months 21 days LocalDate date = LocalDate.now(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); System.out.println("Formatted date: " + date.format(formatter));//2024-06-23 LocalDate parsedDate2 = LocalDate.parse("2024-06-22", formatter);`,``,`html`,`jQuery`,`20240328220321-_前端 jQuery 1. 选择器 基本选择器：$("p") 选择所有 p 元素。 ID选择器：$("#myId") 选择ID为 myId 的元素。 类选择器：$(".myClass") 选择类为 myClass 的元素。 属性选择器：$("input[name='username']") 选择name属性为 username 的所有 input 元素。 2. DOM 操作 获取或设置文本内容：$("#element").text() 或 $("#element").text("New Text")。 获取或设置HTML内容：$("#element").html() 或 $("#element").html("html源码")。 获取或设置属性：$("#element").attr("href") 或 $("#element").attr("href", "newlink.html")。 添加或删除类：$("#element").addClass("newClass")，$("#element").removeClass("oldClass")。 3. 事件处理 单击事件：$("#button").click(function() { alert("Button clicked!"); }); 鼠标悬停事件：$("#element").hover(function() { /* mouse over */ }, function() { /* mouse out */ }); 其他事件：$("input").focus(function() { /* focus event */ }); 4. 动画效果 显示和隐藏：$("#element").show()，$("#element").hide()。 淡入和淡出：$("#element").fadeIn()，$("#element").fadeOut()。 滑动：$("#element").slideDown()，$("#element").slideUp()。 5. Ajax 简单的GET请求：$.get("url", function(data) { /* handle data */ }); 简单的POST请求：$.post("url", { key: "value" }, function(data) { /* handle data */ }); 通用的Ajax请求：$.ajax({ url: "url", type: "GET", success: function(data) { /* handle data */ } }); 6. 遍历和过滤 遍历：$("ul li").each(function(index) { $(this).addClass("item-" + index); }); 过滤：$("li").filter(".active")，$("li").not(".inactive")。 7. 链式操作 $("#element").addClass("newClass").show().html("New Content"); window.onload=function(){ jquery_selector(); // sizzle_selector(); } /* jQuery()和$()相等 常用选择器表达式 $("#id") $("tag") $(".className") $("S1,S2,SN") 组合选择器,以逗号分隔 层叠选择器 $("ancestor descendant") 后代 $("ancestor>descendant") 直子 $("a~b") 选择a之后符合条件的兄弟节点 属性选择器,明确匹配,如果标签内没有书写该属性,将不会作用 $("a[href='b']") 选择链接值为b的a标签 $("a[href^='b']") 以b开头 $("a[href$='b']") 以b结尾 $("a[href*='b']") 包含b 位置选择器,以0开始 $("a:first") $("a:last") $("a:odd") 奇 $("a:even") 偶 $("a:eq(n)") 获取指定位置的元素 表单选择器 非明确匹配,如果标签内没有书写该属性,使用默认属性 $(":input") $(":text") 可直接:开头,后跟type值 $(":password") $("selector:submit") $("selector:reset") .. 操作属性 $("a[href*='b']").attr("href","abc") 一个参数时获取属性值(多个元素时返回第一个),两个参数设置属性值 $("a[href*='b']").removeAttr("href") 操作样式 $("a").css("color","red"); 一个参数时获取属性值(多个元素时返回第一个),两个参数设置属性值 $("a").css({"color":"red","font-style":"italic"}); 通过传入json对象,同时设置多个属性值 $("li").addClass("class1 class2"); 不用加点 $("li").removeClass("class"); 设置元素内容 $("input[name='unsme']").val("administrator"); val(),无参时为获取值,有参时为设置值 $("span.myclass").text("ok"); 获取或设置(标签会被转义)纯文本 $("span.myclass").html("ok"); 获取(包括标签)或设置纯html内容, */ function jquery_selector(){ $("#btnSelect").click(function() { var a = $("#txtSelector").val(); $("*").removeClass("highlight"); $(a).addClass("highlight"); }); } /* 鼠标:click,dblclick,mouseenter,mouseleave,mouseover 键盘:keypress,keydown,keyup 表单:submit,change,focus,blur 文档窗口:load,resize,scroll,unload(窗口关闭) */ function jquery_event(){ $("p.myclass").on("click",function(){ $(this).css("background-color","yellow") }); //简写 $("span.myclass").click(function () { $(this).css("background-color","green") }); //当用户名包含非法空格时,提示红色 $("input[name='uname']").keypress(function(event) { console.log(event);//查看字符对应的keycode if(event.keycode==32) //空格 $(this).css("color","red") }) } /* 使用 Sizzle 选择器功能 如果只需要使用 jQuery 的选择器功能，可以考虑仅引入 Sizzle，而不必引入完整的 jQuery https://github.com/jquery/sizzle/wiki */ function sizzle_selector(){ document.getElementById("btnSelect").addEventListener("click", function() { var a = document.getElementById("txtSelector").value; Sizzle("*").forEach(function(element) { element.classList.remove("highlight"); }); Sizzle(a).forEach(function(element) { element.classList.add("highlight"); }); }); } /* 定义json对象 */ function define_json_obj(){ var json = {}; json.name="小明"; json.interest=["唱歌","跳舞"]; json.cats=[{"花花":"中华田园猫"},{"凡凡":"英国短毛猫"}]; console.log(json); console.log(json.cats[1]); } 判断页面加载完成 //等价于 $(document).ready(function(){}) //等待DOM(包括样式表)加载完成后 //不等待整个页面（包括图片等资源）完全加载完成 $(function(){}); $(function(){});//允许多次 //等待整个HTML文档被完全加载和解析后触发 //不等待样式表、图片等资源的加载完成 document.addEventListener("DOMContentLoaded", function() {}); //等待整个页面加载完成后，包括所有的图片和其他资源 window.onload=function(){} //与 window.onload 类似，但是可以添加多个事件处理函数，通过 addEventListener 添加的事件处理函数不会覆盖之前添加的处理函数 window.addlistener("load",function(){}); 表单校验 <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Document</title> <script src="index.js"></script> </head> <body> <form action="#" id="fo"> <div id="error"></div> 姓名:<input id="name"/><br> 身份证号:<input id="no"/><br> <input type="submit"/> </form> <script> document.getElementById('fo').onsubmit=function(){ var error = document.getElementById('error'); var reg1 = /^[\u4e00-\u9fa5]{2,8}$/; var reg2 = /^[1234568]\d{16}[0-9xX]$/; var name = document.getElementById('name').value; var no = document.getElementById('no').value; if(!reg1.test(name)){ error.innerHTML="姓名格式有误" return false; //终止提交 }else if(!reg2.test(no)){ error.innerHTML="身份证号有误"; return false; }else{ alert("格式正确,准备提交"); error.innerHTML=""; return true; } }; </script> </body> </html>`,``,`html`,`JSON`,`20240616183123-_数据交换格式 JSON JavaScript Object Notation JS对象简谱 20240625140456.webp Gson 依赖 <!-- JSON 数据的序列化和反序列化 --> <dependency> <groupId>com.google.code.gson</groupId> <artifactId>gson</artifactId> <version>2.10.1</version> </dependency> 序列化：将对象转换为 JSON 字符串 Gson gson = new Gson(); String json = gson.toJson(object); 反序列化：将 JSON 字符串转换为对象 Gson gson = new Gson(); MyClass obj = gson.fromJson(jsonString, MyClass.class); 泛型支持：使用 TypeToken 来处理泛型 Type type = new TypeToken<List>(){}.getType(); List<MyClass> list = gson.fromJson(jsonString, type); 自定义序列化/反序列化：使用 JsonSerializer 和 JsonDeserializer GsonBuilder builder = new GsonBuilder(); builder.registerTypeAdapter(MyClass.class, new MyClassSerializer()); builder.registerTypeAdapter(MyClass.class, new MyClassDeserializer()); Gson gson = builder.create(); Gson 不会序列化 transient 和 static 字段，默认不序列化 null 值 class Person { String name; String email; } Person person = new Person(); person.name = "John"; //使用 serializeNulls()将值为 null 的字段也包含在生成的 JSON 字符串中 Gson gson = new GsonBuilder().serializeNulls().create(); String json = gson.toJson(person); System.out.println(json); // 输出：{"name":"John","email":null} 命名策略 IDENTITY: 保持原字段名不变 UPPER_CAMEL_CASE: 使用首字母大写的驼峰命名法 LOWER_CASE_WITH_UNDERSCORES: 使用小写并用下划线分隔单词 LOWER_CASE_WITH_DASHES: 使用小写并用连字符分隔单词 LOWER_CASE_WITH_DOTS: 使用小写并用点号分隔单词 class Person { String firstName; String lastName; } Person person = new Person(); person.firstName = "John"; person.lastName = "Doe"; // 使用 UPPER_CAMEL_CASE 策略 Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create(); String json = gson.toJson(person); System.out.println(json); // 输出：{"FirstName":"John","LastName":"Doe"} // 使用 LOWER_CASE_WITH_UNDERSCORES 策略 Gson gson2 = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create(); String json2 = gson2.toJson(person); System.out.println(json2); // 输出：{"first_name":"John","last_name":"Doe"} 日期格式 默认情况下，Gson 使用的是 Date 类的默认格式 class Event { Date date; } public class Main { public static void main(String[] args) { DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss").create(); Event event = new Event(); event.date = new Date(); String json = gson.toJson(event); System.out.println(json);//{"date":"2024-06-25 10:31:55"} Event eventFromJson = gson.fromJson(json, Event.class); System.out.println(eventFromJson.date);//Tue Jun 25 10:33:00 CST 2024 System.out.println(df.format(eventFromJson.date)); } } 注解 class Person { //将类中的name字段映射到JSON中的full_name字段 @SerializedName("full_name") //选择性地包括字段,如果使用GsonBuilder().excludeFieldsWithoutExposeAnnotation()，未标记的字段将被忽略 @Expose private String name; @Expose(serialize = false, deserialize = false) //serialize 和 deserialize，它们分别表示序列化和反序列化时是否应该处理该字段 private int age; //@Since和@Until注解用于根据版本控制字段的序列化和反序列化 @Since(1.0) private String address; @Until(2.0) private String phone; @JsonAdapter(PersonTypeAdapter.class) //指定一个自定义的TypeAdapter来处理该字段的序列化和反序列化 private String customField; // 构造函数，getter 和 setter 方法 } Gson gson = new GsonBuilder() .excludeFieldsWithoutExposeAnnotation() .setVersion(1.5) .create(); @JsonAdapter例子 在这个例子中，PersonTypeAdapter 类实现了 JsonSerializer 和 JsonDeserializer 接口 分别定义了在序列化和反序列化时对 Date 类型的 birthday 字段执行的逻辑 在 serialize 方法中，将 Date 对象转换为指定格式的字符串； 在 deserialize 方法中，将字符串转换为 Date 对象。 public class Person { private String name; private int age; @JsonAdapter(PersonTypeAdapter.class) private Date birthday; // 省略构造函数和其他方法 } public class PersonTypeAdapter extends JsonSerializer<Date> implements JsonDeserializer<Date> { private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); @Override public JsonElement serialize(Date date, Type type, JsonSerializationContext jsonSerializationContext) { return new JsonPrimitive(dateFormat.format(date)); } @Override public Date deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException { try { return dateFormat.parse(jsonElement.getAsString()); } catch (ParseException e) { throw new JsonParseException(e); } } } 处理循环引用 方式一, setExclusionStrategies, 在序列化和反序列化时排除可能引起循环引用的字段。避免了循环引用带来的无限递归, 但会丢失该字段 class Person { String name; Person friend; Person(String name) { this.name = name; } } class FriendExclusionStrategy implements ExclusionStrategy { @Override public boolean shouldSkipField(FieldAttributes f) { return f.getName().equals("friend"); } @Override public boolean shouldSkipClass(Class<?> clazz) { return false; } } public class Main { public static void main(String[] args) { Person person1 = new Person("Alice"); Person person2 = new Person("Bob"); // 创建循环引用 person1.friend = person2; person2.friend = person1; Gson gson = new GsonBuilder() .setExclusionStrategies(new FriendExclusionStrategy()) .serializeNulls() .setPrettyPrinting() .create(); // 序列化 String json = gson.toJson(person1); System.out.println(json); // 反序列化 Person deserializedPerson = gson.fromJson(json, Person.class); System.out.println(deserializedPerson.name); System.out.println(deserializedPerson.friend); // should be null } } 方式二, JsonSerializer 和 JsonDeserializer 自定义序列化和反序列化逻辑来处理循环引用 class Person { String name; Person friend; public Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Person getFriend() { return friend; } public void setFriend(Person friend) { this.friend = friend; } } class PersonSerializer implements JsonSerializer<Person> { @Override public JsonElement serialize(Person person, Type typeOfSrc, JsonSerializationContext context) { JsonObject jsonObject = new JsonObject(); jsonObject.addProperty("name", person.getName()); if (person.getFriend() != null) { JsonObject friendObject = new JsonObject(); friendObject.addProperty("name", person.getFriend().getName()); jsonObject.add("friend", friendObject); } return jsonObject; } } class PersonDeserializer implements JsonDeserializer<Person> { @Override public Person deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { JsonObject jsonObject = json.getAsJsonObject(); Person person = new Person(jsonObject.get("name").getAsString()); if (jsonObject.has("friend")) { JsonObject friendObject = jsonObject.get("friend").getAsJsonObject(); Person friend = new Person(friendObject.get("name").getAsString()); person.setFriend(friend); } return person; } } public class Main { public static void main(String[] args) { Person john = new Person("John"); Person jane = new Person("Jane"); john.setFriend(jane); jane.setFriend(john); // Circular reference Gson gson = new GsonBuilder() .registerTypeAdapter(Person.class, new PersonSerializer()) .registerTypeAdapter(Person.class, new PersonDeserializer()) .create(); String json = gson.toJson(john); System.out.println(json); Person deserializedJohn = gson.fromJson(json, Person.class); System.out.println(deserializedJohn.getName()); System.out.println(deserializedJohn.getFriend().getName()); } } /* {"name":"John","friend":{"name":"Jane"}} John Jane */ 例1 class User { String name; int age; User(String name, int age) { this.name = name; this.age = age; } } public class Main { public static void main(String[] args) { User user = new User("Alice", 30); Gson gson = new Gson(); String json = gson.toJson(user); System.out.println(json);//{"name":"Alice","age":30} User _user = gson.fromJson(json, User.class); System.out.println("Name: " + _user.name); System.out.println("Age: " + _user.age); } } 例2 class Animal { private String className; //getter,setter } class Cat extends Animal { private int age; public Cat(int age) { this.age = age; } //getter,setter,toString } class Dog extends Animal { private String color; public Dog(String color) { this.color = color; } //getter,setter,toString } class AnimalDeserializer implements JsonDeserializer<Animal> { @Override public Animal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { JsonObject jsonObject = json.getAsJsonObject(); String className = jsonObject.get("className").getAsString(); switch (className) { case "Cat": return context.deserialize(jsonObject, Cat.class); case "Dog": return context.deserialize(jsonObject, Dog.class); default: throw new JsonParseException("Unknown element type: " + className); } } } public class Main { private static Map<String, List<? extends Animal>> createAnimalMap() { List<Animal> cats = new ArrayList<>(); Cat c1 = new Cat(3); Cat c2 = new Cat(5); c1.setClassName("Cat");//设置类型字段用于区分 c2.setClassName("Cat"); cats.add(c1); cats.add(c2); List<Animal> dogs = new ArrayList<>(); Dog d1 = new Dog("yellow"); Dog d2 = new Dog("gray"); d1.setClassName("Dog"); d2.setClassName("Dog"); dogs.add(d1); dogs.add(d2); Map<String, List<? extends Animal>> animalMap = new HashMap<>(); animalMap.put("cats", cats); animalMap.put("dogs", dogs); return animalMap; } public static void main(String[] args) { Map<String, List<? extends Animal>> animalMap = createAnimalMap(); Gson gson = new GsonBuilder() //AnimalDeserializer 将根据 className 字段正确地将 JSON 反序列化为 Cat 或 Dog 对象。 .registerTypeAdapter(Animal.class, new AnimalDeserializer()) .setPrettyPrinting() .create(); String json = gson.toJson(animalMap); System.out.println(json); TypeToken<Map<String, List<Animal>>> typeToken = new TypeToken<Map<String, List<Animal>>>() {}; Type mapType = typeToken.getType(); Map<String, List<Animal>> map = gson.fromJson(json, mapType); List<Animal> cats = map.get("cats"); for (Animal cat : cats) { if (cat instanceof Cat) { System.out.println(cat); } } List<Animal> dogs = map.get("dogs"); for (Animal dog : dogs) { if (dog instanceof Dog) { System.out.println(dog); } } } } Jackson Spring Framework 默认使用 Jackson 作为 JSON 数据的序列化和反序列化工具 <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.13.4.1</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-core</artifactId> <version>2.13.3</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-annotations</artifactId> <version>2.13.3</version> </dependency> //注解在类上 // NON_NULL表示在序列化时忽略值为 null 的字段 // NON_EMPTY在序列化时忽略空集合、空数组、空 Map 等字段 // NON_DEFAULT,假设默认情况下，age 字段的默认值为 0，active 字段的默认值为 false。如果现在创建一个 Person 对象并将 age 设置为 0，active 设置为 false，则在序列化时，这两个字段将被忽略，因为它们的值与默认值相同 //@JsonInclude(JsonInclude.Include.NON_NULL) class Person { @JsonProperty("full_name") private String name; //JsonFormat.Shape.STRING：将日期格式化为字符串 //JsonFormat.Shape.NUMBER将日期格式化为时间戳（毫秒数） //JsonFormat.Shape.ARRAY格式为 [year, month, day, hour, minute, second, millisecond] //JsonFormat.Shape.OBJECT对象的格式为 {year: 2022, month: 6, dayOfMonth: 25, hourOfDay: 15, minuteOfHour: 30, secondOfMinute: 0, nanoOfSecond: 0} //JsonFormat.Shape.BOOLEAN：将日期格式化为布尔值。该格式通常用于表示日期是否存在，而不是实际的日期值 @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd", timezone ="GMT+8") private Date birthday; private transient String x; @JsonIgnore //忽略字段 private String y="y"; private String z;//null值也会序列化 //可以在类级别和字段级别都使用 @JsonInclude(JsonInclude.Include.NON_NULL) 注解，它们的效果会叠加。 //换句话说，如果类级别和字段级别都指定了 @JsonInclude(JsonInclude.Include.NON_NULL)，那么字段为 null 时仍会包含在输出的 JSON 中 @JsonInclude(JsonInclude.Include.NON_NULL) private int w; @JsonSerialize(using = CustomDateSerializer.class) @JsonDeserialize(using = CustomDateDeserializer.class) private Date birthday2; //必须提供无参和getset public Person() { // 无参构造函数 } public Person(String name, Date birthday) { this.name = name; this.birthday = birthday; } public static class CustomDateSerializer extends JsonSerializer<Date> { @Override public void serialize(Date value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeString(new SimpleDateFormat("yyyy-MM-dd'T'").format(value)); } } public static class CustomDateDeserializer extends JsonDeserializer<Date> { @Override public Date deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { try { return new SimpleDateFormat("yyyy-MM-dd'T'").parse(p.getText()); } catch (ParseException e) { throw new RuntimeException(e); } } } } public class Demo { public static void main(String[] args) { try { ObjectMapper objectMapper = new ObjectMapper(); Person person = new Person("Alice", new Date()); person.setBirthday2(new Date()); String jsonString = objectMapper.writeValueAsString(person); System.out.println(jsonString); Person _person = objectMapper.readValue(jsonString, Person.class); System.out.println(_person.getName()); System.out.println(_person.getBirthday()); System.out.println(_person.getBirthday2()); } catch (Exception e) { e.printStackTrace(); } try { ObjectMapper objectMapper = new ObjectMapper(); List<Person> people = new ArrayList<>(); people.add(new Person("Alice", new Date())); people.add(new Person("Bob", new Date())); String jsonString = objectMapper.writeValueAsString(people); System.out.println(jsonString); List<Person> people2 = objectMapper.readValue(jsonString, objectMapper.getTypeFactory().constructCollectionType(List.class, Person.class)); System.out.println(people2.size()); for (Person p : people2) { System.out.println(p.getName() + ": " + p.getBirthday()); } } catch (Exception e) { e.printStackTrace(); } } } Fastjson 依赖 <dependency> <groupId>com.alibaba</groupId> <artifactId>fastjson</artifactId> <version>1.2.78</version> </dependency> class Person { //Fastjson 需要一个无参构造函数来创建对象，然后再通过反射设置字段值, 没写时报错 public Person() {} @JSONField(name = "full_name") private String name; @JSONField(format = "yyyy-MM-dd") private Date birthday; @JSONField(serialize = false) private String x; public Person(String name, Date birthday) { this.name = name; this.birthday = birthday; } //gs } public class Demo { public static void main(String[] args) { Person person = new Person("Alice", new Date()); String jsonString = JSON.toJSONString(person); System.out.println(jsonString); Person person2 = JSON.parseObject(jsonString, Person.class); System.out.println(person2.getBirthday()); // 序列化和反序列化列表 List<Person> people = new ArrayList<>(); people.add(new Person("Alice", new Date())); people.add(new Person("Bob", new Date())); String jsonString2 = JSON.toJSONString(people); System.out.println(jsonString2); List<Person> people2 = JSON.parseArray(jsonString2, Person.class); System.out.println(people2.size()); for (Person p : people2) { System.out.println(p.getName() + ": " + p.getBirthday()); } } } 自定义序列化和反序列化逻辑 SerializeFilter 和 ObjectDeserializer 接口来自定义序列化和反序列化过程中的逻辑 对于复杂类型，比如原子类例如AtomicLong属性，fastjson会按照基本类型解析，而不是对象`,``,`html`,`JSONP`,`20240521124656-_前端 JSONP（JSON with Padding）是一种跨域请求的技术，通常用于从不同域的服务器获取数据。 它利用了script元素没有跨域限制的特性来实现跨域请求,只能用于 GET 请求 它属于前端和后端共同实现的一种解决方案 jsonp和ajax比较 都是用于在客户端与服务器之间进行异步数据传输的技术 JSONP不受同源策略限制 AJAX默认遵循同源策略，除非使用CORS JSONP有一定的安全风险，因为它执行的是脚本，可能会引入恶意代码 AJAX更安全，因为它通过XMLHttpRequest或Fetch API进行请求 JSONP只能返回JavaScript代码 AJAX支持多种数据格式（JSON、XML、HTML、纯文本等） 在网页中动态创建一个script标签, 它的src属性设置为一个远程服务器的 URL, 并将回调函数的名称作为查询参数附加到 URL 末尾 远程服务器接收到请求后，解析出查询参数中的回调函数名称, 将实际的数据包装在这个回调函数中，生成一个 JavaScript 代码片段返回给客户端 浏览器下载并执行返回的 JavaScript 代码片段（因为它是通过 script 标签引入的） 由于返回的内容包含调用回调函数的代码，所以回调函数会被立即执行，数据被传入回调函数 //http://localhost:9000/data.json @WebServlet("/data.json") public class JSOPServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { String data = "{ \"name\": \"汤姆\", \"age\": 12 }"; response.setContentType("application/javascript;charset=UTF-8"); response.getWriter().write(request.getParameter("callback") + "(" + data + ")"); } } <!-- http://localhost/jsonpTest.jsp --> <%@ page contentType="text/html;charset=UTF-8" language="java" %> <html> <head> <title>Title</title> <script src="js/jquery-1.11.1.min.js"></script> <script> //常规发起jsonp请求 function fetchJSONP(url, handler) { const script = document.createElement('script'); //src的值为 http://localhost:9000/data.json?callback=handleResponse 返回的响应, 即 handleResponse(..) script.src = url + "?callback=" + handler; document.body.appendChild(script); // handleResponse(..) 被作为脚本执行 } function handleResponse(data) { console.log(data); document.getElementById("result").innerHTML=data.name + " 常规发起jsonp请求"; } //使用jquery的ajax方法发起jsonp请求 $(document).ready(function() { $('#btn2').click(function () { $.ajax({ url: 'http://localhost:9000/data.json', dataType: 'jsonp', //指定类型为jsonp, 发送的 JSONP 请求中会自动尾随一个名为 "callback" 的参数 //jsonpCallback: 'handleResponse', //指定回调函数名或者success中直接处理 success: function (data) { console.log(data); $("#result").html(data.name + " 使用jquery的ajax方法发起jsonp请求"); } }); }) }); </script> </head> <body> <button onclick="fetchJSONP('http://localhost:9000/data.json', 'handleResponse')">常规发起jsonp请求</button> <button id="btn2">使用jquery的ajax方法发起jsonp请求</button> <div id="result"></div> </body> </html>`,``,`html`,`JSP`,`20240521124656-_视图 JSP是 JSP(Java Server Pages),Java服务器页面, J2EE的功能模块, 由Servlet扩展而来, 运行时转换为Servlet JSP本质就是Servlet, 当请求一个jsp页面时, jsp引擎首先将jsp文件转译为一个Servlet类, 然后加载它并以html形式响应给浏览器 非尖括号百分部分用out.println()包裹,尖括号百分部分原封不动 <h1> <% int a = 2; a = a * 100; %> <%=a%> </h1> out.write("<h1>") int a = 2; a = a * 100 out.println(a); out.println("</h1>") JSP语法 JSP指令 提供了JSP容器所需的信息 page 指令：用于定义页面级的属性，如页面编码、错误页面等 <%@ page contentType="text/html; charset=UTF-8" language="java" %> <%@ page import="java.util.*" %> include 指令：用于在编译时包含另一个文件的内容 <%@ include file="header.jsp" %> taglib 指令：用于引用自定义标签库 <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %> JSP脚本元素 脚本元素允许在页面中嵌入Java代码 表达式（Expression）：等号, 用于输出Java表达式的结果，输出内容会自动转为字符串 <%= new java.util.Date() %> 声明（Declaration）：感叹号, 用于声明Java变量和方法 <%! int counter = 0; %> <%! public String getGreeting() { return "Hello, world!"; } %> 脚本片段（Scriptlet）：用于嵌入任意Java代码 <% counter++; out.println("Counter: " + counter); %> JSP注释 不会被发送到客户端浏览器 <%-- 这是一个JSP注释 --%> 隐式对象 九大内置对象 在jsp文件转译时直接定义好的,在jsp页面内可以直接使用的对象名 request 请求对象 - HttpServletRequest, 作用范围是一次请求-响应周期 response 响应对象 - HttpServletResponse session 用户会话 - HttpSession application 应用全局对象 - ServletContext, 整个 web 应用程序的上下文环境 out 输出对象 - PrintWriter page 当前页面对象 - this, 包含该jsp的servlet实例 pageContext 页面上下文对象 - PageContext pageContext是 JSP 中一个非常重要的隐式对象，它提供了对 JSP 页面范围内的所有对象和属性的访问 生命周期开始于 JSP 页面请求处理的开始，结束于请求处理的完成 config 应用配置对象 - ServletConfig exception 应用异常对象 - Throwable 标记 isErrorPage="true" 的页面才可以使用隐式对象 exception，这个标记告诉 JSP 容器这是一个处理异常的页面。 在Java程序中，可以使用try…catch关键字来处理异常情况，如果在JSP页面中出现没有捕获到的异常，就会生成exception对象 如果页面指定了errorPage属性, 就会转发到转发到属性指定的页面 , 此时web.xml中的配置失效 errorPage 和 isErrorPage两者配合使用 pageContext 虽然 pageContext 提供了广泛的功能和访问权限，但它和 request、session、application 等对象有着不同的作用和使用场景 获取和设置属性, 可以用于在不同范围（页面、请求、会话、应用程序）内存储和检索属性 <%-- 设置页面范围内的属性(这些属性并不等同于request中的属性) --%> pageContext.setAttribute("pageAttribute", "value"); <%-- 获取页面范围内的属性 --%> String value = (String) pageContext.getAttribute("pageAttribute"); 访问其他隐式对象 HttpServletRequest request = (HttpServletRequest) pageContext.getRequest(); HttpServletResponse response = (HttpServletResponse) pageContext.getResponse(); HttpSession session = pageContext.getSession(); ServletContext application = pageContext.getServletContext(); 转发和包含 <%-- 请求转发 --%> pageContext.forward("otherPage.jsp"); <%-- 包含其他资源 --%> pageContext.include("header.jsp"); 获取页面相关信息 ServletConfig config = pageContext.getServletConfig(); ServletContext context = pageContext.getServletContext(); 错误处理 Exception exception = pageContext.getException(); if (exception != null) { // 处理异常 } exception err.jsp <%@ page contentType="text/html;charset=utf-8" isErrorPage="true" %> <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Error Page</title> <style> body { font-family: Arial, sans-serif; margin: 50px; } .error-details { color: red; } </style> </head> <body> <h1>服务器内部错误</h1> <p>抱歉，服务器遇到了内部错误。请稍后再试。</p> <% if (exception != null) { out.println("<p class=\"error-details\">" + exception.getClass().getSimpleName() + ": " + exception.getMessage() + "</p>"); } %> </body> </html> err-maker.jsp <%@ page contentType="text/html;charset=utf-8" errorPage="err.jsp" %> <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Generate Error</title> </head> <body> <h1>触发异常</h1> <% int result = 1 / 0; %> </body> </html> 20240702200151.webp JSP动作元素 jsp:include：在请求处理时包含另一个资源的内容 <jsp:include page="header.jsp" /> jsp:forward：将请求转发到另一个资源 <jsp:forward page="anotherPage.jsp" /> jsp:param：用于传递参数。 <jsp:include page="header.jsp"> <jsp:param name="username" value="JohnDoe" /> </jsp:include> include 页面重用 <!-- index.jsp --> <%@ page contentType="text/html;charset=UTF-8" language="java" %> <hr>copyright 2024 <!-- header.jsp --> <%@ page contentType="text/html;charset=UTF-8" language="java" %> 图片 | 视频 | 文本 <!-- footer.jsp --> <%@ page contentType="text/html;charset=UTF-8" language="java" %> <hr>copyright 2024 20240825181231.webp forward, param <!-- main.jsp --> <jsp:forward page="forwarded.jsp"> <jsp:param name="username" value="JohnDoe" /> <jsp:param name="age" value="30" /> </jsp:forward> <!-- forwarded.jsp --> <% String username = request.getParameter("username"); String age = request.getParameter("age"); %> <p>Username: <%= username %></p> <p>Age: <%= age %></p> EL 表达式语言（EL，Expression Language）是一种在Java EE中的JSP（JavaServer Pages）和JSF（JavaServer Faces）中内置的表达式语言。 EL提供了一种简洁的语法来访问Java对象和操作数据，避免了在JSP页面中直接使用Java代码，从而提高了代码的可读性和可维护性 MyBatis中使用类似EL的OGNL表达式来构建动态SQL语句 在JSP页面中要显示字符串&#36;{，则必须写成&#36;{'&#36;{'} 访问JavaBean属性 &#36;{user.name}相当于调用user.getName() 访问集合中的元素 &#36;{map.key}相当于map.get("key") &#36;{list[0]}相当于list.get(0) &#36;{array[0]} 访问隐式对象 &#36;{session.user}, pageContext,request,application &#36;{param.c} 是直接从 HTTP 请求参数中获取名为 c 的参数值。 &#36;{requestScope.param.c} 是从请求作用域中获取名为 param 的属性，然后访问这个属性中的 c 值。 20240705130652.webp 调用方法(EL 3.0中，支持调用方法) &#36;{user.getName} 当你访问对象的属性时，不需要带括号。EL 会自动调用相应的 getter 方法。 &#36;{user.fullName} 实际上调用 user.getFullName() 当你明确要调用一个无参数的方法时，可以带上括号，以明确表达这是一个方法调用。 &#36;{myBean.sayHello()} 调用 myBean.sayHello() 方法 算术运算和逻辑运算 &#36;{1 + 1} // 结果是2 &#36;{3 > 2} // 结果是true &#36;{not empty list} // 判断list是否为空, 返回的值是一个布尔值 常用运算符 算术运算符： +, -, *, /, % 比较运算符： ==, !=, <, >, <=, >= 逻辑运算符： &&（与）, ||（或）, !（非） 条件运算符： ? :（三元运算符） 其他： empty（用于判断空） 内置的四种作用域对象 忽略书写作用域对象时,el则按照作用域从小到大依次尝试获取,没有则返回空字符串而非null 作用域从小到大依次为pageScope, requestScope, sessionScope, applicationScope , <!-- pageScope 数据在这个作用域中只在当前JSP页面内有效，不会在页面之间共享--> <% pageContext.setAttribute("pageVar", "This is a page scope variable"); %> <p>Page Scope Variable: &#36;{pageScope.pageVar}</p> <!-- requestScope 数据在这个作用域中会在整个请求过程中有效，包括请求转发的目标页面--> <% request.setAttribute("requestVar", "This is a request scope variable"); %> <p>Request Scope Variable: &#36;{requestScope.requestVar}</p> <!-- sessionScope 数据在这个作用域中会在整个会话过程中有效，直到会话结束或数据被显式移除--> <% session.setAttribute("sessionVar", "This is a session scope variable"); %> <p>Session Scope Variable: &#36;{sessionScope.sessionVar}</p> <!-- applicationScope 数据在这个作用域中会在整个应用程序的生命周期内有效，直到应用程序停止或数据被显式移除--> <% application.setAttribute("appVar", "This is an application scope variable"); %> <p>Application Scope Variable: &#36;{applicationScope.appVar}</p> JSTL JavaServer Pages Standard Tag Library JSTL是一组标准标签库，用于简化JSP页面中的常见任务 依赖 <dependency> <groupId>javax.servlet</groupId> <artifactId>jstl</artifactId> <version>1.2</version> </dependency> 导入JSTL核心标签库 <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %> 设置变量 <c:set var="variableName" value="expression" scope="scope" />scope默认为page <c:set var="myVar" value="Hello, World!" /> 使用EL表达式输出变量值 &#36;{myVar} 使用EL表达式设置变量 <c:set var="userName" value="&#36;{user.name}" /> Hello, &#36;{userName}! c:out 标签：用于输出表达式的值, default escapeXml <c:out value="&#36;{username}" /> c:if 标签：用于条件判断。 <c:if test="&#36;{user != null}"> Welcome, &#36;{user.name}! </c:if> c:forEach 标签：用于循环遍历集合。 <c:forEach var="item" items="&#36;{itemList}"> <c:out value="&#36;{item}" /> </c:forEach> <c:forEach var="emp" items="&#36;{employees}" varStatus="i"> <tr> <td>&#36;{i.index+1}</td> <td>&#36;{emp.id}</td> <td>&#36;{emp.name}</td> <td> <c:forEach var="item" items="&#36;{emp.skills}" varStatus="status"> &#36;{item}<c:if test="&#36;{!status.last}">, </c:if> </c:forEach> </td> <td>&#36;{emp.department}</td> <td><fmt:formatNumber value="&#36;{emp.commission}" pattern="￥0,000.00"/></td> </tr> </c:forEach> c:choose when test otherwise @WebServlet("/page27") public class JstlTest extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setAttribute("score","50"); req.setAttribute("star","B+"); List<SearchEngine> list = new ArrayList<>(); list.add(new SearchEngine("谷歌","google")); list.add(new SearchEngine("鸭鸭go","duckduckgo")); req.setAttribute("engines",list); req.getRequestDispatcher("/desktop/jstl-test.jsp").forward(req,resp); } } <%@ page contentType="text/html;charset=UTF-8" language="java" %> <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> <html> <head> <title>Title</title> </head> <body> <c:if test="&#36;{score>60}"> <h1>greater then 10</h1> </c:if> <c:if test="&#36;{score<=60}"> <h1>less then or equals 60</h1> </c:if> <c:choose> <c:when test="&#36;{star=='A+'}"> <h1>good</h1> </c:when> <c:when test="&#36;{star=='B+'}"> <h1>ok</h1> </c:when> <c:otherwise> <h1>bad</h1> </c:otherwise> </c:choose> <c:forEach items="&#36;{requestScope.engines}" var="item" varStatus="i"> <h1>&#36;{i.index+1}: &#36;{item.name}-&#36;{item.url}</h1> </c:forEach> </body> </html> fmt 格式化标签 <%@ page contentType="text/html;charset=UTF-8" language="java" %> <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> <%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %> <html> <head> <title>Title</title> </head> <body> <% request.setAttribute("now",new java.util.Date()); request.setAttribute("cost","123456.789"); request.setAttribute("uncertain",null); request.setAttribute("html_code","<a href='#'>link</a>"); %> <p> &#36;{now}<br> <fmt:formatDate value="&#36;{now}" pattern="yyyy/MM/dd HH:mm:ss"/> </p> <p> &#36;{cost}<br> <fmt:formatNumber value="&#36;{cost}" pattern="$0,000.00"/> </p> <p> &#36;{uncertain}<br> <!--如果value为null,则采用default值--> <c:out value="&#36;{uncertain}" default="无"/> </p> <p> &#36;{html_code}<br> <!--显示源码--> <c:out value="&#36;{html_code}" escapeXml="true"/> </p> </body> </html> EL,JSTL,OGNL,Struts EL (Expression Language) 用于在 JSP（JavaServer Pages）页面中简化数据访问和操作的语言。它使得 JSP 页面更简洁和可读。 特点 语法简洁: 使用 &#36;{} 语法来访问和操作对象属性。 易于集成: 与 JSP 和 JSTL 无缝集成。 数据访问: 能够访问 JSP 范围（page, request, session, application）内的属性和对象。 JSTL (JavaServer Pages Standard Tag Library) 提供了一组标准标签库，用于在 JSP 页面中执行常见任务，如条件判断、循环、国际化、XML 处理等 特点 标签库: 包含核心标签库、格式化标签库、SQL 标签库、XML 标签库和函数标签库。 简化 JSP 开发: 通过标签简化 JSP 页面中的 Java 代码。 国际化支持: 提供国际化和格式化功能。 OGNL (Object-Graph Navigation Language) 一种用于访问和操作 Java 对象图的表达式语言，广泛用于 Struts2 框架中 特点 强大的表达式语言: 能够执行复杂的对象图导航和操作。 与 Struts2 集成: 作为 Struts2 的默认表达式语言，支持表单数据绑定和表单验证。 功能丰富: 支持条件判断、集合操作、方法调用等。 Struts Struts 是一个用于开发基于 MVC（Model-View-Controller）架构的 Java Web 应用程序的框架, 提供标签库和配置驱动的开发模式 特点 MVC 架构: 清晰分离模型、视图和控制器，促进代码组织和维护。 配置驱动: 使用 XML 配置文件（struts-config.xml）来定义动作映射、表单 Bean 和视图。 丰富的标签库: 提供标签库来简化 JSP 页面中的表单处理和国际化支持 Struts 和 Struts 2 是两个不同版本的 Java Web 应用框架，虽然它们有共同的目标，即简化基于 MVC（Model-View-Controller）架构的 Web 应用开发，但它们在架构、特性和使用方式上有显著的不同。 例 表单录入与动态显示 @WebServlet("/page28") public class EmployeeServlet extends HttpServlet { @SuppressWarnings("unchecked") @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = getServletContext(); if (context.getAttribute("employees") == null) { List<Employee> list = new ArrayList<>(); context.setAttribute("employees",list); } String id = req.getParameter("empno"); String name = req.getParameter("ename"); String[] skills = req.getParameterValues("skills"); String department = req.getParameter("dept"); String commission = req.getParameter("comm"); Employee employee = new Employee(Integer.parseInt(id),name,department,Float.parseFloat(commission)); employee.setSkills(skills); List<Employee> employees = (List<Employee>) context.getAttribute("employees"); employees.add(employee); context.setAttribute("employees",employees); req.getRequestDispatcher("/desktop/employee.jsp").forward(req,resp); } } <%@ page contentType="text/html;charset=UTF-8" language="java" %> <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> <%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %> <html> <head> <title>Title</title> <style> table { border-collapse: collapse; } table, th, td { padding: 5px; border: 1px solid; } </style> </head> <body> <form action="/page28" method="post"> <input type="text" name="empno" placeholder="请输入编号"> <input type="text" name="ename" placeholder="请输入姓名"> <input type="checkbox" name="skills" value="java">java <input type="checkbox" name="skills" value="c">c <input type="checkbox" name="skills" value="c++">c++ <select name="dept"> <option selected="selected">请选择部门</option> <option value="市场部">市场部</option> <option value="研发部">研发部</option> <option value="后勤部">后勤部</option> </select> <input type="text" name="comm" placeholder="请输入佣金"> <button type="submit">保存</button> </form> <table> <thead> <tr> <th>序号</th> <th>员工编号</th> <th>姓名</th> <th>技能</th> <th>部门</th> <th>佣金</th> </tr> </thead> <tbody> <c:forEach var="emp" items="&#36;{employees}" varStatus="i"> <tr> <td>&#36;{i.index+1}</td> <td>&#36;{emp.id}</td> <td>&#36;{emp.name}</td> <td> <c:forEach var="item" items="&#36;{emp.skills}" varStatus="status"> &#36;{item}<c:if test="&#36;{!status.last}">, </c:if> </c:forEach> </td> <td>&#36;{emp.department}</td> <td><fmt:formatNumber value="&#36;{emp.commission}" pattern="￥0,000.00"/></td> </tr> </c:forEach> </tbody> </table> </body> </html> 20240703115802.webp`,``,`html`,`Linux`,`20240428165642-_环境容器 操作系统(Operating System)是应用程序运行的基础支撑环境 操作系统的作用是管理和控制计算机系统的硬件与软件资源 Intel x86架构上常见的操作系统:Windos,Linux,Unix(Mac OS基于此开发).. Linux是目前最主要的服务器端操作系统 发行版 Linux系统内核(kernel)提供了Linux操作系统的核心功能 不同开发商在内核基础上扩展封装, 形成了不同的发行版本 桌面系统 Ubuntu (可替代windows) 服务器系统 CentOS 社区 Community Enterprise Operating System 基于Red Hat Enterprise Linux的开源企业级Linux发行版本 各版本CentOS都会获得十年的支持,与RHEL保持同步更新 CentOS采用社区支持,bug修复会及时更新到RHEL, 两者互利 Red Hat Enterprise Linux 商业(技术支持) 特定需求 Debian 稳定 Fedora 新特性 麒麟Linux 中国版 centos桌面版登录时选择未列出,以最高级的帐号登录 目录结构 "/"是所有目录的顶点也即根目录 与windows相比没有盘符的概念, 不同目录下的数据可分布在不同磁盘,所有目录按规则组织与命名 /:根目录，所有文件和目录的起点。 /bin:二进制可执行文件，常用的用户命令（如 ls、cp、mv 等）存放在这里。 /boot:启动引导程序文件，包括内核、初始 RAM 磁盘映像等启动时需要的文件。 /dev:设备文件，表示系统中的硬件设备。 /etc:配置文件和脚本。 /home:用户主目录，每个用户都有一个对应的子目录。 /lib:系统库文件，包含内核和系统程序使用的共享库。 /media:可移动媒体设备挂载点（如 CD-ROM、USB 驱动器）。 /mnt:临时文件系统挂载点。 /opt:可选的应用程序包。 /proc:虚拟文件系统，提供系统进程和内核状态的信息。 /root:根用户的主目录。 /run:临时文件系统，存储系统运行时的数据。 /sbin:系统二进制文件，包含系统管理员使用的命令（如 fsck、reboot 等）。 /srv:服务数据目录，存放特定服务的数据（如 HTTP 服务器的网页数据）。 /sys:虚拟文件系统，包含设备和内核信息。 /tmp:临时文件目录，系统启动时清空。 /usr:用户程序和数据，包含更高层次的系统文件和目录。 /usr/bin:大多数用户级命令。 /usr/lib:用户级库文件。 /usr/sbin:非系统管理员使用的系统二进制文件。 /usr/share:共享数据，如文档、配置文件样本。 /var:可变数据文件，如日志、邮件、临时文件等。 /var/log:日志文件目录。 /var/tmp:临时文件目录，系统重启后不清空。 安装centos7 vmware创建空白磁盘,配置硬件和iso路径 打开以太网接口(ens前缀),命名主机,最小型安装 设置root密码 无法解析镜像源 DNS 地址 vi /etc/yum.repos.d/CentOS-Base.repo base,updates,extras 注释mirrorlist,启用baseurl,并改为..vault.centos.org.. vi /etc/resolv.conf 清理 YUM 缓存并重新生成缓存 yum clean all yum makecache 添加Google 的公共 DNS 服务器 nameserver 8.8.8.8 nameserver 8.8.4.4 SSH客户端 idc机房 SSH（Secure Shell）是专为远程登录和其它网络服务提供的安全性协议 SSH分为两个不兼容版本1.x与2.x 基于SSH远程连接工具有很多,最常见的是Xshell与SecureCRT Xshell是Linux客户端,常用于在Windows下远程访问 Xftp是Xshell配套组件,用于向服务器上传/下载文件 文件操作 #清屏 clear #linux下任何询问以y或n答复 #返回上级目录 cd .. cd ../../ #当前位置 pwd #列出当前目录内容, ls仅文件名, ll包含文件详情 ls #也可以列出指定目录下的内容 ls /boot #tab补全文件名 #不唯一时, 例如目录下存在lib,lib64,libexec, 输入lib按两次tab则列出所有以lib开头的目录或文件 #命令帮助 mkdir --help #单级目录 #mkdir ./test mkdir test #多级目录, p多级v提示 #mkdir -p -v test/demo/oa mkdir -pv test/demo/oa #复制文件 cp test.txt test #复制整个文件夹 cp -r test demo #当目标文件已存在时，mv 命令默认会覆盖目标文件。使用 -i 选项可以在覆盖前进行提示, -f强制模式不进行提示 # mv 命令不会在源和目标位置相同时移动文件 #移动 mv file.txt /home/user/documents/ mv file1.txt file2.txt file3.txt /home/user/documents/ mv /home/user/old_directory /home/user/new_directory/ #重命名 mv oldname.txt newname.txt mv /home/user/old_directory /home/user/new_directory #移动并重命名文件 mv file.txt /home/user/documents/newfile.txt #删除,r迭代删除目录及内容,f不询问 rm test.txt rm -r test #查找, -type f文件d目录, -o或, -mtime天, immin分, +-大于小于 find /home/user -name file.txt find /home/user -name "*.txt" find /home/user -type f -name "*.txt" -size +100k find /home/user \( -name "*.txt" -o -name "*.log" \) find /home/user -mtime -7 find /home/user -mmin -60 #找到后删除, {} 是一个占位符，表示当前找到的文件名，而 \; 则标志着 -exec 命令的结束 find /home/user -name "*.log" -exec rm -f {} \; #找到后移动 find /home/user -name "*.txt" -exec mv {} /home/user/documents/ \; # .当前目录下 find . -type d -name "*ttt" -exec rm -rf {} \; 文本操作 vi是Linux重要的文字编辑工具,vim是它的增强版,vim用于在远程环境下用命令形式对文本进行在线编辑 vim三种模式 普通模式 默认,只读 编辑模式 普通模式下按 i 键进入, esc 退出 命令模式 (只能在普通模式下使用) 执行保存,搜索,退出等操作 20240422203158.webp 20240725190030.webp #输出到屏幕, 反斜杠转义,或单引包裹 echo 'hello"' echo "hello\"" #输出到文件 #覆盖 echo "hello" > hello.txt #追加 echo "hello" >> hello.txt echo "ok\\\" " >> hello.txt #合并日志 echo "hello" > hello.txt echo "my name is Lily" > name.txt cat hello.txt name.txt >> greeting.txt #查看文件, 相比vim不用进入命令模式和退出模式, 更简单, n显示行号,E显示换行符(用$表示)用于区分出空格 cat -n greeting.txt #在控制台上写文件, 新增或覆盖(>),追加(>>) #向greeting.txt追加内容,以EOF作为结束标志 cat >> test.txt << EOF hi, Lily i love u .. EOF cat -nE greeting.txt #查看文件倒数两行的内容,查看最近产生的错误日志 tail -n 2 test.txt #监控文件变化实时输出到控制台上(复制会话,向test中追加内容,在原会话中可以看到变化),ctrl+c退出监控 tail -f test.txt #筛选文本行, -v排除 #筛选出包含h[任意一个字符]t的文本行,输出到控制台 grep h.t test.txt #筛选出不包含h[任意一个字符]t的文本行,输出到out.txt grep -v h.t test.txt > out.txt #将ll的结果作为源,筛选出符合正则的文件列表,-E开启可扩展的正则表达式 ll | grep log1.txt ll | grep -E "log[0-5]{1,}.txt" 解压缩 gzip是Linux系统的压缩程序,压缩后扩展名.gz tar是打包软件,将多个文件打包为一个文件,并不提供数据压缩,扩展名.tar 两者配合生成.tar.gz文件 #将/usr/local/tomcat目录进行压缩并命名为tomcat.tar.gz tar zcvf tomcat.tar.gz /usr/local/tomcat #将tomcat.tar.gz解压到/usr/local/tomcat, 如果去掉-C及后面的内容则默认解压到当前目录 tar zxvf tomcat.tar.gz -C /usr/local/tomcat 20240422213909.webp yum安装 在centos中安装第三方应用程序包有两种方式, 一种是yum,一种是编译安装 两者生成的应用存放地点是不一样的 yum会自动在usr/bin下生成对应的应用程序 编译安装只能在当前编译目录中生成应用程序 20240423090513.webp rpm, 红帽软件包管理器,相当于应用程序安装文件的执行者 yum是rpm的前端程序,目的是简化rpm的安装过程,通过引入软件仓库,联网下载rpm包及依赖,并依次自动安装, 类似于maven依赖 只适合红帽的产品且不同环境对应不同的版本 如果你的系统是64位的，并且没有32位的兼容性要求，那么通常情况下，应用程序名中的.x86_64可以省略 如果系统上只有一种架构的可执行文件（例如所有软件都是64位的），那么可以省略架构信息，因为没有其他可能的选择 #在仓库中查询是否存在指定应用, 应用名可通配 yum search tree #全自动下载安装应用及其依赖,遇到询问自动y yum install -y tree.x86_64 #查看应用详细信息 yum info tree #查看应用的安装位置 which tree #查看已安装的应用程序 #全部列出 yum list installed #筛选 yum list installed *tree* #查看安装后输出的文件清单 rpm -ql tree #卸载指定应用,遇到询问自动y yum remove -y tree.x86_64 从仓库安装和本地安装 方式一：通过 YUM 仓库安装 优点： 自动依赖管理：YUM 仓库会自动解决软件包的依赖关系，确保所有依赖包都能正确安装。 安全性：使用 GPG 密钥签名验证包的来源和完整性，防止恶意软件包。 简便性：安装命令简单，yum install package-name即可，适合日常维护和更新。 版本控制：YUM 仓库会提供经过测试的包版本，减少不兼容和错误的风险。 缺点： 依赖网络连接：需要访问远程仓库，如果网络连接不好或仓库配置有问题，安装可能失败。 仓库维护：需要正确配置仓库地址和 GPG 密钥，有时会遇到配置错误或过期的密钥。 仓库更新：如果仓库更新不及时，可能无法获得最新版本的软件包。 # 1. 配置仓库 vim /etc/yum.repos.d/rabbitmq_erlang.repo [rabbitmq-erlang] name=rabbitmq-erlang baseurl=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/rpm/el/7/x86_64/ gpgcheck=1 gpgkey=https://dl.cloudsmith.io/rabbitmq/rabbitmq-release-signing-key.asc enabled=1 # 2. 清除和重新生成 YUM 缓存 yum clean all yum makecache # 3. 安装包 yum install erlang 方式二：下载 RPM 包并本地安装 优点： 灵活性：可以从任何可用的来源下载特定版本的 RPM 包，适合特殊需求或解决仓库配置问题。 绕过仓库配置问题：不依赖于远程仓库的配置，避免了仓库地址或 GPG 密钥配置错误导致的问题。 本地安装：适用于离线环境，下载后可以在多个机器上重复使用。 缺点： 依赖管理复杂：需要手动处理依赖关系，可能需要下载和安装多个依赖包。 安全性降低：没有自动的 GPG 密钥验证，需手动确认包的来源和完整性，增加了安全风险。 不便于更新：本地安装的包需要手动更新，不能自动从仓库获取最新版本。 # 1. 下载 RPM 包 curl -L -O -J "https://github.com/rabbitmq/erlang-rpm/releases/download/v23.3.4.18/erlang-23.3.4.18-1.el7.x86_64.rpm" # 2. 本地安装 RPM 包 # Erlang 是直接安装的软件包。当你下载并使用 yum localinstall 命令安装该 RPM 包时，实际的软件包内容会立即被解压和安装到系统中, 包含完整的应用程序及其依赖项 yum localinstall erlang-23.3.4.18-1.el7.x86_64.rpm 编译安装 编译安装, 用户自己从网站下载程序源码解压进行编译安装 兼容性好, 但是在安装过程中需要用户自己解决依赖问题 如果yum仓库未提供rpm,则通常采用编译安装,在源文件解压目录下执行make make只是调用第三方编译程序完成对代码的编译工作 # gcc是c语言源代码的编译工具包 yum install -y gcc 首次编译安装时提示未安装gcc,安装gcc后编译安装报错,因为前次安装失败有残留,需要删除解压后的源目录重新解压执行make 系统管理 #查看网卡ip ifconfig #查看网络端口号 netstat -tulpn netstat -ano netstat -tulpn | grep ssh 20240423104518.webp #显示包含单机程序在内的所有进程信息, 可以配合grep筛选, ps -ef | grep redis ps -ef #强制结束PID为41139的进程, 通常情况下建议使用程序自带的退出命令 kill -9 41139 应用服务化 20240423110231.webp #查找pid文件 find / -name *.pid #查看其当前占用的端口(和ps -ef | grep redis 端口结果一致) cat /run/redis_6379.pid #服务描述文件.sevice存放地址 cd /usr/lib/systemd/system #新建redis.service服务 cat > redis.service <<EOF [Unit] Description=Redis #服务的描述信息 After=syslog.target network.target remote-fs.target nss-lookup.target #在这些服务启动之后再启动该服务 [Service] Type=forking #后台运行 PIDFile=/run/redis_6379.pid #进程的pid文件 ExecStart=/usr/local/redis-4.0.14/src/redis-server /usr/local/redis-4.0.14/redis.conf #服务启动时使用的命令 ExecStop=/bin/kill -s QUIT $MAINPID #服务结束时的命令, $MAINPID是变量存放PIDFile中变化的进程id, -s QUIT按正常流程通知指定进程进行关闭,-9是对进程进行强制结束 PrivateTmp=ture #为该服务设置私有的临时文件目录 [Install] WantedBy=multi-user.target #将该服务分配到multi-user.target服务组上, multi-user中的服务被允许随系统启动而自动启动 #使新增的service生效 systemctl daemon-reload #对所有service配置文件进行重载 #启动服务 systemctl start redis #查看服务状态 systemctl status redis #当修改了配置文件时对服务进行重新启动,相当先停止然后启动 systemctl restart redis #停止服务 systemctl stop redis #让redis随系统启动 systemctl enable redis #立即重启 shutdown -r now #取消随系统自动启动 systemctl disable redis #查看系统有哪些服务及其状态, static随其它服务的关联而启动,enabled随系统启动,disabled不随系统启动 systemctl list-unit-files #查看哪些服务是自启动的 systemctl list-unit-files | grep enabled 用户及用户组 一个用户可隶属于多个组, 同一时间只能有一个组作为当前组 每个用户都有一个主要组和可以属于多个附加组 主要组（Primary Group） 每个用户都有一个主要组，它是用户的默认组。主要组在用户创建时指定，通常是用户的用户名作为组名 当用户创建文件时，文件的默认组所有权是用户的主要组。主要组在用户操作文件时影响文件的组权限。 附加组（Supplementary Groups） 附加组是用户可以加入的其他组。用户可以属于多个附加组，每个附加组提供额外的访问权限或文件权限 #新建用户 useradd d1 #修改密码 passwd d1 #创建新组 groupadd dev #更改用户的主要组 usermod -g dev d1 #查看自己所属于组 groups #查看某用户所属组 groups d1 #更改用户的附加组列表。此命令会覆盖用户的现有附加组列表, 所以要把原有附加组带上 usermod -G tes d1 #d1需要重新连接才能拥有新用户组权限 # groups # dev tes #第一个组为当前用户组,如果要访问tes用户组的资源则需要切换 newgrp tes groups # tes dev #当删除一个用户后，用户拥有的其他文件和目录将保留其原有的所有权，除非手动修改。文件和目录的所有者将显示为已删除的用户的 UID（用户 ID），而不是用户名 #删除用户, -r 选项将删除用户及其主目录和邮件池文件 userdel -r d1 #查找用户主目录 find / -type d -name d1 #在删除用户后，可以使用 find 命令查找系统中与该用户有关的所有文件，以确保没有遗漏的残留文件 #查找系统中与 UID 相关的文件 find / -user [UID] #检查 /etc/passwd 和 /etc/group 文件，确认用户是否已被完全删除 grep 'd1' /etc/passwd grep 'd1' /etc/group #如果你将用户的主要组更改为其他组（而不是用户的用户名组），那么在删除用户时，主要组不会被删除用户组删除，除非手动删除(确保系统的整洁和一致性) #只能删除没有任何成员的组。如果组中仍有用户，你需要先将这些用户从组中移除 groupdel d1 #查看创建的所有用户组 cat /etc/group #从用户组中移除用户,无法将用户从自己的默认组中移除 gpasswd -d d1 tes #也可以通过重新设置附加组的方式 usermod -G dev d1 #在Linux系统中，即使是root账户也无法直接查看其他用户的密码明文 # 列出所有用户及其主组 awk -F: '{ print $1 " - " $4 }' /etc/passwd | while IFS=" -" read -r username gid; do groupname=$(getent group "$gid" | cut -d: -f1) echo "$username - $groupname" done # 列出所有用户及其主组和附加组 awk -F: '{ print $1 " - " $4 }' /etc/passwd | while IFS=" -" read -r username gid; do primary_group=$(getent group "$gid" | cut -d: -f1) additional_groups=$(id -Gn "$username") echo "$username - Primary Group: $primary_group, Additional Groups: $additional_groups" done 文件权限 20240726142709.webp 第一位d表示目录-表示文件,其它位-无权限 三个数字相加后的值 7,rwx 5,r-x 0,--- 对于文件名的修改，实际上是对文件所在目录的操作，而不是对文件本身的操作。因此，要修改文件名，需要对包含该文件的目录拥有相应的权限 删除文件的操作是对包含该文件的目录的操作，而不是对文件本身的操作 对文件内容的修改权限由文件自身的权限控制 例如A文件夹为777, 它里面有一个文件b权限为000, 无法修改文件内容, 但能够修改文件b的文件名和删除文件b 目录权限 r-x 只允许查看目录内容和进入目录，但不允许对目录内容进行任何修改，包括创建、删除或重命名文件或子目录 对于文件 读	r	可以查看文件内容。 写	w	可以修改文件内容。 执行	x	可以执行文件（如果文件是可执行的脚本或程序, 否则可以-）。 对于目录 读	r	可以列出目录中的文件和子目录。 写	w	可以在目录中创建、删除和重命名文件或子目录。 执行	x	可以进入目录并访问其内容（包括读取和执行文件）。 cd /usr/local/share mkdir dev_folder #改变文件所有者 chown d1:dev dev_folder #改变文件权限 chmod 750 dev_folder #drwxr-x---. 2 d1 dev 6 4月 23 16:31 dev_folder 超级管理员权限 #系统管理员交他人代管时不用交出密码 #执行visudo visudo #普通模式下100gg定位到 ## Allow root to run any commands anywhere root ALL=(ALL) ALL #普通模式下光标处按o向下插入新行同时进入编辑状态 d1 ALL=(ALL) ALL #第1个all表示可以从任意主机名称(ip),第2个all表示可以切换到任意账户,第3个all表示可以执行任意命令 #不允许直接在一行中指定多个目标用户(user1,user2)来执行命令,需要分别为每个目标用户配置权限 # 允许 admin1 和 admin2 在 server1、server2 和 server3 上以 user1 身份执行 /usr/bin/command1 和 /usr/bin/command2 admin1,admin2 server1,server2,server3 = (user1) /usr/bin/command1, /usr/bin/command2 # 允许 admin1 和 admin2 在 server1、server2 和 server3 上以 user2 身份执行 /usr/bin/command1 和 /usr/bin/command2 admin1,admin2 server1,server2,server3 = (user2) /usr/bin/command1, /usr/bin/command2 #如果要创建更复杂的配置，通常需要将 sudoers 文件中的规则分解为多个条目 # 允许 admin1 在 server1、server2 和 server3 上以 user1 身份执行 /usr/bin/command1 和 /usr/bin/command2 admin1 server1,server2,server3 = (user1) /usr/bin/command1, /usr/bin/command2 # 允许 admin1 在 server1、server2 和 server3 上以 user2 身份执行 /usr/bin/command1 和 /usr/bin/command2 admin1 server1,server2,server3 = (user2) /usr/bin/command1, /usr/bin/command2 # 允许 admin2 在 server1、server2 和 server3 上以 user1 身份执行 /usr/bin/command1 和 /usr/bin/command2 admin2 server1,server2,server3 = (user1) /usr/bin/command1, /usr/bin/command2 # 允许 admin2 在 server1、server2 和 server3 上以 user2 身份执行 /usr/bin/command1 和 /usr/bin/command2 admin2 server1,server2,server3 = (user2) /usr/bin/command1, /usr/bin/command2 #修改保存后进行格式检查 visudo -c #接管人在执行超级命令前加sudo sudo useradd d3 #sudo执行任何命令前不必输入密码 d1 root ALL=(ALL) NOPASSWD:ALL 防火墙 centos7基于firewall实现应用层防火墙,centos6基于iptables #查看防火墙是否开启 firewall-cmd --state #查看放行的端口 firewall-cmd --list-ports #--permanent永久性策略修改需要执行frewall-cmd --reload, 不写视为临时策略 #采用tcp通讯时放行8080端口 firewall-cmd --zone=public --permanent --add-port=8080/tcp frewall-cmd --reload #放行8000到9000区域内的端口 firewall-cmd --zone=public --permanent --add-port=8000-9000/tcp firewall-cmd --reload #移除放行的端口 firewall-cmd --zone=public --permanent --remove-port=8080/tcp firewall-cmd --reload Shell Shell是一个用c语言编写的脚本解释器,使用户能够通过代码操作Linux Shell脚本描述要执行的任务,完成系列复杂操作,文件后缀.sh Shell脚本通过Shell解释器执行,按解释器分类分为多种类型 默认解释器为bash 20240423193948.webp 自动部署tomcat #!/bin/bash 指定脚本的解释器,确保脚本在不同系统上以一致的方式运行 cat > deploy_tomcat.sh << EOF #!/bin/bash echo "准备下载tomcat9" wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.91/bin/apache-tomcat-9.0.91.tar.gz echo "正在解压缩tomcat9" tar zxf apache-tomcat-9.0.91.tar.gz echo "开放8080端口" firewall-cmd --zone=public --permanent --add-port=8080/tcp echo "重新应用防火墙规则" firewall-cmd --reload echo "启动tomcat" ./apache-tomcat-9.0.91/bin/startup.sh EOF #将默认权限644改755 chmod 755 deploy_tomcat.sh ./deploy_tomcat.sh oa部署到服务器 新建两个最小安装的linux虚拟机 CentOS-DB 192.168.149.130 CentOS-Web 192.168.149.134 #最小安装不带ifconfig yum install -y net-tools.x86_64 ifconfig #yum中没有提供mysql-community相关的安装组件 yum search mysql-community #网页搜索mysql yum #从mysql官网获取对应版本rpm文件链接地址 #使用wget命令进行下载 #最小安装不带wget yum install -y wget mkdir /usr/local/mysql cd /usr/local/mysql wget https://dev.mysql.com/get/mysql84-community-release-el7-1.noarch.rpm #使用yum安装,本质已是下载rpm文件执行里面的安装命令,执行本地rpm文件时用localinstall准备安装源 #安装 MySQL 社区版本的 RPM 包时，你实际上安装的是 MySQL 仓库配置包，而不是 MySQL 服务器本身 #这个配置包的作用是添加 MySQL 仓库到你的 yum 配置中，以便你可以方便地安装和更新 MySQL 及其相关组件 yum localinstall -y mysql84-community-release-el7-1.noarch.rpm #此时可以查询到mysql相关的安装组件 yum search mysql-community #开始安装mysql,可以省略末尾的.x86_64 yum install -y mysql-community-server #启动mysql,确认运行状态 systemctl start mysqld systemctl status mysqld #设置开机启动 systemctl enable mysqld #从日志中获取生成的临时密码 cat /var/log/mysqld.log #登陆mysql,修改root帐户密码,'localhost'只允许在本机登陆,with mysql_native_password针对旧版本navicat连接不上mysql8的兼容处理 mysql -uroot -p #alter user 'root'@'localhost' identified with mysql_native_password by 'fsafASDfs2#@'; #mysql_native_password 插件在 MySQL 中用于处理用户身份验证。它提供了一种将用户密码存储在 MySQL 数据库中的方法，并在用户登录时验证这些密码 #在 MySQL 8.0 及更高版本中，默认的身份验证插件是 caching_sha2_password。这种插件比 mysql_native_password 更加安全 alter user 'root'@'localhost' identified by 'fsafASDfs2#@'; #切换到mysql数据库 use mysql; #查看用户信息 select host,user from user; #使root账户可以远程登陆,修改允许登陆的设备, %表示可以从任意设备上登陆 update user set host='%' where user='root'; #当 MySQL 启动时，它会从权限表（如 mysql.user, mysql.db, mysql.tables_priv 等）中读取权限数据并将其加载到内存中 #如果直接对权限表进行手动修改（例如，通过 INSERT, UPDATE, DELETE 操作），这些修改不会自动生效。必须执行 FLUSH PRIVILEGES; 命令以使这些手动修改生效 flush privileges; #放行mysql端口 firewall-cmd --zone=public --permanent --add-port=3306/tcp firewall-cmd --reload firewall-cmd --zone=public --permanent --remove-port=3306/tcp firewall-cmd --reload #对db服务器增强安全设置,只对指定主机开放指定端口 firewall-cmd --permanent --zone=public --add-rich-rule="rule family="ipv4" source address="192.168.149.134" port protocol="tcp" port="3306" accept" firewall-cmd --reload #查看自定义的防火墙规则 firewall-cmd --permanent --zone=public --list-rich-rules #登录建库 mysql -uroot -p create database oa #宿主机数据库导出sql文件 mysqldump -u username -p oa > oa.sql #宿主机sql文件导入到远程主机 mysql -h 192.168.149.130 -P 3306 -uroot -p oa < D:\mess\oa.sql #查看仓库中的jdk yum search jdk #java-1.8.0-openjdk与标准jdk是一致的 yum install -y java-1.8.0-openjdk.x86_64 java -version which java #安装tomcat,上传war包 #修改tomcat端口号和上下文 #放行80端口 firewall-cmd --zone=public --permanent --add-port=80/tcp firewall-cmd --reload #启动tomcat,确认80 ./bin/startup.sh netstat -tupln #修改WEB-INF/classes/mybatis-config.xml中的jdbc驱动参数ssl设true,数据库用户名密码`,``,`html`,`Maven`,`20240410210148-_工具使用 项目设置遵循统一的规则,保证不同开发环境的兼容性 自动下载和管理项目所依赖的库和JAR文件及其依赖关系 可扩展的插件机制, 使用简单功能丰富 POM POM (Project Object Model)项目对象模型 groupId 组织或项目的唯一标识符 artifactId 项目的唯一标识符, 项目名称用途cms,oa.. version 项目的版本号。版本+单词,1.0.0-RELEASE(发布版),ALPHA,BETA,SNAPSHOT packaging 构件的打包类型，默认是jar。常见的值有jar、war、pom等。例如：pom表示该项目是一个POM项目，主要用于聚合其他项目。 classifier 附加分类符，用于区分相同groupId、artifactId和version的不同构件。例如：sources表示源代码包，javadoc表示Javadoc包。 type 构件的类型，通常与packaging相同，默认是jar。这个属性在声明依赖时可以使用，例如：pom、jar、war等。 scope 依赖范围，指定依赖在哪些阶段有效。常见的值有： compile：默认值，依赖在编译、测试和运行时都有效。 provided：依赖在编译和测试时有效，但运行时由容器（如Servlet容器）提供。 runtime：依赖在测试和运行时有效，编译时不需要。 test：依赖仅在测试时有效。 system：类似于provided，但依赖必须显式指定路径。 import：用于导入依赖管理范围。 optional 可选依赖，表示该依赖是可选的，默认为false 当值为true时,下游项目在构建时不会自动包含这些可选依赖项, 标记可选依赖项可以防止下游项目引入不必要的库，从而减小构建的复杂性和大小 假设你有一个项目A，它依赖于项目B，而项目B依赖于项目C。如果项目B中的项目C依赖被标记为可选，那么项目A在构建时将不会自动包含项目C 本地,中央和远程仓库 Maven 会在构建项目时优先从本地仓库查找依赖项，如果未找到，则会从配置的远程仓库(由第三方或组织托管的附加仓库)中下载依赖项,如果在本地仓库和所有配置的远程仓库中都没有找到所需的依赖项，Maven 最后会尝试从社区中央仓库下载(https://repo.maven.apache.org/maven2) 默认本地地址&#36;{user.home}/.m2/repository 修改本地地址,在maven的config目录下setting.xml中localRepository中指定新的本地仓库路径 idea构建工具maven设置中指定maven的安装目录,应用setting.xml文件地址和仓库新地址 远程仓库配置,例如墙国阿里云 <repositories> <repository> <id>aliyun</id> <url>https://maven.aliyun.com/repository/public</url> </repository> .. </repositories> maven打包jar 演示说明 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <!-- 项目信息 --> <groupId>com.example</groupId> <artifactId>my-app</artifactId> <version>1.0.0</version> <packaging>jar</packaging> <!-- 指定打包类型为 JAR --> <!-- 项目描述 --> <name>My Application</name> <description>A simple Java application</description> <url>http://www.example.com/my-app</url> <!-- 依赖项 --> <dependencies> <!-- 你的项目依赖项 --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>5.3.8</version> </dependency> <!-- 更多依赖项 --> </dependencies> <!-- 构建配置 --> <build> <plugins> <!-- Maven 编译插件：指定 Java 源代码和目标版本 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> <!-- maven-compiler-plugin 的 compile 目标绑定到 compile 阶段 --> <executions> <execution> <id>default-compile</id> <phase>compile</phase> <goals> <goal>compile</goal> </goals> </execution> </executions> </plugin> <!-- Maven JAR 插件：配置生成 JAR 文件的名称和位置 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-jar-plugin</artifactId> <version>3.2.0</version> <configuration> <outputDirectory>&#36;{project.build.directory}</outputDirectory> <finalName>&#36;{project.artifactId}-&#36;{project.version}</finalName> </configuration> <!-- maven-jar-plugin 的 jar 目标绑定到 package 阶段 --> <executions> <execution> <id>default-jar</id> <phase>package</phase> <goals> <goal>jar</goal> </goals> </execution> </executions> </plugin> <!-- Maven Assembly 插件：如果需要打包成可执行的 JAR 文件，可以使用这个插件，并指定主类 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-assembly-plugin</artifactId> <version>3.3.0</version> <configuration> <archive> <manifest> <mainClass>com.example.Main</mainClass> <!-- 指定主类 --> </manifest> </archive> <descriptorRefs> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> </configuration> <executions> <execution> <id>make-assembly</id> <phase>package</phase> <goals> <goal>single</goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> Phase（阶段） 构建生命周期的一个阶段，代表一组任务的集合 default（默认生命周期）：处理项目的编译、测试、打包、部署等任务。 validate：验证项目是否正确且所有必要信息都可用。 compile：编译项目的源代码。 test：使用合适的单元测试框架测试编译的源代码。 package：将编译后的代码打包成可分发的格式（例如 JAR、WAR）。 verify：运行任何检查以验证包的有效性和质量。 install：将包安装到本地仓库，以供本地其他项目使用。 deploy：将最终的包复制到远程仓库，以共享给其他开发人员和项目。 clean（清理生命周期）：处理项目的清理任务。 pre-clean：执行清理前需要完成的工作。 clean：清理上一次构建生成的所有文件。 post-clean：执行清理后需要完成的工作。 site（站点生命周期）：生成项目站点文档。 pre-site：执行生成站点文档前需要完成的工作。 site：生成项目的站点文档。 post-site：执行生成站点文档后需要完成的工作。 site-deploy：将生成的站点文档发布到特定的服务器。 Goal（目标） goal 是插件执行的具体任务 每个插件包含一个或多个目标 每个目标可以绑定到一个或多个生命周期阶段 当 Maven 执行一个阶段时，它会执行该阶段绑定的所有目标。 每个目标可以直接在命令行中指定，也可以在 pom.xml 文件中配置。 mvn clean compile 依次执行 clean 阶段及其之前的所有阶段，然后执行 compile 阶段及其之前的所有阶段 mvn compile 执行 compile 阶段及其之前的所有阶段 mvn org.apache.maven.plugins:maven-compiler-plugin:compile 只执行 maven-compiler-plugin 插件的 compile 目标，而不管生命周期阶段 简化 Maven 编译插件 (maven-compiler-plugin): Maven 默认使用 JDK 1.5 来编译代码。指定 source 和 target 版本是为了使用特定的 JDK 版本（如 Java 8）。但如果你项目使用的是默认的 JDK 版本，可以省略。 Maven JAR 插件 (maven-jar-plugin): maven-jar-plugin 是 Maven 默认会在 package 阶段执行的插件。如果不需要特殊配置（例如自定义 JAR 文件名或位置），可以省略，因为 Maven 会自动执行默认配置。 Maven Assembly 插件 (maven-assembly-plugin): 用于创建包含所有依赖项的可执行 JAR 文件，必要时才配置。 执行配置部分： executions 部分允许你定义插件在构建生命周期的不同阶段执行的任务。对于许多插件，默认绑定的目标已经足够，因此可以省略自定义的 executions 配置。 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <!-- 项目信息 --> <groupId>com.example</groupId> <artifactId>my-app</artifactId> <version>1.0.0</version> <packaging>jar</packaging> <!-- 依赖项 --> <dependencies> <!-- .. --> </dependencies> <!-- 构建配置 --> <build> <plugins> <!-- Maven 编译插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <!-- Maven Assembly 插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-assembly-plugin</artifactId> <version>3.3.0</version> <configuration> <archive> <manifest> <mainClass>com.example.Main</mainClass> </manifest> </archive> <descriptorRefs> <!-- 生成包含所有依赖项的 JAR 文件 --> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> </configuration> <executions> <execution> <id>make-assembly</id> <phase>package</phase> <goals> <goal>single</goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> 虽然已经配置了 descriptorRef jar-with-dependencies/descriptorRef，但如果没有配置 executions 元素，Maven 并不知道在构建生命周期的哪个阶段执行这个插件以及执行哪个目标。 descriptorRefjar-with-dependencies/descriptorRef 本身只是指定了要使用的预定义描述符，但并没有指定插件的执行时机。 descriptorRef 的作用 descriptorRefjar-with-dependencies/descriptorRef 是 Maven Assembly 插件的一个配置项，用于告诉插件创建一个包含所有依赖项的 JAR 文件。这个配置指向一个预定义的描述符，该描述符告诉插件如何构建这个包含依赖项的 JAR 文件。 缺少 executions 配置的情况 如果缺少 executions 配置，虽然指定了要创建包含所有依赖项的 JAR 文件，但 Maven 在构建过程中并不知道何时执行这个任务。因此，构建过程中不会生成包含依赖项的 JAR 文件，导致生成的 JAR 文件没有包含依赖项的清单。 添加 executions 配置的作用 通过添加 executions 配置，你明确指定了在构建生命周期的某个阶段（如 package 阶段）执行插件的 single 目标。这样 Maven 知道何时执行这个任务，确保在构建过程中生成包含所有依赖项的 JAR 文件。 maven打包war <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <!-- 项目信息 --> <groupId>com.example</groupId> <artifactId>my-web-app</artifactId> <version>1.0.0</version> <packaging>war</packaging> <!-- 指定打包类型为 WAR --> <!-- 项目描述 --> <name>My Web Application</name> <description>A simple Java web application</description> <url>http://www.example.com/my-web-app</url> <!-- 依赖项 --> <dependencies> <!-- Servlet API 依赖项（scope 设置为 provided，表示运行时由应用服务器提供） --> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>4.0.1</version> <scope>provided</scope> </dependency> <!-- Spring Web 依赖项 --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>5.3.8</version> </dependency> <!-- 更多依赖项 --> </dependencies> <!-- 构建配置 --> <build> <finalName>&#36;{artifactId}-&#36;{version}</finalName> <!-- 指定最终生成的 WAR 文件名 --> <plugins> <!-- Maven 编译插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <!-- Maven WAR 插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.3.1</version> </plugin> </plugins> </build> </project> Maven命令 mvn -v maven版本信息 mvn archetype:generate 通过命令向导创建maven工程结构 mvn compile 编译项目的源代码。 mvn test 运行测试用例 mvn clean 清理项目，删除target目录。 mvn package 将编译后的代码打包成JAR文件。 mvn install 将打包后的构件安装到本地仓库。 mvn deploy 将打包后的构件部署到远程仓库。 mvn package -DskipTests 跳过执行测试用例，但会编译测试代码 boot项目 spring-boot-maven-plugin是 Spring Boot 项目中最重要的插件。它用于打包 Spring Boot 应用为可执行 JAR 文件 Spring Boot 项目默认使用 Java 1.8 或更高版本编译代码，因此 maven-compiler-plugin 的配置已经在 spring-boot-starter-parent 中内置 Spring Boot 项目默认打包为可执行 JAR 文件（通过内嵌的 Tomcat、Jetty 等 Servlet 容器），因此不需要显式配置 maven-war-plugin <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> Since Maven 3.8.1 http repositories are blocked 自 Maven 3.8.1 起，为了安全起见，HTTP 仓库被默认阻止。如果你的项目或 Maven 配置中使用了 HTTP URL 的仓库，你需要更新为 HTTPS，或者配置 Maven 使用支持 HTTP 的镜像。`,``,`html`,`MVC油画展示`,`20240521124656-_项目例 javaBean是一种可重用组件,用于承载数据, 很多地方地javabean有天然支持如el表达式 javabean不是一种技术,而是一种java类的格式要求 类公有,属性私有,写了带参构造后必须手写无参构造,提供getter,setter 开发PaintingDao读取XML数据, 实现分页操作 XmlDataSoruce类, xml数据源工具类简化Dao提取操作 所有Dao类共用一个XmlDataSoruce对象减少内存消耗 dom4j开发流程 SAXReader.read()读取xml文件,得到Document对象 document.selectNodes()利用Xpath得到xml节点集合 遍历xml节点, 包装成javabean或者集合对象返回 PaintingDao.pagination(), 数据分页查询方法 PageModel类, 分布结果的包装类 开发PaintingService服务类,对PaingtingDao进行调用 开发PaintingController控制器, 调用PaintingService 重写index.html, 利用jsp读取分页数据 20240704170046.webp pom <dependencies> <!-- dom4j,jaxen(Xpath) --> <dependency> <groupId>org.dom4j</groupId> <artifactId>dom4j</artifactId> <version>2.1.4</version> </dependency> <dependency> <groupId>jaxen</groupId> <artifactId>jaxen</artifactId> <version>1.2.0</version> </dependency> <!-- jstl --> <dependency> <groupId>javax.servlet</groupId> <artifactId>jstl</artifactId> <version>1.2</version> </dependency> <!-- 文件上传 --> <dependency> <groupId>commons-fileupload</groupId> <artifactId>commons-fileupload</artifactId> <version>1.4</version> </dependency> <!-- 编译时servlet,单元测试 --> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.13.2</version> <scope>test</scope> </dependency> </dependencies> <packaging>war</packaging> <build> <plugins> <!-- Maven 编译插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <!-- Maven WAR 插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.4.0</version> </plugin> </plugins> </build> 目录结构脚本 #!/bin/bash # #!: 称为 Shebang，它告诉系统这个文件是一个脚本，而不是普通的文本文件, /bin/bash: 告诉系统使用 bash 作为解释器, 必须放在第一行 # 定义颜色 GREEN='\ 033[32m' BLUE='\ 033[34m' RESET='\ 033[0m' # 重置颜色 echo -e "&#36;{BLUE}[ start.. ]----------------------------------------------------&#36;{RESET}" # 定义要创建的目录结构 prefix="src/main/java/com/ida/painting/" directories=( "controller" "dao" "entity" "filter" "service" "utils" "vo" ) cut=' src/main/resources/mkdir.sh ' # -p 静默地跳过已经存在的文件夹, 保持幂等性，即不管运行多少次，最终的结果都是一致的 for dir in "&#36;{directories[@]}"; do full_path="$prefix$dir" if [ ! -d "$full_path" ]; then mkdir -p "$full_path" echo -e "&#36;{GREEN}>> created : $full_path&#36;{RESET}" else echo -e "&#36;{BLUE}>> ignored : $full_path&#36;{RESET}" fi done echo -e "&#36;{BLUE}------------------------------------------------------[ over. ]&#36;{RESET}" 20240901103345.webp 工具类 XmlDataSource /* <root> <painting id="1"> <pname>古典油画鉴赏1</pname> <category>1</category> <price>3800</price> <preview>/upload/1.jpg</preview> <description>古典油画鉴赏1的描述文本</description> </painting> <!-- .. --> </root> */ public class XmlDataSource { private static final List<Painting> data = new ArrayList<>(); private static final String dataFile; static { // 如果资源未找到，getResource 将返回 null，然后调用 getPath() 会引发 NullPointerException // dataFile = XmlDataSource.class.getResource("/painting.xml").getPath(); // 通过 Objects.requireNonNull，可以确保 URL 不为 null，避免了后续 NullPointerException 的可能。这使得错误处理更加明确。 dataFile = Objects.requireNonNull(XmlDataSource.class.getResource("/painting.xml")).getPath(); reload(); } public static List<Painting> getRawData() { return data; } private static Document getDoc() { try { return new SAXReader().read(URLDecoder.decode(dataFile, "UTF-8")); } catch (DocumentException | UnsupportedEncodingException e) { throw new RuntimeException(e); } } //写文件 private static void overWrite(Document doc) { Writer osw = null; try { osw = new OutputStreamWriter(new FileOutputStream(dataFile), "UTF-8"); doc.write(osw); } catch (IOException e) { throw new RuntimeException(e); } finally { if (osw != null) { try { osw.close(); } catch (IOException e) { throw new RuntimeException(e); } } reload(); //保证内存中的文件和更新后的文件一致 } } //内存刷新 private static void reload() { data.clear(); //清空前次列表 for (Node node : getDoc().selectNodes("/root/painting")) { Element e = (Element) node; Painting p = new Painting(); p.setId(Integer.parseInt(e.attributeValue("id"))); p.setPname(e.elementText("pname")); p.setCategory(Integer.parseInt(e.elementText("category"))); p.setPrice(Integer.parseInt(e.elementText("price"))); p.setPreview(e.elementText("preview")); p.setDescription(e.elementText("description")); data.add(p); } } //新增 public static void append(Painting painting) { Document doc = getDoc(); XPath xPath = doc.createXPath("count(/root/painting)"); int count = xPath.numberValueOf(doc).intValue(); Element p = doc.getRootElement().addElement("painting"); p.addAttribute("id", String.valueOf( count + 1)); p.addElement("pname").setText(painting.getPname()); p.addElement("category").setText(painting.getCategory().toString()); p.addElement("price").setText(painting.getPrice().toString()); p.addElement("preview").setText(painting.getPreview()); p.addElement("description").setText(painting.getDescription()); overWrite(doc); } //修改 public static void update(Painting painting) { Document doc = getDoc(); List<Node> nodes = doc.selectNodes("/root/painting[@id=" + painting.getId() + "]"); Element e = (Element) nodes.get(0); e.selectSingleNode("pname").setText(painting.getPname()); e.selectSingleNode("category").setText(painting.getCategory().toString()); e.selectSingleNode("price").setText(painting.getPrice().toString()); e.selectSingleNode("preview").setText(painting.getPreview()); e.selectSingleNode("description").setText(painting.getDescription()); overWrite(doc); } //删除 public static void delete(Integer id) { Document doc = getDoc(); List<Node> nodes = doc.selectNodes("/root/painting[@id=" + id + "]"); Element element = (Element) nodes.get(0); element.getParent().remove(element); //删除自身 overWrite(doc); } } ParamUtils public class ParamUtils { public static int parseIntOrDefault(String value, int defaultValue) { try { return Integer.parseInt(value); } catch (NumberFormatException e) { return defaultValue; } } } 字符编码过滤器 @WebFilter( filterName = "characterEncodingFilter", urlPatterns = "/*", initParams = { @WebInitParam(name = "encoding", value = "UTF-8") } ) public class CharacterEncodingFilter implements Filter { private String encoding = "UTF-8"; @Override public void init(FilterConfig filterConfig) { if (filterConfig.getInitParameter("encoding") != null) { this.encoding = filterConfig.getInitParameter("encoding"); } } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; request.setCharacterEncoding(encoding); filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { } } VO VO（Value Object）不变的业务实体的对象, 用于封装一组相关的值，作为业务逻辑的一部分 不变性: VO 对象通常是不可变的，一旦创建后，内部状态不应该被修改。 业务逻辑: VO 可以包含一些业务逻辑或计算方法，用于操作和处理其封装的值。 设计目标: 表示业务模型中的概念，提供丰富的语义和行为。 分页模型 20240705102114.webp public final class PageModel<T> { private int page; //查询的页号 private int totalPages; //总页数 private int rows; //每页记录数 private int totalRows; //总记录数 private int pageStartRow; //当前页从第几条开始 private int pageEndRow; //当前页到第几条结束 private boolean hasPreviousPage; private boolean hasNextPage; private List<T> pageData; //当前页的数据 private final int displayPages = 5; //导航条页码按钮数量 private int startPage; //起始页码 private int endPage; //结束页码 public PageModel() {} public PageModel(List<T> data, int page, int rows) { //数据源, 查询的页号, 每页记录数 totalRows = data.size(); this.rows = rows <=0 | rows > 100 ? 6 : rows; // 总页数 = 总行数/每页记录数, 不能整除时向上取整 20/6=3.333 向上取整=4 totalPages = (int) Math.ceil(totalRows * 1.0 / this.rows); //两个整数乘除运算时会对结果中的小数会进行截尾 this.page = page <= 0 ? 1 : Math.min(page, totalPages); //防止大于总页数 pageStartRow = (this.page - 1) * this.rows; //第一页时,起始行号为0 pageEndRow = Math.min(this.page * this.rows, totalRows); //防止subList()下标越界 hasPreviousPage = this.page > 1; hasNextPage = this.page < totalPages; pageData = data.subList(pageStartRow, pageEndRow); // 计算startPage和endPage int halfPagesToShow = displayPages / 2; if (totalPages <= displayPages) { startPage = 1; endPage = totalPages; } else { if (this.page - halfPagesToShow <= 0) { startPage = 1; endPage = displayPages; } else if (this.page + halfPagesToShow >= totalPages) { startPage = totalPages - displayPages + 1; endPage = totalPages; } else { startPage = this.page - halfPagesToShow; endPage = this.page + halfPagesToShow; } } } //getter,setter } public class PageModelTest { @Test public void case1() { List<Integer> list = new ArrayList<>(); for (int i = 0; i < 100; i++) { list.add(i + 1); } Scanner scanner = new Scanner(System.in); while (true) { System.out.println("每页的记录数:"); int rows = scanner.nextInt(); System.out.println("要查询的页号:"); int pageNum = scanner.nextInt(); PageModel pageModel = new PageModel(list, pageNum, rows); System.out.println( Arrays.toString( new Object[]{ pageModel.getPage(), pageModel.getTotalPages(), pageModel.getRows(), pageModel.getTotalRows(), pageModel.getPageStartRow(), pageModel.getPageEndRow(), pageModel.isHasPreviousPage(), pageModel.isHasNextPage(), pageModel.getPageData(), pageModel.getStartPage(), pageModel.getEndPage() } )); System.out.println("是否继续[y/*]:"); String go = scanner.next(); if (!go.equals("y")) break; } } } DAO PaintingDao public class PaintingDao { private final List<Painting> rawData = XmlDataSource.getRawData(); public PageModel<Painting> pagination(int page, int rows, String... args) { List<Painting> data; if (args.length == 0) { data = rawData; } else { try { int category = Integer.parseInt(args[0]); data = rawData.stream().filter(o -> o.getCategory() == category).collect(Collectors.toList()); } catch (NumberFormatException e) { data = rawData; } } return new PageModel<>(data, page, rows); } public void create(Painting painting){ XmlDataSource.append(painting); } public Painting findById(Integer id) { //如果过滤后的列表是空的, get(0)会抛出IndexOutOfBoundsException异常 //return rawData.stream().filter(o -> o.getId() == id).collect(Collectors.toList()).get(0); //findFirst() 会返回一个 Optional<Painting>，然后通过 orElse(null) 方法在没有找到匹配的对象时返回 null return rawData.stream().filter(o -> Objects.equals(o.getId(), id)).findFirst().orElse(null); } public void update(Painting painting) { XmlDataSource.update(painting); } public void delete(Integer id) { XmlDataSource.delete(id); } } Service PaintingService public class PaintingService { private final PaintingDao paintingDao = new PaintingDao(); public PageModel<Painting> pagination(int page, int rows, String... args) { return paintingDao.pagination(page, rows, args); } public void create(Painting painting){ paintingDao.create(painting); } public Painting findById(Integer id) { Painting painting = paintingDao.findById(id); if (painting == null) { throw new RuntimeException("[id为"+id+"的油画不存在]"); } return painting; } public void update(Painting newPainting, Integer isPreviewModified) { Painting rawPainting = this.findById(newPainting.getId()); rawPainting.setPname(newPainting.getPname()); rawPainting.setCategory(newPainting.getCategory()); rawPainting.setPrice(newPainting.getPrice()); rawPainting.setDescription(newPainting.getDescription()); if(isPreviewModified == 1) { rawPainting.setPreview(newPainting.getPreview()); } paintingDao.update(rawPainting); } public void delete(Integer id) { this.findById(id); paintingDao.delete(id); } } Controller PaintingController @WebServlet("/page") public class PaintingController extends HttpServlet { private final PaintingService paintingService = new PaintingService(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { int page = ParamUtils.parseIntOrDefault(req.getParameter("p"), 1); int rows = ParamUtils.parseIntOrDefault(req.getParameter("r"), 6); String category = req.getParameter("c"); PageModel pageModel = paintingService.pagination(page, rows, category); req.setAttribute("pageModel", pageModel); req.getRequestDispatcher("/WEB-INF/jsp/index.jsp").forward(req, resp); } } 首页 index.html web/index.html <script>window.location.href="/page"</script> index.jsp web/WEB-INF/jsp/index.jsp <!-- 不要使用<% %>代码块, 使用 EL + JSTL提取数据 --> <%@ page contentType="text/html;charset=UTF-8" language="java" %> <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> <%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %> <!DOCTYPE html> .. <!-- 根据参数是否存在设置变量值 --> <c:if test="&#36;{param.c !=null}"> <c:set var="categoryParam" value="&c=&#36;{param.c}"/> </c:if> <c:if test="&#36;{param.c ==null}"> <c:set var="categoryParam" value=""/> </c:if> .. <!-- 分类 --> <ul id="title"> <li><a href="/page?c=1">现实主义</a></li> <li><a href="/page?c=2">抽象主义</a></li> </ul> .. <!-- 分页导航条 --> <div class="page-nav"> <ul> <li><a href="/page?p=1&#36;{categoryParam}">首页</a></li> <li><a href="/page?p=&#36;{pageModel.hasPreviousPage ? pageModel.page-1 : 1}&#36;{categoryParam}">上一页</a></li> <c:if test="&#36;{pageModel.startPage > 1}"> <li><a href="/page?p=1&#36;{categoryParam}">1</a></li> <li>...</li> </c:if> <c:forEach begin="&#36;{pageModel.startPage}" end="&#36;{pageModel.endPage}" var="pno"> <li> <span &#36;{pageModel.page == pno ? "class='current-page'" : ""}> <a href="/page?p=&#36;{pno}&#36;{categoryParam}">&#36;{pno}</a> </span> </li> </c:forEach> <c:if test="&#36;{pageModel.endPage < pageModel.totalPages}"> <li>...</li> <li><a href="/page?p=&#36;{pageModel.totalPages}&#36;{categoryParam}">&#36;{pageModel.totalPages}</a></li> </c:if> <li><a href="/page?p=&#36;{pageModel.hasNextPage ? pageModel.page+1 : pageModel.totalPages}&#36;{categoryParam}">下一页</a></li> <li><a href="/page?p=&#36;{pageModel.totalPages}&#36;{categoryParam}">尾页</a></li> </ul> </div> <!-- 当前页数据 --> <div class="img-content"> <ul> <c:forEach items="&#36;{pageModel.pageData}" var="painting"> <li> <img src="&#36;{painting.preview}" class="img-li"> <div class="info"> <h3>&#36;{painting.pname}</h3> <p>&#36;{painting.description}</p> <div class="price"><fmt:formatNumber pattern="$0.00" value="&#36;{painting.price}"/></div> </div> </li> </c:forEach> </ul> </div> .. 关于jsp中的文件引用 浏览器解析相对路径css/common.css是基于当前请求URL，即host:port/page 因此，浏览器会请求：host:port/css/common.css, common.css被正确访问到 但是如果转发到/page/sub时, 浏览器将解析为：host:port/page/css/common.css, 导致无法正确加载 common.css 使用基于上下文路径的绝对路径确保相对路径在不同情况下都能正确解析 href="&#36;{pageContext.request.contextPath}/css/common.css" contextPath是request对象的一个方法，getContextPath() 方法在 EL 中表示为 contextPath EL 通过约定俗成的方式将 getter 方法转化为属性名称，使得表达式更加简洁和直观 后台功能 说明 油画列表,分页 油画预览 利用sweetalert2对话框组件 新增, 上传油画 使用Servlet 3.0的内置文件上传功能和使用Apache Commons FileUpload组件是两种处理文件上传的常见方式 Servlet 3.0 内置文件上传功能 适合较简单的文件上传需求。 与 Servlet 容器（如 Tomcat 7+）紧密集成，无需额外的库。 Apache Commons FileUpload组件 独立的库，需要单独引入和配置 支持旧版本的 Servlet 容器和环境，比如 Servlet 2.5。 在不支持 Servlet 3.0 的环境中，仍然可以使用 Apache Commons FileUpload 实现文件上传功能。 封装可重用的js脚本解决表单检验问题 Dom4j追加 修改油画 删除油画 功能分发 @WebServlet("/management") /* @MultipartConfig( location = "C:/TEMP", fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 10, maxRequestSize = 1024 * 1024 * 50 ) */ public class ManagementController extends HttpServlet { private final PaintingService paintingService = new PaintingService(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getParameter("method"); switch (method) { case "list": list(req, resp); break; case "show_create": showCreate(req, resp); break; case "create": create(req, resp); break; case "show_update": showUpdate(req, resp); break; case "update": update(req, resp); break; case "delete": delete(req, resp); break; } } //.. } 列表预览 private void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { int page = ParamUtils.parseIntOrDefault(req.getParameter("p"), 1); int rows = ParamUtils.parseIntOrDefault(req.getParameter("r"), 10); PageModel<Painting> pageModel = paintingService.pagination(page,rows); req.setAttribute("pageModel", pageModel); req.getRequestDispatcher("/WEB-INF/jsp/list.jsp").forward(req, resp); } jsp/list.jsp <!-- sweetalert2 --> function showPreview(obj) { var pname = $(obj).attr("data-pname"); var preview = $(obj).attr("data-preview"); Swal.fire({ title: pname, html: "<img src='" + preview + "'>", showCloseButton: true, showConfirmButton: false }) } <a href="/management?method=show_create" class="btn-button">新增</a> <!-- 油画列表 --> <c:forEach items="&#36;{pageModel.pageData}" var="painting"> <tr> <td> <%-- &#36;{painting.category==1?"现实主义":"抽象主义"} --%> <c:choose> <c:when test="&#36;{painting.category==1}">现实主义</c:when> <c:when test="&#36;{painting.category==2}">抽象主义</c:when> <c:otherwise>未分类</c:otherwise> </c:choose> </td> <td>&#36;{painting.pname}</td> <td><fmt:formatNumber pattern="¥0.00" value="&#36;{painting.price}"/></td> <td>&#36;{painting.description}</td> <td> <a class="oplink" data-preview="&#36;{painting.preview}" data-pname="&#36;{painting.pname}" href="javascript:void(0)" onclick="showPreview(this)">预览</a> <a class="oplink" href="/management?method=show_update&id=&#36;{painting.id}">修改</a> <a class="oplink" href="javascript:void(0)" data-id="&#36;{painting.id}" data-pname="&#36;{painting.pname}" data-preview="&#36;{painting.preview}" onclick="del(this)">删除</a> </td> </tr> </c:forEach> <!-- 列表分页 --> 新增和上传 表单验证 function switchValid(onOff, input, errSelector, message) { if (onOff == false) { $(errSelector).text(message); $(errSelector).addClass("error_message"); $(input).addClass("error_input"); } else { $(errSelector).text(""); $(errSelector).removeClass("error_message"); $(input).removeClass("error_input"); } } function errPrefix(str) { return "#err" + str.charAt(0).toUpperCase() + str.slice(1); } function checkEmpty(input) { var val = $.trim($(input).val()); var valid = (val !== ""); switchValid(valid, input, errPrefix(input.id), "请输入内容"); return valid; } function checkCategory(input) { var val = $.trim($(input).val()); var valid = (val !== "-1"); switchValid(valid, input, errPrefix(input.id), "请选择油画类型"); return valid; } function checkPrice(input) { var val = $(input).val(); var regex = /^[1-9][0-9]*$/; //第一位不能有0 var valid = regex.test(val); switchValid(valid, input, errPrefix(input.id), "无效的价格"); return valid; } function checkFile(input) { if (!checkEmpty(input)) { return false; } var val = $.trim($(input).val().toLowerCase()); var valid = false; if (val.length >= 4) { var suffix = val.substring(val.length - 3); valid = (suffix === "jpg" || suffix === "png" || suffix === "gif"); } switchValid(valid, input, errPrefix(input.id), "请选择有效图片"); return valid; } function checkSubmit() { //var validPname = checkEmpty($("#pname")); //此处错误应传原生DOM元素对象, var validPname = checkEmpty(document.getElementById("pname")); var validCategory = checkCategory(document.getElementById("category")); var validPrice = checkPrice(document.getElementById("price")); var validPainting = checkFile(document.getElementById("painting")); var validDescription = checkEmpty(document.getElementById("description")); return validPname && validCategory && validPrice && validPainting && validDescription; } <form action="/management?method=create" method="post" autocomplete="off" enctype="multipart/form-data" onsubmit="return checkSubmit()"> <ul class="ulform"> <li> <span>油画名称</span> <span id="errPname"></span> <input id="pname" name="pname" onblur="checkEmpty(this)" /> </li> <li> <span>油画类型</span> <span id="errCategory"></span> <select id="category" name="category" onchange="checkCategory(this)"> <option value="-1">请选择油画类型</option> <option value="1">现实主义</option> <option value="2">抽象主义</option> </select> </li> <li> <span>油画价格</span> <span id="errPrice"></span> <input id="price" name="price" onblur="checkPrice(this)" /> </li> <li> <span>作品预览</span> <span id="errPainting"></span> <input id="painting" name="painting" type="file" style="padding-left: 0px;" accept="image/*" onchange="checkFile(this)"/> </li> <li> <span>详细描述</span> <span id="errDescription"></span> <textarea id="description" name="description" onblur="checkEmpty(this)" ></textarea> </li> <li style="text-align: center;"> <button type="submit" class="btn-button">提交表单</button> </li> </ul> </form> Servlet 3.0 内置文件上传功能 // location: 用于指定文件存储的位置。如果不指定，文件会存储在临时目录中，通常是系统临时目录。 // fileSizeThreshold: 上传文件的大小阈值，如果文件大小超过这个值，文件会被写入磁盘；否则，文件会保存在内存中。 // maxFileSize: 单个文件的最大允许大小。如果上传的文件超过这个大小，将会抛出 IllegalStateException。 // maxRequestSize: 请求的最大允许大小，包括所有上传的文件和表单数据。如果请求大小超过这个值，将会抛出 IllegalStateException。 @MultipartConfig( location = "C:/TEMP", fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 10, maxRequestSize = 1024 * 1024 * 50 ) public class ManagementController extends HttpServlet { //.. private void showCreate(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getRequestDispatcher("/WEB-INF/jsp/create.jsp").forward(req, resp); } private void create(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //在 Servlet 环境中getRealPath返回的是 web 应用的根目录 //在 Spring Boot 中,因为打包为一个可执行的 JAR 或 WAR 文件, 是编译后的资源路径, 因此不可用getRealPath Path uploadPath = Paths.get(getServletContext().getRealPath(""), "upload"); //尝试创建指定的目录及其所有父目录。如果目标目录已经存在，方法会成功返回 Files.createDirectories(uploadPath); Part filePart = req.getPart("painting"); String uniqueFileName = generateUniqueFileName(Paths.get(filePart.getSubmittedFileName()).getFileName().toString()); //当前路径与给定路径片段合并, resolve 方法会处理路径的规范化，例如去除冗余的分隔符或当前路径符号（"."） Path destFile = uploadPath.resolve(uniqueFileName); try (InputStream input = filePart.getInputStream()) { Files.copy(input, destFile, StandardCopyOption.REPLACE_EXISTING); //存在则覆盖 } //.. } //.. } apache commons fileupload组件 private void create(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //使用apache commons fileupload组件, 与@MultipartConfig互斥 try { List<FileItem> formData = new ServletFileUpload(new DiskFileItemFactory()).parseRequest(req); Painting painting = new Painting(); for (FileItem fileItem : formData) { if (fileItem.isFormField()) {//判断是普通字段还是文件上传项,所有非文件上传项都被视为普通表单字段 String fieldValue = fileItem.getString("UTF-8"); switch (fileItem.getFieldName()) { //字段名称,即表单中的name属性值 case "pname": painting.setPname(fieldValue); break; case "category": painting.setCategory(Integer.parseInt(fieldValue)); break; case "price": painting.setPrice(Integer.parseInt(fieldValue)); break; case "description": painting.setDescription(fieldValue); break; } } else { String uploadPath = Paths.get(getServletContext().getRealPath(""), "upload").toString(); String rawFileName = fileItem.getName(); String fileName = UUID.randomUUID() + rawFileName.substring(rawFileName.lastIndexOf(".")); String destFile = uploadPath + File.separator + fileName; fileItem.write(new File(destFile)); painting.setPreview(File.separator + "upload" + File.separator + fileName); } } paintingService.create(painting); resp.sendRedirect("/management?method=list"); } catch (Exception e) { throw new RuntimeException(e); } } 修改 修改与新增的最大不同是在修改前要加载原有数据 在修改页面放置hidden隐藏域保存id编号, 随表单提交 对xml更新时, 先按id获取原始记录, 在此基础上覆盖更新 表单回填 <script> $(function () { $("#category").val(&#36;{painting.category}) }); function selectPreview(){ checkFile(document.getElementById("painting")); $("#preview").hide(); $("#isPreviewModified").val(1); } function checkSubmit2() { var validPname = checkEmpty(document.getElementById("pname")); var validCategory = checkCategory(document.getElementById("category")); var validPrice = checkPrice(document.getElementById("price")); var validPainting = false; if($("#isPreviewModified").val() === "1"){ validPainting = checkFile(document.getElementById("painting")); }else{ validPainting = true; } var validDescription = checkEmpty(document.getElementById("description")); return validPname && validCategory && validPrice && validPainting && validDescription; } </script> <form action="/management?method=update" method="post" autocomplete="off" enctype="multipart/form-data" onsubmit="return checkSubmit2()"> <ul class="ulform"> <li> <span>油画名称</span> <span id="errPname"></span> <input id="pname" name="pname" onblur="checkEmpty(this)" value="&#36;{painting.pname}" /> </li> <li> <span>油画类型</span> <span id="errCategory"></span> <select id="category" name="category" onchange="checkCategory(this)"> <option value="-1">请选择油画类型</option> <option value="1">现实主义</option> <option value="2">抽象主义</option> </select> </li> <li> <span>油画价格</span> <span id="errPrice"></span> <input id="price" name="price" onblur="checkPrice(this)" value="&#36;{painting.price}" /> </li> <li> <span>作品预览</span> <span id="errPainting"></span><br/> <img id="preview" src="&#36;{painting.preview}" style="width:361px;height:240px"/><br/> <input type="hidden" id="isPreviewModified" name="isPreviewModified" value="0"> <input id="painting" name="painting" type="file" style="padding-left: 0px;" accept="image/*" onchange="selectPreview()"/> </li> <li> <span>详细描述</span> <span id="errDescription"></span> <textarea id="description" name="description" onblur="checkEmpty(this)">&#36;{painting.description}</textarea> </li> <li style="text-align: center;"> <input type="hidden" id="id" name="id" value="&#36;{painting.id}" /> <button type="submit" class="btn-button">提交表单</button> </li> </ul> </form> update private void showUpdate(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String id = req.getParameter("id"); Painting painting = paintingService.findById(Integer.parseInt(id)); req.setAttribute("painting",painting); req.getRequestDispatcher("/WEB-INF/jsp/update.jsp").forward(req,resp); } private void update(HttpServletRequest req, HttpServletResponse resp) { int isPreviewModified = 0; try { List<FileItem> formData = new ServletFileUpload(new DiskFileItemFactory()).parseRequest(req); Painting painting = new Painting(); for (FileItem fileItem : formData) { if (fileItem.isFormField()) { String fieldValue = fileItem.getString("UTF-8"); switch (fileItem.getFieldName()) { case "id": painting.setId(Integer.parseInt(fieldValue)); break; case "pname": painting.setPname(fieldValue); break; case "category": painting.setCategory(Integer.parseInt(fieldValue)); break; case "price": painting.setPrice(Integer.parseInt(fieldValue)); break; case "description": painting.setDescription(fieldValue); break; case "isPreviewModified": isPreviewModified = Integer.parseInt(fieldValue); } } else { if (isPreviewModified == 1){ String uploadPath = Paths.get(getServletContext().getRealPath(""), "upload").toString(); String rawFileName = fileItem.getName(); String fileName = UUID.randomUUID() + rawFileName.substring(rawFileName.lastIndexOf(".")); String destFile = uploadPath + File.separator + fileName; fileItem.write(new File(destFile)); painting.setPreview(File.separator + "upload" + File.separator + fileName); } } } paintingService.update(painting, isPreviewModified); resp.sendRedirect("/management?method=list"); } catch (Exception e) { throw new RuntimeException(e); } } 删除 public void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { try { paintingService.delete(Integer.parseInt(request.getParameter("id"))); response.getWriter().println("{\"result\":\"ok\"}"); }catch(Exception e) { response.getWriter().println("{\"result\":\"" + e.getMessage() + "\"}"); e.printStackTrace(); } }`,``,`html`,`MyBatis`,`20240415121153-_数据库 框架提倡"不要重复造轮子" MyBatis 可以自动处理 java.util.Date 类型的转换，无需手动将其转换为 java.sql.Date ORM框架 ORM框架（Object-Relational Mapping，对象-关系映射）是一种编程技术，用于在关系型数据库和面向对象编程语言之间建立一种映射关系，从而实现通过面向对象的方式来操作数据库。 ORM框架的主要目标是消除数据库和应用程序之间的耦合，简化数据库操作，提高开发效率。 ORM框架通常通过以下方式实现对象和数据库表之间的映射关系： 对象和表的映射： ORM框架将每个对象映射到数据库中的一张表，对象的属性对应表的列。 关系映射： ORM框架可以处理对象之间的关系，如一对一、一对多、多对多等关系，并将其映射到数据库中的外键关系。 CRUD操作： ORM框架提供了类似于创建（Create）、读取（Read）、更新（Update）、删除（Delete）等方法，用于对数据库进行操作，开发者无需编写SQL语句。 性能优化： ORM框架通常提供了缓存、延迟加载、批量操作等功能，用于优化数据库访问性能。 常见的ORM框架包括Hibernate、MyBatis、Entity Framework等，它们在不同的编程语言和平台上提供了ORM的实现，使开发者能够更方便地使用面向对象的方式来操作数据库。 mybatis开发步骤 依赖 <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.9</version> </dependency> 与spring整合时 <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>5.3.19</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.9</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>2.0.3</version> </dependency> 配置文件 <?xml version="1.0" encoding="UTF-8" ?> <!-- PUBLIC：表示这是一个公开的DTD。 "-//mybatis.org//DTD Config 3.0//EN"：这是该DTD的公共标识符（Public Identifier）。它包含了以下信息： -//：这通常用于表示这是一个由组织定义的DTD。 mybatis.org：表示定义此DTD的组织是MyBatis。 DTD Config 3.0：表示此DTD是针对MyBatis配置版本3.0的。 EN：表示此DTD是用英语编写的。 --> <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> <configuration> <environments default="dev"> <environment id="dev"> <!-- 采用JDBC方式对数据库进行事务管理commit/rollback --> <transactionManager type="JDBC"/> <!-- 采用连接池方式管理数据库连接 --> <dataSource type="POOLED"> <property name="driver" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;characterEncoding=utf-8"/> <property name="username" value="root"/> <property name="password" value="root"/> </dataSource> </environment> <environment id="prd"> <transactionManager type="JDBC"/> <dataSource type="POOLED"> <property name="driver" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://192.168.206.133:3306/babytun?useUnicode=true&amp;characterEncoding=utf-8"/> <property name="username" value="root"/> <property name="password" value="root"/> </dataSource> </environment> </environments> </configuration> 工具类 public class MybatisUtils { private static final SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsReader("mybatis-config.xml")); } catch (IOException e) { throw new ExceptionInInitializerError(e); } } public static Object excuteQuery(Function<SqlSession, Object> func) { SqlSession sqlSession = sqlSessionFactory.openSession(); try { return func.apply(sqlSession); } finally { sqlSession.close(); //如果使用了连接池则将连接回收,否则将连接关闭 } } public static Object executeUpdate(Function<SqlSession, Object> func) { SqlSession sqlSession = sqlSessionFactory.openSession(false); //关闭自动commit try { Object object = func.apply(sqlSession); sqlSession.commit(); return object; } catch (RuntimeException e) { sqlSession.rollback(); throw e; } finally { sqlSession.close(); } } } 实体类 Goods mapper映射文件 <?xml version="1.0" encoding="UTF-8" ?> <!-- 注意声明和mybatis-config.xml不同, 根标签为mapper,dtd地址为mybatis-3-mapper --> <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> <!-- mapper需要在mybatis-config.xml中注册 --> <mapper namespace="goods"> <!-- parameterType 和 resultType, [数字包装类,String,Map]可以直接使用类型名称而不需要完整包名 --> <select id="selectAll" resultType="com.ida.demo3.mybatis.entity.Goods"> select * from t_goods order by goods_id desc limit 10 </select> </mapper> 注册mapper文件 mybatis-config.xml <!-- .. --> </configuration> <settings> <!-- goods_id == goodsId --> <setting name="mapUnderscoreToCamelCase" value="true"/> </settings> <!-- .. --> <mappers> <!-- 开头不用加斜杠 --> <mapper resource="mappers/goods.xml"/> </mappers> </configuration> 使用 mybatis的两种传值方式 &#36;{},文本替换,未经任何处理 #{},预编译传值 查询 <!-- 传入单个参数使用#{value}提取 --> <select id="selectById" parameterType="Integer" resultType="com.ida.demo3.mybatis.entity.Goods"> select * from t_goods where goods_id=#{value} </select> <!-- 传入多个参数用Map包装,使用#{key}提取 --> <select id="selectByPriceRange" parameterType="Map" resultType="com.ida.demo3.mybatis.entity.Goods"> select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0, #{count} </select> @Test public void case3() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); //无参数 List<Goods> list = sqlSession.selectList("goods.selectAll"); list.forEach(System.out::println); //单参 Goods goods = sqlSession.selectOne("goods.selectById", 1001); System.out.println(goods); //多参 Map params = new HashMap(); params.put("min",100); params.put("max",200); params.put("count",5); List<Goods> list2 = sqlSession.selectList("goods.selectByPriceRange", params); list2.forEach(System.out::println); } catch (Exception e) { throw new RuntimeException(e); } finally { MybatisUtils.closeSession(sqlSession); } } @Test public void case1() { String result = (String) MybatisUtils.executeQuery(sqlSession -> sqlSession.selectOne("test.A")); System.out.println(result); } <!-- 多表关联, LinkedHashMap让结果字段有按原表字段顺序, 结果字段类型根据表结构自动推断 --> <select id="selectGoodsMap" parameterType="Map" resultType="java.util.LinkedHashMap"> select g.*,c.category_name from t_goods g join t_category c on g.category_id=c.category_id where g.current_price between #{min} and #{max} order by g.current_price limit 0, #{count} </select> <!-- 多表关联, 结果使用DTO承载(明确类型), dto在持有原实体对象的基础上增加额外字段 --> <!-- private Goods goods; private String categoryName; private String test; --> <resultMap id="rmGoods" type="com.ida.demo3.mybatis.dto.GoodsDTO"> <!-- 主键映射,结果中的字段映射到dto中的属性, 属性为对象时可以通过对象.属性 --> <id column="goods_id" property="goods.goodsId"/> <!-- 非主键映射 --> <result column="title" property="goods.title"/> <result column="sub_title" property="goods.subTitle"/> <result column="original_cost" property="goods.originalCost"/> <result column="current_price" property="goods.currentPrice"/> <result column="discount" property="goods.discount"/> <result column="is_free_delivery" property="goods.isFreeDelivery"/> <result column="category_id" property="goods.categoryId"/> <result column="category_name" property="categoryName"/> <result column="test" property="test"/> </resultMap> <select id="selectGoodsDTO" parameterType="Map" resultMap="rmGoods"> select g.*, c.category_name, 't' test from t_goods g join t_category c on g.category_id=c.category_id where g.current_price between #{min} and #{max} order by g.current_price limit 0, #{count} </select> @Test public void case4() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); Map params = new HashMap(); params.put("min",100); params.put("max",200); params.put("count",5); //多表关联, 结果使用LinkedHashMap承载 List<Map> results = sqlSession.selectList("goods.selectGoodsMap",params); for (Map map : results) { System.out.println(map); } //多表关联, 结果使用DTO承载 List<GoodsDTO> results2 = sqlSession.selectList("goods.selectGoodsDTO",params); for (GoodsDTO goodsDTO : results2) { System.out.println(goodsDTO); } } catch (Exception e) { throw new RuntimeException(e); } finally { MybatisUtils.closeSession(sqlSession); } } 更新 注意手动提交和异常回滚 获取数据库在插入操作后生成的主键值 selectKey 在插入数据之前或之后，使用一个额外的查询来获取主键值。可以用于支持复杂的主键生成策略, 适用于更多数据库和复杂情况 useGeneratedKeys 用于获取数据库在插入操作后生成的主键值。这种方式通常在 JDBC 中使用 Statement.RETURN_GENERATED_KEYS 实现, 适合主键由数据库自动生成的简单情况 <!-- selectKey标签需要显式获取编写最新主键的SQL语句 selectKey适用于所有的关系型数据库 insert into执行完后执行select last_insert_id(),返回当前会话中最后插入的自增id将其填充到对象的goodsId --> <insert id="insertGoods" parameterType="com.ida.demo3.mybatis.entity.Goods"> insert into t_goods(title,sub_title,original_cost,current_price,discount,is_free_delivery,category_id) values (#{title},#{subTitle},#{originalCost},#{currentPrice},#{discount},#{isFreeDelivery},#{categoryId}) <selectKey resultType="Integer" keyProperty="goodsId" order="AFTER"> select last_insert_id() </selectKey> </insert> <!-- useGeneratedKeys属性会自动跟据驱动生成对应的sql语句 useGeneratedKeys只支持"自增主键"类型的数据库 --> <insert id="insertGoods2" parameterType="com.ida.demo3.mybatis.entity.Goods" useGeneratedKeys="true" keyProperty="goodsId" keyColumn="goods_id"> insert into t_goods(title,sub_title,original_cost,current_price,discount,is_free_delivery,category_id) values (#{title},#{subTitle},#{originalCost},#{currentPrice},#{discount},#{isFreeDelivery},#{categoryId}) </insert> @Test public void case5() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle("测试商品"); goods.setSubTitle("说明"); goods.setOriginalCost(100f); goods.setCurrentPrice(80f); goods.setDiscount(0.8f); goods.setIsFreeDelivery(1); goods.setCategoryId(2); //返回插入的记录数 int cnt = sqlSession.insert("goods.insertGoods2", goods); //提交事务 sqlSession.commit(); //插入成功后将id回填到对象方便后续处理 System.out.println(goods.getGoodsId()); } catch (Exception e) { //回滚事务 if (sqlSession != null) { sqlSession.rollback(); } throw new RuntimeException(e); } finally { MybatisUtils.closeSession(sqlSession); } } <update id="update" parameterType="com.ida.demo3.mybatis.entity.Goods"> update t_goods set title = #{title}, sub_title=#{subTitle} where goods_id=#{goodsId}; </update> <delete id="delete" parameterType="Integer"> delete from t_goods where goods_id=#{value} </delete> @Test public void case6() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); Goods goods = sqlSession.selectOne("goods.selectById", 1933); goods.setTitle("测试商品beta"); //返回修改的记录数 int cnt = sqlSession.update("goods.update", goods); //返回删除的记录数 //int cnt = sqlSession.delete("goods.delete",1933); //提交事务 sqlSession.commit(); } catch (Exception e) { //回滚事务 if (sqlSession != null) { sqlSession.rollback(); } throw new RuntimeException(e); } finally { MybatisUtils.closeSession(sqlSession); } } 动态SQL 根据参数数据动态组织SQL MyBatis中使用类似EL的OGNL表达式来构建动态SQL语句 <!-- where标签会根据条件结果重新组织语句使语法正确,例如去掉多余and --> <!-- if标签中,大于小于需要写成转义符 --> <select id="dynamicSQL" parameterType="Map" resultType="com.ida.demo3.mybatis.entity.Goods"> select * from t_goods <where> <if test="categoryId !=null"> and category_id=#{categoryId} </if> <if test="currentPrice !=null"> and current_price &lt; #{currentPrice} </if> </where> </select> @Test public void case7() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); Map params = new HashMap(); //可选条件 //params.put("categoryId", 14); params.put("currentPrice", 300); List<Goods> list = sqlSession.selectList("goods.dynamicSQL", params); list.forEach(System.out::println); } catch (Exception e) { throw new RuntimeException(e); } finally { MybatisUtils.closeSession(sqlSession); } } 二级缓存 20240415155150.webp 一级缓存作用范围SqlSession会话,默认开启 二级缓存作用范围Mapper Namespace,需要手动开启 二级缓存开启后默认所有查询操作均使用缓存 select标签中配置useCache="false"不使用缓存 useCache 在 select 中默认值为 true select标签中配置flushCache="true"强制清空缓存 flushCache 在 select 中默认值为 false，在 insert、update 和 delete 中默认值为 true commit提交后对该namespace缓存强制清空 <?xml version="1.0" encoding="UTF-8" ?> <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> <mapper namespace="goods"> <!-- 手动开启二级缓存 eviction是缓存的清除策略,当缓存对象数量达到size值时,触发对应算法对缓存对象进行选择性清除 LRU: 最近最久未使用,移除最长时间不被使用的对象 (对象) 1, 2, 3.. 512 (时长) 14, 99, 13.. 76 当新缓存进入时,移除时长最大的第2个对象,又一个缓存进入时,移除第512个对象 LFU: 移除最近访问频率最低的对象 (对象) 1, 2, 3.. 512 (次数) 14, 99, 13.. 76 当新缓存进入时,移除访问次数最低的第3个对象 FIFO: 先进先出,按进入缓存的顺序来移除对象 SOFT: 软引用,移除基于jvm垃圾收集器状态和软引用规则的对象 WEAK: 弱引用,更积极地移除基于jvm垃圾收集器状态和软引用规则的对象 flushInterval自动清除缓存的时间间隔(毫秒) size缓存数量上限,对象或集合 不建议将查询结果集合作为缓存对象,其缓存命中率(Cache Hit Ratio)很低且内存占用大,而应该缓存像商品id这样的对象,size大于总id数 readOnly true,返回只读缓存,取出的是缓存对象本身,执行效率高 false,返回缓存对象的副本,安全性较高 --> <cache eviction="LRU" flushInterval="600000" size="512" readOnly="true"/> <select id="selectAll" resultType="com.ida.mybatis.entity.Goods" useCache="false" flushCache="true"> select * from t_goods order by goods_id desc limit 10 </select> </mapper> @Test public void lv1Cache() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); Goods goods = sqlSession.selectOne("selectById", 800); Goods goods1 = sqlSession.selectOne("selectById", 800); System.out.println(goods.hashCode()+":"+goods1.hashCode());//1670546046:1670546046 } catch (Exception e) { throw e; } finally { MybatisUtils.closeSession(sqlSession); } SqlSession sqlSession2 = null; try { sqlSession2 = MybatisUtils.openSession(); Goods goods = sqlSession2.selectOne("selectById", 800); sqlSession2.commit(); Goods goods1 = sqlSession2.selectOne("selectById", 800); System.out.println(goods.hashCode()+":"+goods1.hashCode());//1138410383:875313400 } catch (Exception e) { throw e; } finally { MybatisUtils.closeSession(sqlSession2); } } @Test public void lv2Cache() { String r1 = ""; String r2 = ""; SqlSession sqlSession = null; try { sqlSession = MyBatisUtils.openSession(); Goods goods = sqlSession.selectOne("selectById", 800); r1 = String.valueOf(goods.hashCode()); } catch (Exception e) { throw e; } finally { MyBatisUtils.close(sqlSession); } SqlSession sqlSession2 = null; try { sqlSession2 = MyBatisUtils.openSession(); Goods goods = sqlSession2.selectOne("selectById", 800); r2 = String.valueOf(goods.hashCode()); } catch (Exception e) { throw e; } finally { MyBatisUtils.close(sqlSession2); } //开启二级缓存后 //Cache Hit Ratio [goods]: 0.5 ,缓存命中率越大,缓存使用效率越高 System.out.println(r1);//977552154 System.out.println(r2);//977552154 } 对象关联查询 结果是List时使用collection标签, 单个对象时使用association标签 goods_detail.xml <mapper namespace="goods_detail"> <select id="selectByGoodsId" parameterType="Integer" resultType="com.ida.demo3.mybatis.entity.GoodsDetail"> select * from t_goods_detail where goods_id=#{value} </select> <!-- 将结果包装为GoodsDetail association标签 把表中goods_id字段代入另一个mapper的查询语句,所得的结果赋给GoodsDetail的goods属性 --> <resultMap id="rmGoodsDetail" type="com.ida.demo3.mybatis.entity.GoodsDetail"> <id column="gd_id" property="gdId"/> <!-- goods_id字段被association使用了,导致GoodsDetail对象的goodsId属性无值,需要手动映射一次 --> <result column="goods_id" property="goodsId"/> <association select="goods.selectById" column="goods_id" property="goods"/> </resultMap> <select id="selectGoodsDetailIncludeGoods" resultMap="rmGoodsDetail"> select * from t_goods_detail limit 0,20 </select> </mapper> goods.xml <!-- 将得到的结果包装为Goods对象,此处不需要result标签,因为t_goods可以对应上Goods对象中的属性 对每一个Goods对象,调用另一个mapper文件中的sql语句传入goods_id 将返回结果赋值给该对象的goodsDetails属性 --> <resultMap id="rmGoods2" type="com.ida.demo3.mybatis.entity.Goods"> <id column="goods_id" property="goodsId"/> <collection select="goods_detail.selectByGoodsId" column="goods_id" property="goodsDetails"/> </resultMap> <select id="selectGoodsIncludeDetails" resultMap="rmGoods2"> select * from t_goods limit 0,5 </select> public class Goods { private Integer goodsId; //.. private List<GoodsDetail> goodsDetails; } @Test public void case9(){ SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); List<Goods> list = sqlSession.selectList("goods.selectGoodsIncludeDetails"); list.forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } finally { MybatisUtils.closeSession(sqlSession); } } @Test public void case10(){ SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); List<GoodsDetail> list = sqlSession.selectList("goods_detail.selectGoodsDetailIncludeGoods"); list.forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } finally { MybatisUtils.closeSession(sqlSession); } } 分页插件PageHelper 依赖 <dependency> <groupId>com.github.pagehelper</groupId> <artifactId>pagehelper</artifactId> <version>5.1.10</version> </dependency> <dependency> <groupId>com.github.jsqlparser</groupId> <artifactId>jsqlparser</artifactId> <version>2.0</version> </dependency> 配置 mybatis-config.xml <configuration> <plugins> <plugin interceptor="com.github.pagehelper.PageInterceptor"> <!-- 选择语句方言 --> <property name="helperDialect" value="mysql"/> <!-- pageNum小于0时查询第一页,大于pages时查询最后一页,默认false --> <property name="reasonable" value="true"/> </plugin> </plugins> .. <configuration> @Test public void selectPage() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); PageHelper.startPage(2,10); //语句里不能再有limit Page page = (Page) sqlSession.selectList("goods.selectAll2"); System.out.println("总页码"+page.getPages()); System.out.println("总记录数"+page.getTotal()); System.out.println("当前页码"+page.getPageNum()); System.out.println("当前页码开始行"+page.getStartRow()); System.out.println("当前页码结束行"+page.getEndRow()); //当前页数据 List<Goods> list = page.getResult(); list.forEach(System.out::println); } catch (Exception e) { throw e; } finally { MybatisUtils.closeSession(sqlSession); } } 替代MyBatis自带连接池 HikariCP: 社区活跃，广泛应用于各种大中型Java项目中。其代码库较新，设计现代化，稳定性高。 整体发音为“hee-kah-ree see-pee" Spring Boot中，默认的MySQL连接池是由HikariCP提供的 C3P0: 由于其历史悠久，社区支持相对减少，但仍然在一些老旧系统中使用。其代码库较老，维护频率较低。 Druid: 在中国的Java开发者中非常流行，由阿里巴巴提供支持，社区活跃，稳定性高，适合大多数场景 HikariCP适合追求极高性能、低延迟、简单配置的应用，尤其是在现代高并发环境中。 C3P0适合一些老旧的Java项目，或者需要某些特定功能但对性能要求不高的场景。 Druid适合需要全面监控、SQL分析以及在中国环境下应用的项目，尤其是对功能需求多样化的场景。 自带连接池 mybatis-config.xml <environment id="prd"> <transactionManager type="JDBC"/> <dataSource type="POOLED"> <property name="driver" value="com.mysql.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/babytun?useUnicode=true&characterEncoding=UTF-8"/> <property name="username" value="root"/> <property name="password" value="rootmysql"/> </dataSource> </environment> HikariCP <dependency> <groupId>com.zaxxer</groupId> <artifactId>HikariCP</artifactId> <version>3.4.5</version> <!-- 适用于 Java 8 的 HikariCP 版本 --> </dependency> public class HikariCPDataSourceFactory extends UnpooledDataSourceFactory { public HikariCPDataSourceFactory(){ this.dataSource=new HikariDataSource(); } } <environment id="dev"> <transactionManager type="JDBC"/> <dataSource type="com.ida.demo4.datasource.HikariCPDataSourceFactory"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/oa?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai"/> <property name="username" value="root"/> <property name="password" value="root"/> <property name="poolName" value="MyHikariCPPool"/> <property name="maximumPoolSize" value="10"/> <property name="minimumIdle" value="5"/> <property name="idleTimeout" value="30000"/> <property name="connectionTimeout" value="30000"/> <property name="maxLifetime" value="1800000"/> <property name="connectionTestQuery" value="SELECT 1"/> </dataSource> </environment> poolName: 连接池的名称。 maximumPoolSize: 最大连接数。 minimumIdle: 最小空闲连接数。 idleTimeout: 空闲连接的超时时间（毫秒）。 connectionTimeout: 获取连接的超时时间（毫秒）。 maxLifetime: 连接的最大生命周期（毫秒）。 connectionTestQuery: 用于测试连接有效性的查询语句。 C3P0 <dependency> <groupId>com.mchange</groupId> <artifactId>c3p0</artifactId> <version>0.9.5.4</version> </dependency> import com.mchange.v2.c3p0.ComboPooledDataSource; import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory; public class C3P0DataSourceFactory extends UnpooledDataSourceFactory { //dataSource属于UnpooledDataSourceFactory,将它指向由c3p0创建的连接池 //其它连接池产品迁入时都需要类似操作 public C3P0DataSourceFactory() { this.dataSource = new ComboPooledDataSource(); } } <environment id="prd"> <transactionManager type="JDBC"/> <dataSource type="com.ida.demo3.mybatis.datasource.C3P0DataSourceFactory"> <property name="driverClass" value="com.mysql.jdbc.Driver"/> <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;characterEncoding=UTF-8"/> <property name="user" value="root"/> <property name="password" value="rootmysql"/> <property name="initialPoolSize" value="5"/> <property name="maxPoolSize" value="20"/> <property name="minPoolSize" value="5"/> </dataSource> </environment> druid <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.2.23</version> </dependency> public class DruidDataSourceFactory extends UnpooledDataSourceFactory { public DruidDataSourceFactory() { this.dataSource=new DruidDataSource(); } @Override public DataSource getDataSource() { try { ((DruidDataSource) this.dataSource).init(); } catch (SQLException e) { throw new RuntimeException(e); } return this.dataSource; } } <environment id="dev"> <transactionManager type="JDBC"/> <dataSource type="com.ida.demo4.datasource.DruidDataSourceFactory"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai"/> <property name="username" value="root"/> <property name="password" value="root"/> <property name="initialSize" value="10"/> <property name="maxActive" value="20"/>w </dataSource> </environment> 批处理 <!-- foreach标签 无法获得插入数据的自增id 批量生成sql语句超过网络数据包的限制大小时会被服务器拒绝,需要分组执行 --> <insert id="batchInsert" parameterType="java.util.List"> insert into t_goods(title,sub_title,original_cost,current_price,discount,is_free_delivery,category_id) values <foreach collection="list" item="item" separator=","> (#{item.title},#{item.subTitle},#{item.originalCost},#{item.currentPrice},#{item.discount},#{item.isFreeDelivery},#{item.categoryId}) </foreach> </insert> <insert id="batchDelete" parameterType="java.util.List"> delete from t_goods where goods_id in <foreach collection="list" item="id" open="(" close=")" separator=","> #{id} </foreach> </insert> @Test public void batchInsert() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); long s = System.currentTimeMillis(); int cnt = 0; for (int n=0;n<10;n++){ List<Goods> list = new ArrayList<>(); for (int i= 0;i<10000;i++){ Goods goods = new Goods(); goods.setTitle("测试商品"); goods.setSubTitle("副标题"); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); list.add(goods); } cnt += sqlSession.insert("goods.batchInsert",list); } sqlSession.commit(); System.out.println(cnt+":"+(System.currentTimeMillis()-s)); } catch (Exception e) { if (sqlSession != null) { sqlSession.rollback(); } throw e; } finally { MybatisUtils.closeSession(sqlSession); } } @Test public void batchDelete() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); List<Integer> list = new ArrayList<>(); for (int i=152679;i>2679;i--){ list.add(i); } int cnt = sqlSession.delete("goods.batchDelete",list); sqlSession.commit(); System.out.println("删除了"+cnt+"条数据"); } catch (Exception e) { if (sqlSession != null) { sqlSession.rollback(); } throw e; } finally { MybatisUtils.closeSession(sqlSession); } } MyBatis注解 20240416203417.webp <!-- mybatis-config.xml --> <configuration> <settings> <setting name="mapUnderscoreToCamelCase" value="true"/> </settings> .. <mappers> <!-- 扫描单个接口 --> <!-- <mapper class="com.ida.mybatis.dao.GoodsDAO"/> --> <!-- 扫描包下所有接口 --> <package name="com.ida.mybatis.dao"/> </mappers> </configuration> public interface GoodsDAO { @Select("select * from t_goods where current_price between #{min} and #{max} order by current_price desc limit #{limit}") List<Goods> selectByPriceRange(@Param("min") float min, @Param("max") float max, @Param("limit") int limit); @Select("select g.*, c.category_name, 't' test" + " from t_goods g join t_category c on g.category_id=c.category_id" + " where g.current_price between #{min} and #{max} order by g.current_price limit 0, #{count}") @Results({ @Result(column = "goods_id", property = "goods.goodsId", id = true), @Result(column = "title", property = "goods.title"), @Result(column = "sub_title", property = "goods.subTitle"), @Result(column = "original_cost", property = "goods.originalCost"), @Result(column = "currentPrice", property = "goods.currentPrice"), @Result(column = "discount", property = "goods.discount"), @Result(column = "is_free_delivery", property = "goods.isFreeDelivery"), @Result(column = "category_id", property = "goods.categoryId"), @Result(column = "category_name", property = "categoryName"), @Result(column = "test", property = "test") }) List<GoodsDTO> selectA(@Param("min") float min, @Param("max") float max, @Param("count") int count); @Insert("insert into t_goods (title,sub_title,original_cost,current_price,discount,is_free_delivery,category_id) " + "values (#{title},#{subTitle},#{originalCost},#{currentPrice},#{discount},#{isFreeDelivery},#{categoryId})") @SelectKey(resultType = int.class, keyProperty = "goodsId", before = false, statement = "select last_insert_id()") int insert(Goods goods); } @Test public void case11() { SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); GoodsDAO goodsDAO = sqlSession.getMapper(com.ida.demo3.mybatis.dao.GoodsDAO.class); List<Goods> list = goodsDAO.selectByPriceRange(500,1000,10); list.forEach(System.out::println); } catch (Exception e) { throw e; } finally { MybatisUtils.closeSession(sqlSession); } } @Test public void case12(){ SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); GoodsDAO goodsDAO = sqlSession.getMapper(com.ida.demo3.mybatis.dao.GoodsDAO.class); List<GoodsDTO> list = goodsDAO.selectA(500,1000,10); list.forEach(System.out::println); } catch (Exception e) { throw e; } finally { MybatisUtils.closeSession(sqlSession); } } @Test public void case13(){ SqlSession sqlSession = null; try { sqlSession = MybatisUtils.openSession(); GoodsDAO goodsDAO = sqlSession.getMapper(com.ida.demo3.mybatis.dao.GoodsDAO.class); Goods goods = new Goods(); goods.setTitle("标题"); goods.setSubTitle("副标题"); goods.setOriginalCost(100f); goods.setCurrentPrice(50f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); int cnt = goodsDAO.insert(goods); sqlSession.commit(); System.out.println("插入了"+cnt+"条数据"+"id:"+goods.getGoodsId()); } catch (Exception e) { if (sqlSession != null) { sqlSession.rollback(); } throw e; } finally { MybatisUtils.closeSession(sqlSession); } } xml配置下实现Mapper接口 <!-- mybatis-config.xml --> <configuration"> .. <mappers> .. <mapper class="mappers/goods.xml"/> </mappers> </configuration> public interface GoodsDAO { List<Goods> selectB(); } public class GoodsService { public List<Goods> selectB(){ return (List)MybatisUtils.executeQuery(sqlSession -> { GoodsDao goodsDao = sqlSession.getMapper(GoodsDao.class);//自动创建接口实现类 return goodsDao.selectB(); }) } } <!-- goods.xml --> <!-- 空间命名为接口地址 --> <mapper namespace="com.ida.demo3.mybatis.dao.GoodsDAO"> <!-- id,参数,返回值类型与接口方法名,参数,返回值类型一致 --> <select id="selectB" resultType="com.ida.demo3.mybatis.entity.Goods"> select * from t_goods order by goods_id desc limit 10 </select> </mapper> MyBatis Generator 用于自动生成 MyBatis 的 Mapper 接口、XML 映射文件以及实体类。它通过读取数据库表的元数据，生成相应的代码，从而减少了手动编写代码的工作量。 插件坐标 <plugin> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-maven-plugin</artifactId> <version>1.3.7</version> <configuration> <verbose>true</verbose> <overwrite>true</overwrite> </configuration> </plugin> verbose: true 启用详细模式。设置为 true 时，插件在运行时会输出详细的日志信息 overwrite 在开发环境中启用覆盖，生产环境中禁用覆盖 true，插件每次生成代码时都会覆盖目标目录中的已有文件 false，插件不会覆盖目标目录中的文件。如果文件已经存在则略过 配置文件 generatorConfig.xml <?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"> <generatorConfiguration> <classPathEntry location="D:\Dropbox\workspace\maven\repository\mysql\mysql-connector-java\ 8.0.28\mysql-connector-java-8.0.28.jar"/><!--数据库驱动--> <context id="MysqlTables" targetRuntime="MyBatis3"> <property name="autoDelimitKeywords" value="true"/><!--如果数据库表中的字段名与 SQL 保留字冲突，可以使用限定符（例如 &#715;）来避免冲突--> <property name="beginningDelimiter" value="&#715;"/> <property name="endingDelimiter" value="&#715;"/> <commentGenerator> <property name="suppressDate" value="true"/><!-- 不在生成的代码中添加日期注释 --> <property name="suppressAllComments" value="true"/><!-- 不生成任何注释 --> </commentGenerator> <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1:3306/mall?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull" userId="root" password="root"> <property name="nullCatalogMeansCurrent" value="true"/><!-- 表示当前的 catalog 用于没有明确指定的表 --> </jdbcConnection><!--数据库链接信息, zeroDateTimeBehavior=convertToNull将 0000-00-00 00:00:00 这样的零日期值转换为 NULL，而不是返回一个无效的日期值或抛出异常--> <javaTypeResolver> <property name="forceBigDecimals" value="false"/><!-- 不强制将所有的浮点数类型映射为 BigDecimal --> </javaTypeResolver><!-- 配置 Java 类型解析器，用于处理数据库类型到 Java 类型的转换 --> <javaModelGenerator targetPackage="com.ida.demo14.model.pojo" targetProject="src/main/java"><!-- targetPackage: 指定生成的 Java 模型类的包名, 存放路径 --> <property name="enableSubPackages" value="true"/><!-- 启用子包生成 --> <property name="trimStrings" value="true"/><!-- 对 CHAR 类型的列进行 trim 操作 --> <property name="immutable" value="false"/><!-- 生成的模型类是否不可变（是否只包含构造方法而没有 setter 方法） --> </javaModelGenerator> <sqlMapGenerator targetPackage="mappers" targetProject="src/main/resources"> <property name="enableSubPackages" value="true"/> </sqlMapGenerator> <javaClientGenerator type="XMLMAPPER" targetPackage="com.ida.demo14.model.dao" targetProject="src/main/java"> <property name="enableSubPackages" value="true"/> </javaClientGenerator> <!-- tableName: 数据库中的表名。 domainObjectName: 生成的 Java 模型类的名称。 enableCountByExample, enableUpdateByExample, enableDeleteByExample, enableSelectByExample: 自动生成的辅助类, 启用或禁用根据 Example 生成相应的方法（例如，enableCountByExample="false" 表示不生成根据 Example 统计记录的代码）。 selectByExampleQueryId: 是否生成查询方法的 ID（通常用于 XML 映射文件中）。 --> <table tableName="mall_cart" domainObjectName="Cart" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"> </table> </context> </generatorConfiguration> 自动生成的辅助类 生成器会根据你的数据库表结构自动创建这些类，并生成各种方法来支持常见的查询操作（如等于、不等于、大于、小于、模糊匹配等） xxExample 类是 MyBatis Generator 生成的一个辅助类，用于构建查询条件。它的作用是封装查询条件的构造逻辑，让你可以使用链式调用的方式来定义复杂的查询条件 public Map testUserExample() { Map map = new HashMap<>(); UserExample example = new UserExample(); example.createCriteria().andUsernameLike("%你%"); //查询条件, username字段中包含"你"的记录 List users = userMapper.selectByExample(example); //获取所有符合查询条件的记录 long count = userMapper.countByExample(example); //获取所有符合查询条件的记录的总数 map.put("users",users); map.put("count",count); return map; } andFieldEqualTo(value):等于指定值 andFieldNotEqualTo(value):不等于指定值 andFieldGreaterThan(value):大于指定值 andFieldGreaterThanOrEqualTo(value):大于或等于指定值 andFieldLessThan(value):小于指定值 andFieldLessThanOrEqualTo(value):小于或等于指定值 andFieldLike(value):模糊匹配（前后匹配） andFieldNotLike(value):不匹配指定模式 andFieldBetween(value1, value2):在指定范围内 andFieldNotBetween(value1, value2):不在指定范围内 andFieldIn(values):在指定集合中 andFieldNotIn(values):不在指定集合中 andFieldIsNull():字段值为 NULL andFieldIsNotNull():字段值不为 NULL Spring Boot中的MyBatis配置 Spring Boot 的核心特性之一就是自动配置。它根据项目中的依赖自动配置一些默认的 bean Spring Boot 会自动配置一个数据源（DataSource），并根据配置文件（application.properties 或 application.yml）设置数据源的属性，如 URL、用户名和密码。 DataSource 的配置由 Spring Boot 的 DataSourceAutoConfiguration 类处理，并且如果没有指定其他配置，Spring Boot 会使用 HikariCP 作为默认连接池。 mybatis-spring-boot-starter 是 MyBatis 官方提供的 Spring Boot 启动器，用于简化 MyBatis 在 Spring Boot 应用中的配置。 它会从 Spring Boot 配置中读取必要的参数，并创建一个配置好的 SqlSessionFactory 实例。并扫描项目中的 MyBatis 配置文件（mybatis-config.xml）以及注解驱动的配置。 映射文件地址,字段名转换 application.properties mybatis.mapper-locations=classpath:mappers/*.xml mybatis.configuration.map-underscore-to-camel-case=true mapper接口类地址 @MapperScan 注解的配置是通过 Java 代码进行的，不支持直接在 application.properties 文件中设置 mapper接口类上不用再标记@Mapper @SpringBootApplication @MapperScan(basePackages = "com.ida.demo14.model.dao") public class Demo14Application { public static void main(String[] args) { SpringApplication.run(Demo14Application.class, args); } }`,``,`html`,`MySQL`,`20240424154238-_数据库 mysql使用锁来防止其他事务在特定条件下修改或访问同一数据行,如行级锁,表级锁 mysql会检测是否存在死锁,并会选择一个死锁的事务进行回滚,确保系统中至少有一个事务可以继续执行 windows下安装后使用configurator配置密码, 将mysql的bin目录加入系统PATH 命令行测试 mysql --version mysql -uroot -p show databases; exit 在idea中添加mysql数据源 配置文件 windows配置文件名为my.ini linux中配置文件名为my.cnf [client] #图形界面 port=3306 [mysql] #命令行客户端 #有报警时主机上的蜂鸣器不要响 no-beep [mysqld] #数据库设置 port=3306 #进行数据目录迁移时,将Data文件夹移动到目标位置后,修改此地址,命令行关闭重启服务生效 datadir=C:/ProgramData/MySQL/MySQL Server 8.3/Data authentication_policy=*,, #INNODB支持事务机制 default-storage-engine=INNODB #开启严格模式,未开启时,例如一个规定为字符串格式的内容如果传入了一个整数,则自动将其转换为字符串 sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" # #用文件记录日志 log-output=FILE #0关闭日志输出,1开启 general-log=0 #自定义日志文件名 general_log_file="DESKTOP-D4A35C8.log" #开启慢查询日志 slow-query-log=1 #自定义慢查询日志文件名 slow_query_log_file="DESKTOP-D4A35C8-slow.log" #大于多少秒的SQL查询会被记录在慢查询日志 long_query_time=10 #自定义错误日志文件名 log-error="DESKTOP-D4A35C8.err" log-bin="DESKTOP-D4A35C8-bin" #数据库id,集群时才有意义 server-id=1 #开启表名自动转小写 lower_case_table_names=1 #导入导出数据时的文件中转地址 secure-file-priv="C:/ProgramData/MySQL/MySQL Server 8.3/Uploads" #最大连接数 max_connections=151 #linux下参考配置 [client] port=3306 [mysql] no-beep [mysqld] #服务端口号 默认3306 port = 3306 #mysql安装根目录 basedir = /usr/local/mysql #mysql数据文件所在位置 datadir = /usr/local/mysql/data #密码认证插件 default_authentication_plugin=caching_sha2_password #默认存储引擎 default-storage-engine=INNODB #开启严格模式 sql-mode="STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION" #用文件记录日志 log-output=FILE #关闭日志输出 general-log=0 #日志文件名称 general_log_file="DESKTOP-HB42AU2.log" 开启慢查询日志 slow_query_log = 1 #慢查询日志文件名称 slow_query_log_file = slow.log #大于多少秒的执行SQL被记录在慢查询日志 long_query_time=10 #数据库ID server-id=1 #把表名转换为小写 lower_case_table_names=1 #导入导出数据的目录地址 sercure-file-priv= "/usr/local/mysql/uploads" #最大连接数 max_connections=151 table_open_cache=2000 tmp_table_size=16M #线程数量 thread_cache_size=10 myisam_max_sort_file_size=100G myisam_sort_buffer_size=8M key_buffer_size=8M read_buffer_size=0 read_rnd_buffer_size=256K sort_buffer_size=256K 参数名称:含义:典型值 port:MySQL 服务的监听端口号:3306 bind-address:MySQL 服务绑定的IP地址:0.0.0.0（绑定所有IP地址）或 127.0.0.1（仅本地访问） max_connections:允许的最大并发连接数:151（默认），可以设置为 500 或更多，取决于需求和硬件资源 default-storage-engine:默认的存储引擎:InnoDB（推荐）或 MyISAM innodb_buffer_pool_size:InnoDB缓冲池大小，用于缓存数据和索引:128M（默认），可以设置为 1G 或更多，取决于内存大小和数据量 query_cache_size:查询缓存大小:0（默认禁用），可以设置为 64M 或更多，取决于应用的查询特性 key_buffer_size:MyISAM键缓存大小:8M（默认），如果使用MyISAM，可以设置为 128M 或更多 table_open_cache:表缓存的数量:2000（默认），可以设置为 4000 或更多，取决于打开表的数量和内存大小 max_allowed_packet:服务器允许的最大通信包大小:16M（默认），可以设置为 64M 或更多，取决于应用需求 thread_cache_size:线程缓存大小:9（默认），可以设置为 50 或更多，取决于并发连接数和负载情况 log_error:错误日志文件路径:/var/log/mysql/error.log（典型路径），可以根据需要进行调整 slow_query_log:是否启用慢查询日志:1（启用）或 0（禁用），建议启用以监控慢查询 slow_query_log_file:慢查询日志文件路径:/var/log/mysql/slow.log（典型路径），可以根据需要进行调整 long_query_time:慢查询的时间阈值（秒）:10（默认），可以设置为 1 或更小，以捕捉更多慢查询 character-set-server:服务器字符集:utf8mb4（推荐）或 latin1 collation-server:服务器字符序:utf8mb4_general_ci（推荐）或 latin1_swedish_ci skip-networking:是否禁用网络访问:0（默认允许网络访问），可以设置为 1（禁用网络访问，仅允许本地连接） skip-name-resolve:是否禁用主机名解析:1（启用），可以提高性能 innodb_file_per_table:每个表使用独立的表空间:1（启用，推荐） 字符集 数据库编码方式 和 表编码方式 以及 插入数据（字符串）的编码方式 MySQL 5.7 及之前版本默认的字符集是 latin1 ，MySQL 8.0 版本默认的字符集是 utf8mb4 utf8 其实是 utf8mb3 的别名，只使用 1～3 个字节表示字符。 utf8mb4 使用 1～4 个字节表示字符，能够存储更多的 emoji 表情及任何新增的 Unicode 字符。 utf8mb4是utf8 字符集的超集 查看MYSQL数据库服务器和数据库字符集 SHOW VARIABLES WHERE Variable_name LIKE 'character\_set\_%' OR Variable_name LIKE 'collation%'; 修改系统字符集参数，这样以后创建的库表默认字符集就是 utf8mb4 vi /etc/my.cnf [mysqld] character-set-server = utf8mb4 collation-server = utf8mb4_general_ci # MySQL 服务器将不再执行字符集握手，而是直接使用服务器端的默认字符集来处理数据 # 忽略应用连接自己设置的字符编码，保持与全局设置一致 skip-character-set-client-handshake [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 修改数据库字符集 对于已经创建的数据库，如果原来是 utf8 字符集，则可以这么修改 alter database &#715;testdb&#715; CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 修改表及字段字符集 对于已经创建的表，修改全局及数据库的字符集并不会影响原表及字段的字符集。原有的 utf8 表可以采用如下方法修改 # 修改表字符集 alter table &#715;tb_name&#715; default character set utf8mb4; # 修改某字段字符集 alter table &#715;tb_name&#715; modify col_name varchar(20) character set utf8mb4; # 同时修改表及字段字符集 alter table &#715;tb_name&#715; CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; # 如果某个库里面表比较多 可以拼接出要执行的批量修改语句 SELECT CONCAT( 'ALTER TABLE ', TABLE_NAME, ' CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;') as alter_list FROM information_schema.&#715;TABLES&#715; WHERE TABLE_SCHEMA = 'testdb'; +----------------------------------------------------------------------------+ | alter_list | +----------------------------------------------------------------------------+ | ALTER TABLE a CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; | | ALTER TABLE b CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; | +----------------------------------------------------------------------------+ 数据类型 如果确定是整数，就用INT； 如果确定是小数，就用定点数DECIMAL(M,D) 如果是日期与时间，就用DATETIME 字段如果为非负数，就用UNSIGNED 支持位运算符 SELECT 5 & 3; SELECT id, value1, value2, value1 & value2 AS bitwise_and FROM bitwise_example; 整数类型： TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT(相当JAVA中LONG类型) 整型中有三个可选的属性，分别是数据显示宽度、无符号(UNSIGNED)、零填充(ZEROFILL) ZEROFILL（前导零） 只是影响数据的展示，存储的数据仍然是实际的整数值，只有在检索数据时才会被填充零。 id INT(5) ZEROFILL, 零填充对于需要显示特定格式的数据非常有用，比如需要显示订单号、客户编号或者其他类似标识符时，保持固定长度可以使数据更易于阅读和比较。 浮点类型： FLOAT、DOUBLE 定点数类型： DECIMAL(M, D): 定点数类型，用于精确存储数值，M 是数字的最大位数(整数位数加上小数位数)，D 是小数位的位数。 price DECIMAL(10, 2) NOT NULL, 表示最大长度为10位，其中小数点后有2位，因此这个字段可以存储的最大值是 99999999.99 位类型： BIT 日期时间类型： YEAR、TIME、DATE、DATETIME、TIMESTAMP 在32位系统中，时间戳的最大值为2,147,483,647秒，这个值对应于UTC时间2038年1月19日03:14:07。当时间戳超过这个值时，32位整数会溢出，从而导致时间戳变为负数，回到1970年或更早的时间。 TIMESTAMP 类型直接使用Unix时间戳存储时间数据，在32位系统上会受到2038年问题的影响。 而DATETIME 类型使用自定义格式存储时间数据，不受2038年问题的影响。 升级到64位系统：在64位系统中，时间戳可以使用64位整数表示，有效时间范围可以扩展到大约292,000,000,000年，因此避免了2038年问题 可以使用DATETIME类型，而不是TIMESTAMP类型。DATETIME类型支持的日期范围是 1000-01-01 00:00:00 到 9999-12-31 23:59:59，足够应对大多数需求。 文本字符串类型： CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型： ENUM role ENUM('admin', 'editor', 'viewer') NOT NULL 集合类型： SET, 可以选择其中一个或多个, 使用逗号分隔多个选项 name VARCHAR(100) NOT NULL, favorite_colors SET('Red', 'Green', 'Blue', 'Yellow', 'Black') ('Charlie', 'Green,Black') 二进制字符串类型： BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON类型： JSON对象、JSON数组, 主要用于存储和查询半结构化数据，但并不适合大量的复杂查询或索引 name VARCHAR(100) NOT NULL, contact_info JSON ('Alice', '{"email": "alice@example.com", "phone": "+1234567890", "address": {"city": "New York", "zip": "10001"}}') 查询JSON数据 JSON_EXTRACT(contact_info, '$.email') AS email 更新JSON数据 SET contact_info = JSON_SET(contact_info, '$.phone', '+1122334455') 从JSON对象中删除特定字段 SET contact_info = JSON_REMOVE(contact_info, '$.address') 空间数据类型（了解）： 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； 集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 语法 SQL语句关键字不区分大小写,忽略语句中空格和换行,每一条语句以分号结尾 在 SQL 中，反引号（&#715;&#715;）通常用来引用数据库对象（如表名、列名等），特别是当对象名包含空格或与 SQL 关键字冲突时。使用反引号可以确保数据库正确解析包含特殊字符或空格的对象名。 如果表名或列名没有包含特殊字符或空格，使用反引号引用是可选的，但是在一些数据库中，使用反引号引用对象名可以提高代码的可读性和可移植性。 SQL语言分为三类 DML 数据操作语言 添加,修改,删除,查询 DCL 数据控制语言 用户,权限,事务 DDL 数据定义语言 逻辑库,数据表,视图,索引 MySQL语法和标准SQL语法的差异 MySQL 的语法在很大程度上符合 SQL 标准，但也有一些特定的语法和功能是 MySQL 独有的或者与标准有所不同的。以下是一些 MySQL 与标准 SQL 不同之处的示例： 字符串比较大小写敏感性： 在 MySQL 中，默认情况下，字符串比较是不区分大小写的（例如，'Hello' = 'hello' 返回 true）。但在标准 SQL 中，字符串比较通常是区分大小写的。 字符串拼接： MySQL 使用 CONCAT() 函数来拼接字符串，而标准 SQL 使用双竖线 ||。例如，在 MySQL 中，将两个字符串拼接在一起可以这样做：CONCAT('Hello', 'World')，而在标准 SQL 中，应该是 'Hello' || 'World'。 LIMIT 子句： MySQL 使用 LIMIT 子句来限制结果集的返回行数，而标准 SQL 使用 FETCH FIRST 或 OFFSET 语法来实现类似的功能。 AUTO_INCREMENT 列： MySQL 使用 AUTO_INCREMENT 关键字来指定一个列为自增列，而标准 SQL 中通常使用 IDENTITY 关键字。 日期和时间函数： MySQL 提供了许多与日期和时间相关的特定函数，如 NOW()、DATE_ADD()、DATE_SUB() 等，这些函数在标准 SQL 中可能没有直接对应的函数或者语法。 需要注意的是，虽然 MySQL 有一些与标准 SQL 不同的地方，但大部分情况下，它们仍然可以与标准 SQL 兼容，并且可以通过设置来使其更加符合标准。 库操作 -- 显示所有逻辑库 SHOW DATABASES; -- 创建逻辑库 CREATE DATABASE IF NOT EXISTS demo; -- 使用指定逻辑库 USE demo; -- 删除指定逻辑库 DROP DATABASE demo; 表操作 -- 查看当前逻辑空间里的所有表 SHOW TABLES; -- 查看指定表的所有字段详情注释 show full columns from test; -- 列的信息 SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_KEY FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = 'your_database_name' AND TABLE_NAME = 'your_table_name'; -- 查看指定表的表结构 DESC student; -- 查看表注释,建表语句 SHOW CREATE TABLE test; -- 返回总记录数 SELECT COUNT(*) total_items FROM t_emp; -- 建表,添加表注释和字段注释 CREATE TABLE student( id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT COMMENT "主键,字段注释", name VARCHAR(20) NOT NULL, tel CHAR(11) NOT NULL UNIQUE, sex ENUM("男","女") NOT NULL DEFAULT "男", -- MySQL 会将 BOOLEAN 解释为别名类型,false在表中会自动转为0 -- MySQL 允许在 DEFAULT 子句中使用字符串，而字符串 'FALSE' 会被解释为数字 0。 -- 因此，虽然 MySQL 中没有严格意义上的布尔类型，但可以通过这种方式来模拟布尔类型的行为。 -- married BOOLEAN NOT NULL DEFAULT FALSE -- 习惯上，TINYINT(1) 用于表示布尔值，其中 1 表示 TRUE，0 表示 FALSE。通过在定义表结构时将 TINYINT(1) 定义为 NOT NULL 并设置默认值为 0 或 1，可以实现类似于 BOOLEAN 的行为 married TINYINT(1) NOT NULL DEFAULT 0 ) ENGINE=InnoDB AUTO_INCREMENT=100 CHARSET=utf8 COMMENT="信息表"; -- AUTO_INCREMENT=100设置自增起点, 或者ALTER TABLE t AUTO_INCREMENT = 100; -- 使用 InnoDB 存储引擎，它提供了事务、外键等关系型数据库的特性 -- 拷贝表 -- 获取数据表的完整结构 SHOW CREATE TABLE runoob_tbl; -- 原表结构 CREATE TABLE &#715;runoob_tbl&#715; ( &#715;runoob_id&#715; int(11) NOT NULL auto_increment, &#715;runoob_title&#715; varchar(100) NOT NULL default '', &#715;runoob_author&#715; varchar(40) NOT NULL default '', &#715;submission_date&#715; date default NULL, PRIMARY KEY (&#715;runoob_id&#715;), UNIQUE KEY &#715;AUTHOR_INDEX&#715; (&#715;runoob_author&#715;) ) ENGINE=InnoDB -- 重命名以原有结构新建 CREATE TABLE &#715;clone_tbl&#715; ( &#715;runoob_id&#715; int(11) NOT NULL auto_increment, &#715;runoob_title&#715; varchar(100) NOT NULL default '', &#715;runoob_author&#715; varchar(40) NOT NULL default '', &#715;submission_date&#715; date default NULL, PRIMARY KEY (&#715;runoob_id&#715;), UNIQUE KEY &#715;AUTHOR_INDEX&#715; (&#715;runoob_author&#715;) ) ENGINE=InnoDB; -- 拷贝数据 INSERT INTO clone_tbl (runoob_id,runoob_title,runoob_author,submission_date) SELECT runoob_id,runoob_title,runoob_author,submission_date FROM runoob_tbl; -- 拷贝表2 CREATE TABLE targetTable LIKE sourceTable; INSERT INTO targetTable SELECT * FROM sourceTable; -- 拷贝一个表中的一些字段: CREATE TABLE newadmin AS (SELECT username, password FROM admin) -- 将新建的表的字段改名: CREATE TABLE newadmin AS (SELECT id, username AS uname, password AS pass FROM admin) -- 拷贝一部分数据 -- LEFT(username,1)获取字符串 username 的左边的第一个字符 CREATE TABLE newadmin AS (SELECT * FROM admin WHERE LEFT(username,1) = 's') -- 拷贝表3 CREATE TABLE source (name VARCHAR(255),age int); INSERT into source VALUES ("Alice",12),("Bob",8); CREATE TABLE &#715;new&#715; (id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY); -- 在列之后插入新列 ALTER TABLE &#715;new&#715; ADD COLUMN &#715;name&#715; VARCHAR(255) AFTER &#715;id&#715;; ALTER TABLE &#715;new&#715; ADD COLUMN &#715;age&#715; INT AFTER &#715;name&#715;; -- SELECT NULL INSERT INTO &#715;new&#715; (id, name, age) SELECT NULL, name, age FROM source; -- 临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间 -- 临时表对于需要在某个会话中存储中间结果集或进行复杂查询时非常有用。 -- 临时表的作用范围仅限于创建它的会话。其他会话无法直接访问或引用该临时表。 -- 新建临时表 CREATE TEMPORARY TABLE temp_table_name ( column1 datatype, column2 datatype, ... ); -- 从现有表中新建临时表 CREATE TEMPORARY TABLE temp_table_name AS SELECT column1, column2, ... FROM source_table WHERE condition; -- 修改表注释 ALTER TABLE test COMMENT '修改后的表注释'; -- 修改字段注释 ALTER TABLE test MODIFY COLUMN id INT NOT NULL DEFAULT 0 COMMENT '修改后的字段注释'; -- 修改表名 ALTER TABLE employees RENAME TO staff; -- 清空表记录 DELETE FROM t_emp; -- 删除指定表 DROP TABLE student; 字段 -- 在 MySQL 中，如果将一个字段设为主键 (primary key)，那么这个字段就默认为 NOT NULL -- 插入新字段 ALTER TABLE student ADD COLUMN address VARCHAR(200) NOT NULL, ADD COLUMN home_tel CHAR(11) NOT NULL; -- 在指定列的右侧插入新字段 ALTER TABLE student ADD COLUMN new_column INT AFTER address; -- 修改字段名称 ALTER TABLE student CHANGE tel phone VARCHAR(11), CHANGE address addr VARCHAR(200); -- 修改字段类型 ALTER TABLE student MODIFY home_tel CHAR(31); -- 交换两个字段的位置 ALTER TABLE student ADD COLUMN tmp VARCHAR(11); #插入临时列 UPDATE student SET tmp=tel, tel=remark; UPDATE student SET remark=tmp; #调换数据 ALTER TABLE student CHANGE tel tmp VARCHAR(11); ALTER TABLE student CHANGE remark tel VARCHAR(200); ALTER TABLE student CHANGE tmp remark VARCHAR(11); #修改字段名 ALTER TABLE student DROP COLUMN tmp; #删除临时列 -- 删除指定字段, COLUMN可省略 ALTER TABLE student DROP home_tel, DROP COLUMN remark; 主键,外键,索引 -- 添加主键约束 ALTER TABLE employees ADD PRIMARY KEY (employee_id); -- 在关系型数据库中，一个表可以有多个列构成主键，这种情况被称为复合主键或联合主键。这意味着多个列的值组合在一起必须是唯一的。 -- (column1, column2) 组成了复合主键，意味着 (1, 2) 和 (1, 3) 是合法的行，但 (1, 2) 和 (1, 2) 是不合法的行，因为它们的组合不是唯一的 CREATE TABLE example ( column1 INT, column2 INT, PRIMARY KEY (column1, column2) ); -- 另一种设置数据的唯一性方法是添加一个 UNIQUE 索引 CREATE TABLE person_tbl ( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10), UNIQUE (last_name, first_name) ); -- 外键约束 -- 如果父表中未录入指定的deptno编号,则子表就不能录入该编号 -- 如果子表的相关记录未删除前,父表无法删除指定记录 -- 当形成外键闭环时,将无法删除任何一张表的记录 -- 父表 CREATE TABLE t_dept( deptno INT UNSIGNED PRIMARY KEY, dname VARCHAR(20) NOT NULL UNIQUE, tel CHAR(4) UNIQUE ); -- 子表 CREATE TABLE t_emp( empno INT UNSIGNED PRIMARY KEY, deptno INT UNSIGNED, FOREIGN KEY(deptno) REFERENCES t_dept(deptno) ); -- 添加外键约束 ALTER TABLE orders ADD CONSTRAINT fk_customer FOREIGN KEY (customer_id) REFERENCES customers (customer_id); -- 查看外键信息 SELECT TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME, REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_SCHEMA = 'your_database_name' AND TABLE_NAME = 'your_table_name' AND REFERENCED_TABLE_NAME IS NOT NULL; -- 创建索引,数据量很大,读的次数大于写的次数,经常被用作检索条件的字段,不要在长字段上创建索引 CREATE TABLE t_message( id INT UNSIGNED PRIMARY KEY, content VARCHAR(200) NOT NULL, INDEX idx_type(type) ); -- 在已经存在的表上创建索引 -- 创建了一个名为 idx_type 的索引，它包含了 t_message 表中的 type 字段, 优化对 type 字段的查询操作 CREATE INDEX idx_type ON t_message(type); ALTER TABLE t_message ADD INDEX idx_type(type); -- 查看索引信息 SHOW INDEX FROM t_message; -- 删除索引 DROP INDEX idx_type ON t_message; -- 或 ALTER TABLE employees DROP INDEX idx_age; 分页,排序,COLLATE,去重 -- LIMIT分页,单参时3表示取前3条 -- 双参时,从索引5(第6条,索引起始为0)位置开始向后取3条 -- LIMIT是mysql的方言 SELECT empno,ename FROM t_emp LIMIT 5,3; -- 排序 SELECT ename,sal*12 income FROM t_emp ORDER BY sal; -- 多重排序：选择员工表 employees 中的所有员工，并先按部门 ID 升序 ASC 排序，然后在相同部门中按雇佣日期降序 DESC 排序。 SELECT * FROM employees ORDER BY department_id ASC, hire_date DESC LIMIT 5; -- 多列排序：使用数字, 选择员工表 employees 中的名字和工资列，并按第三列（salary）降序 DESC 排序，然后按第一列（first_name）升序 ASC 排序 SELECT first_name, last_name, salary FROM employees ORDER BY 3 DESC, 1 ASC; -- 使用 NULLS FIRST 或 NULLS LAST 处理 NULL 值 -- 选择产品表 products 中的产品名称和价格，并按价格降序 DESC 排序，将 NULL 值排在最后 SELECT product_name, price FROM products ORDER BY price DESC NULLS LAST; -- 按照中文拼音进行排序，同时忽略大小写（CI 表示 Case Insensitive，AS 表示 Accent Sensitive） SELECT * FROM table_name ORDER BY column_name COLLATE Chinese_Pinyin_CI_AS; -- 去重 -- DISTINCT在SELECT中只能使用一次,查询多个字段时无效 SELECT DISTINCT job FROM t_emp; -- 读取不重复的数据 SELECT last_name, first_name FROM people GROUP BY last_name, first_name; -- 或者 SELECT DISTINCT last_name, first_name FROM people; -- 删除重复数据 CREATE TABLE tmp SELECT last_name, first_name FROM people GROUP BY last_name, first_name; DROP TABLE people; ALTER TABLE tmp RENAME TO people; NULL值处理 NULL 判断 判断NULL, IS NULL,IS NOT NULL,不可以=和!= NULL 运算 跟NULL进行任何运算得到的结果都是NULL NULL 排序 ORDER BY 子句进行排序时，NULL 值默认会被放在排序的最后 将 NULL 值放在最前面,使用 ORDER BY column_name ASC NULLS FIRST 反之使用 ORDER BY column_name DESC NULLS LAST NULL 比较 <=> 同时比较两件事情（两个字段的值是否相等，包括都为 NULL 的情况） 假设你有两个名单，一个是电话号码名单，一个是电子邮件名单。你想找出哪些人没有电话号码并且没有电子邮件。<=> 就像在同时检查两个名单的情况下，不论电话号码还是电子邮件是否为空，都能正确地进行比较。 -- 查看联系人中哪些人的电话号码和电子邮件相同，包括那些都没填写的 SELECT * FROM contacts WHERE phone <=> email; is null 用于检查单个字段是否为 NULL，类似于问“某个字段是不是空的？ 假设你有一个名单，你想找出名单中哪些人没有电话号码。IS NULL 就像在名单中找出所有电话号码为空的记录 -- 这句查询语句就像是在说：“给我所有没有填写电话号码的联系人。” SELECT * FROM contacts WHERE phone IS NULL; NULL 取代 IFNULL(a,b) 返回两个参数中的第一个非NULL值。如果所有参数都是 NULL，则返回 NULL COALESCE(a,b,c) 返回参数列表中第一个非NULL值。如果所有参数都是 NULL，则返回 NULL; 积聚 聚合函数对 NULL 的处理 使用聚合函数（如 COUNT, SUM, AVG）时，它们会忽略 NULL 值，因此可能会得到不同于预期的结果。如果希望将 NULL 视为 0，可以使用 COALESCE 或 IFNULL WHERE,正则,IN -- WHERE中不能使用别名, 避免在where中使用子查询, from子查询只查询一次, 而where子查询每次都会重来一遍 SELECT deptno,ename,(sal+IFNULL(comm,0))*12 income,hiredate FROM t_emp WHERE (deptno=10 OR deptno=20) AND sal*12>=24000 AND DATEDIFF(NOW(),hiredate)/365>=20 ORDER BY income DESC LIMIT 3; -- WHERE子句中条件执行顺序从左往右,应将索引条件或过滤量最多的条件写在最左,比较条件靠后,提高查找速度 -- BETWEEN AND 是全闭区间 SELECT ename,hiredate,comm FROM t_emp WHERE comm IS NULL AND hiredate BETWEEN "1981-1-1" AND "1983-1-1" AND ename REGEXP "^[\\u4e00-\\u9fa5]{2,4}$"; -- MySQL 可以通过 LIKE ...% 来进行模糊匹配, like作为where子句,%通配任意长度字符,_通配任何1个字符,如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的 -- MySQL 中使用 REGEXP 和 RLIKE操作符来进行正则表达式匹配,RLIKE 和 REGEXP 可以互换使用，没有区别。 -- 匹配以字母 'a' 开头，然后是零个或多个字符，以 "o" 结尾并且长度为两个字符 SELECT * FROM users WHERE username LIKE 'a%o_'; SELECT column1, column2, ... FROM table_name WHERE column_name REGEXP 'pattern'; -- IN != < SELECT empno,ename,deptno,hiredate FROM t_emp WHERE deptno IN(10,20,30) AND job !="SALESMAN" AND hiredate<"1982-1-1"; 聚合函数,分组 -- 聚合函数（如 COUNT, SUM, AVG）时，它们会忽略 NULL 值 -- SUM包含字符串时一定为0,日期类型统计结果为毫秒数相加 -- AVG统计包含字符串类型时一定为0 -- 统计1985年后入职,底薪超过平均底薪的人数 SELECT COUNT(*) FROM t_emp WHERE sal>( SELECT AVG(sal) FROM t_emp #相关子查询 ) AND hiredate>"1981-1-1"; -- 当存在多个最值时 SELECT e.empno, e.ename, e.sal FROM t_emp e JOIN ( SELECT MAX(sal) max FROM t_emp ) t ON e.sal = t.max; -- 统计单个部门平均sal SELECT deptno, COUNT(*) emps, ROUND(AVG( sal )) avg_sal FROM t_emp WHERE deptno=10; -- GROUP BY 对一个数据集按规则分组,然后对每个分组进行数据聚合 -- 使用了GROUP BY时,SELECT子句中可以包括聚合函数,或者GROUP BY子句的分组列,其余内容均不可以出现在SELECT子句中 -- 例如GROUP BY中只有deptno字段时,SELECT中加入了ename字段将报语法错误 -- 除非将ename字段拼接成一个字符串,可以使用GROUP_CONTACT函数进行字段拼接 SELECT deptno, COUNT(*) emps, GROUP_CONCAT(ename) emps_list, ROUND(AVG( sal )) avg_sal FROM t_emp GROUP BY deptno; -- 逐级分组 -- 查询每个部门内每种职位的人数和平均sal -- 每个组包含同一个部门中的同一个职位的所有记录 SELECT deptno, job, COUNT(*) emps, GROUP_CONCAT(ename) emps_list, AVG(sal) avg_sal FROM t_emp GROUP BY deptno,job ORDER BY deptno,emps DESC,avg_sal DESC; -- 分组后二次汇总 WITH ROLLUP -- 使用 WITH ROLLUP 对分组后的记录的各字段生成小计, 如组平均数, 组中最值 SELECT COALESCE(deptno,"汇总") deptno, COUNT(*), GROUP_CONCAT(ename) emps_list, SUM(sal), AVG(sal), MAX(sal), MIN(sal) FROM t_emp GROUP BY deptno WITH ROLLUP ORDER BY deptno DESC; -- 执行顺序: FROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY -> LIMIT -- HAVING用于筛选WHERE子句中不能直接筛选的分组聚合后的结果集 -- HAVING子句必须跟在GROUP BY之后,GROUP BY执行完成后再执行HAVING -- 例如查询部门平均sal超过2000的部门编号 SELECT deptno, AVG(sal) FROM t_emp GROUP BY deptno HAVING AVG(sal) > 2000; -- 查询每个部门中,1982年以后入职的员工数量超过2个人的部门编号 -- 可以使用数字代表SELECT中要分组的字段 -- HAVING子句只能用聚合函数和具体值进行判断,不能和字段直接进行判断 -- 筛选出每组中（即每个部门）包含至少两条记录（即至少有两名员工）的组 SELECT deptno FROM t_emp WHERE hiredate>="1982-1-1" GROUP BY 1 HAVING COUNT(*)>=2; #COUNT(*)>=2 AND sal>=AVG(sal); 语法错误 #COUNT(*)>=2 AND AVG(sal)>=2000; 正确 SELECT deptno, sal FROM t_emp WHERE hiredate>="1982-1-1" GROUP BY 1,2 HAVING COUNT(*)>=1 SELECT deptno, COUNT(*) emps FROM t_emp GROUP BY 1 HAVING deptno IN(10,20); #此处HAVING虽然可以当作WHERE使用,但是它执行于分组之后,而WHERE在分组执行之前,筛选效率有差别,应该尽量将普通筛选条件放在WHERE里 -- 笛卡尔积,如果有两个表 A 和 B，使用笛卡尔积来获取 A 表和 B 表的所有排列组合 -- 如果有一个表包含了颜色选项，另一个表包含了尺寸选项，可以使用笛卡尔积生成所有颜色和尺寸的组合。 SELECT * FROM A, B; #这将返回 A 表中的每一行与 B 表中的每一行的组合。 SELECT empno,ename,dname FROM t_emp JOIN t_dept; #无条件连接时,产生笛卡尔积 表连接,UNION -- 内连接等价写法, 可以省略INNER -- SELECT ... FROM 表1 JOIN 表2 ON 连接条件; -- SELECT ... FROM 表1 JOIN 表2 WHERE 连接条件; -- SELECT ... FROM 表1,表2 WHERE 连接条件; SELECT e.empno, e.ename, d.dname FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno; SELECT e.empno, e.ename, d.dname FROM t_emp e JOIN t_dept d WHERE e.deptno=d.deptno; SELECT e.empno, e.ename, d.dname FROM t_emp e, t_dept d WHERE e.deptno=d.deptno; -- 表连接的数据表之间不一定必须要有同名字段,只要字段之间符合逻辑关系即可,相同的数据表也可以做表连接 -- 查询每个员工的工号,姓名,部门名称,底薪,职位,工资等级 SELECT e.empno, e.ename, d.dname, e.sal, e.job, s.grade FROM t_emp e, t_dept d, t_salgrade s WHERE e.deptno=d.deptno AND e.sal BETWEEN s.losal AND s.hisal; SELECT e.empno, e.ename, d.dname, e.sal, e.job, s.grade FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal; -- 子查询虽然更符合思维习惯,但是效率非常低,因为每查询一次deptno,就要重新全表查询一次ename -- 查询与SCOTT相同部门的员工有哪些 SELECT ename FROM t_emp WHERE deptno=(SELECT deptno FROM t_emp WHERE ename="SCOTT") AND ename!="SCOTT"; SELECT e2.ename FROM t_emp e1, t_emp e2 WHERE e1.deptno=e2.deptno AND e1.ename="SCOTT" AND e2.ename!="SCOTT"; -- 自连接（self-join）使用别名来区分同一表中不同的实例 -- 查询和SCOTT相同部门的员工姓名 -- t_emp e1 JOIN t_emp e2 合成的中间集为e1表中所有记录和e2表中所有记录的全部并列组合,(e1.ename,..e2.ename,..) -- 先用e1表的第一条记录依次拼凑e2的每一条记录,再用e1表的第二条记录依次拼凑e2的每一条记录.. -- ON e1.deptno=e2.deptno, 在拼凑过程中仅当e1的该条记录的deptno和e2该条记录的deptno相同时才保留到中间集中 -- WHERE e1.ename="SCOTT" 从中间集筛选出e1.ename字段值为scott的全部记录作为新中间集 -- e2.ename!="SCOTT" 再从新中间集中筛选出e2.ename字段值不为scott的全部记录作为结果集 -- SELECT e2.ename 从结果集中选择e2.ename列输出 SELECT e2.ename FROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno WHERE e1.ename="SCOTT" AND e2.ename!="SCOTT"; -- 查询sal超过平均sal的员工信息 SELECT e.ename, e.sal FROM t_emp e JOIN (SELECT AVG(sal) avg FROM t_emp) e2 ON e.sal>e2.avg; -- 查询RESESRCH部门的人数,最高sal,最低sal,平均sal,平均工龄 SELECT COUNT(e.ename) sum_emps, MAX(e.sal) max_sal, MIN(e.sal) min_sal, AVG(e.sal) avg_sal, FLOOR(AVG(DATEDIFF(NOW(),e.hiredate)/365)) FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno AND d.dname="RESEARCH"; -- 查询每种职业的最高,最低,平均sal,最高等级和最低等级 SELECT e.job, MAX(e.sal+IFNULL(e.comm,0)), MIN(e.sal+IFNULL(e.comm,0)), AVG(e.sal+IFNULL(e.comm,0)), MAX(s.grade), MIN(s.grade) FROM t_emp e JOIN t_salgrade s ON e.sal+IFNULL(e.comm,0) BETWEEN s.losal AND s.hisal GROUP BY e.job; #with rollup -- 查询每个底薪超过部门平均底薪的员工信息 SELECT e.deptno, e.ename, e.sal, t.avg FROM t_emp e, (SELECT AVG(sal) avg,deptno FROM t_emp GROUP BY deptno) t WHERE e.deptno=t.deptno AND e.sal>t.avg ORDER BY e.deptno; -- 左连接,保留左表,右表拿不出对应数据时就用NULL替代 -- 内连接只返回两个表中匹配条件的行。如果某行在任一表中没有匹配的行，则该行不会出现在结果集中 -- 可以将 LEFT JOIN 想象成左边的表是主角，它会尽量把自己的信息携带着去找右边的表，如果找到了就携带信息回来，如果找不到就带着空信息回来 -- RIGHT JOIN 会读取右边数据表的全部数据，即使左边边表无对应数据。 -- 在实际开发过程中，RIGHT JOIN 并不经常使用，因为它可以用 LEFT JOIN 和表的顺序交换来实现相同的效果。 SELECT e.ename, d.dname FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno ORDER BY e.ename; -- 查询每个部门的名称和部门人数, 包括人数为0的部门 -- t_dept作为左表 SELECT d.dname, COUNT(e.deptno) FROM t_dept d LEFT JOIN t_emp e ON d.deptno=e.deptno GROUP BY d.deptno; -- 查询每个部门的名称和部门人数, 没有部门的员工,部门名称用NULL代替 -- UNION连接多张表,去除重复记录,UNION ALL不去除重复记录 -- 一个左连接, 一个右连接 -- UNION 将两个或多个 SELECT 语句的结果集组合成一个结果集，并去除重复的行 SELECT d.dname, COUNT(e.deptno) FROM t_dept d LEFT JOIN t_emp e ON d.deptno=e.deptno GROUP BY d.deptno UNION SELECT IFNULL(d.dname,"无"), COUNT(*) FROM t_dept d RIGHT JOIN t_emp e ON d.deptno=e.deptno GROUP BY d.deptno; -- 由于 UNION 操作要求两个 SELECT 查询的列数和类型必须相同，因此在第二个 SELECT 查询中使用 NULL 来匹配第一个查询的 last_name 列 SELECT first_name, last_name FROM employees UNION SELECT nick, NULL FROM employees2 ORDER BY first_name; -- 查询每名员工的编号,姓名,部门,月薪,工资等级,工龄,上司编号,上司姓名,上司部门 SELECT e.empno, e.ename, d.dname, e.sal+IFNULL(e.comm,0) income, s.grade, FLOOR(DATEDIFF(NOW(),e.hiredate)/365) yr, e.mgr, e2.ename, d2.dname FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno LEFT JOIN t_salgrade s ON e.sal+IFNULL(e.comm,0) BETWEEN s.losal AND s.hisal LEFT JOIN t_emp e2 ON e.mgr=e2.empno LEFT JOIN t_dept d2 ON e2.deptno=d2.deptno WHERE e.deptno IN(10,20) ORDER BY e.empno; SELECT e.empno, e.ename, d.dname, e.sal+IFNULL(e.comm,0) income, s.grade, FLOOR(DATEDIFF(NOW(),e.hiredate)/365) yr, t.empno, t.ename, t.dname FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno LEFT JOIN t_salgrade s ON e.sal+IFNULL(e.comm,0) BETWEEN s.losal AND s.hisal LEFT JOIN ( SELECT e1.empno, e1.ename, d1.dname FROM t_emp e1 JOIN t_dept d1 ON e1.deptno=d1.deptno ) t ON e.mgr=t.empno ORDER BY e.empno; -- 子查询可以写在三个地方,SELECT子句,WHERE子句,FROM子句 -- 但是只有FROM子查询是推荐的,这种子查询只会执行一次,其它两种都是相关子查询,会查询多次 SELECT e.empno, e.ename, (SELECT dname FROM t_dept WHERE deptno=e.deptno) FROM t_emp e; SELECT empno, ename, sal FROM t_emp WHERE sal>=(SELECT AVG(sal) FROM t_emp); SELECT e.empno, e.ename, e.sal, t.avg FROM t_emp e JOIN ( SELECT deptno, AVG(sal) avg FROM t_emp GROUP BY deptno ) t ON e.deptno=t.deptno AND e.sal>=t.avg; -- 用WHERE子查询查找FORD和MARTIN两个人的同事 SELECT ename,deptno FROM t_emp WHERE deptno IN (SELECT deptno FROM t_emp WHERE ename IN("FORD","MARTIN")) AND ename NOT IN("FORD","MARTIN"); -- 用FROM子查询查找FORD和MARTIN两个人的同事 SELECT e.ename FROM t_emp e JOIN ( SELECT deptno FROM t_emp WHERE ename IN("FORD","MARTIN") ) t ON e.deptno=t.deptno WHERE ename NOT IN("FORD","MARTIN"); -- WHERE子句中的多行子查询 -- ALL 大于结果集中的所有结果 -- ANY 大于结果集中的任何结果 -- EXISTS 如果括号中的子查询返回不为空 SELECT ename FROM t_emp WHERE sal>= ALL (SELECT sal FROM t_emp WHERE ename IN ("FORD","MARTIN")) AND ename NOT IN("FORD","MARTIN"); SELECT ename,sal FROM t_emp WHERE EXISTS( SELECT * FROM t_salgrade WHERE sal BETWEEN losal AND hisal AND grade IN(4,5) ); INSERT,IGNORE -- INSERT INTO -- 写上字段名后不用去查询表的数据结构,因此写入速度更快 -- INSERT INTO里使用子查询 -- 忘记部门编号时 INSERT INTO t_emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES( 8001,"刘娜", "SALESMAN", 8000," 1988-1-1", 2000, NULL, (SELECT deptno FROM t_dept WHERE dname="SALES") ); -- mysql的INSERT INTO的方言, INTO也可以省略 INSERT INTO t_emp SET empno=8002,ename="张三",job="SALESMAN",mgr=8000, hiredate="1990-1-1",sal=2000,comm=200,deptno=30; -- IGNORE 防止全部写入失败,当写入多条数据时,主键冲突重复的条目会被忽略,正确的数据会保留 INSERT IGNORE t_dept (deptno,dname,loc) VALUES (40,"A","US"), (50,"B","US"); -- REPLACE INTO -- 如果插入的行违反了唯一约束，MySQL 会先删除已存在的行，然后插入新行。 REPLACE INTO table_name (column1, column2) VALUES (value1, value2); UPDATE,DELETE,TRUNCATE -- UPDATE [IGNORE] 表名 -- SET 字段1=值1,字段2=值2,.. -- [WHERE 条件1 ..] #不写视为全表修改 -- [ORDER BY ..] -- [LIMIT ..] #UPDATE中的LIMIT只能接受一个参数,不能任意指定位置 -- 执行顺序 WHERE -> ORDER BY -> LIMIT -> SET -- 员工编号和上司编号加1 -- 需要倒序避免主键重复 UPDATE t_emp SET empno=empno+1,mgr=mgr+1 ORDER BY empno DESC; UPDATE t_emp SET empno=empno-1,mgr=mgr-1 ORDER BY empno ASC; -- 将月收入前三的员工底薪减100 UPDATE t_emp SET sal=sal-100 ORDER BY sal+IFNULL(comm,0) DESC LIMIT 3; -- 将10部门中,工龄超过20的员工sal增加200 UPDATE t_emp SET sal=sal+200 WHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365>20; -- UPDATE表连接,可以修改多张表的信息 -- UPDATE 表1 [LEFT|RIGHT] JOIN 表2 ON 条件 -- SET 字段1=值1,字段2=值2,..; -- UPDATE 表1,表2 -- SET 字段1=值1,字段2=值2,.. -- WHERE 连接条件; -- 将ALLEN调往RESEARCH部门,职务调整为ANALYST,RESEARCH部门地点改为US UPDATE t_emp e JOIN t_dept d ON e.ename="ALLEN" AND d.dname="RESEARCH" #查出RESEARCH对应的deptno SET e.deptno=d.deptno,e.job="ANALYST",d.loc="US"; -- 将sal低于平均sal的员工,底薪增加150 UPDATE t_emp e JOIN (SELECT AVG(sal) avg FROM t_emp) t ON e.sal<t.avg SET e.sal=e.sal+150; -- 将无部门的员工,或SALES部门低于2000的员工,调往20部门 UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno SET e.deptno=20 WHERE e.deptno IS NULL OR (d.dname="SALES" AND e.sal<2000); -- DELETE [IGNORE] FROM 表名 -- [WHERE 条件1,条件2,..] -- [ORDER BY ..] -- [LIMIT ..]; -- 删除10部门中工龄超过20年的员工记录 DELETE FROM t_emp WHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365>=20; -- 删除20部门中sal最高的员工记录 DELETE FROM t_emp WHERE deptno=20 ORDER BY sal+IFNULL(comm,0) DESC LIMIT 1; -- 表连接删除多张表记录 -- DELETE 表1,.. FROM 表1 [LEFT|RIGHT] JOIN 表2 ON 条件 -- [WHERE 条件1,条件2,..] -- [ORDER BY ..] -- [LIMIT ..]; -- 删除SALES部门和该部门的全部员工记录 DELETE e,d #不能为临时表,结果集里的记录是不能删的 FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno WHERE d.dname="SALES"; #同时也删除了e中员工记录 -- 删除低于部门平均底薪的员工记录 DELETE e FROM t_emp e JOIN (SELECT AVG(sal) avg FROM t_emp GROUP BY deptno) t ON e.deptno = t.deptno WHERE e.sal>t.avg; -- 删除ADAMS及其直接下属员工记录 DELETE e FROM t_emp e JOIN (SELECT empno FROM t_emp WHERE ename="ADAMS") t ON e.mgr=t.empno OR e.empno=t.empno; -- 删除SALES部门员工及无部门员工 DELETE e FROM t_emp e LEFT JOIN (SELECT deptno FROM t_dept WHERE dname="SALES") t ON e.deptno=t.deptno OR e.deptno IS NULL; 数字,日期,字符,条件函数 -- ROUND,FLOOR,CEIL得到的都是整数,保留位数时乘百除百 SELECT ABS(-1); SELECT ROUND(4.6288*100)/100; SELECT FLOOR(9.9); SELECT CEIL(3.1); SELECT POWER(2,3); #2的3次幂 -- NOW() yyyy-MM-dd hh:mm:ss -- CURDATE() yyy-MM-dd -- CURTIME() hh:mm:ss SELECT NOW(),CURDATE(),CURTIME(); -- %Y年,%m月,%d日 -- %w星期(0为周日),%W英文星期 -- %j本年第几天,%U本年第几周 -- %H小时(24),%h(12) -- %i分,%s秒 -- %r时间(12),%T(24) SELECT DATE_FORMAT(NOW(),"%w %W %T"); -- 查询1981年上半年入职人数 SELECT COUNT(*) FROM t_emp WHERE DATE_FORMAT(hiredate,"%Y")=1981 AND DATE_FORMAT(hiredate,"%m")<=6; -- 日期偏移计算 -- DATE_ADD(日期,INTERVAL 偏移量 时间单位) SELECT DATE_ADD(NOW(), INTERVAL 100 DAY); -- 六个月零三天前的日期,嵌套 SELECT DATE_FORMAT( DATE_ADD( DATE_ADD(NOW(),INTERVAL-6 MONTH), INTERVAL-3 DAY ), "%Y/%m/%d" ); -- 字符函数 SELECT LOWER(ename),UPPER(ename), LENGTH(ename), #utf8编码时,一个汉字占3个长度 CONCAT("$",sal), INSTR(ename,"A") #字符出现位置,下标从1起,0为不存在 FROM t_emp; -- 插入替换字符 SELECT INSERT("abcd",2,1,"xy"); #在原始字符串第2个字符位置插入指定字符,并覆盖掉从此处开始的原始字符串的1个字符,axycd -- 替换字符 SELECT REPLACE("abcd","ab","xy"); #xycd -- SUBSTR(str,m,n),下标从1起,截取第m到n个字符 -- SUBSTRING(str,m,n),下标从1起,截取第m个开始连续n个字符 -- LPAD("hello",10,"*")向原始字符串左侧填充星号直到整体长度为10 -- RPAD右侧填充字符 -- TRIM(" hello world ")去首尾空格 -- 遮挡手机号 SELECT LPAD(SUBSTRING("13312345678",8,4),11,"*"); #*******5678 SELECT INSERT("13312345678",4,4,"****"); #133****5678 -- 遮挡姓名 SELECT RPAD(SUBSTRING("李晓娜",1,1),LENGTH("李晓娜")/3,"*"); #李** SELECT LPAD(SUBSTRING("李晓娜",2,LENGTH("李晓娜")/3),LENGTH("李晓娜")/3,"*"); #*晓娜 SELECT LPAD(SUBSTRING("李晓娜",LENGTH("李晓娜")/3,1),LENGTH("李晓娜")/3,"*"); #**娜 -- 条件函数 -- IF(expr,result1,result2)类似三元运算 -- 复活节发礼品,SALES部门发放礼品A,其余部门发放礼品B,列出每名员工获得的礼品 SELECT e.ename,d.dname,IF(d.dname="SALES","A","B") present FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno -- CASE -- 季度旅游,SALES部门去A地,ACCOUNTING部门去B地,RESEARCH部门去C地,列出每名员工的旅行地点 SELECT e.ename, d.dname, CASE d.dname WHEN "SALES" THEN "A" WHEN "ACCOUNTING" THEN "B" WHEN "RESEARCH" THEN "C" ELSE "C" END position FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno; SELECT e.ename, d.dname, CASE WHEN d.dname="SALES" THEN "A" WHEN d.dname="ACCOUNTING" THEN "B" WHEN d.dname="RESEARCH" THEN "C" ELSE "C" END position FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno; -- 调薪方案 -- SALES部门中工龄满20年,涨10% -- SALES部门中工龄不满20年,涨5% -- ACCOUNTING部门,涨300 -- RESEARCH部门里低于平均底薪的员工,涨200 -- 无部门的员工,涨100 UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno LEFT JOIN (SELECT deptno,AVG(sal) avg FROM t_emp GROUP BY deptno) t ON e.deptno=t.deptno SET e.sal=( CASE WHEN d.dname="SALES" AND DATEDIFF(NOW(),e.hiredate)/365>=20 THEN e.sal*1.1 WHEN d.dname="SALES" AND DATEDIFF(NOW(),e.hiredate)/365<20 THEN e.sal*1.05 WHEN d.dname="ACCOUNTING" THEN e.sal+300 WHEN d.dname="RESEARCH" AND e.sal>t.avg THEN e.sal+300 WHEN e.deptno IS NULL THEN e.sal+100 ELSE e.sal END ); https://www.runoob.com/mysql/mysql-functions.html https://www.runoob.com/mysql/mysql-operator.html information_schema -- SCHEMATA 表, 存储有关数据库的信息，如数据库名、字符集、排序规则等。 SELECT * FROM information_schema.SCHEMATA; -- TABLES 表, 包含有关数据库中所有表的信息，如表名、数据库名、引擎、行数等。 SELECT * FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'your_database_name'; -- COLUMNS 表, 包含有关表中列的信息，如列名、数据类型、是否允许 NULL 等。 SELECT * FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = 'your_database_name' AND TABLE_NAME = 'your_table_name'; -- STATISTICS 表, 提供有关表索引的统计信息，如索引名、列名、唯一性等。 SELECT * FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = 'your_database_name' AND TABLE_NAME = 'your_table_name'; -- KEY_COLUMN_USAGE 表, 包含有关表中外键的信息，如外键名、列名、关联表等。 SELECT * FROM information_schema.KEY_COLUMN_USAGE WHERE TABLE_SCHEMA = 'your_database_name' AND TABLE_NAME = 'your_table_name'; -- REFERENTIAL_CONSTRAINTS 表, 存储有关外键约束的信息，如约束名、关联表等。 SELECT * FROM information_schema.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_SCHEMA = 'your_database_name' AND TABLE_NAME = 'your_table_name'; 当前连接信息 -- id,user,host,db,command,time,state,info SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST; SELECT COUNT(*) AS connection_count FROM INFORMATION_SCHEMA.PROCESSLIST; SQL注入 通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。攻击者通过恶意构造的输入，成功地执行恶意的 SQL 查询，这通常发生在用户输入未经适当验证或转义的情况下，攻击者试图在输入中插入 SQL 代码，以执行意外的查询或破坏数据库。 必须认定用户输入的数据都是不安全的并对用户输入的数据进行过滤处理 -- 假设有一个登录系统，用户通过输入用户名和密码进行身份验证： SELECT * FROM users WHERE username = 'input_username' AND password = 'input_password'; -- 如果没有正确的输入验证和防范措施，攻击者可以输入类似于以下内容的用户名： ' OR 1=1; -- ' -- 在这种情况下，SQL 查询会变成： SELECT * FROM users WHERE username = '' OR 1=1; -- 'AND password = 'input_password'; -- 这会使查询返回所有用户，因为 1=1 总是为真，注释符号 --(后面一个空格) 用于注释掉原始查询的其余部分，以确保语法正确。 -- like 查询时，如果用户输入的值有 _ 和 %，则会出现这种情况：用户本来只是想查询 abcd_，查询结果中却有" abcd_"、"abcde"、"abcdf" 等等；用户要查询 "30%"（注：百分之三十）时也会出现问题。 防范 SQL 注入, 注入的检测方法一般采取辅助软件或网站平台来检测 -- 使用专门的漏洞扫描工具（如 sqlmap、Acunetix、Netsparker）对应用程序进行自动化的 SQL 注入检测。 使用参数化查询或预编译语句： 使用参数化查询（Prepared Statements）可以有效防止 SQL 注入，因为它们在执行查询之前将输入数据与查询语句分离。 输入验证和转义： 对用户输入进行适当的验证，并使用合适的转义函数（如mysqli_real_escape_string）来处理输入，以防止恶意注入。 最小权限原则： 给予数据库用户最小的权限，确保它们只能执行必要的操作，以降低潜在的损害。 使用ORM框架： 使用对象关系映射（ORM）框架（如Hibernate、Sequelize）可以帮助抽象 SQL 查询，从而降低 SQL 注入的风险。 禁用错误消息显示： 在生产环境中，禁用显示详细的错误消息或使用自定义的错误信息对原始错误信息进行包装，以防止攻击者获取有关数据库结构的敏感信息。 限制查询结果集大小：在 SQL 查询中使用 LIMIT 关键字限制返回的行数，避免返回过大的结果集。 使用索引：为 LIKE 查询的字段添加索引，可以加快查询速度并减少对数据库的压力。 输入验证：在接受用户输入时进行验证，确保输入的内容符合预期，避免恶意构造的输入。 使用白名单：限制 LIKE 查询中 % 的使用，只允许特定的格式或者通配符使用。 监控和限制查询频率：监控数据库查询的频率，并设置阈值来限制频繁查询的用户或者 IP。 使用缓存：对查询结果进行缓存，减少对数据库的访问次数。 使用数据库连接池：使用连接池管理数据库连接，可以避免频繁地创建和关闭连接。 事务 应用程序 -- 事务区 -- 数据表 A向B转账 操作1, A-100 操作2, B+100 事务的提交 两个操作仅面向事务区 只有应用程序发起commit之后,mysql才会将两个操作所作的修改一次性写入数据表, 然后将事务区清空 事务的回滚 假如操作1时正常完成, 操作2过程中报错, 应用程序发起rollback请求,mysql收到后将事务区清空, 不会涉及数据表的改动 Redo Log (原子性) 记录物理更改，比如数据页上的位置和新的值 负责在系统崩溃后重做已提交事务的更改 WAL（Write-Ahead Logging，先写日志后写数据） 数据库在进行修改操作时首先将操作记录到日志中,记录成功后在末尾标记Commit Record 然后开始进行实际修改,修改完成后在日志末尾标记End Record 如果在记录过程中系统崩溃,重启后检查到日志里没有Commit Record,则回滚整个事务，什么都不做 如果在数据修改的过程中系统崩溃,重启后检查到日志里没有End Record,则根据日志的内容重新进行修改操作。 Undo Log (持久性) 记录逻辑更改，比如数据修改前的原始值。 负责在事务回滚时撤销未提交的更改 当一个事务开始执行时，数据库会在Undo Log中为该事务分配一段空间，称为Undo Log Record。 在事务执行过程中，所有对数据的修改都会被记录到Undo Log中，但实际的数据修改是在事务提交时才会被应用到数据库中。这样做的目的是为了确保在事务回滚或者发生异常时能够恢复数据到事务执行之前的状态。 当一个事务提交时，Undo Log中记录的修改会被应用到数据库中，并且相应的Undo Log Record会被标记为已提交。如果事务发生回滚或者异常，数据库会根据Undo Log中的记录将数据恢复到之前的状态，并且相应的Undo Log Record会被标记为已回滚。 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 在人员管理系统中，删除一个人员，既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务 事务4个条件（ACID） 原子性（Atomicity） 指事务是一个不可分割的工作单位，要么全部执行成功，要么全部不执行，不存在部分执行的情况。如果一个事务中的任何操作失败，则整个事务将被回滚到初始状态，以确保数据的一致性。 一致性（Consistency） 事务在执行前后，数据库的完整性约束没有被破坏。这意味着事务执行后，数据库从一个一致性状态转变到另一个一致性状态，不会使数据处于中间不一致的状态。 隔离性（Isolation） 多个事务并发执行时，每个事务的操作被隔离并保护不被其他事务的操作影响，从而防止数据并发访问引起的问题如脏读、不可重复读和幻读。 持久性（Durability） 一旦事务提交，其所做的修改将会永久保存在系统中，即使系统发生故障，修改的数据也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。 因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 MYSQL 事务处理主要有两种方法： 1、用 BEGIN, ROLLBACK, COMMIT 来实现 BEGIN 或 START TRANSACTION：开用于开始一个事务。 ROLLBACK 事务回滚，取消之前的更改。 COMMIT：事务确认，提交事务，使更改永久生效。 2、直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 START TRANSACTION; #手动开始一个事务,让多条SQL语句纳入到一个事务之下 DELETE FROM t_emp; #在redo日志里修改 SELECT * FROM t_emp; #,此时在redo日志里查询结果为空, 真实文件内容不变, 只要不提交事务,redo日志就不会和数据文件做同步 [COMMIT|ROLLBACK]; -- COMMIT提交的是一个结果,而不是将上面的语句再去执行一遍 -- 如果不想提交事务,ROLLBACK回滚,会在redo日志中将此事务下的所有记录标记为失效,redo日志就不会和数据文件做同步,也即整体失败,保证了事务的原子性 -- 在事务中设置保存点，以便稍后能够回滚到该点： SAVEPOINT savepoint_name; -- 回滚到之前设置的保存点： ROLLBACK TO SAVEPOINT savepoint_name; 事务隔离级别 Read uncommitted 可以读未提交的, 应用场景如多窗口售票判断某一个座位是否被其它窗口订下 -- 在一个窗口中开启事务A START TRANSACTION; #1 UPDATE t_emp SET sal=1; #2 -- 在另一个窗口中开启事务B START TRANSACTION; SELECT * FROM t_emp; #[当事务A执行完第2句时] 此处查询的结果sal没有变为1,说明了事务之间的隔离性,不能读取对方事务在日志中的临时数据 -- 设置当前会话中的事务隔离级别为可以读其它事务的未提交数据 SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTD; -- 在当前窗口开启事务C START TRANSACTION; SELECT * FROM t_emp; #[当事务A执行完第2句时] 此处查询的结果sal变为1,说明了读取到了其它事务在日志中的临时数据 read committed 可以读已提交的 例如银行转账,事务A存入的同时,事务B撤销了一笔支出进行回滚,事务A就需要读取其它事务已经提交的数据 repeatable read 可以重复读 ,这是mysql默认的事务级别 例如下单后商品涨价了,订单仍然要按涨价前的价格来处理,事务在执行期间多次读取同一数据时，将始终看到同样的数据快照，即使其他事务对数据进行了修改 -- 在一个窗口中开启事务A START TRANSACTION; #1 UPDATE t_emp SET sal=1; #2 COMMIT; #3 -- 设置当前会话中的事务隔离级别为可以重复读 SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; #1 执行完此句后,执行事务A#2 -- 在当前窗口开启事务B START TRANSACTION; #2 执行完此句后,事务A执行#3 SELECT * FROM t_emp; #3 事务A执行完#3后,执行此句,查询的结果sal变为1,这是因为只有在执行查询语句的时候mysql才会把用到的数据载入到undo日志里面,由于undo日志里没有记录,所以此处的查询只有去加载真实的数据; -- 要达到REPEATABLE的效果应该,事务A执行完#1#2,事务B执行完#1#2#3,这时undo日志就有了相关数据,此时事务A执行#3改变sal,事务B第二次执行#3,则得到的结果是原始sal,不会受事务A更改数据的影响 Serializable 序列化,等待其它事务结束后才会开始本事务 -- 在一个窗口中开启事务A START TRANSACTION; #1 UPDATE t_emp SET sal=1; #2 COMMIT; #3 -- 设置当前会话中的事务隔离级别为序列化 SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; #1 执行完此句后,执行事务A#2 -- 在当前窗口开启事务B START TRANSACTION; #2 继续执行此句 SELECT * FROM t_emp; #3 继续执行此句,此时查询会一直处于等待状态,除非事务A结束掉,才会返回结果 导出导入 导出 数据不多的时候导出为sql文件,否则导出为文本文件(避免导入时执行海量INSERT语句) idea中可通过export with mysqldrump, 指定mysqldrump.exe位置, 指定输出位置(具体文件名而不是一个目录) ::导出数据结构和业务数据 mysqldump -u username -p database_name > dump_file.sql ::从远程主机导出 mysqldump -h remote_host -P port_number -u username -p database_name > dump_file.sql ::导出指定表, 仅表结构, 压缩文件 mysqldump -u username -p --no-data database_name table_name | gzip > dump_file.sql.gz ::导出指定表, 仅数据, 仅符合条件的记录,比如id100之后的数据行 mysqldump -u username -p --no-create-info database_name table_name --where="id>100" > dump_file.sql SELECT ... INTO OUTFILE 将数据库查询的结果导出为文本文件，如 CSV 或其他格式的文件 SELECT columns INTO OUTFILE 'file_name' FIELDS TERMINATED BY '\t' -- 字段分隔符，默认是制表符 (tab) ENCLOSED BY '' -- 字段包围符，默认是没有 ESCAPED BY '\\' -- 转义字符，默认是反斜杠 (\) LINES TERMINATED BY '\n' -- 行终止符，默认是换行符 (newline) SELECT last_name, first_name INTO OUTFILE 'C:/ProgramData/MySQL/MySQL Server 8.3/Uploads/user_data.csv' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n' FROM people WHERE last_name="a"; 导入 ::导入本机或远程主机 mysql -u username -p database_name < dump_file.sql mysql -h remote_host -P port_number -u username -p database_name < dump_file.sql ::从压缩文件导入 gzip -dc dump_file.sql.gz | mysql -u username -p database_name ::MySQL命令行环境中执行导入 source /path/dump_file.sql; LOAD DATA 适合批量导入大量数据，特别是从 CSV 或其他文本格式文件中导入数据, 追加而不是覆盖 LOAD DATA INFILE 'file_name' INTO TABLE table_name FIELDS TERMINATED BY '\t' -- 字段分隔符，默认是制表符 (tab) OPTIONALLY ENCLOSED BY '' -- 字段可选的包围符，默认是没有 ESCAPED BY '\\' -- 转义字符，默认是反斜杠 (\) LINES TERMINATED BY '\n' -- 行终止符，默认是换行符 (newline) IGNORE 0 LINES -- 忽略的行数，默认是 0 行 LOAD DATA INFILE '/path/to/data.csv' INTO TABLE users FIELDS TERMINATED BY ',' LINES TERMINATED BY '\n' (id, first_name, last_name); 用户 -- 显示所有用户 SELECT user, host FROM mysql.user; -- 查看所有用户的权限信息 SELECT Db, User, Host, Select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, Drop_priv, Grant_priv FROM mysql.db; -- 创建一个名为 newuser 的用户，密码为 password，并允许该用户从任何主机连接到 MySQL 服务器, 仅创建了用户，并没有赋予任何权限 CREATE USER 'newuser'@'%' IDENTIFIED BY 'password'; -- 修改密码 ALTER USER 'newuser'@'%' IDENTIFIED BY 'newpassword'; -- 授予 newuser 用户对 testdb 数据库的所有权限 GRANT ALL PRIVILEGES ON testdb.* TO 'newuser'@'%'; -- 查询用户 newuser 可以访问的数据库及其权限 SELECT Db, User, Host, Select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, Drop_priv, Grant_priv FROM mysql.db WHERE User = 'newuser' AND Host = '%'; -- 修改登陆权限 update user set host='localhost' where user='newuser'; -- 删除用户 newuser 对 testdb 数据库的 SELECT 和 INSERT 权限 REVOKE SELECT, INSERT ON testdb.* FROM 'newuser'@'localhost'; -- 删除用户 newuser 对 testdb 数据库的所有权限 REVOKE ALL PRIVILEGES ON testdb.* FROM 'newuser'@'localhost'; -- 删除用户 use mysql; drop user 'newuser'@'localhost'; 查询练习1 create table Student(SId varchar(10),Sname varchar(10),Sage datetime,Ssex varchar(10)); insert into Student values('01' , '赵雷' , '1990-01-01' , '男'); insert into Student values('02' , '钱电' , '1990-12-21' , '男'); insert into Student values('03' , '孙风' , '1990-12-20' , '男'); insert into Student values('04' , '李云' , '1990-12-06' , '男'); insert into Student values('05' , '周梅' , '1991-12-01' , '女'); insert into Student values('06' , '吴兰' , '1992-01-01' , '女'); insert into Student values('07' , '郑竹' , '1989-01-01' , '女'); insert into Student values('09' , '张三' , '2017-12-20' , '女'); insert into Student values('10' , '李四' , '2017-12-25' , '女'); insert into Student values('11' , '李四' , '2012-06-06' , '女'); insert into Student values('12' , '赵六' , '2013-06-13' , '女'); insert into Student values('13' , '孙七' , '2014-06-01' , '女'); create table Course(CId varchar(10),Cname nvarchar(10),TId varchar(10)); insert into Course values('01' , '语文' , '02'); insert into Course values('02' , '数学' , '01'); insert into Course values('03' , '英语' , '03'); create table Teacher(TId varchar(10),Tname varchar(10)); insert into Teacher values('01' , '张三'); insert into Teacher values('02' , '李四'); insert into Teacher values('03' , '王五'); create table SC(SId varchar(10),CId varchar(10),score decimal(18,1)); insert into SC values('01' , '01' , 80); insert into SC values('01' , '02' , 90); insert into SC values('01' , '03' , 99); insert into SC values('02' , '01' , 70); insert into SC values('02' , '02' , 60); insert into SC values('02' , '03' , 80); insert into SC values('03' , '01' , 80); insert into SC values('03' , '02' , 80); insert into SC values('03' , '03' , 80); insert into SC values('04' , '01' , 50); insert into SC values('04' , '02' , 30); insert into SC values('04' , '03' , 20); insert into SC values('05' , '01' , 76); insert into SC values('05' , '02' , 87); insert into SC values('06' , '01' , 31); insert into SC values('06' , '03' , 34); insert into SC values('07' , '02' , 89); insert into SC values('07' , '03' , 98); 20240708135160.webp 查询" 01 “课程比” 02 "课程成绩高的学生的信息及课程分数 SELECT s.SId, s.Sname, s.Sage, s.Ssex, a.score, b.score FROM student s JOIN sc a ON s.SId = a.SId AND a.CId = "01" JOIN sc b ON s.SId = b.SId AND b.CId = "02" WHERE a.score > b.score; 查询同时存在" 01 “课程和” 02 "课程的成绩情况 SELECT s.SId, s.Sname, s.Sage, s.Ssex, a.score, b.score FROM student s JOIN sc a ON s.SId = a.SId AND a.CId = '01' JOIN sc b ON s.SId = b.SId AND b.CId = '02'; 查询存在" 01 “课程但可能不存在” 02 "课程的成绩情况(不存在时显示为 null ) SELECT s.SId, s.Sname, s.Sage, s.Ssex, a.score, b.score FROM student s JOIN sc a ON s.SId = a.SId AND a.CId = '01' Left JOIN sc b ON s.SId = b.SId AND b.CId = '02'; 查询不存在" 01 “课程但存在” 02 "课程的成绩情况 SELECT s.*, a.score FROM student s JOIN sc a ON s.SId = a.SId and a.CId='02' left join sc b ON s.SId = b.SId and b.CId='01' where b.SId is null; 查询平均成绩大于等于 60 分的同学信息和平均分 select s.*, t.avg from (select sc.SId id, avg(score) avg from sc group by sc.SId having avg>=60) t join student s on t.id = s.SId 查询在 SC 表存在成绩的学生信息 SELECT DISTINCT student.* FROM student JOIN sc ON student.SId = sc.SId; select s.* from (select SId id from sc group by SId) t left join student s on t.id = s.SId; 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null ) select s.SId, s.Sname, ifnull(t.cs,0) c, t.sum from student s left join (select sc.SId id, count(*) cs, sum(score) sum from sc group by sc.SId) t on s.SId = t.id; 查有成绩的学生信息 select s.* from (select sc.SId id from sc group by sc.SId) t left join student s on s.SId = t.id 查询[李]姓老师数量 -- LIKE '李%' 通常比 SUBSTRING(Tname, 1, 1) = '李' 更快，因为 LIKE 运算符能够利用索引。 -- 而 SUBSTRING 函数需要逐行处理字符串，无法使用索引。 -- 如果 Tname 列有索引，使用 LIKE '李%' 可以大大提高查询性能。 select count(*) from teacher where substring(Tname,1,1)='李'; select count(*) from teacher where tname like '李%'; 查询学过「张三」老师授课的同学的信息 -- 现代 SQL 优化器对 JOIN 语法的优化通常比旧式逗号分隔法更好，尤其是涉及多个表连接时。 select stu.* from course c join (select t.TId tid from teacher t where t.Tname='张三') t1 on t1.tid=c.TId join sc s on c.CId=s.CId join student stu on stu.SId=s.SId; select student.* from student,teacher,course,sc where student.sid = sc.sid and course.cid=sc.cid and course.tid = teacher.tid and tname = '张三'; 查询没有学全所有课程的同学的信息 select s.* from student s left join (select sc.SId id, count(*) c from sc group by sc.SId) t on s.SId=t.id join (select count(*) a from course) t2 where t.c<t2.a or t.c is null 查询至少有一门课与学号为" 01 "的同学所学相同的同学的信息 select distinct s.* from student s join sc c on s.SId=c.SId and c.CId in (select sc.CId from sc where sc.SId='01') where s.SId!='01'; 查询和" 01 "号的同学学习的课程 完全相同的其他同学的信息 -- 使用 GROUP_CONCAT 函数来连接课程 ID，并通过子查询来比较这些连接后的字符串 -- 使用 ORDER BY 确保课程 ID 的顺序一致，这样才可以进行正确的字符串比较 select s.* from student s join (select group_concat(CID order by CId) c, SId from sc group by SId) t on s.SId=t.SId join (select group_concat(CID order by CId) c from sc where SId='01' group by SId) t2 on t.c=t2.c where s.SId!='01'; 查询没学过"张三"老师讲授的任一门课程的学生姓名 -- 这是一种经典的反连接（anti-join）操作，通常用于查找不匹配的记录 select stu.* from teacher t join course c on t.TId=c.TId and t.Tname='张三' join sc s on s.CId=c.CId right join student stu on s.SId=stu.SId where s.CId is null; 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 -- sc 表被扫描了两次，一次用于计算低于 60 分的课程数量，另一次用于计算平均成绩。 select s.SId, s.Sname, t2.a from (select SId, count(*) c from sc where sc.score<60 group by SId) t join (select SId, avg(score) a from sc group by SId) t2 on t.SId=t2.SId and t.c>=2 join student s on s.SId=t2.SId; -- sc 表只被扫描了一次，所有计算和筛选条件都在一个子查询中完成。 SELECT s.SId, s.Sname, t2.a FROM (SELECT SId, AVG(score) AS a FROM sc GROUP BY SId HAVING SUM(score < 60) >= 2) t2 JOIN student s ON s.SId = t2.SId; 检索" 01 "课程分数小于 60，按分数降序排列的学生信息 select s.*, t.score from (select SId,score from sc where score<60 and CId='01' order by score desc) t join student s on t.SId=s.SId; -- 直接在主查询中处理连接和筛选, 避免了子查询带来的额外开销 SELECT s.*, sc.score FROM student s JOIN sc ON s.SId = sc.SId WHERE sc.score < 60 AND sc.CId = '01' ORDER BY sc.score DESC; 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 select * from sc left join (select SId, avg(score) a from sc group by SId) t on t.SId = sc.SId order by t.a desc 查询各科成绩最高分、最低分和平均分 -- 课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 -- 输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 select c.*, t.选修人数,t.max,t.min,t.avg,t.及格率,t.中等率,t.优良率,t.优秀率 from course c join (select CId, count(*) 选修人数, max(score) max, min(score) min, avg(score) avg, -- sum(case when score>=60 then 1 else 0 end)/count(*) 及格率, sum(if(score>=60,1,0))/count(*) 及格率, sum(if(score>=70 and score<80,1,0))/count(*) 中等率, sum(if(score>=80 and score<90,1,0))/count(*) 优良率, sum(if(score>=90,1,0))/count(*) 优秀率 from sc group by CId) t on c.CId=t.CId order by t.选修人数 desc ,t.CId; 按各科成绩进行排序，并显示排名， Score 重复时合并名次 -- 执行顺序: FROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY -> LIMIT -- group by a.CId, a.SId,a.score, 将表中具有相同 CId、SId 和 score 的行进行分组 -- count(b.higher_score)计算的是比当前学生成绩更高的记录数, 如果没有更高的(第一)则为0,为了从1开始所以+1 select a.CId, a.SId, a.score, count(b.score)+1 rk from sc as a left join sc as b on a.score<b.score and a.CId = b.CId group by a.CId, a.SId,a.score order by a.CId, rk ASC; 查询学生的总成绩，并进行排名，总分重复时保留名次空缺 -- 内层查询执行：从表 sc 中按 sid 分组，计算每个学生的总分，并按总分从高到低排序。 -- 外层查询执行：从内层查询生成的结果集中，逐行处理每一行，每处理一行将 @crank 的值加1，并将其作为 rank 列的值。 -- 会话变量以 @ 开头，并且在同一会话中可以通过多个查询使用和修改 -- SET 语句：使用 = 进行赋值。 -- SELECT 语句：使用 := 进行赋值。因为在 SELECT 查询中，赋值操作并不是标准 SQL 的一部分，而是 MySQL 特有的语法扩展 set @crank=0; select q.sid, total, @crank:=@crank+1 as rnk from( select sc.sid, sum(sc.score) as total from sc group by sc.sid order by total desc ) q; 统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] -- 不要想着先单表group by计算出结果再从第二张表里添上课程信息，而应该先将两张表join在一起得到所有想要的属性再对这张总表进行统计计算 -- group by sc.CId, course.CId; select中用了几个字段,group by后面也得跟几个字段 select course.Cname, course.CId, sum(case when sc.score<=100 and sc.score>85 then 1 else 0 end) as "[100-85]", sum(case when sc.score<=85 and sc.score>70 then 1 else 0 end) as "[85-70]", sum(case when sc.score<=70 and sc.score>60 then 1 else 0 end) as "[70-60]", sum(case when sc.score<=60 and sc.score>0 then 1 else 0 end) as "[60-0]" from sc left join course on sc.CId = course.CId group by sc.CId, course.CId; 查询各科成绩前三名的记录 -- 在 GROUP BY 子句中使用的列必须与 SELECT 列表中的所有非聚合列一致，而 ORDER BY 子句中的列必须是聚合列或 GROUP BY 子句中的列 select a.CId, a.SId, a.score, count(b.score)+1 rk from sc a left join sc b on a.score<b.score and a.CId=b.CId group by a.SId,a.CId,a.score having rk<4 order by a.CId,rk; SELECT sub.CId, sub.SId, sub.score FROM ( SELECT a.CId, a.SId, a.score, COUNT(b.score) + 1 AS rk FROM sc a LEFT JOIN sc b ON a.score < b.score AND a.CId = b.CId GROUP BY a.CId, a.SId, a.score HAVING rk < 4 ) sub ORDER BY sub.CId, sub.rk; 查询出只选修两门课程的学生学号和姓名 select s.SId id, s.Sname name from student s join sc on s.SId=sc.SId group by s.SId, s.Sname having count(*) = 2 统计同名同姓学生人数 select s.Sname, s.Ssex, count(*) c from student s group by s.Sname, s.Ssex having c>1 查询1990年出生的学生名单 select * from student -- where date_format(Sage,'%Y')=1990 where year(Sage)=1990 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 select c.Cname,c.CId, avg(score) avg from course c join sc on c.CId=sc.CId group by c.Cname,c.CId order by avg desc ,c.CId 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 select sc.SId,s.Sname, avg(score) avg from student s join sc on s.SId=sc.SId group by sc.SId,s.Sname having avg>=85 查询课程名称为「数学」，且分数低于 60 的学生姓名和分数 select s.Sname, sc.score from student s join sc on s.SId=sc.SId join course c on sc.CId=c.CId and c.Cname='数学' where sc.score<60 -- 查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数 select s.Sname,c.Cname, sc.score from student s join sc on s.SId=sc.SId join course c on sc.CId=c.CId where sc.score>70 查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩, 包括重复的 SELECT stu.*, sc.score FROM sc JOIN student stu ON sc.SId = stu.SId JOIN ( SELECT sc.score co FROM sc JOIN course c ON sc.CId = c.CId JOIN teacher t ON c.TId = t.TId AND t.Tname = '张三' ORDER BY sc.score DESC LIMIT 1 ) sub WHERE sc.score = sub.co; -- 定义变量存储最高分 SET @highest_score = ( SELECT sc.score FROM sc JOIN course c ON sc.CId = c.CId JOIN teacher t ON c.TId = t.TId AND t.Tname = '张三' ORDER BY sc.score DESC LIMIT 1 ); -- 使用变量在主查询中查找对应的学生记录 SELECT stu.*, sc.score FROM sc JOIN student stu ON sc.SId = stu.SId WHERE sc.score = @highest_score; 查询每门功课成绩最好的前两名 select sub.* from (select a.CId, a.SId, a.score, count(b.score) + 1 rk from sc a left join sc b on a.CId = b.CId and a.score < b.score group by a.CId, a.SId, a.score order by a.CId, rk) sub where sub.rk < 3 -- having count(b.CId) < 2 -- b.CId的数量是分数比当前行高的其它记录数量,要求前两名,所以最多为1,因此条件是小于2 select a.SId, a.CId, a.score from sc as a left join sc as b on a.CId = b.CId and a.score < b.score group by a.CId, a.SId, a.score having count(b.CId) < 2 order by a.CId; 根据出生日期计算年龄 select * ,timestampdiff(year,Sage,now()) from student 查询本周过生日的学生 select * from student where weekofyear(Sage)=weekofyear(now()) 查询下周过生日的学生 select * from student where weekofyear(Sage)=weekofyear(now())+1 查询上个月过生日的学生 select * from student where month(Sage)=month(now())-1`,``,`html`,`Nginx`,`20240602102650-_环境容器 20240602110902.webp 用作HTTP反向代理服务器 用作静态资源服务器, 当静态资源请求到达时,nginx直接获取到当前请求的文件并返回, 不经过tomcat, tomcat只负责处理动态请求, 动态静态资源分离从而提高响应速度 高并发高性能 模块化设计可扩展性好 高可靠性,可以在服务器上持续不间断运行长达数年 热部署,可以在不停止服务的情况下对自身的内容进行升级更新 BSD开源,可商用 正向和反向代理 20240602105317.webp 20240602111044.webp 正向代理（Forward Proxy） 代表客户端向服务器发送请求，并将服务器的响应返回给客户端 匿名访问：隐藏客户端的 IP 地址，保护用户隐私。 访问控制：管理和控制客户端对外部资源的访问。 缓存：缓存常用资源，减少带宽使用和加快访问速度。 内容过滤：拦截和过滤不良内容或特定网站。 用户配置浏览器使用正向代理服务器，访问被防火墙阻挡的网站。 反向代理（Reverse Proxy） 代表服务器接受客户端请求并将请求转发给后端服务器进行处理，然后将后端服务器的响应返回给客户端 负载均衡：将客户端请求分配到多个后端服务器，均衡负载。 安全性：隐藏后端服务器的真实 IP 地址，增强安全性。 缓存：缓存静态内容，加快响应速度。 SSL 卸载：处理 SSL 加密和解密，减轻后端服务器的负担。 使用 Nginx 作为反向代理服务器，将客户端请求分配给多台后端 Web 服务器，提供高可用性和负载均衡。 安装运行 #检查是否安装了yum-utils yum list installed | grep utils #创建yum存储库配置文件 vi /etc/yum.repos.d/nginx.repo #------------------------------ [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true #------------------------------ #这个配置文件定义了两个 Nginx 的软件包存储库：nginx-stable 和 nginx-mainline。 #[nginx-stable]：Nginx 稳定版本的存储库配置。适合生产环境，因为它的功能已经经过充分测试和验证，确保了高稳定性和可靠性。 #[nginx-mainline]：Nginx 主线版本的存储库配置。适合开发环境，可以测试和利用最新的功能和改进。 #查看源及版本 yum list | grep nginx #安装 Nginx 稳定版本 #运行 yum install nginx，它将安装 nginx-stable 存储库中的 nginx 版本 #因为 [nginx-stable] 存储库的 enabled 参数设置为 1，而 [nginx-mainline] 存储库的 enabled 参数设置为 0。默认情况下，yum 会从启用的存储库中安装软件包。 #如果你想要安装 nginx-mainline 版本，可以先启用该存储库，然后再安装： # yum-config-manager --enable nginx-mainline # yum install nginx yum install nginx nginx -v #二进制文件、配置文件和其他相关文件的位置 whereis nginx #运行,在某些环境中，使用绝对路径可以避免环境变量设置导致的路径问题 /usr/sbin/nginx #确认是否正在运行,再执行一遍nginx如果有在运行会提示端口已绑定,或者访问80端口是否有nginx页面 #列出所有与 Nginx 相关的进程 ps aux|grep nginx #nginx默认端口80 firewall-cmd --list-all firewall-cmd --permanent --zone=public --add-port=80/tcp firewall-cmd --reload #帮助 nginx -h #停止nginx ,-s后 stop(立即停止),quit(手头事情做完后停止),reload(手头事情做完后停止然后再启动) nginx -s stop #启动时指定配置文件 nginx -c /etc/nginx/nginx.conf #编辑完配置文件后,检查配置文件语法, 或者用来确认当前使用的是哪里配置文件 nginx -t nginx配置文件 全局配置 /etc/nginx/nginx.conf Nginx 的主配置文件。它定义了全局的设置和配置 # 设置 Nginx 进程使用的用户，通常设置为 &#715;nginx&#715; 或 &#715;www-data&#715; user nginx; # 设置工作进程的数量为自动，根据 CPU 核心数自动调整 worker_processes auto; # 指定错误日志的路径，并设置日志级别为 &#715;notice&#715; error_log /var/log/nginx/error.log notice; # 指定 Nginx 主进程的 PID 文件路径 pid /var/run/nginx.pid; events { # 设置每个工作进程的最大连接数 worker_connections 1024; } http { # 引入 MIME 类型配置文件，以便 Nginx 正确处理不同类型的文件 include /etc/nginx/mime.types; # 设置默认的 MIME 类型 default_type application/octet-stream; # 定义访问日志的格式 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; # 指定访问日志的路径，并使用 &#715;main&#715; 格式 access_log /var/log/nginx/access.log main; # 启用高效文件传输 sendfile on; # &#715;tcp_nopush&#715; 指令可用于优化大文件的传输 # tcp_nopush on; # 设置持久连接的超时时间 keepalive_timeout 65; # 启用 Gzip 压缩可以减少传输数据的大小 # gzip on; # 引入 &#715;/etc/nginx/conf.d/&#715; 目录下的所有配置文件 include /etc/nginx/conf.d/*.conf; } 单个站点 /etc/nginx/conf.d/default.conf server { # 监听 80 端口，处理 HTTP 请求 listen 80; # 服务器名称或虚拟主机名 server_name example.com www.example.com; # 访问日志文件及格式 access_log /var/log/nginx/example.access.log combined; # 错误日志文件及日志级别 error_log /var/log/nginx/example.error.log error; # 根目录设置 root /var/www/html; # 默认首页文件 index index.html index.htm; # 处理根路径的配置, 如果请求的文件或目录存在，则返回该文件或目录；如果不存在，则返回 404 错误 # try_files 指令用于尝试多个文件路径，以寻找匹配的文件或目录, $uri是一个变量，表示客户端请求的 URI location / { try_files $uri $uri/ =404; } # 处理静态文件目录, 将 /static/ 请求路径映射到 /var/www/static/ 目录，用于提供静态文件 location /static/ { alias /var/www/static/; } # 处理特定文件类型的请求, 对于特定的文件类型（如图片），设置缓存过期时间为 30 天，并关闭访问日志 # ~* 表示使用不区分大小写的正则表达式匹配 location ~* \.(jpg|jpeg|png|gif|ico)$ { expires 30d; access_log off; } # 处理特定请求的配置, 将以 /api/ 开头的请求转发到 http://backend_server，并设置适当的代理头部。 location /api/ { proxy_pass http://backend_server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # 设置 404 错误页面的自定义页面 error_page 404 /404.html; # 配置 404 错误页面的位置, internal 表示此页面不能直接被客户端请求 location = /404.html { root /var/www/html; internal; } # 设置 50x 错误页面 error_page 500 502 503 504 /50x.html; location = /50x.html { root /var/www/html; } # 启用基本的重定向, 对于 /old-page 路径的请求，执行永久重定向到 /new-page location /old-page { return 301 /new-page; } # 配置限制请求速率, 限制每个 IP 地址的请求速率为每秒 1 个请求 limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s; # 对于 /rate-limited/ 路径的请求，应用请求速率限制，允许突发的请求，并且不延迟处理突发请求(如果没有设置 nodelay，突发的请求可能会被延迟处理，以平衡请求速率) # burst=5: 允许每个 IP 地址在短时间内有 5 个请求超出正常速率限制。 # 例如，正常速率为每秒 1 个请求，而允许的突发量是 5。这意味着在 1 秒钟内，如果一个 IP 地址发送了 6 个请求（超出了正常速率限制），Nginx 会允许这 6 个请求中的前 5 个请求通过，而第 6 个请求会受到速率限制。 location /rate-limited/ { limit_req zone=mylimit burst=5 nodelay; } } 作为反向代理服务器时的配置 # HTTP 服务器配置 http { # 定义一个名为 backend 的后端服务器池, 包含多个后端服务器地址，根据负载均衡算法将请求分发到这些服务器 upstream backend { # 后端服务器列表 server backend1.example.com; # 后端服务器 1 server backend2.example.com; # 后端服务器 2 server backend3.example.com; # 后端服务器 3 # 负载均衡算法（可选） # round-robin: 默认算法，依次将请求分发给后端服务器 # least_conn: 将请求分发给连接数最少的服务器 # ip_hash: 通过客户端 IP 地址哈希，保持会话一致性 } # 服务器块，处理客户端请求 server { # 监听 80 端口 listen 80; # 服务器名称或虚拟主机名 server_name www.example.com; # 访问日志文件及格式 access_log /var/log/nginx/proxy.access.log; # 错误日志文件及日志级别 error_log /var/log/nginx/proxy.error.log; # 根目录设置（用于静态文件） root /var/www/html; # 默认首页文件 index index.html index.htm; # 处理根路径的请求 location / { # 将请求代理到 upstream 定义的后端服务器池 proxy_pass http://backend; # 设置适当的请求头部 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; # 代理请求的超时设置（可选） proxy_connect_timeout 60s; proxy_send_timeout 60s; proxy_read_timeout 60s; # 处理特殊的头部（例如 cookie） proxy_cookie_path / "/; secure; HttpOnly; SameSite=Strict"; } # 处理特定路径的请求，例如 API 请求 location /api/ { # 将 API 请求代理到另一个后端服务器 proxy_pass http://api_backend; # 设置请求头部 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # 自定义错误页面（可选） error_page 404 /404.html; location = /404.html { root /var/www/html; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /var/www/html; } } }`,``,`html`,`OA请假审批模块`,`20240616183123-_项目例 基于Mybatis开发实战 系统权限设计 MD5敏感数据加密 LayUI框架使用入门 工作流程设计 办公自动化Office Automation RBAC Role-Based Access Control 基于角色的访问权限控制 用户角色对照表, 角色资源对照表 围绕角色将用户和资源间接关联起来 20240425163028.webp md5摘要 md5长度固定,不可逆,容易受彩虹表字典攻击,对猜测的密码进行md5摘要,再与已知的md5比较来尝试获取原密码 不能要求用户设置特别复杂的密码,因为可能连他自己都记不住 通过应用不同的盐值,两个相同的密码可以得到不同的摘要 攻击者即使通过字典猜测破解了md5摘要,得到的也是无意义的字符串,除非获得底层的盐值算法 20240901151904.webp 1.持久化form表单数据,8级以下员工表单状态为processing,8级(总经理)状态为approved 2.增加第一条流程数据,说明表单已提交,状态为complete 3.分情况创建其余流程数据 3.1 7级以下员工,生成部门经理审批任务,请假时间大于72小时,还需生成总经理审批任务 3.2 7级员工,生成总经理审批任务 3.3 8级员工,生成总经理审批任务,系统自动通过 pom <dependencies> <!-- mysql,mybatis --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.33</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.9</version> </dependency> <!-- HikariCP --> <dependency> <groupId>com.zaxxer</groupId> <artifactId>HikariCP</artifactId> <version>3.4.5</version> <!-- 适用于 Java 8 的 HikariCP 版本 --> </dependency> <!-- fastjson --> <dependency> <groupId>com.alibaba</groupId> <artifactId>fastjson</artifactId> <version>1.2.78</version> </dependency> <!-- freemarker --> <dependency> <groupId>org.freemarker</groupId> <artifactId>freemarker</artifactId> <version>2.3.30</version> </dependency> <!-- codec --> <dependency> <groupId>commons-codec</groupId> <artifactId>commons-codec</artifactId> <version>1.14</version> </dependency> <!-- logback --> <dependency> <groupId>ch.qos.logback</groupId> <artifactId>logback-classic</artifactId> <version>1.2.3</version> </dependency> <!-- servlet, junit --> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.13.2</version> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <!-- Maven 编译插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <!-- Maven WAR 插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.4.0</version> </plugin> </plugins> </build> mybatis-conf <?xml version="1.0" encoding="UTF-8" ?> <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> <configuration> <settings> <setting name="mapUnderscoreToCamelCase" value="true"/> </settings> <environments default="dev"> <environment id="dev"> <transactionManager type="JDBC"/> <dataSource type="com.ida.demo4.datasource.HikariCPDataSourceFactory"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/oa?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai"/> <property name="username" value="root"/> <property name="password" value="root"/> <property name="poolName" value="MyHikariCPPool"/> <property name="maximumPoolSize" value="10"/> <property name="minimumIdle" value="5"/> <property name="idleTimeout" value="30000"/> <property name="connectionTimeout" value="30000"/> <property name="maxLifetime" value="1800000"/> <property name="connectionTestQuery" value="SELECT 1"/> </dataSource> </environment> </environments> <mappers> <mapper resource="mappers/user.xml"/> <mapper resource="mappers/rbac.xml"/> <mapper resource="mappers/employee.xml"/> <mapper resource="mappers/department.xml"/> <mapper resource="mappers/leave_form.xml"/> <mapper resource="mappers/process_flow.xml"/> <mapper resource="mappers/notice.xml"/> </mappers> </configuration> 登录跳转 @WebServlet(name = "LoginServlet", urlPatterns = "/check_login") public class LoginServlet extends HttpServlet { private final Logger logger = LoggerFactory.getLogger(LoginServlet.class); private final UserService userService = new UserService(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { req.setCharacterEncoding("utf-8"); String username = req.getParameter("username"); String password = req.getParameter("password"); Map<String,Object> result = new HashMap<>(); try { User user = userService.checkLogin(username, password); req.getSession().setAttribute("login_user",user); result.put("code","0"); result.put("message","success"); result.put("redirect_url","/index"); } catch (BussinessException e) { logger.error(e.getMessage(), e); result.put("code",e.getCode()); result.put("message",e.getMessage()); } catch (Exception e) { logger.error(e.getMessage(), e); } String jsonString = JSON.toJSONString(result); resp.setContentType("text/html;charset=utf-8"); resp.getWriter().println(jsonString); } } @WebServlet(name = "IndexServlet", urlPatterns = "/index") public class IndexServlet extends HttpServlet { private final UserService userService = new UserService(); private final EmployeeService employeeService = new EmployeeService(); private final DepartmentService departmentService = new DepartmentService(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); User user = (User) session.getAttribute("login_user"); Employee employee = employeeService.selectById(user.getEmployeeId()); Department department = departmentService.selectById(employee.getDepartmentId()); List<Node> nodeList = userService.selectNodeByUserId(user.getUserId()); session.setAttribute("current_employee",employee); req.setAttribute("node_list",nodeList); session.setAttribute("current_department",department); req.getRequestDispatcher("/index.ftl").forward(req,resp); } }`,``,`html`,`Once Upon a Time In America`,`20240307183503-影摘 无论你多么的年轻健壮最后都会倒在上帝的剑下`,``,`html`,`PostgreSQL`,`20240906180530-_数据库 PostgreSQL 和 MySQL 都是流行的开源关系型数据库管理系统（RDBMS） PostgreSQL适合复杂数据处理、分析型应用、企业级系统、需要高扩展性和自定义功能的场景，特别是需要处理结构化和非结构化数据的大型系统。 MySQL适合高并发的 Web 应用、轻量级的数据库需求，以及需要高性能读写操作的中小型项目。 被称为“世界上最先进的开源数据库”。注重标准兼容性和功能的完整性。支持复杂的数据类型和高级的查询功能。 MySQL主要强调 性能和易用性，更轻量，通常在 Web 开发中使用广泛。专注于简单的查询性能，通常较少使用复杂的SQL特性。 严格遵循 SQL 标准，支持许多高级 SQL 特性，如窗口函数、CTE（公共表表达式）、递归查询等，适合复杂查询。 MySQL 对 SQL 标准的支持不如 PostgreSQL 完整，在处理复杂查询和高级 SQL 特性上略显不足，但其语法更加简化，易于使用。 使用多版本并发控制（MVCC），可以处理高并发的事务而不锁定数据行，完全支持 ACID（原子性、一致性、隔离性、持久性），确保数据的一致性和可靠性。适合需要复杂事务处理的应用。 MySQL 通过 InnoDB 引擎也支持 ACID 事务和 MVCC，但其默认的隔离级别为 可重复读（Repeatable Read），在处理复杂事务时可能性能稍逊。锁机制的处理在并发性上不如 PostgreSQL。 可以使用 多种编程语言（如 PL/pgSQL、Python、Perl 等）编写存储过程。支持自定义数据类型、函数和操作符，提供极高的扩展性。外部数据封装器（FDW） 允许将外部数据源（其他数据库、文件系统）作为本地表使用。 在复杂查询和大规模数据处理上，PostgreSQL 的性能往往优于 MySQL。它支持 并行查询，并能对复杂查询和大量数据进行更优化的处理。更适合需要复杂数据操作和高性能的企业级应用。 MySQL在简单查询和读操作场景中，MySQL 的性能表现较好，尤其适合高读写比的 Web 应用。对于中小型应用程序，MySQL 可以提供更高效的查询性能。 支持多种索引类型，包括 B-tree、Hash、GIN、GiST 等，能针对不同查询需求选择合适的索引。提供丰富的数据类型，如 数组、JSON、XML、IP地址类型，以及自定义数据类型的支持，非常适合需要存储复杂数据的应用。 MySQL 索引类型较为有限，主要支持 B-tree 索引，但其查询性能在简单场景下表现较好。数据类型相对简单，虽然支持 JSON，但处理能力不如 PostgreSQL 的 JSONB 强大。 提供主从复制 和 逻辑复制，支持流式复制，并允许热备份。逻辑复制允许在表级别进行复制，适合对部分数据集进行复制和分发。 MySQL 提供了较为简单的主从复制功能，支持 异步复制 和 半同步复制，且其复制设置较为简单，适合 Web 开发。 拥有强大的社区支持和活跃的开发者生态，提供了许多第三方扩展和插件（如 PostGIS 用于地理空间数据），被认为是学术研究和企业应用中的首选数据库。 MySQL 社区庞大，文档和教程丰富，是 Web 开发、CMS（如 WordPress）等领域中最流行的数据库，特别适合中小型项目和初学者。 postgresql.conf # 客户端编码 client_encoding = 'UTF8' # 指定 PostgreSQL 监听的 IP 地址。设置为 '*' 以监听所有地址，或指定具体的地址。 listen_addresses = '*' port = 5432 max_connections = 100 # PostgreSQL 使用的共享内存缓冲区大小。通常设置为总内存的 25% 左右。 shared_buffers = 128MB # 每个操作（如排序）可使用的内存量。应根据工作负载进行调整。 work_mem = 4MB # 维护操作（如创建索引）可使用的内存量。通常设置为比 work_mem 大。 maintenance_work_mem = 64MB # WAL（写前日志）的记录级别。选项包括 minimal、replica 和 logical。 wal_level = replica # 检查点之间的时间间隔。默认是 5 分钟。 checkpoint_timeout = 15min # 日志记录的目标。可以是 stderr、csvlog、syslog 等。 log_destination = 'stderr' # 是否启用日志收集器。如果启用，则日志会写入文件。 logging_collector = on log_directory = 'pg_log' log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log' # 是否启用自动清理功能，以避免表膨胀。 autovacuum = on # 自动清理进程之间的时间间隔。 autovacuum_naptime = 1min # 估计数据库系统能够使用的缓存内存量。帮助优化查询规划。 effective_cache_size = 4GB # 用于估计随机访问磁盘页面成本的值。影响查询优化器的决策。 random_page_cost = 4.0 # cpu_tuple_cost 和 cpu_index_tuple_cost：影响优化器估计 CPU 消耗的设置。 cpu_tuple_cost = 0.01 cpu_index_tuple_cost = 0.005 # 设置密码加密方法。可以选择 md5 或 scram-sha-256。 password_encryption = scram-sha-256 # 启用 SSL 加密连接。 ssl = on # ssl_cert_file 和 ssl_key_file：指定 SSL 证书和私钥文件的位置。 ssl_cert_file = 'server.crt' ssl_key_file = 'server.key' # 设置数据库的时区。 timezone = 'UTC' # 设置用于自动统计数据的目标，影响查询优化器的统计信息。 default_statistics_target = 100 # 设置每个事务允许的最大锁定数。 max_locks_per_transaction = 64 PostgreSQL 和 MySQL 之间的命令差异 PostgreSQL 的命令以反斜杠 \ 开头是 psql 命令行工具的内部命令 MySQL 的命令是 SQL 语句，直接在 MySQL 命令行工具中执行 显示所有数据库 : \l 或 \list : SHOW DATABASES; 切换数据库 : \c database_name : USE database_name; 显示所有表 : \dt : SHOW TABLES; 显示表结构 : \d table_name : DESCRIBE table_name; 或 SHOW COLUMNS FROM table_name; 查看索引 : \di : SHOW INDEX FROM table_name; 查看视图 : \dv : SHOW FULL TABLES WHERE Table_type = 'VIEW'; 查看用户 : \du : SELECT User FROM mysql.user; 创建用户 : CREATE USER 'user' WITH PASSWORD 'password'; : CREATE USER 'user'@'host' IDENTIFIED BY 'password'; 删除用户 : DROP USER 'user'; : DROP USER 'user'@'host'; 授权权限 : GRANT ALL PRIVILEGES ON database_name.* TO 'user'; : GRANT ALL PRIVILEGES ON database_name.* TO 'user'@'host'; 撤销权限 : REVOKE ALL PRIVILEGES ON database_name.* FROM 'user'; : REVOKE ALL PRIVILEGES ON database_name.* FROM 'user'@'host'; 查看当前连接信息 : \conninfo : SHOW PROCESSLIST; 命令行基础操作 # 使用默认的postgres帐号登录到本地数据库 psql -U postgres -h localhost create database testdb; # 切换到testdb \c testdb; # user 是一个保留字，它用于表示当前数据库用户。因此，直接使用 user 作为表名会导致语法错误 # 单引号（'）用于包裹字符串值, 双引号（"），它们用于标识表名、列名、模式名等标识符, 使用两个连续的单引号来转义单引号, 或用反斜杠 \ 转义单引号字符 testdb=# create table "user"( testdb(# id serial primary key, testdb(# name varchar(32), testdb(# email varchar(128) testdb(# ); # 列出所有表, pgadmin中位于testdb/schemas/public/tables \dt # 插入数据, INSERT 0 1其中 0 是影响的行数（通常是 0），1 是实际插入的行数 testdb=# insert into "user"(name,email) values('小丽','@com'); # 使用扩展显示模式时，查询结果会以更加易读的格式进行显示，特别是当表的列数很多时，扩展模式会将每一行数据纵向排列，这样更容易阅读。 \ x on select * from "user"; centos7中安装 https://www.postgresql.org/download/linux/redhat/ yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm yum install -y postgresql13-server # 初始化数据库 /usr/pgsql-13/bin/postgresql-13-setup initdb # 加入自启 systemctl enable postgresql-13 # 启用应用 systemctl start postgresql-13 systemctl status postgresql-13 # 切换到 postgres 用户的环境 sudo -i -u postgres # 进入PostgreSQL交互式终端 psql # 为postgres设置密码 alter user postgres with password 'root';`,``,`html`,`RabbitMQ`,`20240602102650-_中间件 20240813160757.webp MQ (Message Queue) 消息队列的特性 业务无关,消息队列中的消息是与具体业务逻辑无关的，它们只是简单的数据包 FIFO 容灾,在系统故障时保证消息不会丢失(持久化),正常后重新传递 性能,消息队列能够提高系统的性能和可伸缩性，允许异步处理消息，从而减少了请求之间的耦合 为什么要使用消息队列 系统解耦, 消息队列可以将不同组件之间的耦合度降低(生产者,消息队列,消费者位于不同服务器)，使系统更容易扩展和维护 异步调用, 发送者不需要等待接收者的响应，从而提高系统的响应速度和吞吐量 流量削峰, 消息队列可以作为缓冲区，平滑处理系统的高峰流量，避免系统因突发流量而崩溃 Kafka, RabbitMQ, MQTT Kafka 设计用于高吞吐量的数据流，适合于需要处理大量数据的场景。 RabbitMQ 更适合于需要灵活路由和复杂消息传递模式的场景，但吞吐量相对较低。 AMQP协议 (Advanced Message Queuing Protocol ) 20240813161245.webp server connection 与server建立连接 channel 大部分操作都在信道上进行 message 由properties(修饰消息优先级等属性)和body(消息实体)组成 virtual host 顶层隔离,同一个虚拟主机下不能有重复的exchange和queue Exchange 交换机接收生产者的消息, 根据指定的路由器将消息转发到与交换机所绑定的队列上 binding 绑定交换机和队列,一个交换机可以绑定多个队列 routing key 路由键,虚拟机据此确定如何路由该消息 queue 消费者只需要监听队列来消费消息, 不必关注此消息来自哪个交换机 MQTT 作为一种轻量级消息传递协议，广泛应用于物联网和受限环境中。 MQTT 有多个开源和商用实现，包括： Mosquitto：一个轻量级的开源 MQTT 消息代理。 HiveMQ：一个企业级 MQTT 消息代理，支持高可用性和扩展性。 Eclipse Paho：一个开源的 MQTT 客户端库，支持多种编程语言。 与 RabbitMQ 和 Kafka 相比，MQTT 专注于轻量级和实时消息传递，而 RabbitMQ 和 Kafka 更适合企业级应用和高吞吐量的数据流处理。 RabbitMQ的安装 erlang-rpm https://github.com/rabbitmq/erlang-rpm/releases rabbitmq-server https://github.com/rabbitmq/rabbitmq-server/releases 版本对应关系 https://www.rabbitmq.com/which-erlang.html #下载 erlang-23.3.4.18-1.el7.x86_64.rpm #wget --content-disposition "https://github.com/rabbitmq/erlang-rpm/releases/download/v23.3.4.18/erlang-23.3.4.18-1.el7.x86_64.rpm" #未安装wget时用curl代替 curl -L -O -J "https://github.com/rabbitmq/erlang-rpm/releases/download/v23.3.4.18/erlang-23.3.4.18-1.el7.x86_64.rpm" #安装本地rmp yum localinstall erlang-23.3.4.18-1.el7.x86_64.rpm erl -version #下载 RabbitMq-Server rabbitmq-server-3.10.0-1.el7.noarch.rpm curl -L -O -J "https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.0-rc.6/rabbitmq-server-3.10.0.rc.6-1.el7.noarch.rpm" yum localinstall rabbitmq-server-3.10.0.rc.6-1.el7.noarch.rpm #如果虚拟机改过默认主机名,需要 vi /etc/hosts 将名字映射到127.0.0.1, RabbitMQ 节点是通过主机名来识别和通信的 systemctl start rabbitmq-server systemctl stop rabbitmq-server systemctl restart rabbitmq-server #检查 RabbitMQ 服务的系统级状态, 服务的启动时间、最近的日志条目、服务的 PID,服务的当前状态，如运行、停止或失败 systemctl status rabbitmq-server #检查 RabbitMQ 实例的运行时状态, 显示 RabbitMQ 节点的内部状态和详细信息，如 RabbitMQ 版本、节点状态、队列、连接等 rabbitmqctl status #5672 端口：这是 RabbitMQ 的默认 AMQP 端口，用于处理AMQP客户端的连接。这是消息传递服务的主要端口，所有通过 AMQP 协议进行的消息传递都会使用这个端口。 #15672 端口：RabbitMQ 管理插件的默认端口。通过这个端口可以访问 RabbitMQ 的管理界面。 #25672 端口：用于 集群通信 #启用管理界面 rabbitmq-plugins enable rabbitmq_management #创建账号密码 rabbitmqctl add_user ida 123456 #分配用户组 rabbitmqctl set_user_tags ida administrator #设置用户权限, 用户的默认权限是限制性的，新创建的用户没有任何权限。必须通过显式的 set_permissions 命令为用户分配适当的权限，以允许他们访问和操作 RabbitMQ 的资源 #如果用户已经是管理员组的成员，那么他们已经具备了对所有虚拟主机和资源的完全访问权限。此时，单独使用 set_permissions 命令为该用户设置权限是冗余的 #依次为用户对交换机和队列的创建和删除权限, 用户对交换机的消息发布权限, 用户对队列的消息消费权限 #rabbitmqctl set_permissions -p / ida ".*" ".*" ".*" #默认用户guest只能在本机上登陆,不能远程登陆, 新建管理员后要去后台与主机"/"绑定 #放行端口 firewall-cmd --permanent --add-port=15672/tcp firewall-cmd --permanent --add-port=5672/tcp firewall-cmd --reload firewall-cmd --list-ports Status of node rabbit@master ... Runtime OS PID: 3277 OS: Linux Uptime (seconds): 40 #RabbitMQ 节点自启动以来的运行时间（以秒为单位） Is under maintenance?: false #节点是否处于维护模式，此处为 false 表示节点未处于维护模式。 RabbitMQ version: 3.10.0-rc.6 Node name: rabbit@master Erlang configuration: Erlang/OTP 23 [erts-11.2.2.17] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] [hipe] Erlang processes: 355 used, 1048576 limit #Erlang 进程的使用情况和最大限制 Scheduler run queue: 1 #Erlang 调度程序的运行队列中待处理的进程数量 Cluster heartbeat timeout (net_ticktime): 60 #集群心跳超时时间（秒），用于节点间的心跳检测 Plugins Enabled plugin file: /etc/rabbitmq/enabled_plugins #存储启用的插件配置文件路径 Enabled plugins: * rabbitmq_management #提供 RabbitMQ 管理界面的插件 * amqp_client #AMQP 客户端库 * rabbitmq_web_dispatch #Web 分发插件 * cowboy #HTTP 服务器库 * cowlib #辅助库 * rabbitmq_management_agent #管理代理插件 # .. Total: 2, limit: 32671 Sockets: 0, limit: 29401 Free Disk Space Low free disk space watermark: 0.05 gb Free disk space: 16.5814 gb Totals Connection count: 0 #当前连接的数量 Queue count: 0 #当前队列的数量 Virtual host count: 1 #当前虚拟主机的数量 Listeners Interface: [::], port: 15672, protocol: http, purpose: HTTP API Interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication Interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0 使用docker安装 使用 Docker 安装 RabbitMQ 时，不需要额外安装 Erlang，因为 RabbitMQ Docker 镜像已经包含了 Erlang 的所有必要组件和依赖 #rabbitmq:management 是 RabbitMQ 官方提供的一个 Docker 镜像，其中包含 RabbitMQ 和管理插件。management 是镜像的标签（tag） docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management #RabbitMQ 服务：容器启动后，RabbitMQ 服务将在后台运行，并接受来自主机的端口 5672 上的 AMQP 请求。 #Web 管理界面：你可以通过访问 http://localhost:15672 来访问 RabbitMQ 的 Web 管理界面，进行消息队列的管理和监控。 持久化和非持久化 如果需要队列的完整性，数据在队列中的保存是必须不允许丢失的，那么可以使用持久化。 而当需要获取的信息是实时的，或者是随机的信息，不需要信息的精确性或完整性，但是追求获取性能，可以选择非持久化队列 RabbitMQ 持久化包含3个部分 exchange 持久化，在声明时指定 durable 为 true queue 持久化，在声明时指定 durable 为 true message 持久化，在投递时指定 delivery_mode=2（1是非持久化） RabbitMQ的java客户端 依赖 <dependency> <groupId>com.rabbitmq</groupId> <artifactId>amqp-client</artifactId> <version>5.8.0</version> </dependency> <!-- rabbitmq内部的日志依赖 --> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-nop</artifactId> <version>1.7.29</version> </dependency> 生产者方法相关参数说明 队列 异常处理：确保在代码中适当处理可能出现的异常，尤其是在消费者无法连接到队列或队列不存在时。 队列配置：如果你在生产者中声明了队列，消费者中的 queueDeclare 语句可以省略，但如果队列的参数配置不一致，可能会引发问题。确保在任何地方声明队列时使用一致的参数配置。 预先创建：考虑在应用程序之外（如 RabbitMQ 管理界面）创建队列，避免在代码中声明队列时产生冲突或不一致问题。 public class Send { private static final String QUEUE_NAME = "q1"; private static final String HOST = "192.168.149.130"; private static final String USERNAME = "ida"; private static final String PASSWORD = "123456"; private static final String MESSAGE = "Hello world"; public static void main(String[] args) { // 创建连接工厂,设置连接信息,建立连接,获得信道,声明队列,发送消息,关闭连接 // 定义队列参数 Map<String, Object> arguments = new HashMap<>(); arguments.put("x-message-ttl", 60000); // 消息 TTL: 60,000 毫秒（60 秒） arguments.put("x-max-length", 1000); // 最大长度: 1000 条消息 // 定义消息头部属性 Map<String, Object> messageHeaders = new HashMap<>(); messageHeaders.put("format", "pdf"); messageHeaders.put("type", "report"); // 定义消息属性 AMQP.BasicProperties props = new AMQP.BasicProperties.Builder() .contentType("text/plain") // 内容类型 .contentEncoding("UTF-8") // 内容编码 .deliveryMode(2) // 消息持久化: 1 = 非持久, 2 = 持久 .priority(1) // 消息优先级 .correlationId("correlation-id-123") // 相关 ID .headers(messageHeaders) // 头部信息 .replyTo("reply-to-queue") // 回复队列 .expiration("60000") // 消息过期时间 (以毫秒为单位) .messageId("message-id-123") // 消息 ID .timestamp(new java.util.Date()) // 消息时间戳 .type("message-type") // 消息类型 .userId("ida") // 用户 ID .build(); ConnectionFactory factory = new ConnectionFactory(); factory.setHost(HOST); factory.setUsername(USERNAME); factory.setPassword(PASSWORD); try { Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare( QUEUE_NAME, //队列名 true, //是否持久化 false, //队列是否为独占队列(仅创建者可以使用的私有队列,断开后自动删除) false, //是否在最后一个消费者断开连接后自动删除 arguments); //Map类型, 指定队列的其他属性或插件参数, 例如队列的消息 TTL、队列的最大长度等 channel.basicPublish( "", //交换机, 默认交换机(AMQP default)用空字符串 "" 表示, 类型是 direct QUEUE_NAME, //队列名, 在使用默认交换机时，路由键被用作队列的名称 //MessageProperties.MINIMAL_PERSISTENT_BASIC, //消息属性 props, //消息属性 MESSAGE.getBytes("UTF-8")); //消息实体, 类型为字节数组 channel.close(); connection.close(); } catch (IOException | TimeoutException e) { throw new RuntimeException(e); } } } 消费者方法相关参数说明 public class Receive { //.. public static void main(String[] args) { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(HOST); factory.setUsername(USERNAME); factory.setPassword(PASSWORD); try { Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); //自动确认(可靠性要求不高),意味着一旦消息被发送到消费者，RabbitMQ 会认为消息已经成功处理，不论消费者是否真的处理了该消息 //手动确认(可靠性要求较高),消费者需要在处理完消息后显式地调用 channel.basicAck 方法来确认消息。只有在调用了 basicAck 后，RabbitMQ 才会从队列中移除该消息 channel.basicConsume( QUEUE_NAME, //队列名 false, //手动确认 new DefaultConsumer(channel){ //处理收到的消息, 传入channel @Override public void handleDelivery( String consumerTag, //RabbitMQ 在创建消费者时分配一个唯一的标识符 Envelope envelope, //包含有关消息传递的信息，包括消息的路由键、交换机、消息的唯一标识符等 AMQP.BasicProperties properties, //消息的属性，如消息的内容类型、消息的优先级、发布者设置的自定义属性等 byte[] body ) { try { // 打印消费者标签 System.out.println("Consumer Tag: " + consumerTag); // 打印消息的基本信息 System.out.println("Envelope Details:"); System.out.println(" Exchange: " + envelope.getExchange()); System.out.println(" Routing Key: " + envelope.getRoutingKey()); System.out.println(" Delivery Tag: " + envelope.getDeliveryTag()); System.out.println(" Redelivered: " + envelope.isRedeliver()); // 打印消息属性 System.out.println("Message Properties:"); System.out.println(" Content Type: " + properties.getContentType()); System.out.println(" Content Encoding: " + properties.getContentEncoding()); System.out.println(" Headers: " + properties.getHeaders()); System.out.println(" Delivery Mode: " + properties.getDeliveryMode()); System.out.println(" Priority: " + properties.getPriority()); System.out.println(" Correlation ID: " + properties.getCorrelationId()); System.out.println(" Reply To: " + properties.getReplyTo()); System.out.println(" Expiration: " + properties.getExpiration()); System.out.println(" Message ID: " + properties.getMessageId()); System.out.println(" Timestamp: " + properties.getTimestamp()); System.out.println(" Type: " + properties.getType()); System.out.println(" User ID: " + properties.getUserId()); // 打印消息体 String messageBody = new String(body, "UTF-8"); System.out.println("Message Body: " + messageBody); // 确认消息 channel.basicAck( envelope.getDeliveryTag(), //用于确认哪一条消息已经被成功处理 false); //true:表示确认所有到达 deliveryTag 之前的所有消息（批量确认）,false:仅确认 deliveryTag 对应的单条消息 } catch (Exception e) { // 处理异常逻辑 try { channel.basicNack( envelope.getDeliveryTag(), //指定哪一条消息未被成功处理 false, //true表示将所有到达 deliveryTag 之前的消息标记为未确认（批量拒绝）,false:仅将 deliveryTag 对应的单条消息标记为未确认 true); //true表示将未确认的消息重新投递到队列中, false:将未确认的消息丢弃或丢入死信队列（如果配置了死信队列） } catch (IOException ex) { ex.printStackTrace(); } } } } ); } catch (IOException | TimeoutException e) { throw new RuntimeException(e); } } } /* Consumer Tag: amq.ctag-gDpSJcGELhBsb8VSAuDo5A Envelope Details: Exchange: Routing Key: q1 Delivery Tag: 2 Redelivered: false Message Properties: Content Type: text/plain Content Encoding: UTF-8 Headers: {format=pdf, type=report} Delivery Mode: 2 Priority: 1 Correlation ID: correlation-id-123 Reply To: reply-to-queue Expiration: 60000 Message ID: message-id-123 Timestamp: Wed Aug 14 10:00:25 CST 2024 Type: message-type User ID: ida Message Body: Hello world */ 根据消息内容做处理 public class Producer { public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); channel.queueDeclare( "q2", //队列名 true, //持久化 false, //独占性 false, //自动删除 null); //队列参数 for (int i = 0; i < 10; i++) { String msg = i + "..."; channel.basicPublish( "", //交换机, 默认交换机没有名称，它用空字符串 "" 表示, 默认交换机的类型是 direct "q2", //队列名, 在使用默认交换机时，路由键被用作队列的名称 null, //消息属性 msg.getBytes("UTF-8")); //消息实体 } channel.close(); connection.close(); } } public class Consumer { public static void main(String[] args) throws IOException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); channel.basicConsume( "q2", //队列名 true, //自动确认 new DefaultConsumer(channel){ //消息处理, 传入channel @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws UnsupportedEncodingException { String msg = new String(body, "UTF-8"); System.out.println("收到消息:" + msg); char[] chars = msg.toCharArray(); for (char ch : chars) { if (ch == '.') { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } System.out.println("处理完成"); } } ); } } /* 收到消息:0... 处理完成 收到消息:1... 处理完成 .. */ 多个消费者平均压力 循环调度 再实例化运行一个Consumer, (idea运行配置,修改选项,允许多个实例) 队列生成10个消息, 这时两个Consumer会轮流取出消息进行处理, 整体速度得到提高 公平派遣 循环调度下每个消费者处理的消息个数接近相同, 但是每个消息的处理耗时存在差异, 导致消费者中有的提早完成, 有的仍在处理 公平派遣加入消息确认机制, 消费者在每个消息消费完后主动通知rabbitmq, rabbitmq为其派发新的消息, 这样所有消费者都会尽可能处于消费状态, 整体速度得到进一步提高 public class ConsumerV2 { public static void main(String[] args) throws IOException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); channel.basicQos(1); //限制消费者一次处理的消息数量，避免消费者过载(因为处理慢而被堆积大量消息) channel.basicConsume( "q2", false, //手动确认 new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, "UTF-8"); System.out.println("收到消息:" + msg); char[] chars = msg.toCharArray(); for (char ch : chars) { if (ch == '.') { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } System.out.println("处理完成"); channel.basicAck(envelope.getDeliveryTag(), false); //手动确认 } } ); } } 交换机工作模式 fanout fanout 消息会被广播到所有绑定到该交换机的队列，不考虑路由键。 适用于广播消息，例如：日志系统，发布/订阅模式。 //生产者 channel.exchangeDeclare("fanout_exchange", "fanout"); //枚举形式 BuiltinExchangeType.FANOUT channel.queueDeclare("queue1", true, false, false, null); channel.queueDeclare("queue2", true, false, false, null); channel.basicPublish("fanout_exchange", "", null, "Hello World!".getBytes()); //消费者 channel.exchangeDeclare("fanout_exchange", "fanout"); channel.queueBind("queue1", "fanout_exchange", ""); channel.queueBind("queue2", "fanout_exchange", ""); 20240603204902.webp direct direct 精确路由到匹配路由键的队列。默认交换机的类型是 direct 适用于需要精确路由的场景，例如任务分发系统，根据不同的任务类型将消息发送到不同的处理队列。 //产生日志 public class EmitLogsDirect { public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); channel.exchangeDeclare("x2", "direct"); //一个交换机向多个路由键发送不同消息 channel.basicPublish("x2", "info", null, "is info".getBytes("UTF-8")); channel.basicPublish("x2", "warn", null, "is warn".getBytes("UTF-8")); channel.basicPublish("x2", "error", null, "is error".getBytes("UTF-8")); channel.close(); connection.close(); } } //接收所有级别日志, 输出到控制台 public class ReceiveLogsDirect1 { public static void main(String[] args) throws IOException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); //可以创建一个临时（非持久、自动删除）队列, rabbitmq会生成默认队列名, 如果生产者发送消息时消费者的队列还未创建，消息会丢失 String queue = channel.queueDeclare().getQueue(); //使用同一个队列接收同一个交换机下的不同路由键消息 channel.queueBind(queue, "x2", "info"); channel.queueBind(queue, "x2", "warn"); channel.queueBind(queue, "x2", "error"); channel.basicConsume(queue, true, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws UnsupportedEncodingException { String msg = new String(body, "UTF-8"); System.out.println("收到消息:" + msg); } } ); } } //仅接收error级别的日志, 保存到文件 public class ReceiveLogsDirect2 { public static void main(String[] args) throws IOException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); String queue = channel.queueDeclare().getQueue(); channel.queueBind(queue,"x2","error"); channel.basicConsume(queue,true, new DefaultConsumer(channel){..} ); } } 20240814132506.webp topic topic 基于主题模式（Pattern Matching）进行路由，支持复杂的路由逻辑 路由键中的.具有特定的含义, 点用作分隔符，允许你使用通配符 * 和 # 来指定绑定模式 队列的绑定模式可以包含通配符(* 替代一个单词, # 替代零个或多个单词 (任意个))允许队列接收符合这些模式的消息 public class EmitLogsTopic { public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); channel.exchangeDeclare("x3", "topic"); String[] routingKeys = { "quick.orange.rabbit", "lazy.orange.elephant", "quick.orange.fox", "lazy.brown.fox", "lazy.pink.rabbit", "quick.brown.fox", "orange", "quick.orange.male.rabbit", "lazy.orange.male.rabbit" }; for (int i = 0; i < routingKeys.length; i++) { channel.basicPublish("x3", routingKeys[i], null, "ok".getBytes("UTF-8")); } channel.close(); connection.close(); } } public class ReceiveLogsTopic1 { public static void main(String[] args) throws IOException, InterruptedException { Connection connection = ConnUtils.getConn(); Channel channel = connection.createChannel(); channel.queueDeclare("tq1", false, false, false, null); channel.queueBind("tq1", "x3", "*.orange.*"); //队列名, 交换机名, 路由键. queueBind重载版本,四参比三参多一个绑定参数 channel.queueDeclare("tq2", false, false, false, null); channel.queueBind("tq2", "x3", "*.*.rabbit"); channel.queueBind("tq2", "x3", "lazy.#"); Map<String, List<String>> result = new TreeMap<>(); //TreeMap 自动按键排序 // 创建 CountDownLatch 等待所有消息处理完成 CountDownLatch latch = new CountDownLatch(8); channel.basicConsume("tq1", true, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) { //尝试在 Map 中查找指定的键（在这里是 "tq1"）。如果该键存在，它将返回键对应的值； //如果键不存在，它将使用提供的函数（在这里是 k -> new ArrayList<>()）来生成一个新的值，并将其放入Map然后返回这个新值 result.computeIfAbsent("tq1", k -> new ArrayList<>()).add(envelope.getRoutingKey()); latch.countDown(); // 处理完一条消息，计数器减 1 } }); channel.basicConsume("tq2", true, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) { result.computeIfAbsent("tq2", k -> new ArrayList<>()).add(envelope.getRoutingKey()); latch.countDown(); // 处理完一条消息，计数器减 1 } }); try { latch.await(); //调用 await() 方法的线程将阻塞，直到计数器减到零 } catch (InterruptedException e) { e.printStackTrace(); } //basicConsume 是异步的，result.forEach 方法在消息处理还没有完成时就被调用了，所以可能没有任何输出 //使用延时, 或者在能确定出被消费的消息总数时可以使用concurrent包下的CountDownLatch类 //CountDownLatch 是 Java 中用于协调线程的同步工具，主要用于等待其他线程完成某些操作, 可以设置一个倒计时计数器，线程可以等待直到计数器减到零 //Thread.sleep(5000); result.forEach((k, v) -> { System.out.println(k); System.out.println("-----------"); v.forEach(System.out::println); System.out.println("-----------"); }); } } 20240814160920.webp [特点].[颜色].[物种] 20240814140749.webp headers headers 根据消息头部的属性进行路由，不使用路由键 Map<String, Object> headers = new HashMap<>(); headers.put("x-match", "all"); //指定匹配模式, any: 只要消息的任意一个头部属性与绑定的属性匹配，消息就会路由到队列, all: 所有绑定的头部属性必须与消息的头部属性匹配 headers.put("format", "pdf"); headers.put("type", "report"); channel.exchangeDeclare("headers_exchange", "headers"); //"headers": 声明一个名为"headers_exchange"的交换机,交换机的类型为 headers channel.queueDeclare("queue1", true, false, false, null); channel.queueBind("queue1", "headers_exchange", "", headers); //队列名,交换机名,路由键,绑定条件. queueBind重载版本,四参比三参多一个绑定参数 Map<String, Object> messageHeaders = new HashMap<>(); messageHeaders.put("format", "pdf"); messageHeaders.put("type", "report"); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .headers(messageHeaders) .build(); channel.basicPublish("headers_exchange", "", properties, "Document".getBytes()); Spring Boot整合RabbitMQ 依赖 也可以在项目创建时勾选依赖, Messaging - Spring for RabbitMQ <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-amqp</artifactId> </dependency> <dependency> <groupId>org.springframework.amqp</groupId> <artifactId>spring-rabbit-test</artifactId> <scope>test</scope> </dependency> 注解说明 RabbitMQ 本身并不关心消息的内容，它将消息处理为字节数组, 而Spring AMQP会根据方法的参数类型来选择执行匹配的方法 如果方法参数类型是 String, byte[]，Integer等 Spring AMQP会尝试将消息体转换为对应的类型 如果方法参数是自定义对象（例如 MyObject），会尝试将消息体反序列化为相应的对象, 需要配置MessageConverter @RabbitListener 应用于方法上 这个方法将会被用作处理从指定队列接收到的消息。如果消息体不能被转换为方法参数类型，Spring AMQP 将会抛出异常 应用于类上 当消息到达时，Spring只会选择类中的一个方法进行处理, 如果消息类型与多个方法签名匹配，它通常会选择第一个匹配的处理方法 同时应用于类和方法上 类上的 @RabbitListener 注解会指定一个默认的队列或交换机，而方法上的 @RabbitListener 注解可以覆盖或附加其他队列或交换机 @RabbitHandler 一个 @RabbitListener 类可以包含多个 @RabbitHandler 方法，用于处理不同类型的消息 如果多个 @RabbitHandler 方法具有相同的参数类型 这种情况下，具体的行为可能依赖于 Spring AMQP 的实现细节或版本。一般来说，Spring 会根据特定的规则（如注册顺序）来选择合适的方法处理消息，但这个行为可能不是非常直观或一致 当消息到达时，Spring AMQP 根据消息的类型和参数签名选择最合适的 @RabbitHandler 方法来处理消息 如果不使用 @RabbitHandler，在 @RabbitListener 类中建议只定义一个方法来处理所有消息，以避免因多个方法的签名匹配到相同的消息类型而产生不确定或不一致的行为 @RabbitHandler 仅有效于 @RabbitListener 类 producer 配置 server.port=9016 spring.application.name=16-producer spring.rabbitmq.addresses=192.168.149.130 spring.rabbitmq.username=ida spring.rabbitmq.password=123456 spring.rabbitmq.virtual-host=/ spring.rabbitmq.connection-timeout=15000 配置类 @Configuration public class RabbitMQConfig { @Bean public TopicExchange topicExchange() { return new TopicExchange("x4"); } @Bean public Queue queue1() { return new Queue("tq3", true, false, false, null); } @Bean public Queue queue2() { return new Queue("tq4"); } @Bean public Queue queue3() { return new Queue("tq5"); } @Bean public Binding binding1(TopicExchange topicExchange, Queue queue1) { return BindingBuilder .bind(queue1) .to(topicExchange) .with("*.orange.*"); } @Bean public Binding binding2(TopicExchange topicExchange, Queue queue2) { return BindingBuilder .bind(queue2) .to(topicExchange) .with("*.*.rabbit"); } @Bean public Binding binding3(TopicExchange topicExchange, Queue queue2) { return BindingBuilder .bind(queue2) .to(topicExchange) .with("lazy.#"); } @Bean public Binding binding4(TopicExchange topicExchange, Queue queue3) { return BindingBuilder .bind(queue3) .to(topicExchange) .with("*.user"); } @Bean //用于将 RabbitMQ 消息体转换为 Java 对象，或者将 Java 对象转换为 JSON 格式的消息体 public MessageConverter jsonMessageConverter(ObjectMapper objectMapper) { return new Jackson2JsonMessageConverter(objectMapper); } } User public class User { private String name; private int age; private Date birthday; //getter,setter } MessageProducer @Service("messageProducer") public class MessageProducer { @Resource private RabbitTemplate rabbitTemplate; //在 Spring AMQP 中，RabbitTemplate 是默认的 AmqpTemplate 实现 @Resource private TopicExchange topicExchange; public void sendMessage(String routingKey, String message) { rabbitTemplate.convertAndSend(topicExchange.getName(), routingKey, message); } public void sendUser(String routingKey, User user) { rabbitTemplate.convertAndSend(topicExchange.getName(), routingKey, user); } } 测试类 @SpringBootTest class MessageProducerTest { @Resource private MessageProducer messageProducer; @Test void sendMessage() { String[] routingKeys = { "quick.orange.rabbit", "lazy.orange.elephant", "quick.orange.fox", "lazy.brown.fox", "lazy.pink.rabbit", "quick.brown.fox", "orange", "quick.orange.male.rabbit", "lazy.orange.male.rabbit" }; for (int i = 0; i < routingKeys.length; i++) { messageProducer.sendMessage(routingKeys[i], "养石头"); } } @Test void sendUser() { User user = new User(); user.setName("小明"); user.setAge(12); //过时的构造函数,100表示2000年 //user.setBirthday(new Date(100, 5, 15, 18, 59, 59)); //月份用数字表示时从0起, 因此使用常量名的写法 Calendar calendar = Calendar.getInstance(); calendar.set(2000, Calendar.JUNE, 15, 18, 59, 59); //月份用数字表示时从0起, 因此使用常量名的写法 user.setBirthday(calendar.getTime()); messageProducer.sendUser("obj.user", user); } } consumer 配置 server.port=9017 spring.application.name=17-consumer spring.rabbitmq.addresses=192.168.149.130 spring.rabbitmq.username=ida spring.rabbitmq.password=123456 spring.rabbitmq.virtual-host=/ spring.rabbitmq.connection-timeout=15000 配置类 @Configuration public class RabbitMQConfig { @Bean //用于将 RabbitMQ 消息体转换为 Java 对象，或者将 Java 对象转换为 JSON 格式的消息体 public MessageConverter jsonMessageConverter(ObjectMapper objectMapper) { return new Jackson2JsonMessageConverter(objectMapper); } } User public class User { private String name; private int age; private Date birthday; //getter,setter } MessageConsumer @Component public class MessageConsumer { @RabbitListener(queues = "tq3") public void receiveMessageFromQueue1(String message, Message rabbitMessage) { System.out.println("Received from tq3: " + message); System.out.println("Routing key: " + rabbitMessage.getMessageProperties().getReceivedRoutingKey()); } @RabbitListener(queues = "tq4") public void receiveMessageFromQueue2(String message, Message rabbitMessage) { System.out.println("Received from tq4: " + message); System.out.println("Routing key: " + rabbitMessage.getMessageProperties().getReceivedRoutingKey()); } @RabbitListener(queues = "tq5") public void receiveMessageFromQueue3(User user, Message rabbitMessage) { System.out.println("Received from tq5: " + user.toString()); System.out.println("Routing key: " + rabbitMessage.getMessageProperties().getReceivedRoutingKey()); } }`,``,`html`,`Redis`,`20240430090453-_中间件 Redis（键值对型）NoSQL数据库 NoSQL（Not Only SQL）是一类数据库系统的统称，它们不使用传统的关系型数据库模型（SQL），而是采用其他的数据存储模型。NoSQL数据库系统设计的目标是解决传统关系型数据库在处理大数据量、高并发、分布式等方面的局限性。NoSQL数据库通常具有以下特点： 灵活的数据模型： NoSQL数据库通常支持多种数据模型，如键值对、文档型、列族型、图形等，使得能够更好地适应不同的数据结构和数据处理需求。 分布式架构： NoSQL数据库天生支持分布式架构，能够轻松处理大规模数据和高并发访问。 高可用性和容错性： NoSQL数据库通常具有自动分片、数据冗余备份等机制，提供高可用性和容错性。 弱一致性和最终一致性： NoSQL数据库通常不要求严格的一致性，可以在一定程度上牺牲一致性来换取性能和可用性。 适用于特定场景： NoSQL数据库适用于不同的场景，如大数据处理、实时数据处理、图形数据分析等。 常见的NoSQL数据库包括MongoDB（文档型）、Redis（键值对型）、Cassandra（列族型）、Neo4j（图形型）等。 Redis将数据存储在内存中同时也能持久化到磁盘, 常用于缓存(不经常变更的稳定的数据),利用内存的高效率提高程序的处理速度 广泛的语言支持 Redis支持多种编程语言，如Java、Python、JavaScript等，可以轻松与各种应用程序集成。 持久化 Redis支持两种持久化方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。RDB是通过定期将内存中的数据快照保存到磁盘上，而AOF则是将每次写操作记录到一个日志文件中。 多种数据结构 Redis支持多种数据结构，包括字符串、哈希表、列表、集合、有序集合等，使得它可以适用于各种不同的应用场景。 主从复制 Redis支持主从复制，可以将一个Redis服务器的数据复制到其他多个Redis服务器上，以实现数据的备份和负载均衡。 分布式与高可用 Redis支持分布式架构和高可用性配置，可以通过集群和哨兵机制实现数据的分布式存储和高可用性。 当发现一服务器故障时会屏蔽它并使用其它服务器替代 安装 redis.config ,默认daemonize no改yes,后台运行程序不占用终端窗口 #查看是否安装了c语言编译器 yum list installed gcc #安装redis mkdir /usr/local/redis cd /usr/local/redis wget https://download.redis.io/releases/redis-7.0.15.tar.gz tar zxf redis-7.0.15.tar.gz cd redis-7.0.15 make ./src/redis-server ./redis.conf 配置 20240430103413.webp #修改daemonize yes vim redis.conf #启动redis客户端 ./src/redis-cli #客户端下测试连通性,正常返回PONG ping #用它自己的客户端替代kill -9 [pid]方式关闭redis ./src/redis-cli shutdown #修改port 6380 #修改logfile空字符串为"redis.log",将在安装目录下生成redis.log日志文件 #修改默认port后每次启动redis客户端时需要应用端口号 ./src/redis-cli -p 6380 #查看日志 cat redis.log #redis的数据库按数字来区别,没有名字 #客户端下Redis 默认有 16 个数据库（编号从 0 到 15），可以使用 SELECT 命令切换数据库。默认情况下，连接到 Redis 时会使用第 0 个数据库 select 5 #清空当前数据库中的所有键值对 flushdb #修改databases 255, （编号从 0 到 254）关闭重启使之生效 ./src/redis-cli -p 6380 shutdown ./src/redis-server ./redis.conf ./src/redis-cli -p 6380 #设置客户端密码, 取消注释#requirepass修改其后的明文密码,关闭重启使之生效 ./src/redis-cli -p 6380 shutdown ./src/redis-server ./redis.conf ./src/redis-cli -p 6380 auth 12345 #或./src/redis-cli -p 6380 -a 12345 #修改数据库目录,默认dir ./, 全量备份文件dump.rdb文件的存放目录 #获取配置信息 127.0.0.1:6380> config get * 127.0.0.1:6380> config get port #更改配置,设置是临时的，即在当前运行的 Redis 服务器实例中生效，重启 Redis 后会失效 127.0.0.1:6380> config set loglevel "notice" String类型 String最大512mb, 建议单个kv不超过100kb 处理包含空格、双引号和单引号的值时，需要使用正确的转义字符 This is a "complex" value with 'single quotes' and "double quotes" SET title 'This is a "complex" value with '\''single quotes'\'' and "double quotes"' #选择数据库 select 0 #单写,批写 set a apple mset b ball c cow #Redis 默认使用 UTF-8 编码,对于中文命令行客户端会以字节流的十六进制表示, 一个汉字3字节 127.0.0.1:6380[2]> set name 汉字 OK 127.0.0.1:6380[2]> get name "\xe6\xb1\x89\xe5\xad\x97" #如果要显示转义后的中文字符, 登录时附加参数raw, redis-cli --raw #单读,批读 get a mget a b c #单删,批删 del a del b c #设置存活期,秒 expire a 30 #查询剩余寿命 tll a #检查是否存在某key, 1存在0不存在 exists a #查询当前库key总数 dbsize #筛选key keys * keys a* #对key自增自减,步长1,值为整型 incr a decr a #对key自增自减,指定步长,值为整型 incrby a 3 decrby a 3 Hash键值类型 用于存储结构化数据 键名并不强制要求包含冒号，但使用冒号可以使键名更具层次结构和可读性 HSET myhash field1 "value1" HSET myhash field1 value1 加引号和不加引号存储的值是一样的, 引号只是用于命令行中表示字符串值的一种方式，而在实际存储中，Redis 会将值存储为字符串，无论是否使用引号 #写单个属性,写多个属性 hset emp:1 name Bob hmset emp:1 name Bob age 20 sex male #读单个属性,读多个属性,读所有属性 hget emp:1 name hmget emp:1 name age hgetall emp:1 #删除单个属性,删除多个属性 hdel emp:1 sex hdel emp:1 name age #检查是否存在指定属性,1存在0不存在 hexists emp:1 name #查询属性个数 hlen emp:1 List列表类型 通常只用来保存同一类信息 #只有lpush,lpop有对应的rpush和rpop,其它的没有r起头的命令 #向列表右侧(末尾)依次插入 rpush list 1 2 3 #获取指定范围内的元素,-1最后一个元素 lrange list 0 -1 1) "1" 2) "2" 3) "3" #向列表左侧(开头)依次插入 lpush list -1 -2 lrange list 0 -1 1) "-2" 2) "-1" 3) "1" 4) "2" 5) "3" #从左边(开头)取出(消耗,原列表元素减少)1个元素, lpop list lrange list 0 -1 1) "-1" 2) "1" 3) "2" 4) "3" #从右边取出2个元素(3,2) rpop list 2 lrange list 0 -1 1) "-1" 2) "1" #获取列表指定位置的元素,下标0起 #获取列表第一个元素 lindex list 0 #更新列表指定位置的元素 #将列表第二个元素更新为0 lset list 1 0 rpush list 1 2 3 lrange list 0 -1 1) "-1" 2) "0" 3) "1" 4) "2" 5) "3" #裁剪列表,删除范围之外的所有元素,-1最后一个元素 ltrim list 1 1 lrange list 0 -1 1) "-1" 2) "1" 3) "2" 4) "3" ltrim list 2 -1 lrange list 0 -1 1) "2" 2) "3" #删除内容为指定值的元素 #假设list内容为 1) "a" 2) "b" 3) "a" 4) "c" 5) "a" #删除列表中所有值为 "a" 的元素, 0表示全部 lrem list 0 a 1) "b" 2) "c" rpush list b d b #从队首开始,删除列表中的前两个值为 "b" 的元素 lrem list 2 "b" 1) "c" 2) "d" 3) "b" Set和Zset集合类型 Set无序唯一 Zset有序唯一 实际应用较少 #插入元素, 返回值为成功插入的元素个数, 重复不计 sadd set1 a b c d sadd set2 c d e f #显示集合元素 smembers set1 1) "c" 2) "a" 3) "d" 4) "b" #计算set1和set2交集 sinter set1 set2 1) "c" 2) "d" #计算set1和set2并集 sunion set1 set2 1) "d" 2) "c" 3) "a" 4) "f" 5) "e" 6) "b" #计算差集,前者有,而后者没有的元素 sdiff set1 set2 1) "a" 2) "b" sdiff set2 set1 1) "f" 2) "e" #Zset是在set的基础上额外增加一个分数参数用来排序, 默认按分数升序排列, 分数可以是小数。Redis使用双精度浮点数来存储分数 zadd zset1 100 a 101 b 99 c #与lrange命令相似 zrange zset1 0 -1 1) "c" 2) "a" 3) "b" #显示分数 zrange zset1 0 -1 withscores 1) "c" 2) "99" 3) "a" 4) "100" 5) "b" 6) "101" #按分数范围筛选 zrangebyscore zset1 99 100 1) "c" 2) "a" zrangebyscore zset1 99 100 withscores 1) "c" 2) "99" 3) "a" 4) "100" Jedis Jedis是Java语言开发的Redis客户端工具包,仅作为对Redis命令的封装 在绝大多数情况下redis作为一台服务器时不做其它事情 配置 #修改配置关闭保护模式,允许允许远程访问 protected-mode no #0.0.0.0表示所有ip都可以访问(测试环境), 实际应用时应指定为具体ip,多个ip空格分开 bind 0.0.0.0 #检查bind config get bind config get * #端口放行 firewall-cmd --permanent --zone=public --add-port=6380/tcp firewall-cmd --reload 依赖 2.9是国内使用最多的版本 <dependencies> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>2.9.0</version> </dependency> </dependencies> 命令演示 public class RedisTest { public static void jedisUtil(Consumer<Jedis> consumer) { Jedis jedis = new Jedis("192.168.149.133", 6380); jedis.auth("12345"); try { consumer.accept(jedis); } finally { jedis.close(); } } @Test public void _string() { jedisUtil(jedis -> { jedis.select(2); jedis.set("name","Lily"); System.out.println(jedis.get("name"));//Lily jedis.mset("age","20","sex","female"); List<String> result = jedis.mget("name","age","sex"); System.out.println(result);//[Lily, 20, female] System.out.println(jedis.dbSize());//3 System.out.println(jedis.exists("name"));//true System.out.println(jedis.exists("name2"));//false Set<String> result2 = jedis.keys("*");//返回类型为Set System.out.println(result2);//[name, age, sex] jedis.set("num", "2"); System.out.println(jedis.incr("num"));//3 System.out.println(jedis.incrBy("num",5));//8 System.out.println(jedis.del("age","sex","name"));//3 jedis.expire("num",5);//秒 System.out.println(jedis.get("num")); try { Thread.sleep(3000); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(jedis.ttl("num"));//2 try { Thread.sleep(3000); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(jedis.get("num"));//null }); } @Test public void _list() { jedisUtil(jedis -> { jedis.select(2); jedis.rpush("list","a","b","c","d"); jedis.lpush("list","x","y","z"); System.out.println(jedis.lrange("list",0,-1));//[z, y, x, a, b, c, d] System.out.println(jedis.lpop("list"));//z System.out.println(jedis.rpop("list"));//d System.out.println(jedis.lrange("list",0,-1));//[y, x, a, b, c] jedis.del("list"); }); } @Test public void _hash() { jedisUtil(jedis -> { jedis.select(2); jedis.hset("stu:1","name","Lily"); Map kvs = new HashMap<>(); kvs.put("age","20"); kvs.put("sex","female"); jedis.hmset("stu:1",kvs); List<String> list = jedis.hmget("stu:1","name","age");//[Lily, 20] Map<String,String> map = jedis.hgetAll("stu:1");//{name=Lily, age=20, sex=female} System.out.println(jedis.del("stu:1")); }); } } 应用演示 public class GoodsTest { @Test public void write() { RedisTest.jedisUtil(jedis -> { jedis.select(2); List<Goods> goodsList = new ArrayList<>(); goodsList.add(new Goods(101, "苹果", 5.9)); goodsList.add(new Goods(102, "梨子", 3.9)); goodsList.add(new Goods(103, "布拿拿", 2.9)); for (Goods goods : goodsList) { String json = JSON.toJSONString(goods); String key = "goods:" + goods.getId(); jedis.set(key, json); } }); } @Test public void read() { RedisTest.jedisUtil(jedis -> { jedis.select(2); while (true) { Scanner scanner = new Scanner(System.in); System.out.println("请输入商品id: [0 退出]"); String id = scanner.next(); if (id.equals("0")) break; if (jedis.exists("goods:" + id)) { String json = jedis.get("goods:" + id); Goods goods = JSON.parseObject(json, Goods.class); System.out.println(goods.getName() + "-" + goods.getPrice()); } else { System.out.println("无效的商品id"); } } }); } }`,``,`html`,`Servlet`,`20240418220255-_java web J2SE (Java 2 Platform, Standard Edition) Java 平台的标准版，属于 Java 2 平台的一部分 Java SE (Java Platform, Standard Edition) Java SE 是 J2SE 的继任者 J2EE(Java 2 Platform Enterprise Edition) Java 2 企业版 J2EE运行在J2SE之上 开发BS(Web)应用程序是J2EE最核心的功能 J2EE是一组技术规范与指南,具体实现由软件厂商决定 J2EE由13个功能模块组成 Servlet(web服务器小程序, 用于生成动态Web内容) JSP(服务器页面,由Servlet扩展而来) JDBC(数据库交互模块) Tomcat是J2EE Web(Servlet与JSP)的实现者之一 Java EE (Java Platform, Enterprise Edition) Java EE 是 J2EE 的继任者, 继续提供和扩展 J2EE 的功能，并引入了许多新的 API 和特性，以适应现代企业应用程序开发的需求 JPA是在Java EE中引入的标准持久化API，用于对象关系映射（ORM），提供了简化的数据库访问层。 Servlet 3.0+, Servlet 3.0版本开始引入了基于注解的配置 Jakarta EE就是Java EE的新名词 由于Java商标的问题，导致了项目名称和包命名空间的修改，从而引入不兼容的更新 因此，升级Jakarta EE 9及之后版本，必须特别注意将所有javax的引用都改为jakarta，包括直接或间接依赖的部分，否则可能会出现难以排查的异常问题。 JAR、WAR 和 EAR 而 JAR 文件只需要 Java 安装 WAR 文件只需要符合 Java EE Web Profile 的应用程序服务器即可运行 将war包放到tomcat的webapps目录下,运行tomcat的bin目录下startup.bat,会自动解压,没有报错则可以正常访问网页 取消端口号,tomcat目录conf/server.xml文件内Connector标签中port属性改80 取消上下文路径 方式一, 将war重命名为ROOT放到webapps, tomcat 会自动将 ROOT.war 部署为根上下文 方式二, tomcat目录conf/server.xml文件内Host标签下增加Context标签,增加path属性并设空,增加docBase属性,如果使用相对路径,则docBase是相对于webapps的相对路径,它的值也就是描述源目录在webapps中的什么地方, 如Context path="" docBase="demo1-1.0-SNAPSHOT"标签自闭合 EAR 文件需要完全符合 Java Platform, Enterprise Edition (Java EE) 或 Jakarta Enterprise Edition (EE) 的应用程序服务器，例如 WebSphere 或 JBoss，才能运行。 Artifacts:文物,人造物,工件,阶段性成果 java web的三大作用域对象: HttpServletRequest 请求对象, HttpSession 用户会话对象, ServletContext web应用全局对象 WEB-INF 目录下的 文件无法直接通过 URL 访问 Servlet是一种服务器端Java程序，主要用于构建基于Web的应用程序, 处理客户端（通常是浏览器）的请求，并生成动态的响应内容 版本适应 20240411114951.webp Servlet生命周期 tomcat启动时解析web.xml和扫描字节码文件,得知Servlet所绑定的url 当url被访问到时,tomcat构造Servlet对象,通常情况下每个 Servlet 类只有一个实例 Tomcat 使用的是单例模式来管理 Servlet 的生命周期，一个 Servlet 的实例会被多个请求线程共享 如果 Servlet 中包含任何共享的可变状态（例如实例变量、属性等），且这些状态在多个线程之间没有正确同步，那么就可能发生线程安全问题 加载和实例化: 加载这个Servlet类, 然后创建这个Servlet类的一个实例 初始化: 实例创建之后，容器调用init()方法来初始化Servlet。init()方法只被调用一次，用于执行任何一次性的初始化任务。通常，init()方法会获取ServletConfig对象，可以用来获取初始化参数。 请求处理: Servlet被初始化完成后，它就可以处理客户端请求。 每次有请求到达时，Servlet容器会创建一个新的线程，并调用service()方法, service()根据请求类型调用相应的doXXX()方法。 销毁: destroy()方法只会被调用一次，用于执行任何清理任务，例如关闭资源或保存状态 垃圾回收: 最后，Servlet实例会被垃圾回收。 虽然这是Java对象的标准生命周期的一部分，但对于Servlet来说，重要的是在destroy()方法中完成所有需要的清理工作，而不是依赖垃圾回收。 表单参数接收 所有参数的值都会作为字符串处理, 参数没有值返回空字符串, 参数不存在返回 null <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Index</title> </head> <body> <form action="/page2" method="post"><!-- post --> <label>Name:</label> <input type="text" name="name"> <br> <label>性别:</label> <select name="sex"><!-- 单选 --> <option value="male">male</option> <option value="female">female</option> </select> <br> <label>specialties</label> <input type="checkbox" name="spec" value="英文">English<!-- 多选 --> <input type="checkbox" name="spec" value="编程">Program <input type="checkbox" name="spec" value="游泳">Swimming <br> <input type="submit" value="提交"> </form> </body> </html> // name属性是可选的, 如果没有提供name属性，Servlet容器会自动为Servlet生成一个默认名称。这通常是类的完全限定名（即包含包名和类名） @WebServlet(name = "getInfo",urlPatterns = "/page2") public class FormServlet extends HttpServlet { public FormServlet(){ System.out.println("正在构造FormServlet对象..."); //sout乱码, vm参数加-Dfile.encoding=UTF-8 } @Override public void init() throws ServletException { System.out.println("正在初始化FormServlet对象..."); super.init(); } @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException { req.setCharacterEncoding("UTF-8"); String name = req.getParameter("name"); String sex = req.getParameter("sex"); String[] specs = req.getParameterValues("spec"); Map<String, String[]> parameterMap = req.getParameterMap(); parameterMap.forEach((k,v) -> { System.out.println(k+":"+Arrays.toString(v)); }); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); //out.write()输出的字符串会紧接在一起,适合需要精确控制输出格式的情况，例如生成特定格式的内容（如 JSON、XML 等） //out.println() 适合简单输出文本内容时自动换行，例如生成 HTML、日志信息等 out.println("<p>"+ Arrays.asList(name,sex, Arrays.toString(specs))+"</p>"); } @Override public void destroy() { System.out.println("正在销毁FormServlet对象..."); super.destroy(); } } 配置形式 <servlet> <servlet-name>getInfo</servlet-name> <servlet-class>com.ida.javaweb.demo1.servlet.FormServlet</servlet-class> </servlet> <servlet-mapping> <servlet-name>getInfo</servlet-name> <url-pattern>/page2</url-pattern> </servlet-mapping> 文件上传 表单的 enctype 属性设置为 multipart/form-data，表示表单包含文件上传 使用Servlet 3.0自带的@MultipartConfig注解启用对 multipart/form-data 请求的支持 <form action="/page13" method="post" enctype="multipart/form-data"> <input type="file" name="file"> <input type="submit" value="Upload"> </form> @WebServlet("/page13") @MultipartConfig( location = "C:/TEMP", fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 10, maxRequestSize = 1024 * 1024 * 50 ) public class FileUploadServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Path uploadPath = Paths.get(getServletContext().getRealPath(""), "upload"); Files.createDirectories(uploadPath); Part filePart = req.getPart("file"); String uniqueFileName = generateUniqueFileName(Paths.get(filePart.getSubmittedFileName()).getFileName().toString()); Path destFile = uploadPath.resolve(uniqueFileName); try (InputStream input = filePart.getInputStream()) { Files.copy(input, destFile, StandardCopyOption.REPLACE_EXISTING); } resp.getWriter().write("<img src='/upload/"+uniqueFileName+"'>"); } private String generateUniqueFileName(String fileName) { String uuid = UUID.randomUUID().toString(); String extension = ""; int dotIndex = fileName.lastIndexOf('.'); if (dotIndex > 0) { extension = fileName.substring(dotIndex); fileName = fileName.substring(0, dotIndex); } return fileName + "_" + uuid + extension; } } 配置形式 <servlet> <servlet-name>fileUploadServlet</servlet-name> <servlet-class>com.ida.demo13.FileUploadServlet</servlet-class> <multipart-config> <location>C:/TEMP</location> <file-size-threshold>1048576</file-size-threshold> <!-- 1 MB --> <max-file-size>10485760</max-file-size> <!-- 10 MB --> <max-request-size>52428800</max-request-size> <!-- 50 MB --> </multipart-config> </servlet> <servlet-mapping> <servlet-name>fileUploadServlet</servlet-name> <url-pattern>/page13</url-pattern> </servlet-mapping> 请求和响应方法 获取请求信息： getMethod(): 获取请求方法（如 GET、POST）。 getRequestURI(): 获取请求的 URI 部分。 getRequestURL(): 获取请求的 URL。 getQueryString(): 获取请求的查询字符串（URL 中 ? 后面的部分）。 获取请求参数： getParameter(String name): 获取请求参数的值。 getParameterValues(String name): 获取指定请求参数的所有值（用于复选框）。 getParameterMap(): 获取所有请求参数的键值对。 键是请求参数的名称，值是一个字符串数组（String[]） 获取请求头： getHeader(String name): 获取指定的请求头的值。 getHeaderNames(): 获取所有请求头的名称。 获取客户端信息： getRemoteAddr(): 获取客户端的 IP 地址。 getRemoteHost(): 获取客户端的主机名。 getRemotePort(): 获取客户端的端口号。 获取请求体数据： getReader(): 获取请求体的字符输入流，适合读取文本数据 getInputStream(): 获取请求体的字节输入流。适合读取二进制数据或未经处理的原始数据 设置响应状态码： setStatus(int sc): 设置响应状态码。 200:服务器处理成功 404:无法找到文件 500:内部服务器错误 403:服务器拒绝访问 301,302:请求重定向 400:无效的请求 401:未经过授权 503:服务器超负载或正停机维护,无法处理请求 sendError(int sc): 发送错误状态码。 调用这个方法后，Servlet容器会向客户端发送一个HTTP错误响应，响应中包含指定的状态码和相应的错误页面（如果配置了错误页面）。 sendError(int sc, String msg): 发送带错误信息的错误状态码。 public class ErrorCode { @WebServlet("/page21") public static class ErrorCode1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.sendError(503); } } @WebServlet("/page22") public static class ErrorCode2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setCharacterEncoding("UTF-8"); resp.sendError(666,"三个6"); } } } 设置响应头： setHeader(String name, String value): 设置响应头。 addHeader(String name, String value): 添加响应头。 setContentType(String type): 设置响应的内容类型。 setCharacterEncoding(String charset): 设置响应的字符编码。 重定向： sendRedirect(String location): 发送重定向响应。 获取响应输出流： getWriter(): 获取响应的字符输出流。 getOutputStream(): 获取响应的字节输出流。 get和post Get方式是将数据通过在URL附加数据显性向服务器发送数据 Chrome调试面板Headers显示为Query String Parameters Post方式会将数据存放在Form Data中隐性向服务器发送数据 Chrome调试面板Headers显示为Form Data 在HTML表单中，当使用POST方法提交数据时，默认情况下，表单数据会以 application/x-www-form-urlencoded 的格式进行编码和发送到服务器 一个类继承HttpServlet后不重写service(),而分别重写doGet()和doPost() 将由父类的service()方法判断请求的类型,然后分发给doGet()和doPost() form表单无method属性时默认get 转发与重定向 req.getRequestDispatcher("/page16").forward(req,resp) 转发时浏览器只产生一次请求 浏览器请求/page15 > /page15 > /page16 > 响应浏览器 resp.sendRedirect("/page16") 重定向时浏览器产生两次请求 浏览器请求/page15 > /page15 > 响应浏览器告之重新请求/page16 > 浏览器请求/page16 > /page16 > 响应浏览器 过滤器 浏览器请求先经过滤器再到servlet, 在Web应用启动时被创建且全局唯一,并发环境下为单例多线程 3.1.0版本的javax.servlet-api, 过滤器方法init和destroy未被default修饰,需要实现 "/" 仅匹配 http://example.com/。它不会匹配子路径, "/*" 匹配 http://example.com/、http://example.com/page 复合过滤 @WebFilter(Filter(fileName="filter-one",urlPatterns={"/a/*","*.jsp"})) 配置形式 <filter> <filter-name>filter-one</filter-name> <filter-class>FilterTest</filter-class> </filter> <filter-mapping> <filter-name>filter-one</filter-name> <url-pattern>/a/*</url-pattern> </filter-mapping> <filter-mapping> <filter-name>filter-one</filter-name> <url-pattern>*.jsp</url-pattern> </filter-mapping> 过滤链 过滤器应具有各自单独的功能 当以配置web.xml文件绑定过滤路径时,过滤器的执行顺序以filter-mapping书写顺序为准 注解形式时,根据过滤器类名的字母顺序决定 过滤链是双向穿透的 浏览器请求 -> f1 -> f2 -> f3 -> servlet响应 -> f3 -> f2 -> f1 -> 浏览器 filterChain.doFilter() 该行代码的执行与否, 决定了中止请求或继续向后传递请求 处理完请求后，控制权会返回到该行代码之后的部分，这部分代码在响应返回时执行 public class FilterChainTest { @WebServlet("/page18") public static class Root extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) { System.out.println("/page18"); } } @WebFilter(filterName = "f1",urlPatterns = "/page18/*") public static class F1 implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { System.out.println("[往] f1"); chain.doFilter(req,resp); System.out.println("[返] f1"); } @Override //init,destroy } @WebFilter(filterName = "f2",urlPatterns = "/page18/*") public static class F2 implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { System.out.println("[往] f2"); chain.doFilter(req,resp); System.out.println("[返] f2"); } @Override //init,destroy } @WebFilter(filterName = "f3",urlPatterns = "/page18/*") public static class F3 implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { System.out.println("[往] f3"); chain.doFilter(req,resp); System.out.println("[返] f3"); } @Override //init,destroy } } 应用例: 适配桌面端和移动端 应用目录下建立desktop和mobile两个文件夹,文件清单保持一致 @WebFilter(filterName = "ClientFilter",urlPatterns = {"*.html"}) public class ClientFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; String uri = req.getRequestURI(); if (uri.startsWith("/desktop") || uri.startsWith("/mobile")){ chain.doFilter(request,response); //如果已经被正确导向则直接放行 }else{ String s = req.getHeader("user-agent").toLowerCase(); if (s.contains("android") || s.contains("iphone")){ resp.sendRedirect("/mobile"+uri); //否则重定向 } else{ resp.sendRedirect("/desktop"+uri); } } } @Override //init,destroy } 请求响应乱码 Servlet中显式设置字符编码 对于request 分为get和post两种情况 get 对于tomcat8以前的版本,需要到tomcat的conf/server.xml文件中为Connector标签添加属性:URIEncoding="UTF-8" post req.setCharacterEncoding("UTF-8"); get请求直接将参数放在url中没有请求体,所以setCharacterEncoding()对get请求无效 对于response resp.setContentType("text/html;charset=utf-8"); 自定义字符编码过滤器 @WebFilter( filterName = "characterEncodingFilter", urlPatterns = {"/*"}, initParams = { @WebInitParam(name = "encoding", value = "UTF-8") } ) public class CharacterEncodingFilter implements Filter { private String encoding = "UTF-8"; @Override public void init(FilterConfig filterConfig) { if (filterConfig.getInitParameter("encoding") != null) encoding = filterConfig.getInitParameter("encoding"); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; req.setCharacterEncoding(encoding); HttpServletResponse resp = (HttpServletResponse) response; resp.setContentType("text/html;charset=UTF-8"); chain.doFilter(request, response); } @Override public void destroy() {} } 配置形式 <filter> <filter-name>characterEncodingFilter</filter-name> <filter-class>com.ida.javaweb.demo1.filter.CharacterEncodingFilter</filter-class> <init-param> <param-name>encoding</param-name> <param-value>UTF-8</param-value> </init-param> </filter> <filter-mapping> <filter-name>characterEncodingFilter</filter-name> <url-pattern>/*</url-pattern> <!-- /* 包括根路径 / 以及所有子路径; / 仅匹配应用的根路径请求 --> </filter-mapping> 默认首页和错误页面 当根目录下放有首页文件时,访问example.com隐式跳转到了example.com/index.html 如果配置了"/"的servlet, 直接访问example.com/index.html, 得到的是"/"的servlet的响应 如果显式定义了此列表则不再使用默认规则, 当网页打开根目录时,会按列表顺序查找目录下是否有以下文件,有则加载,打开二级目录时也同样会进行查找和加载 <welcome-file-list> <welcome-file>index.html</welcome-file> <welcome-file>index.jsp</welcome-file> <welcome-file>index.htm</welcome-file> <welcome-file>default.html</welcome-file> <welcome-file>default.jsp</welcome-file> <welcome-file>default.htm</welcome-file> </welcome-file-list> tomcat默认的错误页面会暴露底层的路径类名框架结构等应用信息 如果服务器发生了500内部服务器错误，则 500.html 将作为错误页面被加载。 如果抛出了 java.lang.Exception 异常，并且没有匹配到特定的 HTTP 错误代码配置，500.html 也会作为错误页面被加载。 <error-page> <error-code>500</error-code> <location>/error/500.html</location> </error-page> <error-page> <exception-type>java.lang.Exception</exception-type> <location>/error/500.html</location> </error-page> 启动时初始化Servlet 配置 load-on-startup 会在服务器启动时初始化 Servlet，而不是在第一次请求时, 用于系统的预处理,启动时慢,加载完后快 load-on-startup从0起按序串行加载 web.xml中可以不用写servlet-mapping,因为不对外提供服务 在使用注解时,虽然设置loadOnStartup后url不对外暴露，但urlPatterns属性仍然是必需的，因为这是 Servlet 规范的一部分 加个内部无意义的统一前缀隔离它们 public class PreProcessing { @WebServlet(urlPatterns="/pointless/2", loadOnStartup=2) public static class AnalysisSth extends HttpServlet { @Override public void init() { System.out.println("2:分析一些东西"); } } @WebServlet(urlPatterns="/pointless/1", loadOnStartup=1) public static class ImportSth extends HttpServlet { @Override public void init() { System.out.println("1:导入一些东西"); } } @WebServlet(urlPatterns="/pointless/0", loadOnStartup=0) public static class CreatSth extends HttpServlet { @Override public void init() { System.out.println("0:创建一些东西"); } } } 配置形式 <servlet> <servlet-name>creatSth</servlet-name> <servlet-class>com.ida.demo13.PreProcessing$CreatSth</servlet-class><!-- 内部类$ --> <load-on-startup>0</load-on-startup> </servlet> <servlet> <servlet-name>importSth</servlet-name> <servlet-class>com.ida.demo13.PreProcessing$ImportSth</servlet-class> <load-on-startup>1</load-on-startup> </servlet> <servlet> <servlet-name>analysisSth</servlet-name> <servlet-class>com.ida.demo13.PreProcessing$AnalysisSth</servlet-class> <load-on-startup>2</load-on-startup> </servlet> Servlet全局上下文参数和初始化参数 ServletContext提供了与整个web应用程序相关的信息和操作 每个web应用程序有且只有一个 ServletContext 实例 它在web应用程序启动时创建，并在web应用程序关闭时销毁 ServletConfig提供了特定于一个servlet的配置信息 每个servlet都有一个 ServletConfig 实例 @WebServlet( urlPatterns = {"/page3"}, initParams = { @WebInitParam(name = "one", value = "1"), @WebInitParam(name = "two", value = "2") } ) public class ServletContextAndServletConfig extends HttpServlet { private String init_p1; @Override public void init(ServletConfig config) throws ServletException { super.init(config); init_p1 = config.getInitParameter("one"); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) { System.out.println(init_p1); String init_p2 = getServletConfig().getInitParameter("two"); System.out.println(init_p2); String global_p3 = getServletContext().getInitParameter("three"); System.out.println(global_p3); getServletContext().setAttribute("global_attr_four",4); Integer global_attr_four = (Integer) getServletContext().getAttribute("global_attr_four"); System.out.println(global_attr_four); } } 配置形式 <context-param> <param-name>three</param-name> <param-value>3</param-value> </context-param> <servlet> <servlet-name>servletContextAndServletConfig</servlet-name> <servlet-class>com.ida.demo13.ServletContextAndServletConfig</servlet-class> <init-param> <param-name>one</param-name> <param-value>1</param-value> </init-param> <init-param> <param-name>two</param-name> <param-value>2</param-value> </init-param> </servlet> <servlet-mapping> <servlet-name>servletContextAndServletConfig</servlet-name> <url-pattern>/page3</url-pattern> </servlet-mapping> 响应类型 text/plain html css javascript image/jpeg gif png svg+xml audio/mpeg wav video/mp4 ogg application/json xml pdf zip javascript octet-stream x-msdownload application/octet-stream 强制浏览器以二进制数据处理和下载文件，而不尝试解析或显示内容。 它适用于所有文件类型，并确保文件始终被下载，而不是在浏览器中显示 如果需要下载任何类型的文件而不确定具体文件类型，使用 application/octet-stream application/x-msdownload 专门为 Microsoft 可执行文件（如 .exe 文件）设计的 MIME 类型。 它通常用于强制浏览器下载可执行文件而不是尝试运行或显示它们 可执行文件（Executable File）是一种包含可以被计算机直接执行的指令的文件。可执行文件通常是编译后的程序代码，可以在计算机上运行而不需要进一步处理或解释。 如果明确是下载可执行文件（如 .exe 文件），使用 application/x-msdownload 可能更合适。 一些浏览器或下载管理器可能会根据 application/x-msdownload 识别并特别处理可执行文件的下载，而 application/octet-stream 不会有特定的处理。 application/x-www-form-urlencoded 返回URL编码后的表单数据 multipart/form-data 上传文件和提交其他类型的数据 返回图片 @WebServlet("/page8") public class ImageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.setContentType("image/jpeg"); Path imageFile = Paths.get(getServletContext().getRealPath("/img/test.jpg")); //Files.readAllBytes 会将整个文件一次性读入内存中，如果是小文件且确定服务器有足够的内存可以使代码更简洁 //而逐块读取（例如使用缓冲区循环读取）的方式只需要在内存中保留一块数据，可以更快地开始将文件数据写入响应流，降低响应的初始延迟。 byte[] imageData = Files.readAllBytes(imageFile); resp.getOutputStream().write(imageData); } } 返回文件下载动作 @WebServlet("/page9") public class DownloadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { // 从请求参数中获取文件名 Manual.txt String fileName = req.getParameter("fileName"); //防止通过恶意构造请求进行目录遍历攻击 if (fileName == null || fileName.isEmpty() || fileName.contains("..") || fileName.contains("/") || fileName.contains("\\")) { resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid file name."); return; } String relativePath = "/resources/doc/" + fileName; String filePath = getServletContext().getRealPath(relativePath); Path file = Paths.get(filePath); if (Files.exists(file) && !Files.isDirectory(file)) {//同时检查路径是否为目录 //resp.setContentType("application/x-msdownload"); //使用 Files.probeContentType(file) 根据文件类型动态设置MIME类型，而不是固定为 application/x-msdownload。 resp.setContentType(Files.probeContentType(file)); resp.setHeader("Content-Disposition", "attachment; filename=" + fileName); try { //一次性读入内存 byte[] fileData = Files.readAllBytes(file); resp.getOutputStream().write(fileData); } catch (IOException e) { resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Error reading the file."); } } else { resp.sendError(HttpServletResponse.SC_NOT_FOUND, "File not found."); } } } 任意源文件下载 @WebServlet("/page14") public class SecureFileDownloadServlet extends HttpServlet { private static final String UPLOAD_DIR = "uploads"; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { String fileName = req.getParameter("fileName"); if (fileName == null || fileName.isEmpty() || fileName.contains("..") || fileName.contains("/") || fileName.contains("\\")) { resp.getWriter().println("Invalid file name"); return; } String applicationPath = getServletContext().getRealPath(""); String downloadPath = applicationPath + File.separator + UPLOAD_DIR + File.separator + fileName; //normalize() 方法在路径处理中非常有用，可以确保路径是标准化的，去除冗余的路径元素，防止路径遍历攻击 //移除当前目录标识 (.) 例如/a/b/./c 规范化后会变成 /a/b/c //解析父目录标识 (..) 例如，/a/b/c/../d 规范化后会变成 /a/b/d, /a/b/c/../../d 规范化后会变成 /a/d //移除冗余的路径分隔符 例如，/a//b/c 规范化后会变成 /a/b/c Path filePath = Paths.get(downloadPath).normalize(); //二次检查路径合法性 if (!filePath.startsWith(Paths.get(applicationPath + File.separator + UPLOAD_DIR).normalize())) { resp.getWriter().println("Invalid file path"); return; } if (!Files.exists(filePath)) { resp.getWriter().println("File not found"); return; } resp.setContentType("application/octet-stream"); resp.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\""); //逐块读取文件并写入响应 //filePath.toFile()相比String.valueOf(filePath) //在文件下载的场景中, 使用filePath.toFile()时, Java 会正确处理路径中的大多数字符包括空格, 更直接和高效,避免了不必要的字符串转换 try (FileInputStream fileInputStream = new FileInputStream(filePath.toFile()); OutputStream outputStream = resp.getOutputStream()) { byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = fileInputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, bytesRead); } } //一次性读取并写入响应 //byte[] fileData = Files.readAllBytes(filePath); //resp.getOutputStream().write(fileData); } } Session和Cookie Session 服务器端(tomcat内存)存储用户会话信息，通过HttpSession对象来管理 当一个新浏览器发送请求时，Tomcat会检测到这是一个新的请求，于是为其创建一个新的会话（Session），并生成一个唯一的Session ID。 这个Session ID会随着响应一起发送回浏览器，通常通过一个Cookie来保存。 浏览器在接收到这个Session ID后，会将其存储在Cookie中。 只要这个Cookie在有效期内，每次浏览器发送请求时都会携带这个Session ID。 这样，当Servlet需要操作会话属性时，Tomcat就会根据这个Session ID找到对应的会话空间进行读写操作。 在不关闭浏览器应用的情况下，即使关闭并重新打开标签页，Session通常仍然可以使用。 因为Session是与整个浏览器应用（即整个浏览器进程）相关联的，而不是与单个标签页相关联。 Cookie 客户端存储用户信息，通过HttpServletResponse对象来设置Cookie，通过HttpServletRequest对象来读取Cookie cookie在有效期内总是伴随浏览器请求发送给tomcat session public class SessionSetGet { @WebServlet("/page4") public static class SessionSet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); session.setAttribute("sessionId","会话ID:"+session.getId()); req.getRequestDispatcher("/page5").forward(req,resp); } } @WebServlet("/page5") public static class SessionGet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { HttpSession session = req.getSession(); String s = (String) session.getAttribute("sessionId"); resp.getWriter().println("[session信息] " + s); } } } Session有效期 通过配置Tomcat的conf/web.xml文件,单位分钟 <web-app> <session-config> <session-timeout>30</session-timeout> </session-config> </web-app> 过期时间是从用户最后一次与服务器交互开始计算 如果用户在30分钟内没有任何操作，包括与服务器交互，那么Session会过期。 但是，如果用户在30分钟内有任何操作，包括点击按钮、填写表单或与服务器进行其他形式的交互，那么Session的过期时间会被重置，并且会继续有效，直到用户再次长时间无操作。 SessionId的cookie有效期 未设置有效期时,浏览器关闭后SessionId的cookie消失 但是session没有销毁，它会等Session有效期过了之后才会销毁 而设置了有效期时会使得SessionId的cookie在浏览器关闭后再次打开时，仍然可以读取原来的SessionId 方式1 在Tomcat的conf/context.xml文件中添加SessionCookie子元素 专注于Session Cookie的配置，配置项较少且简单 <Context> <SessionCookie name="JSESSIONID" path="/" maxAge="3600" httpOnly="true" secure="false"/> </Context> name：Session Cookie的名称（默认为JSESSIONID）。 path：Session Cookie的路径（默认为/）。 maxAge：Session Cookie的最大存活时间，以秒为单位。 httpOnly：是否仅通过HTTP协议传输，防止客户端脚本访问（默认为true）。 secure：是否仅通过HTTPS传输（默认为false）。 方式2 在Tomcat的conf/context.xml文件中或者在Web应用的META-INF/context.xml文件中添加Manager子元素 除了Session Cookie的配置，还涉及会话管理的其他配置，如会话持久化 <Context> <Manager pathname="" sessionCookieName="JSESSIONID" sessionCookiePath="/" sessionCookieDomain="" sessionCookieMaxAge="3600"/> </Context> pathname：会话持久化文件的路径。如果设置为空字符串，则禁用会话持久化。 sessionCookieName：Session Cookie的名称（默认为JSESSIONID）。 sessionCookiePath：Session Cookie的路径（默认为/）。 sessionCookieDomain：Session Cookie的域（可选）。 sessionCookieMaxAge：Session Cookie的最大存活时间，以秒为单位。 cookie 会话 Cookie (Session Cookie) 默认情况下，未指定有效期的 Cookie 会在用户关闭浏览器时被删除 持久化 Cookie (Persistent Cookie) 通过设置 Cookie 的有效期，可以创建持久化 Cookie，它们在关闭浏览器后依然存在，直到过期时间为止 public class CookieGetSet { @WebServlet("/page6") public static class AddCookie extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { Cookie cookie = new Cookie("username", "汤姆"); cookie.setMaxAge(60 * 60 * 24 * 3);//设置的 Cookie 有效期信息通过 HTTP 响应头传达给浏览器 resp.addCookie(cookie); resp.getWriter().println("login success"); } } @WebServlet("/page7") public static class GetCookie extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { Cookie[] cookies = req.getCookies(); String s = null; if (cookies != null) { for (Cookie cookie : cookies) { System.out.println(cookie.getName() + ":" + cookie.getValue()); if (cookie.getName().equals("username")) { s = cookie.getValue(); //将 Max-Age 设置为零以删除 Cookie //cookie.setMaxAge(0); //resp.addCookie(cookie); break; } } } resp.getWriter().println(s == null ? "user not exist" : "username:" + s); } } } 监听器 过滤器用于处理请求和响应 监听器通常用于初始化和清理任务 对象监听接口(对象初始化完成/session创建,销毁) ServletContextListener contextInitialized contextDestroyed HttpSessionListerner requestInitialized requestDestroyed ServletRequestListener sessionCreated sessionDestroyed 属性监听接口(属性的新建,删除和修改) ServletContextAttributeListener / HttpSessionAttributeListener / ServletRequestAttributeListener attributeAdded attributeRemoved attributeReplaced @WebListener 没有特定的属性来配置。它的唯一作用是标记类为Web应用程序中的监听器 web.xml等价形式 <listener> <listener-class>ListenerObj</listener-class> </listener> <listener> <listener-class>ListenerAttr</listener-class> </listener> @WebListener public class ListenerObj implements ServletContextListener, HttpSessionListener, ServletRequestListener { @Override public void contextInitialized(ServletContextEvent servletContextEvent) { System.out.println("初始化ServletContext"); } @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { System.out.println("销毁ServletContext"); } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); System.out.println("初始化HttpServletRequest:"+req.getRequestURI()); } @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { System.out.println("销毁HttpServletRequest"); } @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); System.out.println("创建Session:"+session.getId()); } @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) { System.out.println("销毁Session"); } } @WebListener public class ListenerAttr implements ServletContextAttributeListener, HttpSessionAttributeListener, ServletRequestAttributeListener { @Override public void attributeAdded(ServletContextAttributeEvent servletContextAttributeEvent) { System.out.println("ServletContext增加属性:" + servletContextAttributeEvent.getName() + "-" + servletContextAttributeEvent.getValue()); } @Override public void attributeRemoved(ServletContextAttributeEvent servletContextAttributeEvent) { System.out.println("ServletContext移除属性:" + servletContextAttributeEvent.getName() + "-" + servletContextAttributeEvent.getValue()); } @Override public void attributeReplaced(ServletContextAttributeEvent servletContextAttributeEvent) { System.out.println("ServletContext修改属性:" + servletContextAttributeEvent.getName() + "-" + servletContextAttributeEvent.getValue()); } @Override public void attributeAdded(ServletRequestAttributeEvent servletRequestAttributeEvent) { System.out.println("ServletRequest增加属性:" + servletRequestAttributeEvent.getName() + "-" + servletRequestAttributeEvent.getValue()); } @Override public void attributeRemoved(ServletRequestAttributeEvent servletRequestAttributeEvent) { System.out.println("ServletRequest移除属性:" + servletRequestAttributeEvent.getName() + "-" + servletRequestAttributeEvent.getValue()); } @Override public void attributeReplaced(ServletRequestAttributeEvent servletRequestAttributeEvent) { System.out.println("ServletRequest修改属性:" + servletRequestAttributeEvent.getName() + "-" + servletRequestAttributeEvent.getValue()); } @Override public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) { System.out.println("Session增加属性:" + httpSessionBindingEvent.getName() + "-" + httpSessionBindingEvent.getValue()); } @Override public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) { System.out.println("Session移除属性:" + httpSessionBindingEvent.getName() + "-" + httpSessionBindingEvent.getValue()); } @Override public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) { System.out.println("Session修改属性:" + httpSessionBindingEvent.getName() + "-" + httpSessionBindingEvent.getValue()); } } @WebServlet("/page19") public class ListenerServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getServletContext().setAttribute("ServletContext_attr","ServletContext_value"); req.getSession().setAttribute("Session_attr","Session_value"); req.setAttribute("request_attr","request_value"); req.getServletContext().setAttribute("ServletContext_attr","ServletContext_value2"); req.getSession().setAttribute("Session_attr","Session_value2"); req.setAttribute("request_attr","request_value2"); req.getServletContext().removeAttribute("ServletContext_attr"); req.getSession().removeAttribute("Session_attr"); req.removeAttribute("request_attr"); } } 流量分析统计 listener @WebListener public class RequestTotalListener implements ServletRequestListener, ServletContextListener { @Override public void contextInitialized(ServletContextEvent servletContextEvent) { List<String> timeList = new ArrayList<>(); List<Integer> valueList = new ArrayList<>(); servletContextEvent.getServletContext().setAttribute("timeList", timeList); servletContextEvent.getServletContext().setAttribute("valueList", valueList); System.out.println("初始统计列表已创建"); } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { HttpServletRequest req = (HttpServletRequest)servletRequestEvent.getServletRequest(); String url = req.getRequestURL().toString(); if (url.endsWith("/page20")){ return; } List<String> timeList = (List<String>) servletRequestEvent.getServletContext().getAttribute("timeList"); List<Integer> valueList = (List<Integer>) servletRequestEvent.getServletContext().getAttribute("valueList"); SimpleDateFormat sdf = new SimpleDateFormat("HH:mm"); String time = sdf.format(new Date()); if (!timeList.contains(time)) { timeList.add(time); valueList.add(1); servletRequestEvent.getServletContext().setAttribute("timeList", timeList); servletRequestEvent.getServletContext().setAttribute("valueList", valueList); } else { int index = timeList.indexOf(time); valueList.set(index, valueList.get(index) + 1); servletRequestEvent.getServletContext().setAttribute("valueList", valueList); } } @Override public void contextDestroyed(ServletContextEvent servletContextEvent) {} @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) {} } servlet @WebServlet("/page20") public class RequestTotalServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { List<String> timeList =(List)req.getServletContext().getAttribute("timeList"); List<Integer> valueList =(List)req.getServletContext().getAttribute("valueList"); Map<String,List> map = new HashMap<>(); map.put("timeList",timeList); map.put("valueList",valueList); String json = JSON.toJSONString(map); resp.getWriter().write(json); } } echarts 图表库https://echarts.apache.org/handbook/zh/get-started/ <html> <head> <meta charset="utf-8"> <title>total</title> <script src="js/jquery-1.11.1.min.js"></script> <script src="js/echarts.min.js"></script> </head> <body> <div id="main" style="height: 300px;width: 600px"></div> <script> function requestTotal(){ $.ajax({ "url":"/page20", "type":"get", "dataType":"json", "success":function (data){ var myChart = echarts.init(document.getElementById('main')); var option = { title: { text: '访问统计' }, tooltip: {}, legend: { data: ['访问量'] }, xAxis: { data: data.timeList }, yAxis: {}, series: [ { name: '访问量', type: 'line', data: data.valueList } ] }; myChart.setOption(option); } }) } setInterval(requestTotal,1000) </script> </body> </html> 20240330190641.webp 静态数据预加载 @WebListener public class SCListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent servletContextEvent) { List<Channel> list = new ArrayList<>(); list.add(new SearchEngine("谷歌","www.google.com")); list.add(new SearchEngine("DuckduckGo","www.duckduckgo.com")); servletContextEvent.getServletContext().setAttribute("channels",list); } @Override public void contextDestroyed(ServletContextEvent servletContextEvent) {} } <%@ page contentType="text/html;charset=UTF-8" language="java" %> <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> <html> <head> <meta charset="UTF-8"> <title>Title</title> </head> <body> <c:forEach items="&#36;{applicationScope.channels}" var="item"> <span>&#36;{item.name} &#36;{item.url}</span> | </c:forEach> </body> </html> 避免在请求期间重复从数据库获取相同的数据 public class CachedDataServlet extends HttpServlet { private static final long serialVersionUID = 1L; //使用 ConcurrentHashMap 作为缓存存储 cache。它允许线程安全的并发操作 private static final Map<String, Object> cache = new ConcurrentHashMap<>(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String key = request.getParameter("key"); if (key == null || key.isEmpty()) { response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing or empty 'key' parameter."); return; } Object data; if (cache.containsKey(key)) { data = cache.get(key); response.setStatus(HttpServletResponse.SC_OK); response.getWriter().println("Cached data: " + data); } else { try { data = fetchDataFromDatabase(key); cache.put(key, data); response.setStatus(HttpServletResponse.SC_OK); response.getWriter().println("Fetched and cached data: " + data); } catch (Exception e) { response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); response.getWriter().println("Error fetching data: " + e.getMessage()); e.printStackTrace(); // Log the exception for debugging } } } private Object fetchDataFromDatabase(String key) throws Exception { // Simulate fetching data from a database if (key.equals("error")) { throw new Exception("Simulated database error"); } return "Data for " + key; } }`,``,`html`,`Socket编程`,`20240307183503-_java 网络协议 协议定义了数据传输的格式、通信规则和错误处理等细节 TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。 TCP TCP是一种面向连接的、可靠的、基于字节流的传输层的双向通信协议 数据可以通过两个数据流在同一时间发送 TCP 层是位于 IP 层之上，应用层之下的中间层。TCP保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 连接时三次握手： 客户端：在吗？ 服务端：在 客户端：上号 断开时四次挥手： 客户端：不玩了 服务端：好吧 服务端：下次什么时候玩？ 客户端：有空再玩 UDP 不需要建立连接（因为把数据源IP、目的地IP、端口封装成数据包）， 每个数据包在64KB内，只管发，不管对方有没有接到确认什么的。 优点：可以广播发送，发送数据结束时无需释放资源，开销小，速度快。 使用场景：语言通话、视频通话等。 UDP是一种面向无连接的传输层协议。UDP不关心对端是否真正收到了传送过去的数据。 如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。 UDP常用在分组数据较少或多播、广播通信以及视频通信等多媒体领域。' 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 单播 单播用于两个主机之间的端对端通信 组播 组播用于对一组特定的主机进行通信 广播 广播用于一个主机对整个局域网上所有主机上的数据通信 通信模式 CS模式（客户端/服务端）,端游 交互性强，网络通信量低，响应数据快。 将任务分到了两端，降低了系统的开销。 客户端要处理大多数的业务逻辑和UI展示。 胖客户端 更新太快，要求用户有相同的操作系统，如果有不同的操作系统还要开发不同的版本，对于计算机电脑的配置要求也高 BS模式（浏览器/服务端）,页游 主要事务在服务端实现。 分布性强、维护方便、开发简单,共享性强、总体成本低，对客户端的电脑配置要求较低 数据安全性问题，对服务器要求高。 数据传输速度较慢，软件的个性化明显降低，难以实现传统模式下的特殊功能要求 他是瘦客户端，大量的数据的传输都要通过服务器与浏览器进行交互，通信开销大，难以实现复杂的应用构造 IP IPv4（32比特4字节） IPv6（128位16个字节） 公网地址和私有地址 192.168开头的就是常见的私有地址（局域网使用） 端口 一个主机设备中，端口号是唯一的,一个程序一个端口号, 范围是0~65535 周知端口：0~1023，被预先定义的知名应用占用。（例如：HTTP占用80端口，FTP占用21端口） 注册端口：1024~49151，分配给用户进程或某些程序（例如：Tomcat占用8080端口） 动态端口：49152~65535，不固定分配到某种进程，动态分配 端口的作用是在互联网上标识特定的应用程序和服务，使得不同的应用程序可以通过互联网同时运行，并且互不干扰 域名 当用户在浏览器中输入一个域名时，操作系统会首先向本地域名服务器发送查询请求。 本地域名服务器会检查自己的缓存中是否有该域名对应的IP地址 如果有则直接返回给操作系统。 如果没有，则本地域名服务器会向根域名服务器发送查询请求。 根域名服务器会返回对应的顶级域名服务器的地址。 根域名服务器是位于全球各地的13个服务器，它们存储了顶级域名（如.com、.org、.net等）的信息。 本地域名服务器再向顶级域名服务器发送查询请求，顶级域名服务器会返回对应的权威域名服务器的地址。 本地域名服务器向权威域名服务器发送查询请求，权威域名服务器会返回该域名对应的IP地址 然后本地域名服务器将结果缓存并返回给操作系统。 在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个hosts列表，一般来说浏览器要先查看要访问的域名是否在hosts列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地hosts列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。 Socket 一般来讲，通过端口号和IP地址，可以唯一确定一个TCP连接，在网络编程中，通常被称为一个socket接口 Socket，本质上就是一组接口，是对TCP/IP协议的封装和应用(程序员层面上)。 常见的Socket编程包括TCP Socket和UDP Socket，分别用于可靠传输和不可靠传输。 socket是基于应用服务与TCP/IP通信之间的一个抽象，他将TCP/IP协议里面复杂的通信逻辑进行分装，对用户来说，只要通过一组简单的API就可以实现网络的连接。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。实现步骤为： 服务器通过实例化 ServerSocket 对象来侦听指定端口上的客户端连接请求 某个客户端实例化一个 Socket 对象并指定服务器名称和端口号来请求连接 服务器端接收到连接请求后调用 accept() 方法返回一个新的 Socket 对象表示与该客户端建立的连接。 服务器端会创建多个 Socket 对象，每个 Socket 对象都代表一个客户端与服务器之间的通信通道 客户端只会创建一个 Socket 对象，用于与服务器端建立连接 设定等待建立连接的超时时间 当客户端的 Socket 构造方法请求与服务器连接时，可能要等待一段时间。在默认情况下，Socket 构造方法会一直等待下去，直到连接成功，或者出现异常。Socket 构造方法请求连接时，受底层网络的传输速度的影响，可能会处于长时间的等待状态。如果希望限定等待连接的时间，就需要使用第一个不带参数的构造方法 Socket() Socket(InetAddress address, int port) throws UnknownHostException,IOException Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException Socket(String host, int port) throws UnknownHostException,IOException Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException Socket(Proxy proxy) Socket socket = new Socket(); SocketAddress remoteAddr = new InetSocketAddress("1ocalhostn", 8000); // 参数endpoint指定服务器的地址,参数timeout设定的超时时间(ms) // 如果参数timeout被设为0则表示永远不会超时 socket.connect(remoteAddr, 60000); 设定客户端的地址 在一个 Socket 对象中既包含远程服务器的 IP 地址和端口信息，也包含本地客户端的 IP 地址和端口信息。在默认情况下，客户端的 IP 地址来自客户程序所在的主机，客户端的端口则由操作系统随机分配。Socket 类还有两个构造方法允许显式地设置客户端的 IP 地址和端口 如果一个主机同时属于两个以上的网络，它就可能拥有两个以上 IP 地址，例如一个主机在 Internet 网络中的 IP 地址为 “222.67,1.34”，在一个局域网中的 IP 地址为 “1125.4.3”，假定这个主机上的客户程序希望和同一个局城网上的一个地址为 “112.5.4.4:8000” 的服务器程序通信，客户端可按照如下方式构造 Socket 对象 Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException InetAddress remoteAddr = InetAddress.getByName("112.5,4.45"); InetAddress localAddr = InetAddress.getByName("112.5.4.3"); //客户端使用口2345 Socket socket = new Socket(remoteAddr, 8000, localAddr, 2345); 使用代理服务器 在实际应用中，有的客户程序会通过代理服务器来访问远程服务器。代理服务器有许多功能，比如能作为防火墙进行安全防范，或者提高访问速度，或者具有访问特定远程服务器的权限 Proxy.Type.SOCKS //在分层的网络结构中，SOCKS 是位于会话层的代理类型 Proxy.Type.HTTP //在分层的网络结构中，HTTP 是位于应用层的代理类型 Proxy.Type.DIRECT //不使用代理，直接连接远程服务器 String proxyIP = "myproxy.abc.oom"; // 代理服务器地址 int proxyPort = 1080; // 代理服务器端口 // 创建代理对象 Proxy proxy = new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(proxyIP, proxyPort)); Socket socket new Socket(proxy); //连接到远程服务器 socket.connect(new InetSocketAddress("www.javathinker.net", 80)); 获取 Socket 的信息 // 获得远程被连接进程的IP地址 getInetAddress() // 获得远程被连接进程的端口 getPort() // 获得本地的IP地址 getLocalAddress() // 获得本地的端口 getLocalPort() // 获得输入流,如果Socket还没有连接,或者已经关团,或者已经通过shutdownInput()方法关闭输入流,那么此方法会抛出IOException getInputStream() // 获得输出流,如果Socket还没有连接,或者已经关闭,或者已经通过shutdownOutput()方法关闭输出流,那么此方法会抛出 IOException getOutputStream() 关闭 Socket 当客户与服务器的通信结束时，应该及时关闭 Socket，以释放 Socket 占用的包括端口在内的各种资源。Socket 的 close() 方法负责关闭 Socket Socket 类提供了三个状态测试方法 // 如果Socket没有关闭，则返回false，否则返回true isClosed() // 如果Socket曾经连接到远程主机，不管当前是否已经关闭，都返回true。如果Socket从未连接到远程主机，就返回false isConnected() // 如果Socket已经与一个本地端口绑定，则返回true，否则返回false isBound() //如果要判断一个 Socket 对象当前是否处于连接状态，可采用以下方式 String isConnected = socket.isConnected() && !socket.isClosed(); 半关闭 Socket 进程 A 与进程 B 通过 Socket 通信，假定进程 A 输出数据，进程 B 读入数据，进程 A 如何告诉进程 B 所有数据已经输出完毕呢？有几种处理办法： 如果进程 A 与进程 B 交换的是字符流，并且都一行一行地读写数据，那么可以事先约定以一个特殊的标志作为结束标志，例如以字符串 “bye” 作为结束标志，当进程 A 向进程 B 发送一行字符串 “bye”，进程 B 读到这一行数据后，就停止读取数据 进程 A 先发送一个消息，告诉进程 B 所发送的正文的长度，然后发送正文。进程 B 先获知进程 A 将发送的正文的长度，接下来只要读取该长度的字符或者字节，就停止读取数据 进程 A 发完所有数据后，关闭 Socket，当进程 B 读入了进程 A 发送的所有数据后，再次执行输入流的 read() 方法时，该方法返回 “-1”，如果执行 BufferedReader 的 readLine() 方法，那么该方法返回 null ByteArrayOutputstream bufferenew = ByteArrayOutputstream(); byte[] buff = new byte[1024]; int len = -1; while((len = socketIn.read(buff)) != -1) { buffer.write(buff, 0, len); } 当调用 Socke t的 close() 方法关闭 Socket 后，它的输出流和输入流也都被关闭。 有的时候，可能仅仅希望关闭输出流或输入流之一，此时可以采用 Socket 类提供的半关闭方法 shutdownInput() // 关闭输入流 shutdownOutput() // 关团输出流 假定进程 A 执行以下代码，先向进程 B 发送一个字符串，等到进程 B 接收到这个字符串后，进程 A 再调用 Socket 的 shutdownOutput() 方法关闭输出流，接下来进程 A 不允许再输出数据，但是仍可以通过输入流读入数据 // 发出请求信息 String data = ...; OutputStream socketOut = socket.getOutputStream(); socketOut.write(data.getBytes()); socketOut.flush(); // 读取响应 InputStream socketIn = socket.getInputStream(); if(服务器端返回提示信息，表明已经接收到客户端的所有请求数据) socket.shutdownOutput(); //关闭输出流 //继续通过socketIn读取数据 ... //值得注意的是，先后调用 Socket 的 shutdownInput() 和 shutdownOutput() 方法，仅仅关闭了输入流和输出流，并不等价于调用 Socket 的 close() 方法。 //在通信结束后，仍然要调用 Socket 的 close() 方法，因为只有该方法才会释放 Socket 占用的资源，比如占用的本地端口等 public boolean isInputShutdown() // 如果输入流关闭，则返回true，否则返回false public boolean isOutputShutdown() // 如果输出流关闭，则返回true，否则返回false https://cloud.tencent.com/developer/article/2359503 URL编程 //URL 的 基本结构由 5部分组成： 传输协议：//主机名：端口号/文件名 #片段名？参数列表 URL url = new URL("http://localhost:8080/helloworld/index.jsp#a?username=kuangshen&password=123"); System.out.println(url.getProtocol()); //获取URL的协议名 System.out.println(url.getHost());	//获取URL的主机名 System.out.println(url.getPort());	//获取URL的端口号 System.out.println(url.getPath());	//获取URL的文件路径 System.out.println(url.getFile());	//获取URL的文件名 System.out.println(url.getQuery());	//获取URL的查询名 //下载文件 public class UrlTest { public static void main(String[] args) throws Exception { //1、定位到服务器上的资源位置 URL url = new URL("https://lmg.jj20.com/up/allimg/4k/s/02/2109250006343S5-0-lp.jpg"); //2、创建连接 HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(); //对于程序而言，写出去----》output/writer；读取---》input/reader //3、获取输入流 InputStream stream = connection.getInputStream(); //4、写入文件 FileOutputStream outputStream = new FileOutputStream("山水.jpg"); byte[] bytes = new byte[1024]; int len; while ((len = stream.read(bytes)) != -1){ outputStream.write(bytes, 0, len); } //5、关闭资源 outputStream.close(); stream.close(); connection.disconnect();//断开连接 } } URL下载 //直接从 URL 中读取字节流数据。 public static void readByteByUrl() throws IOException { // 创建url读取对象 注意要加协议头 URL url = new URL("https://www.baidu.com"); // 创建输入流 - 字节 InputStream inputStream = url.openStream(); // 创建读取流 - 字符 InputStreamReader reader = new InputStreamReader(inputStream, "UTF-8"); // 创建缓冲区读取对象 BufferedReader readerReader = new BufferedReader(reader); String line; // 写入文件 FileOutputStream fileOutputStream = new FileOutputStream("test/baidu.html"); OutputStreamWriter writer = new OutputStreamWriter(fileOutputStream); while ((line = readerReader.readLine()) != null) { Log.info(line); writer.write(line); } writer.close(); readerReader.close(); //下载图片 //通过 网络地址获取网络资源的字节流 URL imgUrl = new URL("https://t7.baidu.com/it/u=4162611394,4275913936&fm=193&f=GIF"); //通过 url打开输入流通道 imgUrl.openStream() InputStream imgInputStream = new BufferedInputStream(imgUrl.openStream()); FileOutputStream imgStream = new FileOutputStream("test/dog.jpg"); byte[] buffer = new byte[1024 * 2]; int cnt; while ((cnt = imgInputStream.read(buffer, 0 , buffer.length)) != -1) { imgStream.write(buffer, 0, cnt); } writer.close(); Log.info("文件下载成功"); } 例1 客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端 //服务端 public class SocketServer { public static void main(String[] args) throws IOException { // 端口号 int port = 7000; // 在端口上创建一个服务器套接字 ServerSocket serverSocket = new ServerSocket(port); // 监听来自客户端的连接 Socket socket = serverSocket.accept(); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do { double length = dis.readDouble(); System.out.println("服务器端收到的边长数据为：" + length); double result = length * length; dos.writeDouble(result); dos.flush(); } while (dis.readInt() != 0); socket.close(); serverSocket.close(); } } //客户端 public class SocketClient { public static void main(String[] args) throws UnknownHostException, IOException { int port = 7000; String host = "localhost"; // 创建一个套接字并将其连接到指定端口号 Socket socket = new Socket(host, port); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); Scanner sc = new Scanner(System.in); boolean flag = false; while (!flag) { System.out.println("请输入正方形的边长:"); double length = sc.nextDouble(); dos.writeDouble(length); dos.flush(); double area = dis.readDouble(); System.out.println("服务器返回的计算面积为:" + area); while (true) { System.out.println("继续计算？(Y/N)"); String str = sc.next(); if (str.equalsIgnoreCase("N")) { dos.writeInt(0); dos.flush(); flag = true; break; } else if (str.equalsIgnoreCase("Y")) { dos.writeInt(1); dos.flush(); break; } } } socket.close(); } } 可以看到上面的服务器端程序和客户端程序是一对一的关系，为了能让一个服务器端程序能同时为多个客户提供服务，可以使用多线程机制，每个客户端的请求都由一个独立的线程进行处理。下面是改写后的服务器端程序。 public class SocketServerM { public static void main(String[] args) throws IOException { int port = 7000; int clientNo = 1; ServerSocket serverSocket = new ServerSocket(port); // 创建线程池 ExecutorService exec = Executors.newCachedThreadPool(); try { while (true) { Socket socket = serverSocket.accept(); exec.execute(new SingleServer(socket, clientNo)); clientNo++; } } finally { serverSocket.close(); } } } class SingleServer implements Runnable { private Socket socket; private int clientNo; public SingleServer(Socket socket, int clientNo) { this.socket = socket; this.clientNo = clientNo; } @Override public void run() { try { DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do { double length = dis.readDouble(); System.out.println("从客户端" + clientNo + "接收到的边长数据为：" + length); double result = length * length; dos.writeDouble(result); dos.flush(); } while (dis.readInt() != 0); } catch (IOException e) { e.printStackTrace(); } finally { System.out.println("与客户端" + clientNo + "通信结束"); try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } https://zhuanlan.zhihu.com/p/648129548?utm_id=0 例2 一收一发 import java.io.IOException; import java.io.OutputStream; import java.io.PrintStream; import java.net.Socket; //发送端 public class Test { public static void main(String[] args) throws IOException { System.out.println("==============客户端启动==============="); //1.创建发送通信管道 Socket socket = new Socket("127.0.0.1",7777);//参数一：服务端地址 参数二：服务端端口 //2.从scoket管道中获得一个字节输出流,负责发送数据 OutputStream os = socket.getOutputStream(); //3.字节流升级成打印流 PrintStream ps = new PrintStream(os); //4.发送消息 ps.println("大哥，我来了"); ps.flush();//刷新 } } import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.ServerSocket; import java.net.Socket; //服务端 public class Test1 { public static void main(String[] args) throws IOException { System.out.println("========服务端启动============"); //1.创建接收管道，注册端口 ServerSocket serverSocket = new ServerSocket(7777);//参数一：定义服务端口 //2.等待管道连接 Socket accept = serverSocket.accept(); //3.从管道中获取一个字节输入流 InputStream is = accept.getInputStream(); //4.字节流升级生缓冲输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); //5.按照行读取消息会更好 String a; if ((a = br.readLine())!=null){ System.out.println(accept.getRemoteSocketAddress()+"说了："+a); } } } ----------------- /127.0.0.1:60316说了：大哥，我来了 例3 多收多发 import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.util.Scanner; public class kehu { public static void main(String[] args) throws Exception { System.out.println("客户端启动"); //1.创建与服务端连接的管道 Socket s = new Socket(InetAddress.getLocalHost(), 9966); //2.创建一个线程负责客户端的消息读取 new ClientReaderThread(s).start(); //3.创建一个字节输入流管道 OutputStream o = s.getOutputStream(); PrintStream p = new PrintStream(o);//升级流 //4.客户端输入数据 Scanner sc = new Scanner(System.in); while (true){ System.out.println("请输入："); String s1 = sc.nextLine(); p.println(s1);//发送数据出去 p.flush();//刷新流 } } } class ClientReaderThread extends Thread{ private Socket socket; public ClientReaderThread(Socket socket){ this.socket = socket; } @Override public void run(){ try { //把字节输入流包装成字符输入流 InputStream i = socket.getInputStream(); BufferedReader b = new BufferedReader(new InputStreamReader(i)); String s1; while (true){ if ((s1=b.readLine())!=null){ System.out.println("收到了消息"+s1); } } } catch (IOException e) { System.out.println("服务器把你提出群聊"); } } } import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.ArrayList; import java.util.List; public class fuwu { //1.定义一个静态变量储存全部管道 public static List<Socket> all_Sockets = new ArrayList<>(); public static void main(String[] args) throws IOException { System.out.println("服务端启动成功"); //2.服务端口注册 ServerSocket ss = new ServerSocket(9966); //3.管道死循环设置 while (true){ Socket s = ss.accept(); System.out.println(s.getRemoteSocketAddress()+"上线了"); all_Sockets.add(s); new fuwuThread(s).start(); } } } class fuwuThread extends Thread{ private Socket socket; public fuwuThread(Socket socket){ this.socket=socket; } @Override public void run(){ try { InputStream i = socket.getInputStream(); BufferedReader b = new BufferedReader(new InputStreamReader(i)); String s1; while ((s1=b.readLine())!=null){ System.out.println(socket.getRemoteSocketAddress()+"说"+s1); sendMessage(s1); } } catch (IOException e) { System.out.println(socket.getRemoteSocketAddress()+"离线了"); fuwu.all_Sockets.remove(socket); } } private void sendMessage (String s1) throws IOException { for (Socket s:fuwu.all_Sockets){ //服务器收到任何客户端的消息后,就向所有客户端转发一遍 OutputStream o = s.getOutputStream(); PrintStream p = new PrintStream(o); p.println(s1); p.flush(); } } } 例3 // 客户端socket public static void clientSocket() throws IOException { int port = 1000; String host = "localhost"; // 创建套接字 Socket socket = new Socket(host, port); // 如果链接不上会报错 Connection refused (Connection refused) Log.info("链接到远程主机地址： " + socket.getRemoteSocketAddress()); // 获取套接字输出流 OutputStream outputStream = socket.getOutputStream(); // 建立数据输出流 DataOutputStream dataOutputStream = new DataOutputStream(outputStream); // 写入数据 - 写入字符数据 dataOutputStream.writeUTF("我是客户端 socket"); // 获取服务端的响应 // 获取输入流 InputStream inputStream = socket.getInputStream(); // 创建数据输入流 DataInputStream dataInputStream = new DataInputStream(inputStream); // 读取数据 Log.info(dataInputStream.readUTF()); // 关闭客户端 socket.close(); } //服务端socket public static void serverSocket() throws IOException { // 创建服务端 ServerSocket serverSocket = new ServerSocket(1000); // 设置超时时间 ms - 30s 内未收到消息自动退出 serverSocket.setSoTimeout(30000); while(true) { try { Log.info("等待远程连接---->" + serverSocket.getLocalPort()); // 等待远程连接---->1000 // 获取服务端套接字 Socket socket = serverSocket.accept(); Log.info("远程主机地址: ---->" + socket.getRemoteSocketAddress()); // 获取客户端响应 // 创建输入流 DataInputStream dataInputStream = new DataInputStream(socket.getInputStream()); Log.info("客户端说了: ---->" + dataInputStream.readUTF()); // 发送消息给客户端 OutputStream outputStream = socket.getOutputStream(); DataOutputStream dataOutputStream = new DataOutputStream(outputStream); dataOutputStream.writeUTF("我收到了你的消息 / server Socket"); socket.close(); // 相关输出: // 服务端: // 等待远程连接---->1000 // 远程主机地址: ---->/127.0.0.1:59773 // 客户端说了: ---->我是客户端 socket // 等待远程连接---->1000 // 远程主机地址: ---->/127.0.0.1:59778 // 客户端说了: ---->我是客户端 socket // 等待远程连接---->1000 // 客户端: // 链接到远程主机地址： localhost/127.0.0.1:1000 // 我收到了你的消息 / server Socket }catch (IOException e) { Log.info("服务端出错了 ----> " + e.getMessage()); break; } } } 例4 //客户端 public static void dataGramClient() throws IOException { // 创建一个数据包对象 并绑定到内核ip DatagramSocket socket = new DatagramSocket(1001); Log.info("client: " + socket.getLocalAddress()); // 写入数据到包 FileInputStream fileInputStream = new FileInputStream("test/dog.jpg"); byte[] buffer = new byte[1024 * 2]; // 如果是数据量大， 比如文件可以利用 buffer stream 借用缓冲区去读取数据 BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); int cnt; while((cnt = bufferedInputStream.read(buffer, 0, buffer.length)) != -1) { // 封包 DatagramPacket dp = new DatagramPacket(buffer, 0, cnt); // 发送包 - Message too long (sendto failed) udp 支持的包最大是 64k // dp.setData(buffer); // 如果初始化好的， 就不用setData dp.setAddress(InetAddress.getLocalHost()); dp.setPort(1002); socket.send(dp); Log.info("传输中..."); // cnt 等于buffer.length Log.info("buffer read index --->"); } Log.info("传输完毕"); // 关闭输入流 - 不然会导致阻塞 bufferedInputStream.close(); Log.info("close"); // 发完后发送一个结束的指令 byte[] successData = "FILE OK".getBytes(StandardCharsets.UTF_8); DatagramPacket successPak = new DatagramPacket(successData, 0, successData.length); successPak.setAddress(InetAddress.getLocalHost()); successPak.setPort(1002); socket.send(successPak); Log.info("send"); // 创建一个包 1M 大小 DatagramPacket packet = new DatagramPacket(new byte[1024], 1024); // 设置远程主机 - 用于数据上报和接收 packet.setPort(1002); packet.setAddress(InetAddress.getLocalHost()); // 接收包 - 如果没接收到 会阻塞 socket.receive(packet); // 获取数据 Log.info(packet.getAddress() + " ---> "+ new String(packet.getData(), "UTF-8")); // 关闭客户端 socket.close(); } // 服务端 public static void dataGramServer() throws IOException { // 创建一个数据包对象 并绑定到内核ip DatagramSocket socket = new DatagramSocket(1002); Log.info("server: " + socket.getLocalAddress()); // 创建文件输出流 FileOutputStream fos = new FileOutputStream("test/dog1.jpg"); // 创建一个输出流 BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] buffer = new byte[1024 * 2]; while (true) { // 解包 DatagramPacket fileDp = new DatagramPacket(buffer, 0, buffer.length); fileDp.setPort(1001); fileDp.setAddress(InetAddress.getLocalHost()); socket.receive(fileDp); // 判断是否接收到文件上传完毕指令 if(new String(fileDp.getData(), "UTF-8").contains("FILE OK")) { Log.info("文件接收完毕"); break; } // 写入文件 bos.write(buffer, 0, buffer.length); bos.flush(); Log.info("正在接收数据 ->"); } // 关闭输出流 bos.close(); Log.info("文件句柄关闭"); // 设置数据 byte[] result = "我已经下载好了文件".getBytes(StandardCharsets.UTF_8); DatagramPacket resPck = new DatagramPacket(result, 0, result.length); resPck.setPort(1001); resPck.setAddress(InetAddress.getLocalHost()); // 发送数据给客户端 - 发包 socket.send(resPck); Log.info("发送结果"); // 关闭服务端 socket.close(); } 例5 //一收一发 import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; //客户端 public class Test { public static void main(String[] args) throws Exception { //一、发送端(测试时候先启动接收再发送端) //1.创建发送端对象，发送端自带默认端口号（人） System.out.println("========客户端启动============"); DatagramSocket socket1 = new DatagramSocket();//不定义就默认端口 //2.创建一个要发送的数据容器（容器里面有数据） byte[] a ="我是水".getBytes(); //3.创建一个数据包对象把容器装起来 DatagramPacket packet1 = new DatagramPacket(a,a.length, InetAddress.getLocalHost(),8899);//数据，大小，服务端的IP，服务端的端口 //4.发送出去 socket1.send(packet1); //5.关闭资源,避免资源浪费 socket1.close(); } } import java.net.DatagramPacket; import java.net.DatagramSocket; //服务端 public class Test1 { public static void main(String[] args) throws Exception { //二、接收端(测试时候先启动接收再发送端) //1.创建接收端对象，注册端口（人） System.out.println("=========接收端启动==============="); DatagramSocket socket2 = new DatagramSocket(8899); //2.创建一个要接收的数据容器（等待接收数据） byte[]b =new byte[1024*64]; //3.把容器数据打包 DatagramPacket packet2 = new DatagramPacket(b,b.length); //4.等待接收数据 socket2.receive(packet2); //5.读取多少倒出多少 int len = packet2.getLength(); String rs = new String(b,0,len); System.out.println("接收到了数据了"+rs); //6.关闭资源,避免资源浪费 socket2.close(); } } //额外知识点,获取对方端口和ip地址 //String ip = packet2.getAddress().toString(); //System.out.println("对方IP地址为"+ip); //int port = packet2.getPort(); //System.out.println("对方端口位置"+port); 例6 多收多发 import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.util.Scanner; //发送端 public class Test { public static void main(String[] args) throws Exception { //一、1.创建发送端对象，发送端自带默认端口号（人） DatagramSocket socket1 = new DatagramSocket();//不定义就默认端口 System.out.println("========客户端启动============"); //二.6创建键盘录入 Scanner sc = new Scanner(System.in); while (true) {//二、5.死循环把代码封起来（多收多发步骤） //二、6.接收键盘录入 System.out.println("请输入："); String msg = sc.nextLine(); //二、7.设置exit退出 if ("exit".equals(msg)){ System.out.println("离线成功"); socket1.close();//释放资源 break; } //2.创建一个要发送的数据容器（容器里面有数据） byte[] a =msg.getBytes(); //3.创建一个数据包对象把容器装起来 DatagramPacket packet1 = new DatagramPacket(a,a.length, InetAddress.getLocalHost(),8899);//数据，大小，服务端的IP，服务端的端口 //4.发送出去 socket1.send(packet1); } } } import java.net.DatagramPacket; import java.net.DatagramSocket; //二、接收端 public class Test1 { public static void main(String[] args) throws Exception { //1.创建接收端对象，注册端口（人） System.out.println("=========接收端启动==============="); DatagramSocket socket2 = new DatagramSocket(8899); //2.创建一个要接收的数据容器（等待接收数据） byte[]b =new byte[1024*64]; //3.把容器数据打包 DatagramPacket packet2 = new DatagramPacket(b,b.length); while (true) {//二、6.把封装代码写入死循环并删掉释放资源的代码（多收多发步骤） //4.等待接收数据 socket2.receive(packet2); //5.读取多少倒出多少 int len = packet2.getLength(); String rs = new String(b,0,len); System.out.println("接收到了来自："+packet2.getAddress()+"对方端口是："+packet2.getPort()+rs); } } } //额外知识点,获取对方端口和ip地址 //String ip = packet2.getAddress().toString(); //System.out.println("对方IP地址为"+ip); //int port = packet2.getPort(); //System.out.println("对方端口位置"+port); https://blog.csdn.net/m0_52861000/article/details/126901321 例7 编写一个服务器端,和一个客户端 服务器端在9999端口监听 客户端连接到服务器端,发送"hello, server"，然后退出 服务器端接收到客户端发送的信息，输出，并退出 import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; /** * 客户端，发送 "hello, server" 给服务端 */ public class SocketTCP01Client { public static void main(String[] args) throws IOException { //思路 //1. 连接服务端 (ip , 端口） //解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象 // 如果链接网络，第一个参数可以改为IP Socket socket = new Socket(InetAddress.getLocalHost(), 9999); System.out.println("客户端 socket返回=" + socket.getClass()); //2. 连接上后，生成Socket, 通过socket.getOutputStream() // 得到 和 socket对象关联的输出流对象 OutputStream outputStream = socket.getOutputStream(); //3. 通过输出流，写入数据到 数据通道 outputStream.write("hello, server".getBytes()); //4. 关闭流对象和socket, 必须关闭 outputStream.close(); socket.close(); System.out.println("客户端退出....."); } } import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; /** * 服务端 */ public class SocketTCP01Server { public static void main(String[] args) throws IOException { //思路 //1. 在本机 的9999端口监听, 等待连接 // 细节: 要求在本机没有其它服务在监听9999 // 细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发] ServerSocket serverSocket = new ServerSocket(9999); System.out.println("服务端，在9999端口监听，等待连接.."); //2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接 // 如果有客户端连接，则会返回Socket对象，程序继续 Socket socket = serverSocket.accept(); System.out.println("服务端 socket =" + socket.getClass()); // //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示 InputStream inputStream = socket.getInputStream(); //4. IO读取 byte[] buf = new byte[1024]; int readLen = 0; while ((readLen = inputStream.read(buf)) != -1) { System.out.println(new String(buf, 0, readLen));//根据读取到的实际长度，显示内容. } //5.关闭流和socket inputStream.close(); socket.close(); serverSocket.close();// 最后也需要关闭 } } 例8 编写一个服务端,和一个客户端。 服务器端在9999端口监听。 客户端连接到服务端,发送"hello, server",并接收服务器端回发的"hello,client",再退出。 服务器端接收到客户端发送的信息,输出，并发送"hello, client".再退出。 注意：设置结束标记。确保输出结束。 import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; /** * 服务端 */ @SuppressWarnings({"all"}) public class SocketTCP02Server { public static void main(String[] args) throws IOException { //思路 //1. 在本机 的9999端口监听, 等待连接 // 细节: 要求在本机没有其它服务在监听9999 // 细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发] ServerSocket serverSocket = new ServerSocket(9999); System.out.println("服务端，在9999端口监听，等待连接.."); //2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接 // 如果有客户端连接，则会返回Socket对象，程序继续 Socket socket = serverSocket.accept(); System.out.println("服务端 socket =" + socket.getClass()); // //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示 InputStream inputStream = socket.getInputStream(); //4. IO读取 byte[] buf = new byte[1024]; int readLen = 0; while ((readLen = inputStream.read(buf)) != -1) { System.out.println(new String(buf, 0, readLen));//根据读取到的实际长度，显示内容. } //5. 获取socket相关联的输出流 OutputStream outputStream = socket.getOutputStream(); outputStream.write("hello, client".getBytes()); // 设置结束标记 socket.shutdownOutput(); //6.关闭流和socket outputStream.close(); inputStream.close(); socket.close(); serverSocket.close();//关闭 } } package com.hspedu.socket; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; /** * 客户端，发送 "hello, server" 给服务端 */ @SuppressWarnings({"all"}) public class SocketTCP02Client { public static void main(String[] args) throws IOException { //思路 //1. 连接服务端 (ip , 端口） //解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象 Socket socket = new Socket(InetAddress.getLocalHost(), 9999); System.out.println("客户端 socket返回=" + socket.getClass()); //2. 连接上后，生成Socket, 通过socket.getOutputStream() // 得到 和 socket对象关联的输出流对象 OutputStream outputStream = socket.getOutputStream(); //3. 通过输出流，写入数据到 数据通道 outputStream.write("hello, server".getBytes()); // 设置结束标记 socket.shutdownOutput(); //4. 获取和socket关联的输入流. 读取数据(字节)，并显示 InputStream inputStream = socket.getInputStream(); byte[] buf = new byte[1024]; int readLen = 0; while ((readLen = inputStream.read(buf)) != -1) { System.out.println(new String(buf, 0, readLen)); } //5. 关闭流对象和socket, 必须关闭 inputStream.close(); outputStream.close(); socket.close(); System.out.println("客户端退出....."); } } 例9 编写一个服务端,和一个客户端 服务端在9999端口监听 客户端连接到服务端，发送"hello, server”,并接收服务端回发的“hello,client",，再退出 服务端接收到客户端发送的信息，输出，并发送"hello, client"，再退出 这里结束标记也可以采用 writer.newLine();，但是这要求对方读取必须使用 readLine() 。 import java.io.*; import java.net.InetAddress; import java.net.Socket; /** * 客户端，发送 "hello, server" 给服务端， 使用字符流 */ @SuppressWarnings({"all"}) public class SocketTCP03Client { public static void main(String[] args) throws IOException { //思路 //1. 连接服务端 (ip , 端口） //解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象 Socket socket = new Socket(InetAddress.getLocalHost(), 9999); System.out.println("客户端 socket返回=" + socket.getClass()); //2. 连接上后，生成Socket, 通过socket.getOutputStream() // 得到 和 socket对象关联的输出流对象 OutputStream outputStream = socket.getOutputStream(); //3. 通过输出流，写入数据到 数据通道, 使用字符流 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream)); bufferedWriter.write("hello, server 字符流"); bufferedWriter.newLine();//插入一个换行符，表示写入的内容结束, 注意，要求对方使用readLine()!!!! bufferedWriter.flush();// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道 //4. 获取和socket关联的输入流. 读取数据(字符)，并显示 InputStream inputStream = socket.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String s = bufferedReader.readLine(); System.out.println(s); //5. 关闭流对象和socket, 必须关闭 bufferedReader.close();//关闭外层流 bufferedWriter.close(); socket.close(); System.out.println("客户端退出....."); } } package com.hspedu.socket; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 服务端, 使用字符流方式读写 */ @SuppressWarnings({"all"}) public class SocketTCP03Server { public static void main(String[] args) throws IOException { //思路 //1. 在本机 的9999端口监听, 等待连接 // 细节: 要求在本机没有其它服务在监听9999 // 细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发] ServerSocket serverSocket = new ServerSocket(9999); System.out.println("服务端，在9999端口监听，等待连接.."); //2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接 // 如果有客户端连接，则会返回Socket对象，程序继续 Socket socket = serverSocket.accept(); System.out.println("服务端 socket =" + socket.getClass()); // //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示 InputStream inputStream = socket.getInputStream(); //4. IO读取, 使用字符流, 老师使用 InputStreamReader 将 inputStream 转成字符流 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String s = bufferedReader.readLine(); System.out.println(s);//输出 //5. 获取socket相关联的输出流 OutputStream outputStream = socket.getOutputStream(); // 使用字符输出流的方式回复信息 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream)); bufferedWriter.write("hello client 字符流"); bufferedWriter.newLine();// 插入一个换行符，表示回复内容的结束 bufferedWriter.flush();//注意需要手动的flush //6.关闭流和socket bufferedWriter.close(); bufferedReader.close(); socket.close(); serverSocket.close();//关闭 } } 例10 编写一个服务端,和一个客户端 服务器端在8888端口监听 客户端连接到服务端,发送一张图片e:llqie.png 服务器端接收到客户端发送的图片，保存到src下,发送“收到图片"再退出 客户端接收到服务端发送的“收到图片”，再退出 该程序要求使用StreamUtils.java, 我们直接使用其中封装好的方法。 import java.io.*; import java.net.InetAddress; import java.net.Socket; /** * 文件上传的客户端 */ public class TCPFileUploadClient { public static void main(String[] args) throws Exception { //客户端连接服务端 8888，得到Socket对象 Socket socket = new Socket(InetAddress.getLocalHost(), 8888); //创建读取磁盘文件的输入流 //String filePath = "e:\\qie.png"; String filePath = "e:\\abc.mp4"; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath)); // 把文件读到字符数组中!!!!! // bytes 就是filePath对应的字节数组 byte[] bytes = StreamUtils.streamToByteArray(bis); //通过socket获取到输出流, 将bytes数据发送给服务端 BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); bos.write(bytes); //将文件对应的字节数组的内容，写入到数据通道 bis.close(); socket.shutdownOutput(); //设置写入数据的结束标记 //=====接收从服务端回复的消息===== InputStream inputStream = socket.getInputStream(); //使用StreamUtils 的方法，直接将 inputStream 读取到的内容 转成字符串 String s = StreamUtils.streamToString(inputStream); System.out.println(s); //关闭相关的流 inputStream.close(); bos.close(); socket.close(); } } package com.hspedu.upload; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 文件上传的服务端 */ public class TCPFileUploadServer { public static void main(String[] args) throws Exception { //1. 服务端在本机监听8888端口 ServerSocket serverSocket = new ServerSocket(8888); System.out.println("服务端在8888端口监听...."); //2. 等待连接 Socket socket = serverSocket.accept(); //3. 读取客户端发送的数据 // 通过Socket得到输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); byte[] bytes = StreamUtils.streamToByteArray(bis); // 已然读到数组中了 //4. 将得到 bytes 数组，写入到指定的路径，就得到一个文件了 String destFilePath = "src\\abc.mp4"; BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath)); bos.write(bytes); bos.close(); // 向客户端回复 "收到图片" // 通过socket 获取到输出流(字符) BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); writer.write("收到图片"); writer.flush();//把内容刷新到数据通道 socket.shutdownOutput();//设置写入结束标记 //关闭其他资源 writer.close(); bis.close(); socket.close(); serverSocket.close(); } } package com.hspedu.upload; import java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; /** * 此类用于演示关于流的读写方法 * */ public class StreamUtils { /** * 功能：将输入流转换成byte[] * @param is * @return * @throws Exception */ public static byte[] streamToByteArray(InputStream is) throws Exception{ ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象 byte[] b = new byte[1024]; int len; while((len=is.read(b))!=-1){ bos.write(b, 0, len);// 读取道德数据写入bos } byte[] array = bos.toByteArray(); bos.close(); return array; } /** * 功能：将InputStream转换成String * @param is * @return * @throws Exception */ public static String streamToString(InputStream is) throws Exception{ BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder builder= new StringBuilder(); String line; while((line=reader.readLine())!=null){ //当读取到 null时，就表示结束 builder.append(line+"\r\n"); } return builder.toString(); } } 例11 编写一个接收端A,和一个发送端B 接收端 A在 9999端口等待接收数据(receive) 发送端B向接收端A发送数据“hello，明天吃火锅~" 接收端A接收到发送端B发送的数据，回复"好的,明天见"再退出 发送端接收回复的数据,再退出 import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; /** * UDP接收端 */ public class UDPReceiverA { public static void main(String[] args) throws IOException { //1. 创建一个 DatagramSocket 对象，准备在9999接收数据 DatagramSocket socket = new DatagramSocket(9999); //2. 构建一个 DatagramPacket 对象，准备接收数据 // 在前面讲解UDP 协议时，老师说过一个数据包最大 64k byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); //3. 调用 接收方法, 将通过网络传输的 DatagramPacket 对象 // 填充到 packet对象 //老师提示: 当有数据包发送到 本机的9999端口时，就会接收到数据 // 如果没有数据包发送到 本机的9999端口, 就会阻塞等待. System.out.println("接收端A 等待接收数据.."); socket.receive(packet); //4. 可以把packet 进行拆包，取出数据，并显示. int length = packet.getLength();//实际接收到的数据字节长度 byte[] data = packet.getData();//接收到数据 String s = new String(data, 0, length); System.out.println(s); //===回复信息给B端 //将需要发送的数据，封装到 DatagramPacket对象 data = "好的, 明天见".getBytes(); //说明: 封装的 DatagramPacket对象 data 内容字节数组 , data.length , 主机(IP) , 端口 packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.12.1"), 9998); socket.send(packet);//发送 //5. 关闭资源 socket.close(); System.out.println("A端退出..."); } } package com.hspedu.udp; import java.io.IOException; import java.net.*; /** * 发送端B ====> 也可以接收数据 */ @SuppressWarnings({"all"}) public class UDPSenderB { public static void main(String[] args) throws IOException { //1.创建 DatagramSocket 对象，准备在9998端口 接收数据 DatagramSocket socket = new DatagramSocket(9998); //2. 将需要发送的数据，封装到 DatagramPacket对象 byte[] data = "hello 明天吃火锅~".getBytes(); // //说明: 封装的 DatagramPacket对象 data 内容字节数组 , data.length , 主机(IP) , 端口 DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.12.1"), 9999); socket.send(packet); //3.=== 接收从A端回复的信息 //(1) 构建一个 DatagramPacket 对象，准备接收数据 // 在前面讲解UDP 协议时，老师说过一个数据包最大 64k byte[] buf = new byte[1024]; packet = new DatagramPacket(buf, buf.length); //(2) 调用 接收方法, 将通过网络传输的 DatagramPacket 对象 // 填充到 packet对象 //老师提示: 当有数据包发送到 本机的9998端口时，就会接收到数据 // 如果没有数据包发送到 本机的9998端口, 就会阻塞等待. socket.receive(packet); //(3) 可以把packet 进行拆包，取出数据，并显示. int length = packet.getLength();//实际接收到的数据字节长度 data = packet.getData();//接收到数据 String s = new String(data, 0, length); System.out.println(s); //关闭资源 socket.close(); System.out.println("B端退出"); } } 例12 (1)使用字符流的方式,编写一个客户端程序和服务器端程序， (2)客户端发送“name"服务器端接收到后，返回“我是nova ", nova是你自己的名字. (3)客户端发送"hobby"，服务器端接收到后，返回“编写java程序” (4)不是这两个问题，回复“你说啥呢" 问题:目前，我们只能问一次，就退出了，怎么可以问多次?->while ->聊天 import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.util.Scanner; /** * 客户端，发送 "hello, server" 给服务端， 使用字符流 */ @SuppressWarnings({"all"}) public class Homework01Client { public static void main(String[] args) throws IOException { //思路 //1. 连接服务端 (ip , 端口） //解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象 Socket socket = new Socket(InetAddress.getLocalHost(), 9999); //2. 连接上后，生成Socket, 通过socket.getOutputStream() // 得到 和 socket对象关联的输出流对象 OutputStream outputStream = socket.getOutputStream(); //3. 通过输出流，写入数据到 数据通道, 使用字符流 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream)); //从键盘读取用户的问题 Scanner scanner = new Scanner(System.in); System.out.println("请输入你的问题"); String question = scanner.next(); bufferedWriter.write(question); bufferedWriter.newLine();//插入一个换行符，表示写入的内容结束, 注意，要求对方使用readLine()!!!! bufferedWriter.flush();// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道 //4. 获取和socket关联的输入流. 读取数据(字符)，并显示 InputStream inputStream = socket.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String s = bufferedReader.readLine(); System.out.println(s); //5. 关闭流对象和socket, 必须关闭 bufferedReader.close();//关闭外层流 bufferedWriter.close(); socket.close(); System.out.println("客户端退出....."); } } package com.hspedu.homework; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 服务端, 使用字符流方式读写 */ @SuppressWarnings({"all"}) public class Homework01Server { public static void main(String[] args) throws IOException { //思路 //1. 在本机 的9999端口监听, 等待连接 // 细节: 要求在本机没有其它服务在监听9999 // 细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发] ServerSocket serverSocket = new ServerSocket(9999); System.out.println("服务端，在9999端口监听，等待连接.."); //2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接 // 如果有客户端连接，则会返回Socket对象，程序继续 Socket socket = serverSocket.accept(); // //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示 InputStream inputStream = socket.getInputStream(); //4. IO读取, 使用字符流, 老师使用 InputStreamReader 将 inputStream 转成字符流 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String s = bufferedReader.readLine(); String answer = ""; if ("name".equals(s)) { answer = "我是韩顺平"; } else if("hobby".equals(s)) { answer = "编写java程序"; } else { answer = "你说的啥子"; } //5. 获取socket相关联的输出流 OutputStream outputStream = socket.getOutputStream(); // 使用字符输出流的方式回复信息 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream)); bufferedWriter.write(answer); bufferedWriter.newLine();// 插入一个换行符，表示回复内容的结束 bufferedWriter.flush();//注意需要手动的flush //6.关闭流和socket bufferedWriter.close(); bufferedReader.close(); socket.close(); serverSocket.close();//关闭 } } 例13 (1)编写一个接收端A,和一个发送端B,使用UDP协议完成 (2)接收端在8888端口等待接收数据(receive) (3)发送端向接收端发送数据“四大名著是哪些” (4)接收端接收到发送端发送的问题后，返回“四大名著是<<红楼梦>>.…."，否则返回what? (5)接收端和发送端程序退出 import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.util.Scanner; /** * 发送端B ====> 也可以接收数据 */ @SuppressWarnings({"all"}) public class Homework02SenderB { public static void main(String[] args) throws IOException { //1.创建 DatagramSocket 对象，准备在9998端口 接收数据 DatagramSocket socket = new DatagramSocket(9998); //2. 将需要发送的数据，封装到 DatagramPacket对象 Scanner scanner = new Scanner(System.in); System.out.println("请输入你的问题: "); String question = scanner.next(); byte[] data = question.getBytes(); // //说明: 封装的 DatagramPacket对象 data 内容字节数组 , data.length , 主机(IP) , 端口 DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.12.1"), 8888); socket.send(packet); //3.=== 接收从A端回复的信息 //(1) 构建一个 DatagramPacket 对象，准备接收数据 // 在前面讲解UDP 协议时，老师说过一个数据包最大 64k byte[] buf = new byte[1024]; packet = new DatagramPacket(buf, buf.length); //(2) 调用 接收方法, 将通过网络传输的 DatagramPacket 对象 // 填充到 packet对象 //老师提示: 当有数据包发送到 本机的9998端口时，就会接收到数据 // 如果没有数据包发送到 本机的9998端口, 就会阻塞等待. socket.receive(packet); //(3) 可以把packet 进行拆包，取出数据，并显示. int length = packet.getLength();//实际接收到的数据字节长度 data = packet.getData();//接收到数据 String s = new String(data, 0, length); System.out.println(s); //关闭资源 socket.close(); System.out.println("B端退出"); } } package com.hspedu.homework; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; /** * UDP接收端 */ @SuppressWarnings({"all"}) public class Homework02ReceiverA { public static void main(String[] args) throws IOException { //1. 创建一个 DatagramSocket 对象，准备在8888接收数据 DatagramSocket socket = new DatagramSocket(8888); //2. 构建一个 DatagramPacket 对象，准备接收数据 // 在前面讲解UDP 协议时，老师说过一个数据包最大 64k byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); //3. 调用 接收方法, 将通过网络传输的 DatagramPacket 对象 // 填充到 packet对象 System.out.println("接收端 等待接收问题 "); socket.receive(packet); //4. 可以把packet 进行拆包，取出数据，并显示. int length = packet.getLength();//实际接收到的数据字节长度 byte[] data = packet.getData();//接收到数据 String s = new String(data, 0, length); // 将字节数组转为string!!!! //判断接收到的信息是什么 String answer = ""; if("四大名著是哪些".equals(s)) { answer = "四大名著 <<红楼梦>> <<三国演示>> <<西游记>> <<水浒传>>"; } else { answer = "what?"; } //===回复信息给B端 //将需要发送的数据，封装到 DatagramPacket对象 data = answer.getBytes(); //说明: 封装的 DatagramPacket对象 data 内容字节数组 , data.length , 主机(IP) , 端口 packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.12.1"), 9998); socket.send(packet);//发送 //5. 关闭资源 socket.close(); System.out.println("A端退出..."); } } 例14 (1)编写客户端程序和服务器端程序 (2)客户端可以输入一个音乐文件名，比如高山流水, 服务端收到音乐名后，可以给客户端返回这个音乐文件，如果服务器没有这个文件，返回一个默认的音乐即可。 (3)客户端收到文件后，保存到本地e:\\ (4)提示:该程序可以使用 StreamUtils.java import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; import java.util.Scanner; /** * 文件下载的客户端 */ public class Homework03Client { public static void main(String[] args) throws Exception { //1. 接收用户输入，指定下载文件名 Scanner scanner = new Scanner(System.in); System.out.println("请输入下载文件名"); String downloadFileName = scanner.next(); //2. 客户端连接服务端，准备发送 Socket socket = new Socket(InetAddress.getLocalHost(), 9999); //3. 获取和Socket关联的输出流 OutputStream outputStream = socket.getOutputStream(); outputStream.write(downloadFileName.getBytes()); //设置写入结束的标志 socket.shutdownOutput(); //4. 读取服务端返回的文件(字节数据) BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); byte[] bytes = StreamUtils.streamToByteArray(bis); //5. 得到一个输出流，准备将 bytes 写入到磁盘文件 //比如你下载的是 高山流水 => 下载的就是 高山流水.mp3 // 你下载的是 无名 => 下载的就是 无名.mp3 String filePath = "e:\\" + downloadFileName + ".mp3"; BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath)); bos.write(bytes); //6. 关闭相关的资源 bos.close(); bis.close(); outputStream.close(); socket.close(); System.out.println("客户端下载完毕，正确退出.."); } } package com.hspedu.homework; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 先写文件下载的服务端 */ public class Homework03Server { public static void main(String[] args) throws Exception { //1 监听 9999端口 ServerSocket serverSocket = new ServerSocket(9999); //2.等待客户端连接 System.out.println("服务端，在9999端口监听，等待下载文件"); Socket socket = serverSocket.accept(); //3.读取 客户端发送要下载的文件名 // 这里老师使用了while读取文件名，时考虑将来客户端发送的数据较大的情况 InputStream inputStream = socket.getInputStream(); byte[] b = new byte[1024]; int len = 0; String downLoadFileName = ""; while ((len = inputStream.read(b)) != -1) { downLoadFileName += new String(b, 0 , len); } System.out.println("客户端希望下载文件名=" + downLoadFileName); //老师在服务器上有两个文件, 无名.mp3 高山流水.mp3 //如果客户下载的是 高山流水 我们就返回该文件，否则一律返回 无名.mp3 String resFileName = ""; if("高山流水".equals(downLoadFileName)) { resFileName = "src\\高山流水.mp3"; } else { resFileName = "src\\无名.mp3"; } //4. 创建一个输入流，读取文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(resFileName)); //5. 使用工具类StreamUtils ，读取文件到一个字节数组 byte[] bytes = StreamUtils.streamToByteArray(bis); //6. 得到Socket关联的输出流 BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //7. 写入到数据通道，返回给客户端 bos.write(bytes); socket.shutdownOutput();//很关键. //8 关闭相关的资源 bis.close(); inputStream.close(); socket.close(); serverSocket.close(); System.out.println("服务端退出..."); } } package com.hspedu.homework; import java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; /** * 此类用于演示关于流的读写方法 * */ public class StreamUtils { /** * 功能：将输入流转换成byte[] * @param is * @return * @throws Exception */ public static byte[] streamToByteArray(InputStream is) throws Exception{ ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象 byte[] b = new byte[1024]; int len; while((len=is.read(b))!=-1){ bos.write(b, 0, len); } byte[] array = bos.toByteArray(); bos.close(); return array; } /** * 功能：将InputStream转换成String * @param is * @return * @throws Exception */ public static String streamToString(InputStream is) throws Exception{ BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder builder= new StringBuilder(); String line; while((line=reader.readLine())!=null){ builder.append(line+"\r\n"); } return builder.toString(); } } https://zhuanlan.zhihu.com/p/627897813?utm_id=0 例15 首先客户端连接服务端，io流写入信息之后，就给出标记点，告知服务端自己的消息已经发送完毕，然后等待服务端传来的消息，一旦接收到服务端传递过来的消息就可以退出连接了。 而服务端在启动之后就开始就开始监听8888端口，然后等待客户端连接，直到客户端连接上之后，首先打印服务端的socket，然后接收到客户端发来的消息并打印在控制台上，并给客户端发送一条消息，然后给出一个标识，告知客户端自己消息已经发送完了。 import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; /** * @author : Leo * @version 1.0 * @date 2023-11-02 9:44 * @description : 服务端 */ public class SocketTCPServer02 { public static void main(String[] args) throws IOException { /* * 1. 在本机的8888端口监听, 等待连接 * 细节: 要求在本机没有其它服务在监听9999 * 细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发] */ ServerSocket serverSocket = new ServerSocket(8888); System.out.println("服务端，在8888端口监听，等待连接.."); //2. 当没有客户端连接8888端口时，程序会 阻塞, 等待连接 //如果有客户端连接，则会返回Socket对象，程序继续 Socket socket = serverSocket.accept(); System.out.println("服务端 socket ="+socket.getClass()); // //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示 InputStream is = socket.getInputStream(); //4. 通过IO流读取 byte[] buf = new byte[1024]; int readLen = 0; while((readLen = is.read(buf))!=-1){ //根据读取到的实际长度，显示内容. System.out.println(new String(buf, 0, readLen)); } //5. 获取socket相关联的输出流 OutputStream outputStream = socket.getOutputStream(); outputStream.write("hello, SocketTCPClent02,我是服务端，这是我给你回的一条信息....".getBytes()); //6.设置结束标记 socket.shutdownOutput(); //7.关闭流和socket is.close(); socket.close(); serverSocket.close(); } } import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; /** * @author : Leo * @version 1.0 * @date 2023-11-02 9:44 * @description : 客户端 */ public class SocketTCPClent02 { public static void main(String[] args) throws IOException { /* * 1. 连接服务端 (ip , 端口) * 连接本机的 8888端口, 如果连接成功，返回Socket对象 */ Socket socket = new Socket(InetAddress.getLocalHost(), 8888); System.out.println("客户端 socket返回=" + socket.getClass()); //2. 连接上之后，生成Socket, 通过socket.getOutputStream() // 得到 和 socket对象关联的输出流对象 OutputStream outputStream = socket.getOutputStream(); //3. 通过输出流，写入数据到 数据通道 outputStream.write("hello, SocketTCPServer02,我是客户端，这是我给你发的一条信息".getBytes()); //4.设置结束标记 socket.shutdownOutput(); //5. 获取和socket关联的输入流. 读取数据(字节)，并显示 InputStream inputStream = socket.getInputStream(); byte[] buf = new byte[1024]; int readLen = 0; while ((readLen = inputStream.read(buf)) != -1) { System.out.println("客户端收到服务端的 回复信息 = " + new String(buf, 0, readLen)); } //6.关闭流对象和socket, 必须关闭 outputStream.close(); socket.close(); System.out.println("客户端退出....."); } } 例16 public class SendDemo { public static void main(String[] args) throws IOException { //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = "hello,udp,我来了".getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("127.0.0.1"),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); } } public class ReceiveDemo { public static void main(String[] args) throws IOException { 	//创建接收端的Socket对象(DatagramSocket) 	DatagramSocket ds = new DatagramSocket(12345); 	//创建一个数据包，用于接收数据 	byte[] bys = new byte[1024]; 	DatagramPacket dp = new DatagramPacket(bys, bys.length); 	//调用DatagramSocket对象的方法接收数据 	ds.receive(dp); 	//解析数据包，并把数据在控制台显示 	System.out.println("数据是：" + new String(dp.getData(), 0,dp.getLength())); } } 例17 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 /* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */ public class SendDemo { public static void main(String[] args) throws IOException { //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //键盘录入数据 Scanner sc = new Scanner(System.in); while (true) { 	String s = sc.nextLine(); //输入的数据是886，发送数据结束 if ("886".equals(s)) { break; } //创建数据，并把数据打包 byte[] bys = s.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); } //关闭发送端 ds.close(); } } /* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */ public class ReceiveDemo { public static void main(String[] args) throws IOException { //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) { //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength())); } //关闭接收端 // ds.close(); } } 例18 UDP组播实现 发送端 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包(DatagramPacket) 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) 释放资源 接收端 创建接收端Socket对象(MulticastSocket) 创建一个箱子,用于接收数据 把当前计算机绑定一个组播地址 将数据接收到箱子中 解析数据包,并打印数据 释放资源 // 发送端 public class ClinetDemo { public static void main(String[] args) throws IOException { // 1. 创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); String s = "hello 组播"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName("224.0.1.0"); int port = 10000; // 2. 创建数据，并把数据打包(DatagramPacket) DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) ds.send(dp); // 4. 释放资源 ds.close(); } } // 接收端 public class ServerDemo { public static void main(String[] args) throws IOException { // 1. 创建接收端Socket对象(MulticastSocket) MulticastSocket ms = new MulticastSocket(10000); // 2. 创建一个箱子,用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中. ms.joinGroup(InetAddress.getByName("224.0.1.0")); // 4. 将数据接收到箱子中 ms.receive(dp); // 5. 解析数据包,并打印数据 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 6. 释放资源 ms.close(); } } 例19 UDP广播实现 发送端 创建发送端Socket对象(DatagramSocket) 创建存储数据的箱子,将广播地址封装进去 发送数据 释放资源 接收端 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 // 发送端 public class ClientDemo { public static void main(String[] args) throws IOException { 	// 1. 创建发送端Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); 		// 2. 创建存储数据的箱子,将广播地址封装进去 String s = "广播 hello"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName("255.255.255.255"); int port = 10000; DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); 		// 3. 发送数据 ds.send(dp); 		// 4. 释放资源 ds.close(); } } // 接收端 public class ServerDemo { public static void main(String[] args) throws IOException { // 1. 创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(10000); // 2. 创建一个数据包，用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 调用DatagramSocket对象的方法接收数据 ds.receive(dp); // 4. 解析数据包，并把数据在控制台显示 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 5. 关闭接收端 ds.close(); } } 例20 多发多收 ​客户端：多次发送数据 ​服务器：接收多次接收数据，并打印 public class Client { public static void main(String[] args) throws IOException { //客户端：多次发送数据 //服务器：接收多次接收数据，并打印 //1. 创建Socket对象并连接服务端 Socket socket = new Socket("127.0.0.1",10000); //2.写出数据 Scanner sc = new Scanner(System.in); OutputStream os = socket.getOutputStream(); while (true) { System.out.println("请输入您要发送的信息"); String str = sc.nextLine(); if("886".equals(str)){ break; } os.write(str.getBytes()); } //3.释放资源 socket.close(); } } public class Server { public static void main(String[] args) throws IOException { //客户端：多次发送数据 //服务器：接收多次接收数据，并打印 //1.创建对象绑定10000端口 ServerSocket ss = new ServerSocket(10000); //2.等待客户端来连接 Socket socket = ss.accept(); //3.读取数据 InputStreamReader isr = new InputStreamReader(socket.getInputStream()); int b; while ((b = isr.read()) != -1){ System.out.print((char)b); } //4.释放资源 socket.close(); ss.close(); } } 例21 客户端：数据来自于本地文件，接收服务器反馈 服务器：接收到的数据写入本地文件，给出反馈 public class Client { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket("127.0.0.1",10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\clientdir\\a.jpg")); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1){ bos.write(bytes,0,len); } //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); } } public class Server { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); //2.等待客户端来连接 Socket socket = ss.accept(); //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\serverdir\\a.jpg")); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1){ bos.write(bytes,0,len); } bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write("上传成功"); bw.newLine(); bw.flush(); //5.释放资源 socket.close(); ss.close(); } } 例22 文件名重复 UUID（Universally Unique Identifier）是一个128位的全局唯一标识符。它是由一组数字和字母组成，采用十六进制表示，并且在理论上具有非常低的重复概率。UUID的生成算法保证了在不同系统、不同时间和不同空间中生成的标识符几乎不可能发生冲突，因此可以被广泛用于分布式系统和大规模应用中。 public class Client { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket("127.0.0.1",10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\clientdir\\a.jpg")); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1){ bos.write(bytes,0,len); } //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); } } public class Server { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); //2.等待客户端来连接 Socket socket = ss.accept(); //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); String name = UUID.randomUUID().toString().replace("-", ""); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\serverdir\\" + name + ".jpg")); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write("上传成功"); bw.newLine(); bw.flush(); //5.释放资源 socket.close(); ss.close(); } } 服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。 优化方案一： ​	使用循环 弊端： ​	第一个用户正在上传数据，第二个用户就来访问了，此时第二个用户是无法成功上传的。 ​	所以，使用多线程改进 优化方案二： ​	每来一个用户，就开启多线程处理 public class Client { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket("127.0.0.1",10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\clientdir\\a.jpg")); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1){ bos.write(bytes,0,len); } //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); } } public class Server { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); while (true) { //2.等待客户端来连接 Socket socket = ss.accept(); //开启一条线程 //一个用户就对应服务端的一条线程 new Thread(new MyRunnable(socket)).start(); } } } public class MyRunnable implements Runnable{ Socket socket; public MyRunnable(Socket socket){ this.socket = socket; } @Override public void run() { try { //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); String name = UUID.randomUUID().toString().replace("-", ""); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\serverdir\\" + name + ".jpg")); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write("上传成功"); bw.newLine(); bw.flush(); } catch (IOException e) { e.printStackTrace(); } finally { //5.释放资源 if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 线程池改进 public class Client { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket("127.0.0.1",10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\clientdir\\a.jpg")); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1){ bos.write(bytes,0,len); } //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); } } public class Server { public static void main(String[] args) throws IOException { //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //创建线程池对象 ThreadPoolExecutor pool = new ThreadPoolExecutor( 3,//核心线程数量 16,//线程池总大小 60,//空闲时间 TimeUnit.SECONDS,//空闲时间（单位） new ArrayBlockingQueue<>(2),//队列 Executors.defaultThreadFactory(),//线程工厂，让线程池如何创建线程对象 new ThreadPoolExecutor.AbortPolicy()//阻塞队列 ); //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); while (true) { //2.等待客户端来连接 Socket socket = ss.accept(); //开启一条线程 //一个用户就对应服务端的一条线程 //new Thread(new MyRunnable(socket)).start(); pool.submit(new MyRunnable(socket)); } } } public class MyRunnable implements Runnable{ Socket socket; public MyRunnable(Socket socket){ this.socket = socket; } @Override public void run() { try { //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); String name = UUID.randomUUID().toString().replace("-", ""); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\serverdir\\" + name + ".jpg")); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write("上传成功"); bw.newLine(); bw.flush(); } catch (IOException e) { e.printStackTrace(); } finally { //5.释放资源 if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 例23 便于阅读的写法 public class TcpServer { public static void main(String[] args) { ByteArrayOutputStream bos = null; InputStream is = null; Socket socket = null; ServerSocket serverSocket = null; try { //1、设置服务端的地址与端口 serverSocket = new ServerSocket(9923); //2、监听该端口的请求 socket = serverSocket.accept(); //3、读取信息,通过管道流 //获取输入流 is = socket.getInputStream(); //获取字节缓冲数组流，用于输出 bos = new ByteArrayOutputStream(); //设置缓冲数组 byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1){ bos.write(buffer, 0, len); } System.out.println(bos.toString()); } catch (IOException e) { e.printStackTrace(); }finally { //4、资源关闭 if (null != bos) {//null写左边主要是用来防止在输入==时少打了个等号变成赋值,在java中可以不用这样写，写在右边更具有阅读性。 try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if (null != is) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (null != socket) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if (null != serverSocket) { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } public class TcpClient { public static void main(String[] args) { OutputStream outputStream = null; Socket socket = null; try { //1、设置ip地址 InetAddress inetAddress = InetAddress.getByName("127.0.0.1"); //2、设置端口 int port = 9923; //3、创建交流的套子接口 socket = new Socket(inetAddress, port); //4、进行交流 outputStream = socket.getOutputStream(); outputStream.write("你好,java网络编程".getBytes()); } catch (Exception e) { e.printStackTrace(); }finally { //5、进行资源关闭 if (null != outputStream) { try { outputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if (null != socket) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 例24 udp多线程 public class TalkServiceSend implements Runnable{ private DatagramSocket socket = null; private BufferedReader dataPacket = null; /** * 接收者的ip */ private String receiveIp; /** * 接收者端口 */ private int receivePort; public TalkServiceSend(String receiveIp, int receivePort) { this.receiveIp = receiveIp; this.receivePort = receivePort; try { socket = new DatagramSocket(); dataPacket = new BufferedReader(new InputStreamReader(System.in)); } catch (SocketException e) { e.printStackTrace(); } } @Override public void run() { while (true){ try { String data = dataPacket.readLine() + "#"; byte[] dataBytes = data.getBytes(); DatagramPacket packet = new DatagramPacket(dataBytes, 0, dataBytes.length, new InetSocketAddress(this.receiveIp, this.receivePort)); //发送数据 socket.send(packet); if (data.split("#")[0].equalsIgnoreCase("bye")){ break; } } catch (IOException e) { e.printStackTrace(); } } //关闭资源 socket.close(); } } 8 public class TalkServiceReceive implements Runnable{ DatagramSocket socket = null; /** * 端口 */ private int port; /** * 发送者 */ private String sender; public TalkServiceReceive(int port, String sender) { this.port = port; this.sender = sender; try { socket = new DatagramSocket(this.port); } catch (SocketException e) { e.printStackTrace(); } } @Override public void run() { //接收多次 while (true){ try { //准备容器接收数据 //在使用socket发送udp包传输文本时，由于包中的char型数组是定长的，且其长度大于消息长度，所以其中必有很多空元素。当接收端接收到udp包时进行转码，空元素就会被转码成方块形状的乱码。 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); //阻塞接收数据 socket.receive(packet); //断开连接 byte[] data = packet.getData(); String receiveData = new String(data); System.out.println(sender + " : " + receiveData); if (receiveData.equalsIgnoreCase("bye")){ break; } } catch (IOException e) { e.printStackTrace(); } } //关闭资源 socket.close(); } } public class TalkStudent { public static void main(String[] args) { new Thread(new TalkServiceSend("127.0.0.1", 9923)).start(); // new Thread(new TalkServiceSend("10.82.148.136", 9923)).start();//虚拟机地址 new Thread(new TalkServiceReceive(9924, "老师")).start(); } } public class TalkTeacher { public static void main(String[] args) { new Thread(new TalkServiceSend("127.0.0.2", 9924)).start(); // new Thread(new TalkServiceSend("192.168.10.102", 9924)).start(); new Thread(new TalkServiceReceive(9923, "学生")).start(); } } 例25 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.Socket; public class TCPClient { public static void main(String[] args) { String serverIP = "127.0.0.1"; // 服务器IP地址 int serverPort = 8888; // 服务器端口号 try { Socket socket = new Socket(serverIP, serverPort); // 获取输入流和输出流 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); // 发送数据 String message = "Hello, server!"; out.println(message); // 接收服务器响应 String response = in.readLine(); System.out.println("Server response: " + response); // 关闭连接 socket.close(); } catch (IOException e) { e.printStackTrace(); } } } import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; public class TCPServer { public static void main(String[] args) { int serverPort = 8888; // 服务器监听端口号 try { ServerSocket serverSocket = new ServerSocket(serverPort); System.out.println("Server started and listening on port " + serverPort); while (true) { // 接受客户端连接 Socket clientSocket = serverSocket.accept(); // 获取输入流和输出流 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); // 读取客户端发送的数据 String receivedMessage = in.readLine(); System.out.println("Received message from client: " + receivedMessage); // 向客户端发送响应 String response = "Hello, client!"; out.println(response); // 关闭连接 clientSocket.close(); } } catch (IOException e) { e.printStackTrace(); } } } 例26 import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; public class UDPClient { public static void main(String[] args) { String serverIP = "127.0.0.1"; // 服务器IP地址 int serverPort = 8888; // 服务器端口号 try { DatagramSocket socket = new DatagramSocket(); InetAddress serverAddress = InetAddress.getByName(serverIP); // 发送数据 String message = "Hello, server!"; byte[] sendData = message.getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, serverPort); socket.send(sendPacket); // 接收服务器响应 byte[] receiveData = new byte[1024]; DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); socket.receive(receivePacket); String response = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println("Server response: " + response); // 关闭连接 socket.close(); } catch (IOException e) { e.printStackTrace(); } } } import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; public class UDPServer { public static void main(String[] args) { int serverPort = 8888; // 服务器监听端口号 try { DatagramSocket socket = new DatagramSocket(serverPort); System.out.println("Server started and listening on port " + serverPort); while (true) { // 接收客户端数据 byte[] receiveData = new byte[1024]; DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); socket.receive(receivePacket); String receivedMessage = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println("Received message from client: " + receivedMessage); // 向客户端发送响应 String response = "Hello, client!"; byte[] sendData = response.getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, receivePacket.getAddress(), receivePacket.getPort()); socket.send(sendPacket); } } catch (IOException e) { e.printStackTrace(); } } }`,``,`html`,`Spring AOP`,`20240729003931-_java web Object-Oriented Programming OOP Aspect-Oriented Programming AOP 面向切面编程 将通用,与业务无关的功能抽象封装为切面类,切面可配置在目标方法的执行前,或执行后运行, 即插即用, 在不修改源码的情况下对程序行为进行扩展 20240502185824.webp AOP原理 Spring基于代理模式实现功能动态扩展,包含两种形式 目标类拥有接口,通过JDK动态代理实现功能扩展 类名为$Proxy加序号 目标类没有接口,通过CGLib(Code Generation Library) 组件实现功能扩展 20240503103729.webp 通过在运行时生成目标继承类字节码的方式进行行为扩展 生成一个继承自委托类的代理类,重写委托类的方法,在原方法的基础上进行前置或后置处理 类名为原类名加上$$EnhaceByCGLIB 代理模式 20240826161746.webp 静态代理 静态代理中，代理类是在编译时定义的，也就是说，代理类的代码在编译时就已经存在，并且直接实现了代理目标类所实现的接口 public interface UserService { void createUser(); } public class UserServiceImpl implements UserService{ @Override public void createUser() { System.out.println("委托类原有功能"); } } public class UserServiceProxyA implements UserService{ //代理类和委托类实现同一个接口 //代理类持有该接口,(持有接口相比于持有委具体托类的优点在于可以嵌套使用) //代理类在执行委托类方法时进行功能扩充 private UserService userService ; public UserServiceProxyA(UserService userService){ this.userService=userService; } @Override public void createUser() { System.out.println("代理类扩充前置功能"); userService.createUser(); } } public class UserServiceProxyB implements UserService{ private UserService userService ; public UserServiceProxyB(UserService userService){ this.userService=userService; } @Override public void createUser() { userService.createUser(); System.out.println("代理类扩充后置功能"); } } public class Application { public static void main(String[] args) { System.out.println("--------未使用代理模式--------"); UserService userService = new UserServiceImpl(); userService.createUser(); System.out.println("\n--------使用代理模式--------"); userService = new UserServiceProxyA(new UserServiceImpl()); userService.createUser(); System.out.println("\n--------嵌套代理--------"); userService = new UserServiceProxyB(new UserServiceProxyA(new UserServiceImpl())); userService.createUser(); } } /* --------未使用代理模式-------- 委托类原有功能 --------使用代理模式-------- 代理类扩充前置功能 委托类原有功能 --------嵌套代理-------- 代理类扩充前置功能 委托类原有功能 代理类扩充后置功能 */ JDK动态代理 动态代理是在运行时生成代理类的代码。 Java提供了 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口来实现动态代理。 Java的动态代理强制要求委托类必须实现了至少一个接口, 否则反射报错 动态代理主要用于为接口创建代理，而无需预先编写代理类的代码 它允许你在运行时动态地创建代理类，并拦截和处理方法调用。 通过向 Proxy.newProxyInstance 传入委托类的类加载器、委托类所实现的接口数组和代理处理器，自动生成一个动态代理实例。 该代理实例同样实现了委托类的接口方法，但其方法实现仅是获取相应的接口方法对象，并将其作为参数委托给代理处理器的 invoke 方法进行实际的调用和增强。 public interface UserService { void createUser(); } public class UserServiceImpl implements UserService{ @Override public void createUser() { System.out.println("创建用户"); } } public interface BookService { void purchase(); } public class BookServiceImpl implements BookService{ @Override public void purchase() { System.out.println("采购图书"); } } //InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强, 其实现类与切面类的环绕通知类似 public class FunctionA implements InvocationHandler { private Object target; public FunctionA(Object target){ this.target=target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println("FunctionA的业务逻辑"); //在方法调用前增加逻辑 return method.invoke(target,args); //可以对返回值进行进一步的处理，或者直接返回给调用者 } } public class Application { public static void main(String[] args) { UserService userService = new UserServiceImpl(); //初始化目标对象 UserService userServiceProxy = (UserService) Proxy.newProxyInstance( userService.getClass().getClassLoader(), //使用目标对象的类加载器 userService.getClass().getInterfaces(), //获取目标对象实现的接口数组, 或 new Class[] { A.class,B.class } new FunctionA(userService) //创建一个 ProxyInvocationHandler 实例，并传入目标对象 ); userServiceProxy.createUser(); //代理对象将方法调用委托给 ProxyInvocationHandler 的 invoke 方法 BookService bookService = new BookServiceImpl(); BookService bookServiceProxy = (BookService) Proxy.newProxyInstance( bookService.getClass().getClassLoader(), bookService.getClass().getInterfaces(), new FunctionA(bookService) ); bookServiceProxy.purchase(); } } /* FunctionA的业务逻辑 创建用户 FunctionA的业务逻辑 采购图书 */ Proxy.newProxyInstance 生成的代理类的伪代码结构 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public final class $Proxy0 extends Proxy implements UserService { private InvocationHandler h; public $Proxy0(InvocationHandler h) { super(h); //由于 Proxy 类的构造函数是受保护(protected修饰)的，其子类必须显式调用 super(h) 来完成父类的初始化 this.h = h; } @Override public void createUser() { try { Method method = UserService.class.getMethod("createUser"); h.invoke(this, method, null); } catch (Throwable t) { t.printStackTrace(); } } } Spring AOP 和 AspectJ Spring AOP 和 AspectJ 是两种用于实现面向切面编程（AOP）的技术 Spring AOP 主要使用动态代理技术来实现 AOP, 只支持方法级别的切入点（Join Point） 即只能在方法调用前后插入切面代码, 不支持构造函数、字段和类级别的切面 Eclipse AspectJ 支持编译时织入、类加载时织入和运行时织入，允许在更细粒度的级别（如字段、构造函数等）进行切面编织 Spring AOP借AspectJWeaver来实现类与方法匹配(切点表达式), 至于功能的扩展是Spring AOP自己来实现的 切点表达式 不要把启动类也纳入到了表达式范围!! 20240503085445.webp execution(public * com.imooc..*.*(..)) public可省略, 不限返回类型,位于com.imooc包下,所有类,所有方法 execution(* com.imooc..*Service.*(..)) 不限返回类型,位于com.imooc包下,名称以Service结尾的类,所有方法 execution(String com.imooc..*Service.*(..)) 返回类型为String,位于com.imooc包下,名称以Service结尾的类,所有方法 execution(* com.imooc..*Service.create*(..)) 不限返回类型,位于com.imooc包下,名称以Service结尾的类,方法名以create开头 execution(* com.immoc..*Service.*(String,*)) 不限返回类型,位于com.imooc包下,名称以Service结尾的类,方法有两个参数且第一个为String 通知 20240503092505.webp After Adivce后置通知类似于finally,不管是否抛出异常一定会执行 还有一种特殊的"通知"引介增强 IntroductionInterceptor是对类的增强,而非方法 引介增强允许在运行时为目标类增加新属性或方法 允许在运行时改变类的行为,让类随运行环境动态变更 基于xml配置AOP 依赖 <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.3.19</version> </dependency> <dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> <version>1.9.5</version> </dependency> 业务类 public class UserDao { public void insert() { System.out.println("新增用户数据");} } public class UserService { private UserDao userDao; //getter,setter public void createUser(){ if (true) { //throw new RuntimeException("用户已存在"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } System.out.println("执行创建用户业务逻辑"); userDao.insert(); } public String generateRandomPassword(String type, Integer length) { System.out.println("按"+type+"方式生成"+length+"位随机密码"); return "fsFDS23"; } } public class Application { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext-spring_aop_baseXml.xml"); UserService userService = context.getBean("userService", UserService.class); userService.createUser(); userService.generateRandomPassword("MD5",8); } } 切面类 前置,后置,返回时,异常时 public class MethodAspect { public void doBefore(JoinPoint joinPoint) {//通过连接点获取目标类/方法的信息 Object target = joinPoint.getTarget();//获取目标类 Signature signature = joinPoint.getSignature();//获取目标方法签名 MethodSignature methodSignature = (MethodSignature) signature; Class<?>[] parameterTypes = methodSignature.getParameterTypes(); Object[] args = joinPoint.getArgs();//获取目标方法的实际参数值 System.out.printf("----- 1> 前置通知: %s \n----- 2> %s.%s%s\n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date()), target.getClass().getName(), signature.getName(), args.length > 0 ? "\n----- 3> 实际参数：" + Arrays.toString(args) + " 参数类型：" + Arrays.toString(parameterTypes) : "" ); } public void doAfter(JoinPoint joinPoint) { System.out.println("<----- 后置通知"); } //两参, 一个连接点参数, 一个返回值注入的接收参数 public void doAfterReturning(JoinPoint joinPoint, Object ret) { System.out.println("<----- 返回后通知:" + ret); } //两参, 一个连接点参数, 一个用于捕获异常的Throwable public void doAfterThrowing(JoinPoint joinPoint, Throwable th) { System.out.println("<----- 异常通知:" + th.getMessage()); } } 环绕-慢方法统计 public class SlowMethodChecker { private Long slowMethodDuration; public void setSlowMethodDuration(Long slowMethodDuration) { this.slowMethodDuration = slowMethodDuration; } //需要声明返回Object,环绕通知可以集中完成前置,后置,返回,异常四种通知的工作 public Object check(ProceedingJoinPoint pjp) throws Throwable { try { long startTime = new Date().getTime(); //前置 Object ret = pjp.proceed(); //返回后 long endTime = new Date().getTime(); //后置 long duration = endTime - startTime; if (duration >= slowMethodDuration) { Object target = pjp.getTarget(); Signature signature = pjp.getSignature(); MethodSignature methodSignature = (MethodSignature) signature; Class<?>[] parameterTypes = methodSignature.getParameterTypes(); Object[] args = pjp.getArgs(); System.out.printf("▬▬▬▬▬ 1> 慢方法(%sms): %s \n▬▬▬▬▬ 2> %s.%s%s\n", duration, new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date()), target.getClass().getName(), signature.getName(), args.length > 0 ? "\n▬▬▬▬▬ 3> 实际参数：" + Arrays.toString(args) + " 参数类型：" + Arrays.toString(parameterTypes) : "" ); } return ret; } catch (Throwable e) { System.out.println("Exception Message:" + e.getMessage()); //异常 //上抛而不是在此处消化 throw e; } } } 切面配置 引入aop,context命名空间 <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd "> <!-- 加载配置文件 --> <context:property-placeholder location="classpath:aop-config.properties"/> <bean id="userDao" class="com.ida.demo10.aop.baseXml.dao.UserDao"/> <bean id="userService" class="com.ida.demo10.aop.baseXml.service.UserService"> <property name="userDao" ref="userDao"/> </bean> <!-- 交容器管理切面类, Spring AOP是基于IoC容器之上的 --> <bean id="methodAspect" class="com.ida.demo10.aop.baseXml.aspect.MethodAspect"/> <bean id="slowMethodChecker" class="com.ida.demo10.aop.baseXml.aspect.SlowMethodChecker"> <!-- 定义property-placeholder后注入其中的属性 --> <property name="slowMethodDuration" value="&#36;{slow.method.duration}"/> </bean> <aop:config> <!-- 定义切点 --> <aop:pointcut id="pointcut" expression="execution(public * com.ida.demo10.aop.baseXml..*.*(..))"/> <!-- 指定要使用哪个切面类 --> <aop:aspect ref="methodAspect"> <!-- 指定执行时机, 要使用该切面类中的哪个方法, [接收返回值/异常的参数], 作用的切点 --> <aop:before method="doBefore" pointcut-ref="pointcut"/> <!-- 后置通知无法获取方法返回值或抛出的异常 --> <aop:after method="doAfter" pointcut-ref="pointcut"/> <!-- 除了通过pointcut-ref引用定义好的切点,也可以直接pointcut指定切点 --> <aop:after-returning method="doAfterReturning" returning="ret" pointcut="execution(public * com.ida.demo10.aop.baseXml..*.*(..))"/> <!-- 后置通知,返回后通知,异常通知三者的执行顺序由标签书写顺序决定 --> <aop:after-throwing method="doAfterThrowing" throwing="th" pointcut-ref="pointcut"/> </aop:aspect> <aop:aspect ref="slowMethodChecker"> <aop:around method="check" pointcut-ref="pointcut"/> </aop:aspect> </aop:config> </beans> aop-config.properties slow.method.duration=1000 基于注解配置AOP <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd "> <context:property-placeholder location="classpath:aop-config.properties"/> <!-- 开启组件扫描 --> <context:component-scan base-package="com.ida.demo10.aop.baseAnno"/> <!-- 扫描并自动代理容器中定义的切面 --> <aop:aspectj-autoproxy/> </beans> 业务类标记为Spring组件, 成员自动装配 切面类标记为Spring组件, 同时标记为切面类(aspectj 的注解) //类注解 @Aspect //方法注解, 通知类型(切点表达式或者切点方法) @Before("execution(* com.ida.demo10.aop.baseAnno..*(..))") @After("execution(* com.ida.demo10.aop.baseAnno..*(..))") @AfterReturning(value = "execution(* com.ida.demo10.aop.baseAnno..*(..))",returning = "ret") @AfterThrowing(value = "execution(* com.ida.demo10.aop.baseAnno..*(..))",throwing = "th") @Around("execution(* com.ida.demo10.aop.baseAnno..*(..))") //切点方法, 这个方法的唯一作用是定义一个切入点表达式, 方法内的逻辑不会被执行 @Pointcut("execution(* com.ida.demo10.aop.baseAnno..*(..))") public void webLog(){} / //这是实际的前置通知方法, 在所有匹配 webLog 切入点的方法执行之前，运行 beforeAdvice() 方法 @Before("webLog()") public void beforeAdvice(){..}`,``,`html`,`Spring Boot`,`20240522102834-_java web Spring 最初利用IOC和AOP解耦应用组件。 大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。 然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。(集成了tomcat) Spring Cloud是在Spring Boot基础上诞生的 特点 开箱即用 约定优于配置 上下文路径 src/main/resources/static 是 Spring Boot 默认的静态资源目录。你可以将静态文件放在这个目录中，它们会被自动暴露为 Web 资源 可以在 application.properties 或 application.yml 文件中配置静态资源的路径 spring.web.resources.static-locations=classpath:/static/ @Resource private ServletContext servletContext; //通过 ServletContext 来获取静态资源的根目录。这通常在 Spring Boot 应用中比较直接 String staticDir = servletContext.getRealPath("/static"); Resource resource = resourceLoader.getResource("classpath:/static/"); //通过 ResourceLoader 获取静态文件的 URL 或文件对象 Path path = resource.getFile().toPath(); 版本 CURRENT 可能包含了最近的更新和修复，但不一定是正式发布的版本。它代表了目前用户可以访问的最新稳定版本 GA (General Availability) 表示软件已经经过充分的测试，并且被认为是稳定的，可以广泛用于生产环境。GA 版本是正式的、最终的发布版本，适合所有用户使用，通常意味着软件经过了完整的开发生命周期和质量保证过程 SNAPSHOT 用于内部测试或开发阶段。SNAPSHOT 版本是不断更新的，可能包含实验性的特性或正在进行的开发改进，因此可能不够稳定，不适合用于生产环境。这个版本用来捕捉当前开发状态的快照，通常会被频繁更新 创建方式 在线, https://start.spring.io/ idea spring initializer 使用早期jdk时改sever url[start.spring.io]为start.aliyun.com pom spring-boot-starter-web 起始依赖, 包含了一系列默认配置和依赖, 帮助开发者快速启动和构建基于 Spring 的 Web 应用 spring-boot-starter-web 适用于开发标准的 Web 应用程序、RESTful API、使用 WebSocket 技术的应用，以及其他需要处理 HTTP 请求的场景 微服务中的网关服务：像 Zuul、Spring Cloud Gateway 这样的网关服务通常不需要直接引入 spring-boot-starter-web，因为它们自己的依赖已经包含了所需的 Web 功能。 非 Web 项目：如果你的项目是一个命令行工具、消息驱动应用或数据处理服务，不使用容器管理, 那么就不需要 spring-boot-starter-web 包含了Spring MVC, Tomcat（默认嵌入式容器）, Jackson, Validation, Logging(默认配置了日志框架Logback) 但是不包括aop, 需要单独引入spring-boot-starter-aop(自动配置模块), 提供了针对 spring-aop、aspectjrt 和 aspectjweaver 的依赖。 dependencyManagement 允许你在项目的根 POM 文件中集中控制所有依赖项的版本。在子模块中，只需声明依赖项的 groupId 和 artifactId，而不需要重复指定版本。这保证了所有模块都使用相同的版本，减少了版本冲突的风险 配置文件 默认位置： Spring Boot 会自动在项目的根目录（src/main/resources/ 或 src/main/resources/config/）、classpath 路径下查找名为 application.properties 或 application.yml 的文件 多环境配置 如果存在 application.properties 和 application-prod.properties 两个配置文件 Spring Boot 会根据激活的环境来选择使用哪个文件，或者是否组合使用它们 如果你没有激活 prod 环境，Spring Boot 只会使用 application.properties 如果激活了 prod 环境，配置会先从 application.properties 加载，然后再加载 application-prod.properties，并用后者的值覆盖前者的相同配置 application-{profile}.properties, 其中 {profile} 对应的是激活的 Spring 环境配置文件 激活 pro 环境 在 application.properties 中配置 spring.profiles.active=prod 这会让 application.properties 还是会被加载，之后加载 application-prod.properties, 如果要禁用 application.properties 的影响，确保它是空文件或没有相关配置 一种做法是, 在 application.properties 文件中，仅设置 spring.profiles.active 属性来指定当前激活的环境 再根据不同的环境创建出相应的配置文件 application.properties spring.profiles.active=dev application-dev.properties server.port=8080 spring.datasource.url=jdbc:mysql://localhost:3306/dev_db .. application-prod.properties server.port=9090 spring.datasource.url=jdbc:mysql://localhost:3306/prod_db .. yml application.properties server.port=80 server.servlet.context-path=/first application.yml 层级结构,冒号后要空格(多个空格解析器视为一个空格) server: port: 80 servlet: context-path: /first YAML 是 JSON 的超集 YAML 和 Properties 文件在配置列表（数组）时有不同的支持和表现形式 YAML 支持以自然且可读的方式配置列表或数组。可以使用短横线（-）来表示列表项 Properties 文件不直接支持列表或数组。要在 Properties 文件中模拟列表，通常需要用逗号分隔或其他自定义的分隔符 # YAML 文件示例 servers: - server1 - server2 - server3 database: urls: - jdbc:mysql://localhost:3306/db1 - jdbc:mysql://localhost:3306/db2 # Properties 文件示例 servers=server1,server2,server3 database.urls=jdbc:mysql://localhost:3306/db1,jdbc:mysql://localhost:3306/db2 绑定配置文件中的参数 server.port=80 #server.servlet.context-path=/first fruit.title=orange fruit.quantity=10 一. 直接绑定 @RestController public class PropertiesController { @Value("&#36;{fruit.title}") private String title; @Value("&#36;{fruit.quantity}") private Integer quantity; @GetMapping("/properties") public String a(){ return title+":"+quantity; } } 二. 通过对象配置 可以防止参数名的拼写错误 使用@ConfigurationProperties注解并提供前缀, 提供对应的属性名及settergetter, 同时标记为组件 @Component @ConfigurationProperties(prefix = "fruit") public class FruitConfig { String title; Integer quantity; //getter,setter } @RestController public class ConfigController { @Autowired private FruitConfig fruitConfig; @GetMapping("/config") public String a(){ return fruitConfig.title+":"+fruitConfig.quantity; } } 使用 Log4j2 作为日志框架 排除Logback引用log4j2 Spring Boot默认会包含 spring-boot-starter-logging 依赖，这个依赖使用 Logback 作为日志框架 <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> <exclusions> <exclusion> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-logging</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-log4j2</artifactId> </dependency> 配置文件 <?xml version="1.0" encoding="UTF-8"?> <Configuration status="fatal"> <Properties> <Property name="baseDir" value="D:\Dropbox\workspace\idea\practice\demo14\logs"/> <Property name="p_console_color" value="[%d{MM:dd HH:mm:ss.SSS}] %highlight{[%level]} [%logger{36}] - %highlight{%msg} %n"/> <Property name="p_file" value="[%d{MM:dd HH:mm:ss.SSS}] [%level] [%logger{36}] - %msg%n"/> <Property name="p_file_lineNo" value="[%d{MM:dd HH:mm:ss.SSS}] [%level] [%logger{36}] [%C{1}.%M:%L] - %msg%n"/> </Properties> <Appenders> <!-- info级别及以上输出控制台 --> <Console name="console" target="SYSTEM_OUT"> <ThresholdFilter level="info" onMatch="ACCEPT"/> <PatternLayout pattern="&#36;{p_console_color}" disableAnsi="false"/> </Console> <!-- debug级别单独输出文件 --> <RollingFile name="debug" fileName="&#36;{baseDir}/debug.log" filePattern="&#36;{baseDir}/debug_%i.log.%d{yyyy-MM-dd}"> <Filters> <ThresholdFilter level="DEBUG"/> <ThresholdFilter level="INFO" onMatch="DENY" onMismatch="NEUTRAL"/> </Filters> <PatternLayout pattern="&#36;{p_file_lineNo}"/> <Policies> <TimeBasedTriggeringPolicy interval="1" modulate="true"/> <SizeBasedTriggeringPolicy size="10 MB"/> </Policies> </RollingFile> <!-- info级别单独输出文件 --> <RollingFile name="info" fileName="&#36;{baseDir}/info.log" filePattern="&#36;{baseDir}/info_%i.log.%d{yyyy-MM-dd}"> <Filters> <ThresholdFilter level="INFO"/> <ThresholdFilter level="ERROR" onMatch="DENY" onMismatch="NEUTRAL"/> </Filters> <PatternLayout pattern="&#36;{p_file}"/> <Policies> <TimeBasedTriggeringPolicy interval="1" modulate="true"/> <SizeBasedTriggeringPolicy size="10 MB"/> </Policies> </RollingFile> <!-- error级别及以上单独输出文件 --> <RollingFile name="error" fileName="&#36;{baseDir}/error.log" filePattern="&#36;{baseDir}/error_%i.log.%d{yyyy-MM-dd}"> <Filters> <ThresholdFilter level="ERROR"/> </Filters> <PatternLayout pattern="&#36;{p_file}"/> <Policies> <TimeBasedTriggeringPolicy interval="1" modulate="true"/> <SizeBasedTriggeringPolicy size="10 MB"/> </Policies> </RollingFile> </Appenders> <Loggers> <Root level="DEBUG"> <appender-ref ref="error"/> <appender-ref ref="info"/> <appender-ref ref="console"/> <appender-ref ref="debug"/> </Root> </Loggers> </Configuration> AOP统一处理请求响应日志 //import org.slf4j.Logger; //import org.slf4j.LoggerFactory; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; @Aspect @Component public class WebLogAspect { //private static final Logger logger = LoggerFactory.getLogger(WebLogAspect.class); private static final Logger logger = LogManager.getLogger(WebLogAspect.class); /* 当使用 spring-boot-starter-log4j2 时，Log4j2 是的实际日志实现 Spring Boot 默认使用的是 SLF4J 作为日志门面(Slf4j常与Logback组合使用)，它提供了一个统一的日志接口，但实际的日志记录由Log4j2完成 虽然 SLF4J 也可以用于与 Log4j2 兼容的项目，但在这种配置下，直接使用 Log4j2 的 API 更符合实际的日志实现 */ @Pointcut("execution(public * com.ida.demo14.controller.*.*(..))") public void webLog() { } //@Before("webLog()") public void doBefore(JoinPoint joinPoint) { //Spring MVC 将 HttpServletRequest 绑定到当前线程的 RequestContextHolder 中(通过 ThreadLocal 实现将数据与当前线程关联)，这使得在任何线程中（包括 AOP 切面方法中）都可以访问当前请求的属性。 //RequestContextHolder 是 Spring 提供的一个类，用于获取当前线程的请求属性 //ServletRequestAttributes 的实例封装了当前 HTTP 请求的各种信息，包括 HttpServletRequest 对象 ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = requestAttributes.getRequest(); String url = request.getRequestURL().toString(); String httpMethod = request.getMethod(); String ip = request.getRemoteAddr(); String classAndMethod = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); logger.info("URL : " + url); logger.info("HTTP_METHOD : " + httpMethod); logger.info("IP : " + ip); logger.info("CLASS_METHOD : " + classAndMethod); logger.info("ARGS : " + Arrays.toString(args)); } //@AfterReturning(returning = "res", pointcut = "webLog()") public void doAfterReturning(Object res) throws JsonProcessingException { //ObjectMapper 是 Jackson 库中的一个类, Spring Boot 会自动包含 Jackson 作为默认的 JSON 处理库 //writeValueAsString(Object value)：将 Java 对象转换为 JSON 字符串 //readValue(String content, Class valueType)：将 JSON 字符串转换为指定类型的 Java 对象 logger.info("RESPONSE : " + new ObjectMapper().writeValueAsString(res)); } //@Around("webLog()") @Around("execution(public * com.ida.demo14.controller.*.*(..))") public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable { // 获取 HTTP 请求信息 ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = requestAttributes.getRequest(); String url = request.getRequestURL().toString(); String httpMethod = request.getMethod(); String ip = request.getRemoteAddr(); String classAndMethod = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); logger.info("URL : " + url); logger.info("HTTP_METHOD : " + httpMethod); logger.info("IP : " + ip); logger.info("CLASS_METHOD : " + classAndMethod); logger.info("ARGS : " + Arrays.toString(args)); Object result = joinPoint.proceed(); logger.info("RESPONSE : " + new ObjectMapper().writeValueAsString(result)); return result; } } RequestContextHolder RequestContextHolder 是 Spring 提供的一个工具类，用于访问与当前请求相关的上下文信息。它主要用于在非 Servlet 环境中访问 HttpServletRequest 或 HttpServletResponse 例如在拦截器、AOP 切面、异步任务和非 MVC 环境下访问请求信息或其他无法直接注入 HttpServletRequest 的地方 RequestContextHolder 中的请求上下文信息是线程局部变量（ThreadLocal）存储的，因此在多线程环境下要小心处理，避免造成内存泄漏或数据不一致 全局json日期格式化 boot默认的json工具为jackson, 实体类中的Date类型字段未进行注解配置时返回日期为零时区 通过注解配置日期格式和时区 @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone ="GMT+8") private Date createTime; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone ="GMT+8") private Date updateTime; 通过配置文件配置日期格式 application.properties spring.jackson.date-format=yyyy-MM-dd HH:mm:ss 通过配置类配置日期格式和时区 要包括时区设置，你需要创建一个配置类来自定义 ObjectMapper。这样你可以设置日期格式和时区。 Spring Boot 的 ObjectMapper 不支持直接在 application.properties 文件中配置时区，因此需要通过配置类来实现 @Configuration public class JacksonConfig { @Bean public ObjectMapper objectMapper() { ObjectMapper mapper = new ObjectMapper(); //ObjectMapper 是 Jackson 库中的一个类 mapper.registerModule(new JavaTimeModule()); // 注册 JavaTimeModule 来处理 Java 8 时间类 SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); // 设置日期格式 dateFormat.setTimeZone(TimeZone.getTimeZone("GMT+8")); // 配置时区 mapper.setDateFormat(dateFormat); mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); // 禁用将日期格式化为时间戳 return mapper; } } 全局数据预处理 @InitBinder 是 Spring MVC 中的一个注解，用于定制数据绑定过程。它允许你在请求处理前对请求数据进行格式化、转换或验证。 通常与 @Controller 或 @RestController 配合使用，用于初始化 WebDataBinder 实例。 将请求中的字符串格式化为日期 @Controller public class SampleController { @InitBinder public void initBinder(WebDataBinder binder) { SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true)); } @GetMapping("/example") public ResponseEntity<String> example(@RequestParam("date") Date date) { return ResponseEntity.ok("Date: " + date); } } 自定义转换逻辑 public class CustomStringEditor extends PropertyEditorSupport { @Override public void setAsText(String text) throws IllegalArgumentException { // 例如将文本转换为大写 setValue(text != null ? text.toUpperCase() : null); } } @ControllerAdvice public class GlobalControllerAdvice { @InitBinder public void initBinder(WebDataBinder binder) { // 注册自定义的 PropertyEditor binder.registerCustomEditor(String.class, new CustomStringEditor()); } } @RestController public class SampleController { @GetMapping("/example") public String example(@RequestParam("text") String text) { return "Converted text: " + text; } } Bean Validation 在 Spring Boot 项目中，使用 Bean Validation（例如 Hibernate Validator）来验证用户输入是一种常见且有效的方法。 Hibernate Validator 是 Hibernate 框架的一部分，它实现了 Java Bean Validation 规范（JSR 303 和 JSR 380） 依赖 SpringBoot2.3.0以后版本没有引入javax.validation，需要手动引入对应版本 <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-validation</artifactId> </dependency> 注解列表 @Valid为开关 在未通过验证时可以通过message属性提示信息 @NotNull @NotEmpty 集合、数组、字符串等不能为空（长度或大小大于 0） @NotBlank 字符串不为空且至少包含一个非空白字符, 仅适用于字符串 @Size 字符串、集合、数组的大小在指定范围内。 @Size(min = 2, max = 14, message = "必须介于2-14") @Pattern 确保字符串匹配指定的正则表达式。 @Pattern(regexp = "[a-zA-Z0-9]+") @Pattern(regexp = "male|female", message = "性别必须是男性或女性") 数值类型 @Min 不小于指定的最小值。@Min(18) @Max 不大于指定的最大值。 @Positive 值为正数 @PositiveOrZero 值为正数或零 @Negative 值为负数 @NegativeOrZero 负数或零 @DecimalMin 不小于指定的最小值。适用于小数和整数。DecimalMin("0.0") @DecimalMax 不大于指定的最大值 @Digits 数值的整数部分和小数部分的位数符合指定限制。 @Digits(integer = 3, fraction = 2) 日期和时间 @Past 确保日期在过去。 @Past(message = "出生年不能大于当前时间") private Date birthday; @PastOrPresent 确保日期在过去或当前时间。 @Future 确保日期在将来。 @FutureOrPresent 确保日期在将来或当前时间。 自定义注解 @Email 确保字符串为有效的电子邮件地址。 适用于字符串。 @AssertTrue 确保布尔值为 true。 @AssertFalse 确保布尔值为 false。 自定义验证注解 例如创建一个@ValidAge, 数值类型,不能为null,范围在18-65之间 @Documented @Constraint(validatedBy = AgeValidator.class) @Target({ ElementType.METHOD, ElementType.FIELD }) @Retention(RetentionPolicy.RUNTIME) public @interface ValidAge { String message() default "Invalid age"; Class<?>[] groups() default {}; Class<? extends Payload>[] payload() default {}; } public class AgeValidator implements ConstraintValidator<ValidAge, Integer> { @Override public boolean isValid(Integer value, ConstraintValidatorContext context) { return value != null && value >= 18 && value <= 65; } }`,``,`html`,`Spring Boot电商`,`20240508101739-_项目例 表 20240809174836.webp &#715;create_time&#715; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', &#715;update_time&#715; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间' pom <properties> <java.version>1.8</java.version> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding> <spring-boot.version>2.3.12.RELEASE</spring-boot.version> </properties> <dependencyManagement> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>&#36;{spring-boot.version}</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <!-- boot web, 排除logback改用log4j2 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> <exclusions> <exclusion> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-logging</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-log4j2</artifactId> </dependency> <!-- aop 自动配置模块 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency> <!-- SpringBoot2.3.0以后版本没有引入javax.validation，需要手动引入 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-validation</artifactId> </dependency> <!-- boot test, 支持JUnit 5，但也兼容JUnit 4 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> <exclusions><!-- 排除junit-vintage-engine有助于确保所有测试都使用JUnit 5，避免混淆 --> <exclusion> <groupId>org.junit.vintage</groupId> <artifactId>junit-vintage-engine</artifactId><!-- junit-vintage-engine 是JUnit 5的一个组件，用于运行基于JUnit 4的测试 --> </exclusion> </exclusions> </dependency> <!-- mysql驱动, mybatis, pagehelper --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.3.2</version> </dependency> <dependency> <groupId>com.github.pagehelper</groupId> <artifactId>pagehelper-spring-boot-starter</artifactId> <version>1.2.13</version> </dependency> <!-- boot cache, redis --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <!-- swagger2 --> <dependency> <groupId>io.springfox</groupId> <artifactId>springfox-swagger2</artifactId> <version>2.9.2</version> </dependency> <dependency> <groupId>io.springfox</groupId> <artifactId>springfox-swagger-ui</artifactId> <version>2.9.2</version> </dependency> <!-- 二维码 --> <dependency> <groupId>com.google.zxing</groupId> <artifactId>javase</artifactId> <version>3.3.0</version> </dependency> </dependencies> <build> <plugins> <!-- boot的maven插件 --> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> <!-- mybatis代码生成插件 --> <plugin> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-maven-plugin</artifactId> <version>1.3.7</version> <configuration> <verbose>true</verbose> <overwrite>false</overwrite> </configuration> </plugin> </plugins> </build> 用户模块 统一返回对象 public class RestResponse<T> { private Integer status; private String msg; private T data; //getter,setter private static final int OK_CODE = 10000; private static final String OK_MSG = "SUCCESS"; //不同的私有构造 private RestResponse(Integer status, String msg, T data) { this.status = status; this.msg = msg; this.data = data; } private RestResponse(Integer status, String msg) { this.status = status; this.msg = msg; } private RestResponse() { this(OK_CODE, OK_MSG); } //成功不带data public static <T> RestResponse<T> success() { return new RestResponse<>(); } //成功并带有data public static <T> RestResponse<T> success(T result) { RestResponse<T> restResponse = new RestResponse<>(); restResponse.setData(result); return restResponse; } //失败时自定义消息 public static <T> RestResponse<T> error(Integer code, String msg) { return new RestResponse<>(code, msg); } //失败时填充异常枚举 public static <T> RestResponse<T> error(MallExceptionEnum exceptionEnum) { return new RestResponse<>(exceptionEnum.getCode(), exceptionEnum.getMsg()); } } public enum MallExceptionEnum { NOT_NULL(10001,"内容不能为空"); Integer code; String msg; //getter,setter MallExceptionEnum(Integer code, String msg) { this.code = code; this.msg = msg; } } public class MallException extends RuntimeException { private final Integer code; private final String msg; //getter public MallException(Integer code, String msg) { this.code = code; this.msg = msg; } public MallException(MallExceptionEnum exceptionEnum) { this(exceptionEnum.getCode(), exceptionEnum.getMsg()); } } 统一异常处理 @ResponseBodyAdvice 是一种允许在响应体返回之前对其进行修改的机制, 可以用于全局异常处理、全局数据绑定和全局数据预处理。 @ResponseBodyAdvice是 @ControllerAdvice 和 @ResponseBody 的组合，自动将结果转化为 JSON 格式响应。 定义一个方法，并用 @ExceptionHandler 注解标注它，以处理控制器中抛出的特定异常 @RestControllerAdvice public class GlobalExceptionHandler { private final Logger logger = LogManager.getLogger(GlobalExceptionHandler.class); @ExceptionHandler(Exception.class) public Object handleDefaultException(Exception e) { logger.error("Default Exception: ", e); return RestResponse.error(MallExceptionEnum.SYSTEM_ERROR); } @ExceptionHandler(MallException.class) public Object handleMallException(MallException e) { //记录异常的堆栈跟踪信息，并且同时输出异常的自定义消息 //"MallException: {}" 是日志消息模板。e.getMsg() 会替换 {}。e 会附加在日志消息的末尾，作为异常对象，日志框架会处理它，并记录堆栈跟踪信息。 logger.error("MallException: {}", e.getMsg(), e); return RestResponse.error(e.getCode(),e.getMsg()); } //处理参数检验注解 @Valid @Size @NotNull.. @ExceptionHandler(MethodArgumentNotValidException.class) public Object handleValidException(MethodArgumentNotValidException e) { BindingResult bindingResult = e.getBindingResult(); List<String> list = new ArrayList<>(); if (bindingResult.hasErrors()) { bindingResult.getAllErrors().forEach(o -> list.add(o.getDefaultMessage())); } if (list.isEmpty()) { return RestResponse.error(MallExceptionEnum.PARAM_VALID_ERROR); } logger.error("MethodArgumentNotValidException: {}", list.toString(), e); return RestResponse.error(MallExceptionEnum.PARAM_VALID_ERROR.getCode(), list.toString()); } } 商品分类模块 多个请求参数用一个实体承载, 防止构造出其它字段(如createTime)并通过*Selective执行非null修改 swagger接口文档 配置类 @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket group1() { return new Docket(DocumentationType.SWAGGER_2) .groupName("组1") .apiInfo(apiInfo1()) .host("localhost:9014") // 测试执行接口时使用的IP或域名 .select() //.apis(RequestHandlerSelectors.any()) .apis(RequestHandlerSelectors.basePackage("com.ida.boot_mall.controller")) //只扫描特定包 //.paths(PathSelectors.ant("/excluded/**").negate()) // 排除路径 .paths(PathSelectors.any()) .build() //忽略指定类 .ignoredParameterTypes(HttpSession.class, HttpServletRequest.class, HttpServletResponse.class); } @Bean public Docket group2() { return new Docket(DocumentationType.SWAGGER_2) .groupName("组2") .apiInfo(apiInfo2()) .host("http://xx.com") .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo1() { return new ApiInfoBuilder() //.. .title("API Documentation - 简化版") .build(); } private ApiInfo apiInfo2() { Contact contact = new Contact("阿虫", "http://xx.om", "email@example.com"); return new ApiInfoBuilder() .title("API Documentation - 完整版") .description("API documentation for my application") .version("1.0.0") .termsOfServiceUrl("https://example.com/terms") .contact(contact) .build(); } } 注解使用 控制器中 @ApiOperation("方法注释") @ApiIgnore 忽略, 可以作用在类,方法,参数上 模型中 @ApiModelProperty(hidden = true) 字段上,排除该属性 页面 http://localhost:9014/swagger-ui.html 统一校验管理员身份 原来的校验步骤 @RestController public class CategoryController { //.. @PostMapping("/admin/category/add") @ApiOperation("添加目录") public RestResponse addCategory(@Valid @RequestBody AddCategoryReq addCategoryReq) { userService.checkPermission(); categoryService.add(addCategoryReq); return RestResponse.success(); } } @Service("userService") public class UserServiceImpl implements UserService { //.. @Override public void checkPermission() { ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = requestAttributes.getRequest(); HttpSession session = request.getSession(); User user = (User) session.getAttribute(Constant.LOGIN_USER); if (user == null) { throw new MallException((MallExceptionEnum.NEED_LOGIN)); } if (!checkAdminRole(user)) { throw new MallException((MallExceptionEnum.NEED_ADMIN)); } } } 使用过滤器 vs 使用切面 过滤器适用于与框架无关的通用权限检查, 易于实现，并且能够在非常早期的阶段拦截请求 过滤器通常用于全局拦截，在请求最早阶段执行，无法直接访问控制器方法或其注解上的信息, 难以实现基于方法级别的精细化权限控制 @ControllerAdvice 发生在控制器逻辑之后, 因此在过滤器中无法利用通过@ControllerAdvice实现的异常处理逻辑 Spring Boot 默认不扫描和注册使用 @WebFilter 注解的过滤器。而是在配置类中通过 FilterRegistrationBean 注册 Filter 切面可以精确地应用到特定的方法上，适合进行方法级别的权限校验, 能够访问方法的元数据和返回值。 可以使权限逻辑与业务逻辑完全分离 实现切面相对复杂，尤其是对项目中所有权限校验点的统一管理和配置 切面可能会增加方法调用的开销，特别是在应用大量切面时 如果权限校验是全局性的，例如对所有 API 统一的认证或简单的角色检查，那么使用过滤器更为合适。它可以在请求链的早期就拦截无权限的请求，减少后续的处理开销。 如果权限校验需要基于具体的方法或注解，例如只有某些用户可以访问特定的 API，并且你希望把权限校验逻辑与业务逻辑完全解耦，切面则是更好的选择。 在 Spring Boot 项目中，你也可以结合使用这两者：过滤器进行全局的认证检查，而切面用于更精细化的权限控制。 过滤器类 @Component //组件标记 public class AdminFilter implements Filter { @Resource private UserService userService; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws ServletException, IOException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpSession session = request.getSession(); User user = (User) session.getAttribute(Constant.LOGIN_USER); if (user == null) { HttpServletResponse response = (HttpServletResponse) servletResponse; response.setContentType("application/json;charset=utf-8"); try(PrintWriter out = response.getWriter()){ out.write("{\n" + " \"data\": null,\n" + " \"msg\": \"NEED_LOGIN\",\n" + " \"status\": 10006\n" + "}"); out.flush(); } return; //中断 } if (!userService.checkAdminRole(user)) { HttpServletResponse response = (HttpServletResponse) servletResponse; response.setContentType("application/json;charset=utf-8"); try(PrintWriter out = response.getWriter()){ out.write("{\n" + " \"data\": null,\n" + " \"msg\": \"NEED_ADMIN\",\n" + " \"status\": 10008\n" + "}"); out.flush(); } return; //中断 } filterChain.doFilter(servletRequest, servletResponse); //放行 } } 配置类 @Configuration public class AdminFilterConfig { //当 Spring 解析 adminFilterRegistration 方法时，它会尝试在容器中找到一个 AdminFilter 类型的 Bean，并将这个 Bean 注入到方法参数 adminFilter 中。 //这是通过类型匹配来完成的，而不是通过名称 @Bean public FilterRegistrationBean<AdminFilter> adminFilterRegistration(AdminFilter adminFilter) { FilterRegistrationBean<AdminFilter> registrationBean = new FilterRegistrationBean<>(); registrationBean.setFilter(adminFilter); registrationBean.addUrlPatterns("/admin/category/*"); registrationBean.addUrlPatterns("/admin/product/*"); registrationBean.addUrlPatterns("/admin/order/*"); return registrationBean; } } VO, DTO DTO（Data Transfer Object）在不同层之间传输数据的对象 无业务逻辑: DTO 通常只包含数据字段和简单的 getter/setter 方法，不包含业务逻辑。 序列化: DTO 通常用于序列化和反序列化，尤其是在跨网络传输数据时（例如，通过 REST API 或 RPC 调用）。 设计目标: 简化数据传输，减少数据冗余，提高性能，适合在应用的不同层（如 Web 层和服务层）之间传输数据。 VO（Value Object）不变的业务实体的对象, 用于封装一组相关的值，作为业务逻辑的一部分 不变性: VO 对象通常是不可变的，一旦创建后，内部状态不应该被修改。 业务逻辑: VO 可以包含一些业务逻辑或计算方法，用于操作和处理其封装的值。 设计目标: 表示业务模型中的概念，提供丰富的语义和行为。 pagehelper PageHelper 是一个用于 MyBatis 的分页插件，提供了对 MyBatis 的分页支持 { "total": 19, "list": [ { "id": 9, "name": "冷饮冻食", "type": 1, "parentId": 0, "orderNum": 4, "createTime": "2019-12-20 13:45:28", "updateTime": "2019-12-28 16:25:22" }, { "id": 10, "name": "蔬菜蛋品", "type": 1, "parentId": 0, "orderNum": 5, "createTime": "2019-12-20 13:45:28", "updateTime": "2019-12-28 16:25:23" }, { "id": 27, "name": "美味菌菇", "type": 1, "parentId": 0, "orderNum": 7, "createTime": "2019-12-20 13:45:28", "updateTime": "2020-02-10 23:20:36" } ], "pageNum": 2, "pageSize": 3, "size": 3, "startRow": 4, "endRow": 6, "pages": 7, "prePage": 1, "nextPage": 3, "isFirstPage": false, "isLastPage": false, "hasPreviousPage": true, "hasNextPage": true, "navigatePages": 8, "navigatepageNums": [ 1, 2, 3, 4, 5, 6, 7 ], "navigateFirstPage": 1, "navigateLastPage": 7 } navigatePages 意味着分页导航将显示当前页码前后各 8 个页码（如果有那么多页码的话） 依赖 <dependency> <groupId>com.github.pagehelper</groupId> <artifactId>pagehelper-spring-boot-starter</artifactId> <version>1.2.13</version> </dependency> public PageInfo listForAdmin(Integer pageNum, Integer pageSize) { //PageHelper.startPage 是通过拦截器机制实现的，它会在接下来的查询方法执行时自动修改生成的 SQL 语句，添加适当的分页参数 //因此，必须在执行查询方法之前调用 PageHelper.startPage //如果一个方法中需要处理两个分页结果集，每个结果集都对应一个 PageInfo 对象，那么您可以分别调用 PageHelper.startPage 两次，每次设置不同的分页参数并执行相应的查询 PageHelper.startPage(pageNum,pageSize,"type,order_num"); List<Category> list = categoryMapper.selectList(); PageInfo pageInfo = new PageInfo(list); return pageInfo; } 递归构建分类的树形结构 @Override public List<CategoryVO> list() { List<CategoryVO> categoryVOList = new ArrayList<>(); recursiveCategory(categoryVOList, 0); //0是根分类的父id return categoryVOList; } private void recursiveCategory(List<CategoryVO> categoryVOList, Integer parentId) { List<Category> categories = categoryMapper.selectListByParentId(parentId); if (categories != null) { for (Category category : categories) { CategoryVO categoryVO = new CategoryVO(); BeanUtils.copyProperties(category, categoryVO); categoryVO.setChildCategory(new ArrayList<>()); //初始化子列表 //递归调用时传递当前category的子列表和当前category的id recursiveCategory(categoryVO.getChildCategory(), categoryVO.getId()); categoryVOList.add(categoryVO); } } } 利用redis缓存目录树 Spring 的缓存机制是基于代理的。被缓存的方法是通过 Spring 容器管理的 Bean 调用的，而不是直接在类内部调用 这意味着，当在同一个类中调用被 @Cacheable 注解修饰的方法时，缓存是不起作用的。这是因为 Spring 无法通过代理拦截内部方法调用 Jedis：用于直接与 Redis 进行低级别交互，适合需要完全控制 Redis 操作的场景。 RedisTemplate：Spring 提供的高级别模板类，简化 Redis 操作，适合频繁与 Redis 交互的 Spring 应用。 @EnableCaching：启用声明性缓存管理，适合需要缓存方法结果以提高性能的应用。 依赖 <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> redis连接信息 spring.redis.host=192.168.149.130 spring.redis.port=6380 spring.redis.password=12345 spring.redis.database=1 配置类 @Configuration @EnableCaching public class CacheConfig { @Bean public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) { /* RedisCacheWriter redisCacheWriter = RedisCacheWriter.lockingRedisCacheWriter(connectionFactory); RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig(); cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30)); RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,cacheConfiguration); return redisCacheManager; */ // 创建 RedisCacheWriter // 使用 nonLockingRedisCacheWriter 代替 lockingRedisCacheWriter 可以提高性能，减少在并发访问时可能的锁竞争。 // lockingRedisCacheWriter 适用于需要分布式锁的场景，但通常情况下，非锁定版本已经足够。 RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(connectionFactory); // 创建默认缓存配置 RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(30)) // 设置缓存过期时间 // 未设置键值序列化方式时,需要使VO类继承Serialize // 为了使缓存键和值的序列化方式更加明确和标准化，使用 StringRedisSerializer 作为键的序列化器，GenericJackson2JsonRedisSerializer 作为值的序列化器。 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())) // 设置 Key 的序列化方式 .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); // 设置 Value 的序列化方式 // 创建 RedisCacheManager return new RedisCacheManager(redisCacheWriter, cacheConfiguration); } } 使用 在配置类或启动类上加@EnableCaching注解(只出现一次就行了) 启用 Spring 框架的声明性缓存管理功能。它允许开发者使用缓存注解（如 @Cacheable、@CachePut 和 @CacheEvict）来管理方法的缓存逻辑 @Override @Cacheable(value = "listCategoryForCustomer") //注意不要误导了swagger的springfox包中同名注解 public List<CategoryVO> list() { List<CategoryVO> categoryVOList = new ArrayList<>(); recursiveCategory(categoryVOList, 0); //0是根分类的父id return categoryVOList; } 确认 在方法内部打断点, 方法返回值被缓存后, 下次不会进入方法内部 服务器验证 Spring Cache 默认使用的是 SimpleKey 类型的缓存键，这种键一般用于没有指定具体键值的缓存方法。实际的List缓存值通常是序列化的字符串 ./src/redis-cli -p 6380 -a 12345 --raw select 1 keys * get "listCategoryForCustomer::SimpleKey []" 进阶使用 @Cacheable 注解的方法。在这个方法中，如果缓存中存在相应的数据，它将直接从缓存中获取，而不是重新执行方法逻辑 @CachePut: 用于更新缓存中的数据，每次调用方法后，缓存中的对应条目都会被更新为方法的返回值。 @CacheEvict: 用于删除缓存中的数据，可以选择性删除单个条目或清空整个缓存 @Cacheable value / cacheNames 缓存的名称（或缓存空间）。这用于区分不同的缓存区域 key: 缓存键的 SpEL 表达式。默认使用方法参数的值作为键。如果不指定，则使用默认键生成器生成键。 condition: 这是一个 SpEL (Spring Expression Language) 表达式，用于决定是否执行缓存操作。如果 condition 表达式的结果为 true，缓存操作将会执行 unless: unless: 这是一个 SpEL 表达式，用于决定是否将结果存入缓存。如果 unless 表达式的结果为 true，缓存操作将会被跳过（即结果不会被缓存） result(方法执行后的返回值) 只能在 unless 属性中使用，用于决定是否将结果存入缓存 .. # 符号: 在 SpEL 表达式中，# 用于引用方法的参数、类属性、或者其他上下文变量。例如，#isbn 表示方法参数 isbn 的值。 无 # 符号: 如果不使用 #，SpEL 表达式将被视为一个字符串字面量。例如，key = "isbn" 将字面量字符串 "isbn" 作为缓存键，而不是实际的 isbn 参数值 @Cacheable( value = "books", key = "#isbn", condition = "#isbn.length() > 5", unless = "#result == null" ) public Book findBook(String isbn) { // 方法体 } 假设你已经有一个 updateBook 方法用 @CachePut 更新缓存，我们可以使用 @Cacheable 注解的 findBook 方法来获取缓存中的内容 @Cacheable 和 @CachePut 使用相同的 value 和 key，updateBook 方法会更新缓存中的相应条目，findBook 方法会从缓存中获取最新的数据。这确保了缓存的有效性和一致性。 @Service public class BookService { @Cacheable( value = "books", key = "#isbn" ) public Book findBook(String isbn) { // 如果缓存中没有这个书籍信息，这里的逻辑会被执行 // 例如从数据库中查询书籍信息 return bookRepository.findByIsbn(isbn); } @CachePut( value = "books", key = "#isbn" ) public Book updateBook(String isbn, Book book) { // 更新书籍信息到数据库 // 返回更新后的书籍对象 book.setName("Updated Name"); return book; } } 商品模块 /admin/product/add name, categoryId, price stock detail image body-json /admin/product/upload 上传图片 body form-data /admin/product/update id, name, categoryId, price stock detail image body-json /admin/product/delete id /admin/product/batchUpdateSellStatus ids sellStatus /admin/product/list pageNum pageSize /product/list orderBy categoryId keyword pageNum pageSize /product/detail id 文件上传和资源映射 上传目录地址 @Component public class Constant { public static final String SALT = "fsjir4jf&(*HIU$#jh34345"; public static final String LOGIN_USER = "login_user"; public static String FILE_UPLOAD_DIR; //静态成员通过setter注入 //属性文件中 file.upload.dir=D:\\mess @Value("&#36;{file.upload.dir}") //别忘了@Component标记 public void setFileUploadDir(String fileUploadDir) { FILE_UPLOAD_DIR = fileUploadDir; } } 上传图片返回url @Override public String upload(MultipartFile file, HttpServletRequest request){ String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(".")); String fileName = UUID.randomUUID() + suffix; //在生产环境中，通常将文件存储在应用的工作目录或专门的文件存储目录, 使用绝对路径或环境变量指定的目录，例如 /var/uploads/images/ File uploadDir = new File(Constant.FILE_UPLOAD_DIR); File destFile = new File(uploadDir + File.separator + fileName); if (!uploadDir.exists()) { if (!(uploadDir.mkdirs())) { throw new MallException(MallExceptionEnum.MKDIRS_FAILED); } } try { file.transferTo(destFile); } catch (IOException e) { e.printStackTrace(); } // getRequestURL() http://example.com:8080/app/context/path?query=param // getRequestURI() /app/context/path?query=param // baseUrl http://example.com:8080 String baseUrl = request.getRequestURL().toString().replace(request.getRequestURI(), ""); return baseUrl + "/images/" + fileName; } 资源地址映射配置类 // http://localhost:9014/images/1f569050-6e2f-417a-8c89-68ad422cdc25.jpg // D:\mess\ 1f569050-6e2f-417a-8c89-68ad422cdc25.jpg @Configuration public class MallWebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //资源地址映射 registry.addResourceHandler("/images/**").addResourceLocations("file:" + Constant.FILE_UPLOAD_DIR + File.separator); } } 批量上下架 参见mybatis批处理 // http://localhost:9014/admin/product/batchUpdateSellStatus?ids=2,3,14&status=1 // URL 查询字符串, Spring MVC 将 ids=2,3,14 解析为一个字符串，并自动将逗号分隔的部分转换为 Integer[] 数组 // 表单提交, ids=2&ids=3&ids=14 表示多个参数名相同，Spring MVC 会将所有这些参数值收集到一个数组中 @PostMapping("/product/batchUpdateSellStatus") public RestResponse batchUpdateSellStatus(Integer[] ids, Integer status) {//..} int batchUpdateStatusByIds(@Param("ids") Integer[] ids, @Param("status") Integer status); <!-- 在 MyBatis 中，如果没有显式地指定 parameterType 属性 如果方法只有一个参数，MyBatis 会使用该参数的类型作为 parameterType 如果方法有多个参数，MyBatis 会将所有参数封装到一个 Map 中 如果没有使用 @Param 注解，MyBatis 会将方法参数封装到一个 Map 中，参数名称默认为 param1, param2, 等 --> <update id="batchUpdateStatusByIds" parameterType="Map"> update mall.mall_product set status=#{status} where id in <foreach collection="ids" item="id" open="(" close=")" separator=","> #{id} </foreach> </update> 前台商品列表 model public class ProductListReq { private String keyword; private Integer categoryId; private String orderBy; private Integer pageNum=1; private Integer pageSize=10; //getter,setter } public class ProductListQuery { private String keyword; private List<Integer> categoryIds; //子分类id } 列表方法 @Override public PageInfo list(ProductListReq productListReq) { ProductListQuery productListQuery = new ProductListQuery(); //搜索处理 // str == null || "".equals(str); if (!StringUtils.isEmpty(productListReq.getKeyword())) { productListQuery.setKeyword("%" + productListReq.getKeyword() + "%"); } //分类处理 if (productListReq.getCategoryId() != null) { List<Integer> categoryIds = new ArrayList<>(); categoryIds.add(productListReq.getCategoryId()); categoryService.recursiveCategoryIds(categoryIds, productListReq.getCategoryId()); productListQuery.setCategoryIds(categoryIds); } //排序处理, 由后台定义前台选择,防止意外构造 if (productListReq.getOrderBy() !=null && Constant.OrderBy.PRICE_ASC_DESC.contains(productListReq.getOrderBy().toLowerCase())) { PageHelper.startPage( productListReq.getPageNum() == null ? 1 : productListReq.getPageNum(), productListReq.getPageSize() == null ? 10 : productListReq.getPageSize(), productListReq.getOrderBy()); } else { PageHelper.startPage( productListReq.getPageNum() == null ? 1 : productListReq.getPageNum(), productListReq.getPageSize() == null ? 10 : productListReq.getPageSize()); } List<Product> productList = productMapper.listForCustomer(productListQuery); PageInfo pageInfo = new PageInfo(productList); return pageInfo; } 递归子目录id @Override public void recursiveCategoryIds(List<Integer> categoryIds, Integer parentId) { List<Category> categories = categoryMapper.selectListByParentId(parentId); if (categories != null) { for (Category category : categories) { recursiveCategoryIds(categoryIds, category.getId()); categoryIds.add(category.getId()); } } } 后台预定义排序属性 @Component public class Constant { public static final String SALT = "fsjir4jf&(*HIU$#jh34345"; public static final String LOGIN_USER = "login_user"; public static String FILE_UPLOAD_DIR; @Value("&#36;{file.upload.dir}") public void setFileUploadDir(String fileUploadDir) { FILE_UPLOAD_DIR = fileUploadDir; } //接口中的变量会被隐式的指定为 public static final public interface OrderBy{ Set<String> PRICE_ASC_DESC = Stream.of("price desc", "price asc").collect(Collectors.toSet()); } } 动态SQL List<Product> listForCustomer(ProductListQuery productListQuery); <select id="listForCustomer" parameterType="com.ida.boot_mall.model.query.ProductListQuery" resultType="com.ida.boot_mall.model.pojo.Product"> select * from mall.mall_product <where> <if test="keyword != null"> and name like #{keyword} </if> <if test="categoryIds != null"> and category_id in <foreach collection="categoryIds" item="item" open="(" close=")" separator=","> #{item} </foreach> </if> and status = 1 </where> </select> 购物车模块 /cart/list /cart/add productId count post 添加商品到购物车, 是否在售是否有库存是否存在于购物车 /cart/update productId count post /cart/delete productId post /cart/select productId selected post /cart/selectAll selected 过滤器和拦截器 过滤器：更低层次的处理，适用于对所有请求和响应进行处理，不依赖于 Spring MVC。 过滤器是 Java Servlet API 的一部分，用于在请求到达 Servlet 或 JSP 之前，对请求进行处理，或在响应返回客户端之前对响应进行处理 适用于对所有请求和响应进行统一的处理，比如日志记录、输入验证、字符编码设置等。 拦截器：更高层次的处理，专注于 Spring MVC 的请求处理链，适用于与业务逻辑相关的处理 拦截器是 Spring Framework 的一部分，用于在处理请求之前和之后进行处理。通常用于 Spring MVC 的请求处理链中 适用于与业务逻辑相关的处理，比如权限验证、用户登录检查、日志记录等。 统一校验用户操作权限 过滤器类 @Component //需要组件标记, 配置类中此Filter会作为参数注入 public class UserFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws ServletException, IOException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpSession session = request.getSession(); User user = (User) session.getAttribute(Constant.LOGIN_USER); if (user == null) { HttpServletResponse response = (HttpServletResponse) servletResponse; response.setContentType("application/json;charset=utf-8"); try(PrintWriter out = response.getWriter()){ out.write("{\n" + " \"data\": null,\n" + " \"msg\": \"NEED_LOGIN\",\n" + " \"status\": 10006\n" + "}"); out.flush(); } return; } filterChain.doFilter(servletRequest, servletResponse); } } 过滤器配置类 @Configuration public class UserFilterConfig { @Bean public FilterRegistrationBean<UserFilter> userFilterRegistration(UserFilter userFilter) { FilterRegistrationBean<UserFilter> registrationBean = new FilterRegistrationBean<>(); registrationBean.setFilter(userFilter); registrationBean.addUrlPatterns("/cart/*"); registrationBean.addUrlPatterns("/order/*"); return registrationBean; } } 拦截器类 public class UserInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { HttpSession session = request.getSession(); User user = (User) session.getAttribute(Constant.LOGIN_USER); RequestContextHolder.getRequestAttributes().setAttribute("loginUser", user, RequestAttributes.SCOPE_REQUEST); return true; } } 拦截器配置类 @Configuration public class MallWebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //资源地址映射 registry.addResourceHandler("/images/**").addResourceLocations("file:" + Constant.FILE_UPLOAD_DIR + File.separator); } @Override public void addInterceptors(InterceptorRegistry registry) { //拦截器注册 registry.addInterceptor(new UserInterceptor()).addPathPatterns("/cart/**", "/order/**");// /**：匹配任意数量的路径层级, /*：匹配当前目录下的一个路径层级 } } 参数注入 @PostMapping("/add") public RestResponse add(Integer productId, Integer count, @RequestAttribute("loginUser") User user) { List<CartVO> cartVOList = cartService.add(productId, count, user.getId()); return RestResponse.success(cartVOList); } 购物车列表 model类 public class CartVO { private Integer id; private Integer productId; private Integer userId; private Integer quantity; private Integer selected; //快照, 防止加入购物车后的商品信息变动 private Integer price; private Integer totalPrice; private String productName; private String productImage; //getter,setter } 常量 @Component public class Constant { //.. public interface SaleStatus{ int NOT_SALE = 0; } } controller @PostMapping("/list") public RestResponse list(@RequestAttribute("loginUser") User user) { List<CartVO> cartVOList = cartService.list(user.getId()); //userId由后台提供,而不是来自前台 return RestResponse.success(cartVOList); } @PostMapping("/add") public RestResponse add(Integer productId, Integer count, @RequestAttribute("loginUser") User user) { List<CartVO> cartVOList = cartService.add(productId, count, user.getId()); return RestResponse.success(cartVOList); } service @Override public List<CartVO> list(Integer userId) { return cartMapper.selectList(userId); } @Override @Transactional //此处返回list因为每次添加商品后购物车列表要刷新 public List<CartVO> add(Integer productId, Integer count, Integer userId) { Product product = productMapper.selectByPrimaryKey(productId); //此处使用常量名表示状态方便后期维护修改时的精准搜索 if (product == null || product.getStatus() == Constant.SaleStatus.NOT_SALE) { throw new MallException(MallExceptionEnum.PRODUCT_NOT_SALE); } if (product.getStock() < count) { throw new MallException(MallExceptionEnum.STOCK_NOT_ENOUGH); } Cart cart = cartMapper.selectByUserIdAndProductId(userId, productId); if (cart == null) { cart = new Cart(); cart.setProductId(productId); cart.setUserId(userId); cart.setQuantity(count); int cnt = cartMapper.insertSelective(cart); if (cnt != 1) { throw new MallException(MallExceptionEnum.INSERT_FAILED); } } else { Cart newCart = new Cart(); newCart.setId(cart.getId()); newCart.setQuantity(cart.getQuantity() + count); int cnt = cartMapper.updateByPrimaryKeySelective(newCart); if (cnt != 1) { throw new MallException(MallExceptionEnum.UPDATE_FAILED); } } return list(userId); } sql List<CartVO> selectList(Integer userId); <resultMap id="rmCartVO" type="com.ida.boot_mall.model.vo.CartVO"> <id column="id" property="id"/> <result column="product_id" property="productId"/> <result column="user_id" property="userId"/> <result column="quantity" property="quantity"/> <result column="selected" property="selected"/> <result column="price" property="price"/> <result column="total_price" property="totalPrice"/> <result column="name" property="productName"/> <result column="image" property="productImage"/> </resultMap> <select id="_selectList" parameterType="Integer" resultMap="rmCartVO"> select c.id, c.product_id, c.user_id, c.quantity, c.selected, p.price, p.price*c.quantity total_price, p.name,p.image from mall.mall_cart c left join mall.mall_product p on c.product_id=p.id where c.user_id=#{value} and p.status =1 </select> <select id="selectList" parameterType="Integer" resultType="com.ida.boot_mall.model.vo.CartVO"> select c.id, c.product_id productId, c.user_id userId, c.quantity, c.selected , p.price, p.price*c.quantity totalPrice, p.name productName, p.image productImage from mall.mall_cart c left join mall.mall_product p on c.product_id=p.id where c.user_id=#{value} and p.status =1 </select> 订单模块 /order/create receiverName receiverMobile receiverAddr post 返回orderNo /order/detail get orderNo /order/list get pageNum pageSize /order/cancel post orderNo /order/qrcode post orderNo /pay get orderNo /admin/order/list get pageNum pageSize /admin/order/delivered post orderNo /order/finish post orderNo 20240809181345.webp 生成订单 @Override @Transactional //高并发访问时可以使用乐观锁,在中添加版本字段,在更新时检查版本号 public String create(CreateOrderReq createOrderReq, Integer userId) { //从购物车中查找已勾选商品,为空报错 List<CartVO> cartVOList = cartService.list(userId); List<CartVO> checkedCartVOList = cartVOList.stream() .filter(o -> o.getSelected().equals(Constant.Selected.CHECKED)) .collect(Collectors.toList()); if (checkedCartVOList.isEmpty()) { throw new MallException(MallExceptionEnum.CART_IS_EMPTY); } //在循环中进行数据库操作可能会导致性能问题。改在循环外集中批量处理 List<Product> products = productMapper.selectByIds( checkedCartVOList.stream() .map(CartVO::getProductId) .collect(Collectors.toList()) ); Map<Integer, Product> productMap = products.stream() .collect(Collectors.toMap(Product::getId, product -> product)); //循环外收集数据库操作目标 List<Integer> cartsToDelete = new ArrayList<>(); //购物车对象转order_item List<OrderItem> orderItemList = new ArrayList<>(); checkedCartVOList.forEach(o -> { //判断商品存在,上下架状态,库存 //Product product = productMapper.selectByPrimaryKey(o.getProductId()); Product rawProduct = productMap.get(o.getProductId()); if (rawProduct == null) { throw new MallException(MallExceptionEnum.PRODUCT_NOT_EXISTED); } else if (rawProduct.getStatus().equals(Constant.SaleStatus.NOT_SALE)) { throw new MallException(MallExceptionEnum.PRODUCT_NOT_SALE); } else if (rawProduct.getStock() < o.getQuantity()) { throw new MallException(MallExceptionEnum.STOCK_NOT_ENOUGH); } OrderItem orderItem = new OrderItem(); orderItem.setProductId(o.getProductId()); orderItem.setProductName(o.getProductName()); orderItem.setProductImg(o.getProductImage()); orderItem.setUnitPrice(o.getPrice()); orderItem.setQuantity(o.getQuantity()); orderItem.setTotalPrice(o.getTotalPrice()); orderItemList.add(orderItem); //扣库存 Product product = new Product(); product.setId(o.getProductId()); product.setStock(o.getQuantity()); //MyBatis 不支持批量 UPDATE 语句的原生支持，需要对每个 update 语句进行单独处理 if (productMapper.updateByPrimaryKeySelective(product) != 1) { throw new MallException(MallExceptionEnum.UPDATE_FAILED); } //删除购物车中对应商品 //cartService.delete(o.getProductId(),userId); cartsToDelete.add(o.getProductId()); }); //批量删除购物车商品 int deleteCnt = cartMapper.deleteByByUserIdAndProductIds(userId, cartsToDelete); if (deleteCnt != cartsToDelete.size()) { throw new MallException(MallExceptionEnum.DELETE_FAILED); } //生成订单 Order order = new Order(); String orderNo = OrderCodeFactory.getOrderCode(Long.valueOf(userId)); order.setOrderNo(orderNo); order.setUserId(userId); //int totalPrice = orderItemList.stream().mapToInt(o -> o.getTotalPrice()).reduce(0,(o1,o2) -> o1+o2); int totalPrice = orderItemList.stream().mapToInt(OrderItem::getTotalPrice).sum(); order.setTotalPrice(totalPrice); order.setReceiverName(createOrderReq.getReceiverName()); order.setReceiverMobile(createOrderReq.getReceiverMobile()); order.setReceiverAddress(createOrderReq.getReceiverAddress()); if (orderMapper.insertSelective(order) != 1) { throw new MallException(MallExceptionEnum.INSERT_FAILED); } //插入订单Item orderItemList.forEach(o -> o.setOrderNo(orderNo)); if (orderItemMapper.batchInsertSelective(orderItemList) != orderItemList.size()) { throw new MallException(MallExceptionEnum.INSERT_FAILED); } return orderNo; } <!-- List<Product> selectByIds(@Param("ids") List<Integer> ids); --> <select id="selectByIds" parameterType="List" resultType="com.ida.boot_mall.model.pojo.Product"> select * from mall.mall_product where id in <foreach collection="ids" item="id" open="(" close=")" separator=","> #{id} </foreach> </select> <!-- int deleteByByUserIdAndProductIds(@Param("userId") Integer userId, @Param("ids") List<Integer> ids); --> <delete id="deleteByByUserIdAndProductIds" parameterType="Map"> delete from mall.mall_cart where user_id = #{userId} and product_id in <foreach collection="ids" item="item" open="(" close=")" separator=","> #{item} </foreach> </delete> <!-- int batchInsertSelective(@Param("orderItems") List<OrderItem> orderItems); --> <!-- trim,去除多余的逗号来保持SQL语法正确 --> <insert id="batchInsertSelective" parameterType="List"> insert into mall_order_item <trim prefix="(" suffix=")" suffixOverrides=","> <if test="orderItems[0].id != null"> id, </if> <if test="orderItems[0].orderNo != null"> order_no, </if> <if test="orderItems[0].productId != null"> product_id, </if> <if test="orderItems[0].productName != null"> product_name, </if> <if test="orderItems[0].productImg != null"> product_img, </if> <if test="orderItems[0].unitPrice != null"> unit_price, </if> <if test="orderItems[0].quantity != null"> quantity, </if> <if test="orderItems[0].totalPrice != null"> total_price, </if> <if test="orderItems[0].createTime != null"> create_time, </if> <if test="orderItems[0].updateTime != null"> update_time, </if> </trim> <foreach collection="orderItems" item="orderItem" separator="," open="values"> <trim prefix="(" suffix=")" suffixOverrides=","> <if test="orderItem.id != null"> #{orderItem.id,jdbcType=INTEGER}, </if> <if test="orderItem.orderNo != null"> #{orderItem.orderNo,jdbcType=VARCHAR}, </if> <if test="orderItem.productId != null"> #{orderItem.productId,jdbcType=INTEGER}, </if> <if test="orderItem.productName != null"> #{orderItem.productName,jdbcType=VARCHAR}, </if> <if test="orderItem.productImg != null"> #{orderItem.productImg,jdbcType=VARCHAR}, </if> <if test="orderItem.unitPrice != null"> #{orderItem.unitPrice,jdbcType=INTEGER}, </if> <if test="orderItem.quantity != null"> #{orderItem.quantity,jdbcType=INTEGER}, </if> <if test="orderItem.totalPrice != null"> #{orderItem.totalPrice,jdbcType=INTEGER}, </if> <if test="orderItem.createTime != null"> #{orderItem.createTime,jdbcType=TIMESTAMP}, </if> <if test="orderItem.updateTime != null"> #{orderItem.updateTime,jdbcType=TIMESTAMP}, </if> </trim> </foreach> </insert> 订单详情 20240810123125.webp @Override public OrderVO detail(String orderNo, Integer userId) { OrderVO orderVO = orderMapper.selectByOrderNoAndUserId(orderNo,userId); if (orderVO == null) { throw new MallException(MallExceptionEnum.ORDER_NOT_EXISTED); } orderVO.setOrderStatusName(Constant.OrderStatus.codeOf(orderVO.getOrderStatus()).getValue()); return orderVO; } @Component public class Constant { //.. public enum OrderStatus{ CANCELED(0,"用户已取消付款"), NOT_PAID(10,"未付款"), PAID(20,"已付款"), DELIVERED(30,"已发货"), FINISHED(40,"交易完成") ; private int code; private String value; //getter,setter OrderStatus(int code, String value) { this.code = code; this.value = value; } public static OrderStatus codeOf(int code) { for (OrderStatus orderStatus : values()) { if (orderStatus.getCode() == code) { return orderStatus; } } throw new MallException(MallExceptionEnum.NO_ENUM); } } } <select id="selectByOrderNo" parameterType="String" resultType="com.ida.boot_mall.model.vo.OrderItemVO"> select order_no,product_name,product_img,unit_price,quantity,total_price from mall.mall_order_item where order_no=#{orderNo} </select> <resultMap id="rmOrderVO" type="com.ida.boot_mall.model.vo.OrderVO"> <result column="order_no" property="orderNo"/> <result column="user_id" property="userId"/> <result column="total_price" property="totalPrice"/> <result column="receiver_name" property="receiverName"/> <result column="receiver_mobile" property="receiverMobile"/> <result column="receiver_address" property="receiverAddress"/> <result column="order_status" property="orderStatus"/> <result column="postage" property="postage"/> <result column="payment_type" property="paymentType"/> <result column="delivery_time" property="deliveryTime"/> <result column="pay_time" property="payTime"/> <result column="end_time" property="endTime"/> <result column="create_time" property="createTime"/> <collection select="com.ida.boot_mall.model.dao.OrderItemMapper.selectByOrderNo" column="order_no" property="orderItemList"/> </resultMap> <select id="selectByOrderNoAndUserId" parameterType="Map" resultMap="rmOrderVO"> select * from mall.mall_order where order_no=#{orderNo} and user_id=#{userId} </select> 订单列表 @Override public PageInfo list(Integer pageNum, Integer pageSize, Integer userId) { PageHelper.startPage(pageNum == null ? 1 : pageNum, pageSize == null ? 10 : pageSize, "create_time desc"); List<OrderVO> orderVOList = orderMapper.selectByUserId(userId); orderVOList.forEach(o -> o.setOrderStatusName(Constant.OrderStatus.codeOf(o.getOrderStatus()).getValue())); PageInfo pageInfo = new PageInfo<>(orderVOList); return pageInfo; } <select id="selectByUserId" parameterType="Map" resultMap="rmOrderVO"> select * from mall.mall_order where user_id=#{userId} </select> 取消订单 @Override @Transactional public void cancel(String orderNo, Integer userId) { Order order = orderMapper.selectByOrderNo(orderNo); if (order == null || !Objects.equals(order.getUserId(), userId)) { throw new MallException(MallExceptionEnum.ORDER_NOT_EXISTED); } //只有未付款时可以取消 if (!order.getOrderStatus().equals(Constant.OrderStatus.NOT_PAID.getCode())) { throw new MallException(MallExceptionEnum.WRONG_ODERE_STAUTS); } //更新订单状态 order.setOrderStatus(Constant.OrderStatus.CANCELED.getCode()); order.setEndTime(new Date()); if (orderMapper.updateByPrimaryKeySelective(order) != 1) { throw new MallException(MallExceptionEnum.UPDATE_FAILED); } //库存返还 List<OrderItem> orderItemList = orderItemMapper.selectStockInfo(orderNo); List<Product> products = productMapper.selectByIds( orderItemList.stream() .map(OrderItem::getProductId) .collect(Collectors.toList()) ); Map<Integer, Product> productMap = products.stream() .collect(Collectors.toMap(Product::getId, p -> p)); Product product = new Product(); orderItemList.forEach(o -> { product.setId(o.getProductId()); product.setStock(productMap.get(o.getProductId()).getStock()+o.getQuantity()); if (productMapper.updateByPrimaryKeySelective(product) != 1) { throw new MallException(MallExceptionEnum.UPDATE_FAILED); } }); } 二维码 依赖 <dependency> <groupId>com.google.zxing</groupId> <artifactId>javase</artifactId> <version>3.3.0</version> </dependency> 工具类 public class QRCodeGenerator { public static void genQRCodeImage(String text, int width, int height, String filePath, String... etc) throws Exception { Path path = FileSystems.getDefault().getPath(filePath, etc); QRCodeWriter qrCodeWriter = new QRCodeWriter(); text = new String(text.getBytes("UTF-8"), "ISO-8859-1"); //字符串转ISO-8859-1编码 BitMatrix bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, width, height); MatrixToImageWriter.writeToPath(bitMatrix, "PNG", path); } public static String readQRCodeImage(String filePath) throws Exception { BufferedImage bufferedImage = ImageIO.read(new File(filePath)); QRCodeReader qrCodeReader = new QRCodeReader(); LuminanceSource source = new BufferedImageLuminanceSource(bufferedImage); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); Result result = qrCodeReader.decode(bitmap); return result.getText(); } public static void main(String[] args) throws Exception { genQRCodeImage("你好abc啊", 200, 200, "d:","mess","地1a.png"); System.out.println(readQRCodeImage("D:\\mess\\地1a.png")); } } service @Override public String qrcode(String orderNo, Integer userId, HttpServletRequest request) { Order order = orderMapper.selectByOrderNo(orderNo); String baseUrl = request.getRequestURL().toString().replace(request.getRequestURI(), ""); //判断存在,归属和订单状态 if (order == null || !Objects.equals(order.getUserId(), userId) || !order.getOrderStatus().equals(Constant.OrderStatus.NOT_PAID.getCode())) { throw new MallException(MallExceptionEnum.ORDER_NOT_EXISTED); } //二维码文本 String text = baseUrl + "/pay?orderNo=" + orderNo; try { QRCodeGenerator.genQRCodeImage(text, 300, 300, Constant.FILE_UPLOAD_DIR, orderNo + ".png"); } catch (Exception e) { throw new MallException(MallExceptionEnum.QRCODE_GEN_ERROR); } //图片url return baseUrl + "/images/" + orderNo + ".png"; } 上线前 将model中的request类加上toString方但切面日志看出具体值 规范请求方式,只要对后台表数据有影响的全部post 图片基础url抽出到配置文件 //base-url=http://localhost:9014 @Value("&#36;{app.base-url}") private String baseUrl; //String baseUrl = request.getRequestURL().toString().replace(request.getRequestURI(), ""); String baseUrl = this.baseUrl; 文件上传路径,日志文件输出地址调整 webmvcconfig静态文件地址路由 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //资源地址映射 registry.addResourceHandler("/images/**").addResourceLocations("file:" + Constant.FILE_UPLOAD_DIR + File.separator); registry.addResourceHandler("/admin/**").addResourceLocations("classpath:/static/admin/"); } 多环境配置文件`,``,`html`,`Spring Cloud`,`20240814232713-_微服务 从单体架构到微服务架构 20240604145527.webp 开发单个应用作为一系列小型服务的套件, 其中每个服务都运行在自己的进程中,并且通过轻量级的机制实现彼此间的通信, 这通常是HTTP资源的API 这些服务是围绕着业务功能构建的, 并且可以通过完全自动化的部署机制进行独立部署 这些服务的集中式管理做到了最小化(例如docker相关技术), 每一种服务都可以通过不同的编程语言进行编写,并且可以使用不同的数据存储技术 微服务特点 组件以服务形式来提供, 网络延迟比单体高 产品不是项目, 单体服务容易外包而微服务难以外包 轻量级通信,独立进程, 如使用消息队列 分散治理, 去中心化治理 容错性设计 会带来组织架构的调整 20240604153101.webp 服务简单,便于学习和上手,相对易于维护 独立部署,灵活扩展 技术栈丰富 运维成本过高 接口可能不匹配 代码可能重复 架构复杂度提高 微服务两大门派 Spring Cloud 众多子项目 spring cloud文档更多的是偏向整合 类似品牌一体机,保证了一整套的兼容可靠 Dubbo 高性能,轻量级的开源java RPC框架, 它提供了三大核心能力: 面向接口的远程方法调用, 智能容错和负载均衡, 以及服务自动注册和发现 其它功能需要扩展组合, 类似组装电脑 RPC（Remote Procedure Call 远程过程调用）框架是一种用于在不同网络节点之间调用服务的方法，使得程序能够像调用本地方法一样调用远程服务 通信协议对比 RPC vs REST RPC通信效率更高(二进制传输), 但服务提供方与调用方接口依赖方式太强 dubbo提供的能力是Spring Cloud的一部分子集 dubbo是阿里的, 文档提供了中英两种版本 20240604154425.webp HTTP和RPC IPC主要用于同一台机器上的进程间通信，而RPC则扩展到了网络上不同机器之间的通信 通信模式： HTTP是一种无状态协议，每次请求都是独立的，服务器不会保存客户端的状态信息。 RPC通常是一种有状态的通信模式，客户端和服务器之间建立了长连接，可以保持一段时间的状态信息，直到连接断开。 通信方式： HTTP(Hypertext Transfer Protocol)是基于文本的协议，通过请求-响应模式进行通信，可以使用浏览器等工具进行调试和查看。 其中序列化和反序列化导致的耗时是最主要的性能消耗 负载均衡需要依赖第三方如nginx RPC通常是基于二进制的协议，通信效率更高，但不易直观地查看和调试。 自带负载均衡功能 使用场景： HTTP通常用于Web应用程序之间的通信，例如浏览器与服务器之间的通信。 RPC通常用于分布式系统中，不同服务之间的通信，例如微服务架构中的服务间调用。 常见的rpc框架, gRPC, Apache Thrift, Apache Dubbo 不适合拆分的情况 项目的第一阶段的主要目标是快速开发和验证想法 然后进一步增加更多的新特性来吸引更多的目标用户 同时进行开发的人员超过10人,就该考虑进行服务化拆分了 流量不高,压力小,业务变化不大, 如企业内部oa 对延迟很敏感的低延迟高并发系统 小团队,技术基础薄弱 服务扩展 水平复制,功能解耦,数据分区(为有价值的vip用户提供更快的响应) 自动按需扩展, 根据cpu负载程度,特定时间例如周末,消息中间件的队列长度, 业务具体规则,预测等来决定是否扩展 自动分配一个新的服务器实例,提高可用性 微服务的重要模块 服务描述,注册中心 服务框架 负载均衡 熔断和降级 网关 Spring Cloud核心组件 20240604161057.webp 服务的注册与发现 Eureka 服务发现框架主要用于解决服务之间的动态 IP 地址变化和自动发现。在云计算环境中，特别是在容器化和微服务架构中，服务的 IP 地址可能会频繁变化，例如容器重启、弹性伸缩等情况。这就导致了传统的硬编码 IP 地址的方式不再适用，因此需要一种机制来实现服务之间的动态发现和通信。 Eureka 提供了一个中心化的服务注册表，服务端在启动时会向 Eureka 注册自己的信息，包括 IP 地址、端口号等。客户端则可以向 Eureka 查询服务的地址，而不是直接访问服务端的 IP 地址。这样一来，即使服务的 IP 地址发生变化，客户端仍然可以通过向 Eureka 查询来获取最新的服务地址，从而保证了服务之间的通信不受 IP 地址变化的影响。 Neffix开发的Eureka (尤瑞卡) 20240604222207.webp 集群, 非单点结构的Eureka server 20240604222513.webp 服务端 注册服务：服务端将自己的服务注册到 Eureka 服务器上。这意味着服务端告诉 Eureka：“我在这里，我可以提供这个服务。” 健康检查：服务端定期向 Eureka 发送健康检查请求，以确保自己仍然处于可用状态。如果服务端不再可用，它将从 Eureka 服务器中注销自己。 提供服务信息：服务端向 Eureka 提供自己的元数据，例如主机名、端口号和其他与服务相关的信息。 客户端： 获取服务：客户端向 Eureka 服务器发送请求，询问特定服务的位置。Eureka 服务器将返回一个或多个可用的服务端地址。 负载均衡：客户端可以使用获得的多个服务端地址之一来调用服务。通常会使用负载均衡算法来选择其中一个服务端，以确保请求分布在不同的服务端之间。 动态更新：客户端定期从 Eureka 服务器获取服务端列表的更新。这意味着如果有新的服务注册或现有服务注销，客户端将及时获取到这些变化。 Eureka 服务器： 服务注册表：Eureka 服务器维护一个服务注册表，其中包含所有已注册的服务的信息。这个注册表是服务发现的核心。 健康监测：Eureka 服务器负责监测服务的健康状态。如果服务长时间不响应或不可用，Eureka 将从注册表中移除该服务。 提供服务信息：Eureka 服务器提供给客户端的是服务端的元数据，例如主机名、端口号等。 Feign和RestTemplate Feign 是一个声明式的 HTTP 客户端，它通过接口和注解将方法调用映射到 HTTP 请求，从而简化了与其他微服务的通信, 不需要编写大量的模板代码 没有Feign的情况下，通常使用 RestTemplate 或其他HTTP客户端库来实现微服务之间的通信 Feign 的降级类用于在 Feign 客户端调用远程服务时出现故障时提供备用逻辑。主要用于处理 Feign 客户端的调用失败（例如，超时、服务不可用等）时的降级策略 20240815160709.webp Feign的作用体现在第三步 负载均衡的两种类型 客户端负载均衡 服务之间互相调用 客户端从服务发现系统（如 Eureka、Consul）获取服务实例列表，Ribbon根据负载均衡策略选择一个实例来处理请求 不经过Nginx以免加长链路 服务端负载均衡 用户调用 客户端将请求发送到Nginx，Nginx根据负载均衡策略将请求转发到一个合适的服务实例 负载均衡策略 RandomRule 随机 RoundRobinRule 轮询 ResponseTimeWeightedRule 加权, 根据每一个Server的平均响应时间动态加权 网关 网关可以将api请求路由到正确的位置, 还可以起到统一鉴权和其他一些重要作用 zuul需要将自己作为一个client在eureka上注册, 由此也获得了其它模块的服务信息, 其它模块只需记住网关的端口, 由网关根据服务名找到对应端口 通过zuul进行用户检验, 凡是通过检验的, 就可以直接访问后面的模块, 从而省去了各模块的冗余校验逻辑 20240606191306.webp 利用网关实现过滤器 前置过滤器（Pre Filter）：在请求被转发到后端服务之前执行。 路由过滤器（Route Filter）：在请求路由到具体服务之前执行（大多数情况下由 Zuul 默认实现，通常不需要自定义）。 后置过滤器（Post Filter）：在请求从后端服务返回响应之后执行。 错误过滤器（Error Filter）：当发生错误时执行（例如，服务不可用时）error 过滤器是在其他所有类型的过滤器（pre、route、post）之后执行的 用来处理在路由、转发、过滤等过程中遇到的错误 ZuulFilter 接口方法： filterType(): 返回过滤器的类型（前置、路由、后置或错误）。 filterOrder(): 同一类型的过滤器中，filterOrder 的数值决定了它们的执行顺序, 数值越小，优先级越高 shouldFilter(): 返回一个布尔值，指示是否应该执行这个过滤器。 run(): 过滤器的具体逻辑`,``,`html`,`Spring Cloud电商`,`20240814232713-_项目例 common模块的拆分 常量,异常,工具类,可复用类,它的主要功能不是对外提供接口而是类的复用,不需要启动类 Session共享处理 共享对象需要标记serializable 使用启动类加@EnableRedisHttpSession注解时将采用以下默认属性 maxInactiveIntervalInSeconds = 1800 秒 redisNamespace = "spring:session" flushMode = FlushMode.ON_SAVE ON_SAVE：在会话保存时，将会话数据写入 Redis（这是默认值）。这种模式适合在性能和数据一致性之间寻找平衡。如果会话中的数据不经常发生变化，或者你不介意在用户会话过程中数据在Redis中的状态稍有滞后 IMMEDIATE：在会话属性变更时，立即将变更写入 Redis。这种模式适合对数据一致性要求较高的场景 cleanupCron = ""（使用 Redis 的 TTL 机制） spring.session.redis.cleanup-cron=0 * * * * * # 每分钟执行一次清理 使用配置文件时 未显式设置 spring.session.store-type，如果你引入了spring-session-data-redis依赖，并且配置了Redis相关的属性（如spring.redis.host），Spring Boot会自动将会话存储方式设置为Redis 虽然Spring Boot能够自动选择适合的存储类型，但显式设置可以让配置更加明确, 避免版本差异导致的意外情况 未设置 spring.session.timeout 时，默认会话超时时间为 1800 秒 未设置 spring.session.redis.namespace 时，默认命名空间为 spring:session。 未设置 spring.session.redis.flush-mode 时，默认刷新模式为 on-save 模块直接从 Redis 中获取 session 与通过 Feign 调用时使用 RequestInterceptor 从网关传递 session，这两种方法各有优缺点 前者适合小型系统或性能敏感的系统 减少了通过网关进行额外的 HTTP 请求，降低了网络延迟, 避免了复杂的 session 传递逻辑 需要依赖Redis并配置连接信息且所有模块访问的 Redis 实例一致 如果没有正确地管理和隔离 Redis 数据库，不同模块可能会意外地访问到其他模块的数据 后者适合大型系统或需要统一管理和安全控制的系统 通过网关传递 session，可以将会话管理和验证集中化到一个位置，便于统一的安全策略和日志管理 网关可以动态调整传递的 session 信息或对请求进行预处理 模块之间不需要知道会话存储的细节，通过网关统一接口来实现模块间的解耦 增加了额外的网络开销和处理时间 模块需要额外配置 RequestInterceptor 来处理 session 的传递逻辑 RequestInterceptor是feign包下的类 @Component public class FeignRequestInterceptor implements RequestInterceptor { @Override public void apply(RequestTemplate requestTemplate) { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); if (requestAttributes == null) { return; } HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest(); Enumeration<String> headerNames = request.getHeaderNames(); if ((headerNames != null)) { while (headerNames.hasMoreElements()) { String name = headerNames.nextElement(); Enumeration<String> values = request.getHeaders(name); while (values.hasMoreElements()) { String value = values.nextElement(); requestTemplate.header(name, value); //使 Feign 携带所有请求头信息, 转发到被调用的模块 } } } } } 网关模块 线上环境时仅暴露网关 结构 demo19 cart-order category-product common mall-eureka-server user zuul pom properties 说明 demo19 <groupId>com.ida</groupId> <artifactId>demo19</artifactId> <version>1.0-SNAPSHOT</version> <packaging>pom</packaging> <modules> <module>mall-eureka-server</module> <module>user</module> <module>common</module> <module>zuul</module> <module>category-product</module> <module>cart-order</module> </modules> <dependencyManagement> <dependencies> <!-- boot版本管理 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-dependencies</artifactId> <version>&#36;{spring-cloud.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!-- cloud版本管理 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>&#36;{spring-boot.version}</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <!-- 版本定义 --> <spring-cloud.version>Hoxton.SR12</spring-cloud.version> <spring-boot.version>2.3.12.RELEASE</spring-boot.version> </properties> cart-order <!-- 父模块 --> demo19 <artifactId>cart-order</artifactId> <dependencies> <!-- web依赖 --> spring-boot-starter-web <!-- 数据库驱动,mybatis,mybatis分页 --> mysql-connector-java mybatis-spring-boot-starter 2.1.1 pagehelper-spring-boot-starter 1.2.13 <!-- 接口文档 --> springfox-swagger2 2.9.2 springfox-swagger-ui 2.9.2 <!-- eureka客户端 --> spring-cloud-starter-netflix-eureka-client <!-- feign远程调用 --> spring-cloud-starter-openfeign <!-- redis读写session --> spring-boot-starter-data-redis spring-session-data-redis <!-- 模块引用 --> common </dependencies> <build> <plugins> <!-- boot的maven插件 --> spring-boot-maven-plugin </plugins> </build> # 模块信息 server.port=9319 spring.application.name=cart-order # mysql连接信息 # mybatis字段转换,xml文件扫描 # eureka注册地址 eureka.client.service-url.defaultZone=http://localhost:9019/eureka/ # session存储方式 spring.session.store-type=redis # session命名空间 spring.session.redis.namespace=user # redis连接信息 # 模块内常量 app.base-url=http://localhost:&#36;{server.port} file.upload.dir=D:\\mess zuul.base-url=http://localhost:9919 WebLogAspect 统一请求响应日志 ProductClient 调用category-product模块接口 UserClient 调用user模块接口 OrderConstant JacksonConfig 时区及日期格式 MallWebMvcConfig 资源地址映射, 拦截器注册 SwaggerConfig GlobalExceptionHandler 统一控制器异常包装 UserInterceptor / FeignRequestInterceptor 向请求注入session中的user对象 OrderCodeFactory category-product <!-- 父模块 --> demo19 <artifactId>category-product</artifactId> <dependencies> <!-- web依赖 --> spring-boot-starter-web <!-- 数据库驱动,mybatis,mybatis分页 --> mysql-connector-java mybatis-spring-boot-starter 2.1.1 pagehelper-spring-boot-starter 1.2.13 <!-- 接口文档 --> springfox-swagger2 2.9.2 springfox-swagger-ui 2.9.2 <!-- eureka客户端 --> spring-cloud-starter-netflix-eureka-client <!-- redis缓存 --> spring-boot-starter-data-redis spring-boot-starter-cache <!-- 模块引用 --> common </dependencies> <build> <plugins> <!-- boot的maven插件 --> spring-boot-maven-plugin </plugins> </build> # 模块信息 server.port=9219 spring.application.name=category-product # mysql连接信息 # mybatis字段转换,xml文件扫描 # eureka注册地址 # redis连接信息 # 模块内常量 WebLogAspect 统一请求响应日志 ProductConstant CacheConfig 配置redis缓存过期时间,序列化方式 JacksonConfig 时区及日期格式 MallWebMvcConfig 资源地址映射, 拦截器注册 SwaggerConfig GlobalExceptionHandler 统一控制器异常包装 common <!-- 父模块 --> demo19 <artifactId>common</artifactId> <dependencies> <!-- web依赖 --> spring-boot-starter-web <!-- 二维码生成 --> <dependency> <groupId>com.google.zxing</groupId> <artifactId>javase</artifactId> <version>3.3.0</version> </dependency> </dependencies> <build> <plugins> <!-- boot的maven插件 --> spring-boot-maven-plugin </plugins> </build> Constant RestResponse 统一响应对象包装 MallException MallExceptionEnum 异常枚举 product User 复用pojo MD5Utils QRCodeGenerator mall-eureka-server <!-- 父模块 --> demo19 <artifactId>mall-eureka-server</artifactId> <dependencies> <!-- eureka服务端 --> spring-cloud-starter-netflix-eureka-server </dependencies> <build> <plugins> <!-- boot的maven插件 --> spring-boot-maven-plugin </plugins> </build> # 模块信息 server.port=9019 spring.application.name=eureka-server # eureka实例名,注册表拉取,自身注册,注册地址 eureka.instance.hostname=localhost eureka.client.fetch-registry=false eureka.client.register-with-eureka=false eureka.client.service-url.defaultZone=http://&#36;{eureka.instance.hostname}:&#36;{server.port}/eureka/ user <!-- 父模块 --> demo19 <artifactId>user</artifactId> <dependencies> <!-- web依赖 --> spring-boot-starter-web <!-- 数据库驱动,mybatis --> mysql-connector-java mybatis-spring-boot-starter 2.1.1 <!-- 接口文档 --> springfox-swagger2 2.9.2 springfox-swagger-ui 2.9.2 <!-- eureka客户端 --> spring-cloud-starter-netflix-eureka-client <!-- feign远程调用 --> spring-cloud-starter-openfeign <!-- redis读写session --> spring-boot-starter-data-redis spring-session-data-redis <!-- 模块引用 --> common </dependencies> <build> <plugins> <!-- boot的maven插件 --> spring-boot-maven-plugin </plugins> </build> # 模块信息 server.port=9119 spring.application.name=user # mysql连接信息 # mybatis字段转换,xml文件扫描 # eureka注册地址 eureka.client.service-url.defaultZone=http://localhost:9019/eureka/ # session存储方式 spring.session.store-type=redis # session命名空间 spring.session.redis.namespace=user # redis连接信息 # 模块内常量 WebLogAspect 统一请求响应日志 JacksonConfig 时区及日期格式 SwaggerConfig GlobalExceptionHandler 统一控制器异常包装 zuul 像 Zuul、Spring Cloud Gateway 这样的网关服务通常不需要直接引入 spring-boot-starter-web，因为它们自己的依赖已经包含了所需的 Web 功能 这意味着当你引入 spring-cloud-starter-netflix-zuul 时，Spring Boot 会自动包含 Web 相关的基础依赖，如 Spring MVC 和嵌入式的 Tomcat 服务器 <!-- 父模块 --> demo19 <artifactId>user</artifactId> <dependencies> <!-- zuul --> spring-cloud-starter-netflix-zuul <!-- eureka客户端 --> spring-cloud-starter-netflix-eureka-client <!-- feign远程调用 --> spring-cloud-starter-openfeign <!-- redis读写session --> spring-boot-starter-data-redis spring-session-data-redis <!-- 模块引用 --> common </dependencies> <build> <plugins> <!-- boot的maven插件 --> spring-boot-maven-plugin </plugins> </build> # 模块信息 server.port=9919 spring.application.name=zuul # eureka注册地址 eureka.client.service-url.defaultZone=http://localhost:9019/eureka/ # session存储方式 spring.session.store-type=redis # session命名空间 spring.session.redis.namespace=user # redis连接信息 # 默认情况下，Zuul 会过滤掉一些敏感的头信息, 设置为空值禁用过滤 zuul.sensitive-headers= # 连接到下游服务时的超时时间(毫秒) zuul.host.connect-timeout-millis=15000 # 自定义路径映射 zuul.routes.category-product.path=/cp/** zuul.category-product.server-id=category-product zuul.routes.cart-order.path=/co/** zuul.cart-order.server-id=cart-order UserClient 调用user模块接口 JacksonConfig 时区及日期格式 UserFilter 网关过滤器 AdminFilter 项目的调试 统一请求响应日志中参数对象重写toString方便查看属性 调整日志级别 logging.level.om.yourpackage.ProductClient: DEBUG logging.level.feign=DEBUG logging.level.org.springframework.http.converter.json=DEBUG logging.level.org.mybatis=DEBUG logging.level.org.apache.ibatis.logging=DEBUG 在构造器中写信息检查类有没有没触发加载 redis共享session时一定要确认是否使用的是同一个命名空间 spring.session.redis.namespace=user 网关在发现新注册的服务实例或移除失效服务实例时，存在一定的延迟。这种延迟可能导致请求路由到已经不可用的服务，或者新上线的服务实例不能立即被访问 对于 Eureka，可以配置 eureka.client.fetchRegistryIntervalSeconds 参数来减小服务实例信息的拉取间隔 Spring Boot DevTools <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> </dependency> DevTools 主要设计用于开发环境，生产环境中移除 DevTools 依赖 当类路径下的文件发生更改时，Spring Boot DevTools 会自动重启应用程序。 这种重启比完全的 JVM 重启要快得多，因为它只重新加载更改的类 禁用自动重启功能，可以在 application.properties 中设置 spring.devtools.restart.enabled=false spring.devtools.restart.exclude=static/**,public/** # 排除特定的类或包 与 IDE（如 IntelliJ IDEA 或 Eclipse）集成后，Spring Boot DevTools 支持实时加载资源（如 Thymeleaf 模板和 CSS 文件），无需重启应用程序即可看到更改效果 开发模式下，Spring Boot DevTools 自动禁用模板引擎（如 Thymeleaf、Freemarker）的缓存，这样你可以实时看到模板的更改 DevTools 会自动为应用程序添加一些开发时的默认属性，例如，它会在开发环境中设置 spring.thymeleaf.cache=false 来禁用模板缓存 全局属性文件 当全局属性文件和模块属性文件都包含例如 spring.devtools.restart.enabled 配置时，模块属性文件的配置优先级更高。 ~/.spring-boot-devtools.properties 是一个固定的文件名。Spring Boot DevTools 会自动检测并读取用户主目录中的这个文件，以应用全局配置`,``,`html`,`Spring Cloud课程查询`,`20240814232713-_项目例 20240604162727.webp 课程查询案例 系统架构和接口设计 分模块构建Spring Cloud项目 课程列表,课程价格服务开发 课程服务整合, 服务注册与发现 整合Feign实现服务间调用 负载均衡Ribbon 引入服务的熔断与降级Hystrix 网关的集成与开发, 并接入服务Zuul spring cloud的每个模块实际上都是spring boot项目 结构 demo18 course-service course-list course-price course-zuul eureka-server pom文件 demo18 java.lang.ClassNotFoundException: org.springframework.boot.context.properties.ConfigurationBeanFactoryMetadata Spring Boot和Spring Cloud的版本组合 Spring Boot 2.3.12.RELEASE + Spring Cloud Hoxton.SR12 Spring Boot 2.4.9 + Spring Cloud 2020.0.4 Spring Boot 2.5.6 + Spring Cloud 2020.0.4 <groupId>com.ida</groupId> <artifactId>demo18</artifactId> <version>1.0-SNAPSHOT</version> <packaging>pom</packaging> <!-- 子模块 --> <modules> <module>course-service</module> <module>eureka-server</module> <module>course-zuul</module> </modules> <properties> <!-- .. --> <!-- 版本定义 --> <spring-cloud.version>Hoxton.SR12</spring-cloud.version> <spring-boot.version>2.3.12.RELEASE</spring-boot.version> </properties> <dependencyManagement> <dependencies> <!-- cloud版本管理 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-dependencies</artifactId> <version>&#36;{spring-cloud.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!-- boot版本管理 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>&#36;{spring-boot.version}</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> course-service <!-- 父模块 --> <parent> <groupId>com.ida</groupId> <artifactId>demo18</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>course-service</artifactId> <packaging>pom</packaging> <!-- 子模块 --> <modules> <module>course-list</module> <module>course-price</module> </modules> course-list <!-- 父模块 --> <parent> <groupId>com.ida</groupId> <artifactId>course-service</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>course-list</artifactId> <dependencies> <!-- boot依赖 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!-- mysql相关 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>2.1.1</version> </dependency> <!-- eureka客户端 --> <dependency> <groupId>org.springframework.cloud</groupId> <!-- 客户端可省略@EnableEurekaClient注解 --> <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId> </dependency> </dependencies> <build> <plugins> <!-- boot的maven插件 --> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> <!-- mybatis代码生成插件 --> <plugin> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-maven-plugin</artifactId> <version>1.3.7</version> <configuration> <verbose>true</verbose> <overwrite>true</overwrite> </configuration> </plugin> </plugins> </build> course-price <!-- 父模块 --> <parent> <groupId>com.ida</groupId> <artifactId>course-service</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>course-price</artifactId> <dependencies> <!-- boot依赖 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!-- mysql相关 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>2.1.1</version> </dependency> <!-- eureka客户端 --> <dependency> <groupId>org.springframework.cloud</groupId> <!-- 客户端可省略@EnableEurekaClient注解 --> <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId> </dependency> <!-- openfeign Http调用 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> <!-- hystrix 熔断 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-hystrix</artifactId> </dependency> <!-- 引用包下的实体类 --> <dependency> <groupId>com.ida</groupId> <artifactId>course-list</artifactId> <version>1.0-SNAPSHOT</version> <scope>compile</scope> </dependency> </dependencies> <build> <plugins> <!-- boot的maven插件 --> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> <!-- mybatis代码生成插件 --> <plugin> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-maven-plugin</artifactId> <version>1.3.7</version> <configuration> <verbose>true</verbose> <overwrite>true</overwrite> </configuration> </plugin> </plugins> </build> eureka-server <!-- 父模块 --> <parent> <groupId>com.ida</groupId> <artifactId>demo18</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>eureka-server</artifactId> <version>1.0-SNAPSHOT</version> <dependencies> <!-- eureka服务端 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> course-zuul <!-- 父模块 --> <parent> <groupId>com.ida</groupId> <artifactId>demo18</artifactId> <version>1.0-SNAPSHOT</version> </parent> <artifactId>course-zuul</artifactId> <version>1.0-SNAPSHOT</version> <dependencies> <!-- eureka客户端 --> <dependency> <groupId>org.springframework.cloud</groupId> <!-- 客户端可省略@EnableEurekaClient注解 --> <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId> </dependency> <!-- zuul网关 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-zuul</artifactId> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> eurake配置使用 服务端 引入依赖 启动类加 @EnableEurekaServer 注解 配置文件 server.port=9018 spring.application.name=eureka-server eureka.instance.hostname=localhost #作为server端,不需要同步其它节点数据时,不必获取注册表, (集群) eureka.client.fetch-registry=false #是否将自己也注册进去, 默认true (集群) eureka.client.register-with-eureka=false eureka.client.service-url.defaultZone=http://&#36;{eureka.instance.hostname}:&#36;{server.port}/eureka/ 注册信息: http://localhost:9018/ 客户端 引入依赖 配置文件 server.port=9218 spring.application.name=course-price eureka.client.service-url.defaultZone=http://localhost:9018/eureka/ feign配置使用 Jackson在序列化和反序列化JSON时，通常处理的是对象类型（例如Boolean），而不是基本数据类型 在处理JSON时，如果字段为空或不存在，基本数据类型可能会引发异常，因为基本数据类型不能为null 如果你的FeignClient接口返回基本数据类型（如int或long），而JSON中包含null值或非数字格式，则可能导致Jackson无法正确解析，并抛出转换异常。 返回对象中涉及Date类型时需要配置Jackson的ObjectMapper全局时区和日期格式 不要省略@RequestParam和@RequestBody 如果请求参数需要以JSON格式发送并在服务器端解析为Java对象，需要使用@RequestBody注解 405 Method Not Allowed 当参数是简单类型（如Integer、String等）时，如果你不使用@RequestParam，Feign会将这些参数视为请求体的一部分（如@RequestBody），这与GET请求不兼容 @RequestParam明确地告诉Feign客户端，它应该将该参数作为查询参数（query parameter）添加到URL中，而不是放入请求体。对于GET请求，这种方法是必需的。 即使方法参数的名称与请求参数的名称一致，也不要省略@RequestParam的value属性, 因为某些版本会报错找不到, 为避免差异, 应写尽写 引入依赖 启动类加 @EnableFeignClients 注解 创建客户端接口和降级类 客户端接口类 该接口中方法对应于远程服务controller类下的方法, 请求路径、参数和返回类型与远程服务控制器方法一致，方法名的不同不会影响请求的正确性 @FeignClient注解参数 name = "course-list" 将要调用的远程服务名称[spring.application.name] fallback = CourseListClientFallback.class 当 Feign 客户端调用失败时(例如远程服务停止时)指定一个降级处理类返回备用结果 它确保了即使远程服务不可用，客户端也能返回某种默认值或处理逻辑 对于需要更复杂的降级逻辑或需要访问异常信息的场景，使用fallbackFactory = CourseListClientFallbackFactory.class path = "/api/s1", 所有通过该 Feign 客户端发出的请求都会自动附加这个前缀, 例如远程服务的控制器配置了统一前缀时可以利用此属性 url = "http://localhost:8080" ,url 属性会覆盖 name 属性中的服务发现配置, 直接使用指定的 URL来查找服务 @FeignClient(name = "course-list", fallback = CourseListClientFallback.class) public interface CourseListClient { @GetMapping("/list") List<Course> list(); @GetMapping("/course/{courseId}") Course getCourseByCourseId(@PathVariable("courseId") Integer courseId); } 降级处理类 实现客户端接口类, 标记为组件 @Component public class CourseListClientFallback implements CourseListClient { @Override public List<Course> list() { Course course = new Course(); course.setName("默认课程"); List<Course> courseList = new ArrayList<>(); courseList.add(course); return courseList; } @Override public Course getCourseByCourseId(Integer courseId) { Course course = new Course(); course.setName("默认课程"); return course; } } 复杂逻辑的降级处理类 实现FallbackFactory接口, 标记为组件 @Component public class CourseListClientFallbackFactory implements FallbackFactory<CourseListClient> { @Override public CourseListClient create(Throwable cause) { return new CourseListClient() { @Override public List<Course> list() { // 根据异常信息提供复杂的降级逻辑 if (cause instanceof CourseException) { // 处理特定异常 return handleSpecificException((CourseException) cause); } // 通用的降级处理 return handleGenericException(cause); } @Override public Course getCourseByCourseId(Integer courseId) { return null; } private List<Course> handleSpecificException(CourseException ex) { // 例如返回特定的备用值或记录日志 return null; } private List<Course> handleGenericException(Throwable ex) { // 例如记录日志或返回默认的备用值 return null; } }; } } 使用 @RestController public class CoursePriceController { @Resource private CourseListClient courseListClient; @GetMapping("/remote/list") public List<Course> getCourseList() { return courseListClient.list(); } @GetMapping("/remote/course/{courseId}") public Course getCourseByCourseId(@PathVariable("courseId") Integer courseId) { return courseListClient.getCourseByCourseId((courseId)); } } feign集成ribbon,hystrix 当 Feign 与 Ribbon 集成时, Feign 客户端会使用 Ribbon 作为负载均衡器来选择服务实例 (服务之间互调) Hystrix熔断器会监控请求的成功率和响应时间。如果请求失败率或响应时间超过了设定的阈值，Hystrix 会自动触发熔断器 熔断状态下，Hystrix 不会再向故障的服务发送请求,而是直接调用fallback 方法, 以避免在服务故障时持续发送请求加剧服务的压力和崩溃 启动类加 @EnableCircuitBreaker 注解是早期版本中用来启用 Hystrix 的熔断器功能的做法, Spring Cloud Hoxton 版本开始，该注解变得不再必要 #当前服务调用远程 course-list 服务时采用的负载均衡策略。即远程 course-list 服务有多个实例可用时，如何选择其中一个实例, 此处使用随机策略 course-list.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RoundRobinRule #允许 Feign 客户端集成 Hystrix 提供的熔断、超时、隔离等功能 feign.hystrix.enabled=true zuul的配置使用 引入依赖 启动类加 @EnableZuulProxy 注解 配置文件 server.port=9918 spring.application.name=course-zuul # 将自己作为一个client在eureka上注册以获得其它模块的服务信息 eureka.client.service-url.defaultZone=http://localhost:9018/eureka/ # zuul未进行显式配置时, 通过网关访问的默认形式为 http://域名:网关端口/服务名/请求uri, localhost:9918/course-price/course/67 # 设置 API 路由的公共前缀, 客户端请求需要加/api前缀, 将所有对 /api/list/** 路径的请求转发到 course-list 服务 zuul.prefix=/api zuul.routes.course-list.path=/list/** zuul.course-list.service-id=course-list zuul.routes.course-price.path=/price/** zuul.course-price.service-id=course-price 网关实现过滤器 继承ZuulFilter实现其中的的接口, 标记为组件 统计请求耗时 前置过滤器 @Component public class ZuulPreFilter extends ZuulFilter { @Override public String filterType() { //return "pre"; return FilterConstants.PRE_TYPE; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { HttpServletRequest request = RequestContext.getCurrentContext().getRequest(); // 只有请求路径以 /api/list/ 开头时才应用过滤逻辑 //getRequestURI不包括查询参数 return request.getRequestURI().startsWith("/api/list/"); } @Override public Object run() { RequestContext currentContext = RequestContext.getCurrentContext(); currentContext.set("startTime",System.currentTimeMillis()); System.out.println("开始记录"); return null; } } 后置过滤器 @Component public class ZuulPostFilter extends ZuulFilter { @Override public String filterType() { return FilterConstants.POST_TYPE; } @Override public int filterOrder() { return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1; } @Override public boolean shouldFilter() { HttpServletRequest request = RequestContext.getCurrentContext().getRequest(); return request.getRequestURI().startsWith("/api/list/"); } @Override public Object run() { RequestContext currentContext = RequestContext.getCurrentContext(); long duration = System.currentTimeMillis() - (Long) currentContext.get("startTime"); String uri = RequestContext.getCurrentContext().getRequest().getRequestURI(); System.out.println(uri + "请求耗时:" + duration); return null; } } 错误过滤器 Zuul 错误过滤器用来处理在路由、转发、过滤等过程中遇到的错误, @Component public class ZuulErrorFilter extends ZuulFilter { @Override public String filterType() { return FilterConstants.ERROR_TYPE; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); Throwable throwable = ctx.getThrowable(); System.out.println("err: " + throwable.getCause().getMessage()); return null; } } Logback格式配置 %clr(内容){颜色}: Logback中用于设置输出颜色的格式化符号 %d{&#36;{LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS}}: &#36;{LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS}是一个变量 %5p: 日志级别信息的最小宽度为5个字符 %PID: 当前进程的 ID %t: 线程名称 %logger{39}: logger 的名称，最多显示 39 个字符 %m: 日志消息 %n: 换行。 &#36;{LOG_EXCEPTION_CONVERSION_WORD:%wEx}: 这部分用于在发生异常时输出异常信息 #控制台输出日期、日志级别、进程 ID、线程名称、Logger 名称和消息，并在发生异常时输出异常信息。同时添加颜色效果 logging.pattern.console=%clr(%d{&#36;{LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS}}){faint} %clr(&#36;{LOG_LEVEL_PATTERN:-%5p}) %clr(&#36;{PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n&#36;{LOG_EXCEPTION_CONVERSION_WORD:%wEx} mybatis及代码生成插件使用 插件overwrite属性在开发环境中启用覆盖，生产环境中禁用覆盖 true，插件每次生成代码时都会覆盖目标目录中的已有文件 false，插件不会覆盖目标目录中的文件。如果文件已经存在，生成的代码将不会更新 启动类加 @MapperScan(basePackages = "com.ida.demo18.course_list.dao") 扫描接口文件 #mapper映射文件地址 mybatis.mapper-locations=classpath:mappers/*.xml #字段名驼峰转换 mybatis.configuration.map-underscore-to-camel-case=true`,``,`html`,`Spring Data JPA`,`20240831131013-_数据库 Hibernate API 直接操作 需要更细粒度的控制数据库事务和 Session 生命周期的场景。 复杂的数据库操作或批量处理（如批量插入、批量更新）时，通过直接使用 Session 可以优化性能。 需要结合原生 SQL 查询、存储过程或 Hibernate 特有的功能（如 HQL、Criteria API）时，直接使用 Hibernate API 可能更灵活。 Spring Data JPA 提供了高层抽象，减少了开发者直接处理数据库访问的复杂性。 内置的 CrudRepository 或 JpaRepository 提供了常见的 CRUD 操作和简单查询，不需要写重复代码。 自动管理事务和 EntityManager，减少了手动管理的负担 在服务层方法上使用 @Transactional 注解来指定事务行为 在需要特殊优化或自定义查询时，可能不如直接使用 Hibernate API 灵活 JpaRepository 预定义的方法 JpaRepository 接口，它包含了基本的 CRUD 操作。只需创建一个接口并继承 JpaRepository，就可以自动获得这些方法。 save(S entity) 保存给定的实体。如果实体已存在（即具有主键），则会更新该实体；否则，会插入新的实体 返回保存后的实体（通常包含数据库生成的主键值） saveAll(Iterable[S] entities) 批量保存给定的实体集合 返回保存后的实体集合 findById(ID id) 根据主键查找实体 返回 Optional 包装的实体对象，如果找不到则返回 Optional.empty() findAll() 查找所有实体 findAllById(Iterable[ID] ids) 根据给定的 ID 集合查找实体 findAllById(Arrays.asList(1L, 2L)) count() 实体数量的 long 值, userRepository.count(); deleteById(ID id) 根据主键删除实体 delete(T entity) 删除给定的实体 deleteAll(Iterable[? extends T] entities) 批量删除给定的实体集合 findAll(Pageable pageable) 分页查询所有实体 Page[User] page = userRepository.findAll(PageRequest.of(0, 10)); findAll(Sort sort) 排序后的实体列表 List[User] users = userRepository.findAll(Sort.by("name").ascending()); existsById(ID id) 检查是否存在具有给定主键的实体 Page对象 getContent(): 返回当前页的实体数据 hasContent(): 检查当前页是否包含数据 getNumber(): 返回当前页的页码（从 0 开始）。 getSize(): 返回每页显示的数据条数。 getNumberOfElements(): 返回当前页实际包含的数据条数。 getTotalPages(): 返回总页数。 getTotalElements(): 返回符合查询条件的总记录数。 hasNext(): 检查是否有下一页。 hasPrevious(): 检查是否有上一页。 isFirst(): 检查是否是第一页。 isLast(): 检查是否是最后一页。 Sort getSort(): 返回当前的排序方式。 boolean isSorted(): 检查数据是否进行了排序。 Pageable getPageable(): 返回用于请求当前 Page 的分页信息对象 Pageable，包含页码和页大小等信息。 Pageable nextPageable(): 返回用于请求下一页的 Pageable 对象。 Pageable previousPageable(): 返回用于请求上一页的 Pageable 对象。 Iterator<T> iterator(): 返回当前页数据的迭代器。 Stream<T> get(): 返回当前页数据的流。 接口 public interface UserRepository extends JpaRepository<User, Long> { //对象类型及主键类型 //接口下存放JpaRepository自带方法之外的自定义CRUD //1. 方法名称约定 //2. 使用 JPQL 查询 @Query("SELECT u FROM User u WHERE u.age BETWEEN ?1 AND ?2") List<User> findByAgeBetween(int minAge, int maxAge); //3. 使用原生 SQL 查询 @Query(value = "SELECT * FROM user WHERE age BETWEEN ?1 AND ?2", nativeQuery = true) List<User> findByAgeBetweenUsingNativeQuery(int minAge, int maxAge); //4. 使用自定义 Repository 实现 } 方法命名约定 Spring Data JPA 会解析方法名称自动创建相应的查询逻辑 简单属性查询 如果你有一个 User 实体类，并希望根据 name 属性查询用户 List[User] findByName(String name); 这个方法会自动生成一个 SQL 查询，类似于 SELECT * FROM user WHERE name = ? 多个属性查询 可以通过And连接多个属性来构造更复杂的查询 findByNameAndEmail(String name, String email); 类似于 SELECT * FROM user WHERE name = ? AND email = ? 使用 Containing 和 Like（模糊查询） findByNameContaining(String nameFragment); 可以带有排序和分页参数 Page[User] findByName(String name, Pageable pageable); Page[User] findByName(String name, Sort sort); 按属性范围查询 findByAgeBetween(int startAge, int endAge) 在方法名称中指定排序条件 findByNameOrderByAgeAsc(String name); 组合写法 findByAgeBetweenOrderByAgeAsc(int startAge, int endAge); findByAgeBetweenOrderByAgeAsc(int startAge, int endAge, Pageable pageable); 自定义 Repository 实现 //自定义 Repository 接口 public interface CustomUserRepository { List<User> findUsersByCustomCriteria(String criteria); } //自定义 Repository 实现类 public class CustomUserRepositoryImpl implements CustomUserRepository { @PersistenceContext private EntityManager entityManager; @Override public List<User> findUsersByCustomCriteria(String criteria) { String query = "SELECT u FROM User u WHERE u.name LIKE :criteria"; TypedQuery<User> typedQuery = entityManager.createQuery(query, User.class); typedQuery.setParameter("criteria", "%" + criteria + "%"); return typedQuery.getResultList(); } } //更新原有 UserRepository 接口以继承自定义 Repository public interface UserRepository extends JpaRepository<User, Long>, CustomUserRepository { } 服务类 @Service public class UserService { @Resource private UserRepository userRepository; public List<User> getAllUsers() { return userRepository.findAll(); } public User getUserById(Long id) { return userRepository.findById(id).orElse(null); } public User createUser(User user) { return userRepository.save(user); } public User updateUser(Long id, User userDetails) { User user = userRepository.findById(id).orElse(null); if (user != null) { user.setName(userDetails.getName()); user.setEmail(userDetails.getEmail()); return userRepository.save(user); } return null; } public void deleteUser(Long id) { userRepository.deleteById(id); } }`,``,`html`,`Spring JDBC`,`20240729003931-_数据库 Spring JDBC是Spring框架用于处理关系型数据库的模块,对JDBC API进行了轻量封装 JdbcTemplate是其核心类,提供数据的CRUD方法 Mybatis和Spring JDBC Mybatis作为一个ORM框架,其封装程度较高,方便快速地完成与数据库的交互工作,但是因为封装程度高导致执行效率相对较低 而Spring JDBC只是对原始的JDBC API进行了简单封装 对于互联网一线大厂无论是数据量还是用户并发量都非常高,使用MyBatis可能由于微小的性能差距导致整体应用变慢,因此更倾向使用像Spring JDBC这样轻量级的封装框架,在此基础上结合自己企业应用的特点进行二次封装,同时因为有底层ioc容器的存在,使程序不至于像原生JDBC那样难以管理 Spring JDBC是介于ORM框架和原生JDBC之间的一种折中选择 依赖 <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>5.3.19</version> </dependency> 配置 <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd "> <!-- 创建数据源 --> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/testdb?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"/> <property name="username" value="root"/> <property name="password" value="root"/> </bean> <!-- 创建jdbcTemplate关联到数据源 --> <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"> <property name="dataSource" ref="dataSource"/> </bean> <!-- 创建DAO注入jdbcTemplate --> <bean id="employeeDao" class="com.ida.demo10.jdbc.dao.EmployeeDao"> <property name="jdbcTemplate" ref="jdbcTemplate"/> </bean> </beans> CURD操作 public class EmployeeDao { private JdbcTemplate jdbcTemplate; //setter //单条记录封装为实体对象 public Employee findById(Integer eno) { String sql = "select * from testdb.employee where eno = ?"; return jdbcTemplate.queryForObject( sql, new Object[]{eno}, new BeanPropertyRowMapper<>(Employee.class) ); } //多条记录封装为实体对象列表 public List<Employee> findByDname(String dname) { String sql = "select * from testdb.employee where dname=?"; return jdbcTemplate.query( sql, new Object[]{dname}, new BeanPropertyRowMapper<>(Employee.class) ); } //多条记录封装为Map对象列表 public List<Map<String, Object>> findByDnameDTO(String dname) { String sql = "select ename name,salary from testdb.employee where dname=?"; return jdbcTemplate.queryForList( sql, new Object[]{dname} ); } public long[] insert(Employee employee) { //无自增主键 // String sql = "INSERT INTO testdb.employee(eno, ename, salary, dname, hiredate) VALUES (?, ?, ?, ?, ?)"; // return jdbcTemplate.update( // sql, // employee.getEno(), // employee.getEname(), // employee.getSalary(), // employee.getDname(), // employee.getHiredate() // ); //有自增主键, 需要实现 PreparedStatementCreator 接口, //PreparedStatement 本身不支持按字段名赋值，只能通过索引来设置参数 //使用 NamedParameterJdbcTemplate 代替 JdbcTemplate可以按字段名来赋值参数，同时保留获取自动生成主键的功能 String sql = "INSERT INTO testdb.employee(ename, salary, dname, hiredate) VALUES (?, ?, ?, ?)"; KeyHolder keyHolder = new GeneratedKeyHolder(); int cnt = jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException { PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setString(1, employee.getEname()); ps.setFloat(2, employee.getSalary()); ps.setString(3, employee.getDname()); ps.setDate(4, new java.sql.Date(employee.getHiredate().getTime())); return ps; } }, keyHolder); return new long[]{cnt, keyHolder.getKey().longValue()}; } public int update(Employee employee) { String sql = "update testdb.employee set ename=?,salary=?,dname=?,hiredate=? where eno=?"; return jdbcTemplate.update( sql, employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno() ); } public int delete(Integer eno) { String sql = "delete from testdb.employee where eno=?"; return jdbcTemplate.update( sql, eno ); } } 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {"classpath:applicationContext-spring_jdbc.xml"}) public class EmployeeDaoTest { @Resource private EmployeeDao employeeDao; @Test public void findById() { System.out.println(employeeDao.findById(3420)); } @Test public void selectByDname() { employeeDao.findByDname("研发部").forEach(System.out::println); } @Test public void selectByDnameDTO() { employeeDao.findByDnameDTO("研发部").forEach(System.out::println); } @Test public void insert() { Employee employee = new Employee(); employee.setEname("Jerry"); employee.setSalary(6666f); employee.setDname("市场部"); employee.setHiredate(new Date()); long[] cnt_key = employeeDao.insert(employee); System.out.println(cnt_key[0]); employee.setEno((int) cnt_key[1]); System.out.println(employee); } @Test public void update() { Employee employee = employeeDao.findById(3611); employee.setSalary(employee.getSalary()+1000); int cnt = employeeDao.update(employee); System.out.println(cnt); } @Test public void delete() { System.out.println(employeeDao.delete(3612)); } } 事务管理 Spring JDBC通过TransactionManager实现事务控制 Spring的事务是通过AOP实现的，这意味着事务管理是基于代理的, 而内部方法调用不会经过代理 Spring 会为你的服务类创建一个代理对象。这个代理对象会拦截对服务方法的调用，并在调用前启动事务，在调用后提交或回滚事务 当在同一个类内部直接调用另一个方法时，这个调用不会经过 Spring 的代理，因此不会应用事务管理 编程式事务 编程式事务指通过代码手动提交和回滚 配置 <!-- 创建事务管理器, 关联dataSource --> <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> <property name="dataSource" ref="dataSource"/> </bean> <!-- 为服务类注入事务管理器 --> <bean id="employeeService" class="com.ida.demo10.jdbc.service.EmployeeService"> <property name="employeeDao" ref="employeeDao"/> <property name="transactionManager" ref="transactionManager"/> </bean> 使用 public class EmployeeService { private EmployeeDao employeeDao; //setter private DataSourceTransactionManager transactionManager; //setter public void batchImport() { //DefaultTransactionDefinition定义了一些默认的事务属性（例如传播行为、隔离级别等） //开始一个事务, TransactionStatus用于管理和跟踪当前事务的状态 TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { //------------------------------------------ for (int i = 1; i <= 10; i++) { if (i == 5) { //throw new RuntimeException("xxx"); } Employee employee = new Employee(); employee.setEname("员工"+i); employee.setSalary(6666f); employee.setDname("市场部"); employee.setHiredate(new Date()); employeeDao.insert(employee); } //------------------------------------------ transactionManager.commit(status); //提交事务 } catch (Exception e) { transactionManager.rollback(status); //回滚事务 throw new RuntimeException(e); } } } 声明式事务 声明式事务指通过配置形式自动实现事务控制 声明式事务本质是AOP环绕通知 目标方法执行成功时自动提交,抛出非检查异常(Error 和 RuntimeException 以及他们的子类)时自动回滚 对于检查异常 Spring 默认情况下不会自动回滚事务。需要显式配置回滚规则，以便在遇到检查异常时进行回滚。 xml配置时在tx:method中添加属性rollback-for="java.io.IOException, java.sql.SQLException" @Transactional(rollbackFor= Exception,class) 任何异常都进行回滚 Error,Exception继承Throwable, RuntimeException继承Exception 如果 IOException 发生在数据写入操作的过程中，通常需要回滚事务以确保数据一致性 在接口上配置 @Transactional 注解后，无需在实现类上重复配置, 除非需要对某些方法使用不同的事务配置，或者需要覆盖接口上的事务注解时 接口上使用事务注解 在接口上配置 @Transactional 注解后，无需在实现类上重复配置, 除非需要对某些方法使用不同的事务配置，或者需要覆盖接口上的事务注解时 配置 增加tx,aop命名空间 配置事务通知属性 为事务通知绑定切点 <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd "> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/testdb?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"/> <property name="username" value="root"/> <property name="password" value="root"/> </bean> <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"> <property name="dataSource" ref="dataSource"/> </bean> <bean id="employeeDao" class="com.ida.demo10.jdbc.dao.EmployeeDao"> <property name="jdbcTemplate" ref="jdbcTemplate"/> </bean> <!-- 编程式事务例 --> <bean id="employeeService" class="com.ida.demo10.jdbc.service.EmployeeService"> <property name="employeeDao" ref="employeeDao"/> <property name="transactionManager" ref="transactionManager"/> </bean> <!-- 声明式事务例 --> <bean id="employeeService2" class="com.ida.demo10.jdbc.service.EmployeeService2"> <property name="employeeDao" ref="employeeDao"/> </bean> <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> <property name="dataSource" ref="dataSource"/> </bean> <!-- 配置声明式事务通知属性 --> <tx:advice id="txAdvice" transaction-manager="transactionManager"> <tx:attributes> <tx:method name="batchImport" propagation="REQUIRED"/> <!-- name支持通配符 read-only="true"设置事务为只读可以帮助采取更高效的执行计划，减少锁定等操作,同时Spring会阻止数据的修改避免误操作 --> <tx:method name="get*" propagation="NOT_SUPPORTED" read-only="true"/> <!-- 不符合上面筛选条件时方法的兜底设置 --> <tx:method name="*" propagation="REQUIRED"/> <!-- 如果切点匹配的方法不在 <tx:method> 范围内，并且没有提供一个通用的兜底设置，那么这些方法将不会被应用任何事务管理策略 --> </tx:attributes> </tx:advice> <!-- 为声明式事务通知绑定切点 --> <aop:config> <aop:pointcut id="pointcut" expression="execution(* com.ida.demo10.jdbc.service..*2.*(..))"/> <aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut"/> </aop:config> </beans> public class EmployeeService2 { private EmployeeDao employeeDao; //setter public void batchImport(int m) { for (int i = m; i < m+10; i++) { if (i == m+3) { //throw new RuntimeException("xxx"); } Employee employee = new Employee(); employee.setEname("员工"+i); employee.setSalary(6666f); employee.setDname("市场部"); employee.setHiredate(new Date()); employeeDao.insert(employee); } } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {"classpath:applicationContext-spring_jdbc.xml"}) public class EmployeeService2Test { @Resource private EmployeeService2 employeeService2; @Test public void batchImport() { employeeService2.batchImport(0); } } 注解形式的声明式事务 放在类上对类中所有方法有效,默认REQUIRED 方法上的注解声明优先于类上的注解声明 查询方法不需要事务,标记@Transactional(propagation = Propagation.NOT_SUPPORTED ,readOnly = true) <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/testdb?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"/> <property name="username" value="root"/> <property name="password" value="root"/> </bean> <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"> <property name="dataSource" ref="dataSource"/> </bean> <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> <property name="dataSource" ref="dataSource"/> </bean> <!-- 启用组件扫描 --> <context:component-scan base-package="com.ida.demo10.jdbc.transactionAnno"/> <!-- 启用注解形式声明事务 --> <tx:annotation-driven transaction-manager="transactionManager"/> </beans> 事务的传播行为 传播方式:存在事务时行为:不存在事务时行为:当前事务异常时行为:新事务异常时行为 REQUIRED(默认):使用当前事务:新建事务:当前事务回滚，新事务也回滚:N/A REQUIRES_NEW:挂起当前事务，新建一个新事务:新建事务:当前事务回滚，新事务不受影响:新事务回滚，当前事务不受影响 SUPPORTS:使用当前事务:不使用事务:当前事务回滚:N/A NOT_SUPPORTED:挂起当前事务，不使用事务:不使用事务:当前事务回滚:N/A MANDATORY:使用当前事务:抛出异常:当前事务回滚:N/A NEVER:抛出异常:不使用事务:当前事务回滚:N/A NESTED:使用当前事务，但创建一个嵌套事务（保存点）:新建事务:当前事务回滚，嵌套事务回滚到保存点:嵌套事务回滚，当前事务不受影响 REQUIRES_NEW 的设计目的是确保新事务完全独立于外层事务运行。这样即使新事务失败或异常回滚，外层事务仍可以独立决定自己的执行或回滚 public class BatchService { private EmployeeDao employeeDao; //setter private DataSourceTransactionManager transactionManager; //setter public void task1(int m) { for (int i = m; i < m + 10; i++) { if (i == m + 3) { //throw new RuntimeException("xxx"); } Employee employee = new Employee(); employee.setEname("员工" + i); employee.setSalary(6666f); employee.setDname("市场部"); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public void task2(int m) { for (int i = m; i < m + 10; i++) { if (i == m + 3) { throw new RuntimeException("xxx"); } Employee employee = new Employee(); employee.setEname("员工" + i); employee.setSalary(6666f); employee.setDname("市场部"); employee.setHiredate(new Date()); employeeDao.insert(employee); } } public void task3(int m) { for (int i = m; i < m + 10; i++) { if (i == m + 3) { //throw new RuntimeException("xxx"); } Employee employee = new Employee(); employee.setEname("员工" + i); employee.setSalary(6666f); employee.setDname("市场部"); employee.setHiredate(new Date()); employeeDao.insert(employee); } } } //task1,3完整写入, task2异常回滚; //如果A或B处放开, 即superTask上抛异常, task1完整写入, task2异常回滚, task3由于superTask异常而没有执行机会 //因为 task1 的事务是独立的 (REQUIRES_NEW)，即使 superTask 方法中的事务被回滚，也不会影响到 task1 的结果 public class BS { private BatchService batchService; //setter public void superTask() { //REQUIRED //在不同类中调用task以保证经过代理应用事务管理 //每个task方法单独try/catch消化,保证所有task都被执行到,各自异常各自回滚互不干扰 try { batchService.task1(0); //REQUIRES_NEW } catch (RuntimeException e) { e.printStackTrace(); } try { batchService.task2(10); //REQUIRES_NEW } catch (RuntimeException e) { e.printStackTrace(); //throw e; //A } try { if (true) { throw new RuntimeException("xxx"); } } catch (RuntimeException e) { e.printStackTrace(); //如果事务内部异常选择内部自行消化而没有抛到外层,将不会触发回滚 //throw e; //B } try { batchService.task3(20); //REQUIRES_NEW } catch (RuntimeException e) { e.printStackTrace(); } } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {"classpath:applicationContext-spring_jdbc.xml"}) public class BSTest { @Resource private BS bs; @Test public void superTask() { bs.superTask(); } } <!-- 事务传播例 --> <bean id="batchService" class="com.ida.demo10.jdbc.service.BatchService"> <property name="employeeDao" ref="employeeDao"/> </bean> <bean id="bs" class="com.ida.demo10.jdbc.service.BS"> <property name="batchService" ref="batchService"/> </bean> <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> <property name="dataSource" ref="dataSource"/> </bean> <!-- 配置声明式事务通知属性 --> <tx:advice id="txAdvice" transaction-manager="transactionManager"> <tx:attributes> <tx:method name="task1" propagation="REQUIRES_NEW"/> <tx:method name="task2" propagation="REQUIRES_NEW"/> <tx:method name="task3" propagation="REQUIRES_NEW"/> <tx:method name="*" propagation="REQUIRED"/> </tx:attributes> </tx:advice> <aop:config> <!-- 可以使用逻辑运算符 --> <aop:pointcut id="pointcut" expression="execution(* com.ida.demo10.jdbc.service.*2.*(..)) || execution(* com.ida.demo10.jdbc.service.B*.*(..))"/> <aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut"/> </aop:config>`,``,`html`,`Spring MVC`,`20240729003931-_java web Spring MVC是Spring体系的轻量级Web MVC框架 所有对象被IoC容器管理, 核心是控制器处理请求和产生响应 模型和视图之间没有必然的联系,两者只面向控制器以此解耦 20240508095618.webp 依赖 spring-context 是 Spring 核心容器的一部分，提供了基于 IoC 容器的功能。它通常包括以下几个包： spring-core spring-beans spring-aop spring-expression spring-context spring-webmvc 是构建在 spring-context 基础上的，因此包含 spring-context 的所有包和功能, 额外增加的有: spring-web spring-webmvc <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.1.9.RELEASE</version> </dependency> 入口拦截 <!-- web.xml --> <?xml version="1.0" encoding="UTF-8"?> <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"> <servlet> <servlet-name>springmvc</servlet-name> <!-- DispatcherServlet是spring mvc的核心类,拦截http请求,根据url调用对应的controller --> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <!-- 加载spring配置文件 --> <param-value>classpath:applicationContext.xml</param-value> </init-param> <!-- web应用启动时创建IoC容器,不写则延后到第一次访问url时创建容器 --> <load-on-startup>0</load-on-startup> </servlet> <servlet-mapping> <servlet-name>springmvc</servlet-name> <!-- / 匹配根路径 (/) 和所有没有被其他更具体的 url-pattern 映射的路径, 它不会拦截静态资源的请求 --> <!-- /* 拦截所有的请求，包括根路径 (/)、所有子路径，以及静态资源的请求--> <!-- 两者的区别在于 /* 还会捕获静态资源，而 / 只捕获动态内容的请求，且不干涉静态资源的处理--> <url-pattern>/</url-pattern> </servlet-mapping> </web-app> 配置 引入context,mvc命名空间 <!-- applicationContext.xml --> <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd "> <!-- 开启组件扫描 --> <context:component-scan base-package="com.ida.demo11"/> <!-- 启用Spring MVC注解 --> <mvc:annotation-driven/> <!-- 即使DispatcherServlet 的 url-pattern 设置为 /，如果应用中有静态资源且需要确保这些资源由容器默认的静态资源处理器处理，那么配置 mvc:default-servlet-handler 依然是推荐的做法。它确保所有无法匹配到控制器的请求（主要是静态资源）能够正常返回，而不会被 DispatcherServlet 拦截或报错。 --> <mvc:default-servlet-handler/> </beans> 注解含义及参数 @GetMapping 参数:说明:示例 value (或 path):指定请求的 URL 路径，可以是一个字符串数组。:@GetMapping("/path") @GetMapping({"/path1", "/path2"}) params:指定请求中必须包含的参数，可以是一个字符串数组。:@GetMapping(value = "/path", params = "id=1") headers:指定请求中必须包含的头，可以是一个字符串数组。:@GetMapping(value = "/path", headers = "headerName=headerValue") produces:指定返回内容的媒体类型，可以是一个字符串数组。:@GetMapping(value = "/path", produces = "application/json") consumes:指定请求内容的媒体类型，可以是一个字符串数组。:@GetMapping(value = "/path", consumes = "application/json") @PostMapping 参数:说明:示例 value:指定请求的 URL 路径。:@PostMapping(value = "/submit") path:指定请求的 URL 路径。是 value 的别名。:@PostMapping(path = "/submit") params:指定请求中必须包含的参数。可以使用表达式。:@PostMapping(value = "/submit", params = "version=1.0") headers:指定请求中必须包含的头。可以使用表达式。:@PostMapping(value = "/submit", headers = "X-Custom-Header") produces:指定返回内容的媒体类型。:@PostMapping(value = "/submit", produces = "application/json") consumes:指定请求内容的媒体类型。:@PostMapping(value = "/submit", consumes = "application/json") @RequestMapping 用在类上定义该类中的所有方法的基础 URL 映射 用在方法上定义方法的 URL 映射, 与类上的 URL 组合形成完整的路径 参数:说明:示例 value (或 path):指定请求的 URL 路径:@RequestMapping(value = "/home") method:指定 HTTP 请求方法:@RequestMapping(method = RequestMethod.GET) params:指定请求中必须包含的参数及其值:@RequestMapping(params = "myParam=myValue") headers:指定请求中必须包含的头及其值:@RequestMapping(headers = "Content-Type=application/json") produces:指定返回内容的媒体类型:@RequestMapping(produces = "application/json") consumes:指定请求内容的媒体类型:@RequestMapping(consumes = "application/json") name:指定映射的名称:@RequestMapping(name = "myMapping") value:指定多个 URL 路径:@RequestMapping(value = {"/home", "/index"}) produces:指定多个返回内容的媒体类型:@RequestMapping(produces = {"application/json", "application/xml"}) consumes:指定多个请求内容的媒体类型:@RequestMapping(consumes = {"application/json", "application/xml"}) @RequestBody 绑定请求体中的数据(不包括 URL 路径、查询参数或表单数据), 适用于 JSON 或 XML 数据。 自动将请求体的数据转换为 Java 对象，支持复杂数据结构（如嵌套对象） @ResponseBody 方法的返回值直接写入响应体，不经过视图解析, 用于产生标准字符串/json/xml等格式数据, 受StringHttpMessageConverter影响 例如方法返回String "ok",未应用此注解时, 会查找名为ok的视图进行解析 Could not resolve view with name 'ok' in servlet with name 'springmvc' @RequestParam 参数名映射 @RequestParam(value = "id") int userId 或 @RequestParam(name = "id") int userId 参数校验 @RequestParam(value = "id", required = false) Integer userId 如果 required 设置为 false，且请求中没有提供此参数，则 userId 会是 null 如果 required 设置为 true，如果请求中没有提供此参数则会抛出异常 默认值 @RequestParam(value = "id", defaultValue = "0") int userId 如果请求中没有提供 id 参数，则 userId 会使用默认值 0 默认值只适用于单独绑定的请求参数，而不适用于绑定到对象字段上的参数 @PathVariable @GetMapping({"/t2/{param}", "/t1"}) public String t2(@PathVariable(value = "param", required = false) String param, @RequestParam(value = "para", required = false) String para) { // 优先使用路径变量 param，如果路径变量为空，则使用请求参数 para String result = param != null ? param : para; return "参数为:" + result; } 请求参数的接收 使用Controller方法参数接收 利用@RequsetParam为参数设置默认值 使用@DateTimeFormat将表单中的日期字符串格式化为Date对象, 可以用在方法参数上或bean的成员属性上 使用java bean接收, 可以使用List类型参数承载前端例如checkbox数组 关联对象赋值, 例如User的bean成员持有Pet对象, 表单input name="pet.name"的值将填充到User的成员pet对象的name属性 利用数组或List接收请求中的复合数据 利用List接收数组时前面要加 @RequestParam 使用Map对象接收请求参数 同样前面要加 @RequestParam 对于数组(如checkbox)只保留第一个元素, 仅适合接收值为单个数据的参数集 表单 <style> div{ position: absolute; top: 50%; left:50%; width: 300px; height: 300px; margin-left: -150px; margin-top: -150px; background-color: #f2f2f2; } form{ padding: 20px; } </style> <div> TEST <form action="./login/p5" method="post"> <!-- <input type="text" name="username" placeholder="username"><br> --> <input type="password" name="password" placeholder="password"><br> select<br> <select name="course"> <option value="java">Java</option> <option value="python">Python</option> <option value="c++">C++</option> </select><br> checkbox<br> <input type="checkbox" name="hobby" value="1">游泳 <input type="checkbox" name="hobby" value="2">射击 <input type="checkbox" name="hobby" value="3">阅读 <input type="checkbox" name="hobby" value="4">园艺<br> <input type="text" name="my_birthday" placeholder="我的生日"><br> <input type="text" name="pet.name" placeholder="宠物名"><br> <input type="text" name="pet.birthday" placeholder="宠物生日"><br> <input type="submit" value="提交"> </form> </div> 实体类 public class User { private String username; private String password; //getter,setter,toString } public class Form { private String username; private Long password; private String course; private List<Integer> hobby; private Pet pet; //getter,setter,toString } public class Pet { private String name; @DateTimeFormat(pattern = "yyyy-MM-dd") private Date birthday; //getter,setter,toString } 控制器 @Controller @RequestMapping("/login") public class TestController { @GetMapping("/g1") //等同 @RequestMapping(path = "/g" ,method = RequestMethod.GET) @ResponseBody public String get(@RequestParam("manager_name") String managerName, @DateTimeFormat(pattern = "yyyy-MM-dd") Date date,Date date2) { //localhost:9011/login/g1?manager_name=Lily&date=2000-1-1&date2=2000-1-2 System.out.println(managerName); System.out.println(date); //Sat Jan 01 00:00:00 CST 2000 使用了@DateTimeFormat System.out.println(date2); //Sun Jan 02 00:00:00 CST 2000 使用了自定义转换器 return "g1"; } @PostMapping("/p1") @ResponseBody public String post(String username, Long password, User user) { System.out.println(username+":"+password); System.out.println(user.getUsername()+":"+user.getPassword()); return "p1"; } @PostMapping("/p2") @ResponseBody public String post2(User user, @RequestParam(defaultValue = "Lily") String username, String course, Integer[] hobby) { //如果username参数不存在,user中的username不会被赋默认值Lily, 可以在在 User 类的字段声明时设置默认值 System.out.println(user.getUsername()+":"+user.getPassword()); System.out.println(username); System.out.println(course); System.out.println(Arrays.toString(hobby)); return "p2"; } @PostMapping("/p3") @ResponseBody public String post3(User user, @RequestParam(defaultValue = "Lily") String username, String course, @RequestParam(required = false) List<Integer> hobby, Form form) { System.out.println(user.getUsername()+":"+user.getPassword()); System.out.println(username); System.out.println(course); System.out.println(hobby); System.out.println(form); return "p3"; } @PostMapping("/p4") @ResponseBody public String post4(@RequestParam Map map) { System.out.println(map); //{password=67567567, course=python, hobby=2} return "p4"; } @PostMapping("/p5") @ResponseBody public String post5(@RequestParam("my_birthday") @DateTimeFormat(pattern = "yyyy-MM-dd") Date myBirthday, Form form) { System.out.println(myBirthday);//Wed Jan 01 00:00:00 CST 1992 System.out.println(form); //Form{username='null', password=123123, course='c++', hobby=[2, 4], pet=Pet{name='keke', birthday=Sun Jan 01 00:00:00 CST 2023}} return "p5"; } } http消息转换器解决响应乱码 <!-- 启用Spring MVC注解 --> <mvc:annotation-driven> <mvc:message-converters> <bean class="org.springframework.http.converter.StringHttpMessageConverter"> <property name="supportedMediaTypes"> <list> <!-- 即Servlet中的resp.setContentType("text/html;charset=utf-8") --> <value>text/html;charset=utf-8</value> </list> </property> </bean> </mvc:message-converters> </mvc:annotation-driven> 自定义转换器 自定义转换器可以在 Spring MVC 控制器中自动应用，简化请求参数的处理 例: 字符串转日期类, 等同@DateTimeFormat注解, 在参数上使用了 @DateTimeFormat 注解时，Spring 将优先使用注解中指定的格式进行日期转换。 如果参数上没有 @DateTimeFormat 注解，Spring 才会使用自定义转换器来处理字符串到日期的转换 转换器类 import org.springframework.core.convert.converter.Converter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; //注意包名 public class DateConverter implements Converter<String, Date> { //泛型参数, String转Date @Override public Date convert(String s) { try { return new SimpleDateFormat("yyyy-MM-dd").parse(s); } catch (ParseException e) { return null; } } } 注册和自定义转换服务 <!-- 启用Spring MVC注解; 指定自定义转换服务 --> <mvc:annotation-driven conversion-service="conversionService"/> <!-- 向spring mvc注册自定义转换器 --> <bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"> <property name="converters"> <set> <bean class="com.ida.demo11.mvc.converter.DateConverter"/> <!-- 更多自定义转换类 --> </set> </property> </bean> ModelAndView 模型(数据)与视图(界面) SpringMVC中默认的View是JSP,可以配置为其它模板引擎 直接访问jsp页面得到的是没有填充数据的jsp, 所以要通过访问url由控制器进行数据填充, 然后再跳转到jsp 模型和视图之间没有必然的联系,两者只面向控制器 默认ModelAndView使用请求转发(forward) 请求转发 new ModelAndView("/view.jsp") 把当前请求传递给view.jsp addObject()方法设置的属性默认放在当前请求中 重定向 new ModelAndView("redirect:/view.jsp") 通知浏览器重新发起一个请求,直接跳转到view.jsp String与ModelMap组合,等效ModelAndView Model 主要特点是它是一个接口，通常通过 ModelMap 或其他实现类进行操作。它简单且直接，不负责视图的渲染，仅负责数据的传递 ModelMap 是 Model 接口的一个实现类, 同时因为它继承自 LinkedHashMap，所以你可以直接使用 Map 的方法 ModelAndView 是 Spring MVC 中最完整的一个封装对象，最大特点是将数据和视图同时封装在一个对象中 @Controller @RequestMapping("/view") public class ModelAndViewController { @GetMapping("/v1") public ModelAndView v1(Integer userId){ //ModelAndView mav = new ModelAndView(); //mav.setViewName("/view.jsp"); ModelAndView mav = new ModelAndView("/view.jsp"); User user = new User(); if (userId == 1) { user.setUsername("海绵宝宝"); } else if (userId == 2) { user.setUsername("章鱼哥"); } mav.addObject("user",user); return mav; } //@ResponseBody @GetMapping("/v2") public String v2(Integer userId, ModelMap modelMap){ //ModelMap不是必须的,很多情况下并不需要为视图设置数据, 而是直接渲染jsp返回html String view = "/view.jsp"; User user = new User(); if (userId == 1) { user.setUsername("海绵宝宝"); } else if (userId == 2) { user.setUsername("章鱼哥"); } modelMap.addAttribute("user",user); //当方法被@ResponseBody描述时,直接返回字符串"/view.jsp",否则将ModelMap中的数据与String view指向的jsp文件组合渲染返回html return view; } } JSP更换为Freemarker 依赖 <dependency> <groupId>org.freemarker</groupId> <artifactId>freemarker</artifactId> <version>2.3.29</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context-support</artifactId> <version>5.1.9.RELEASE</version> </dependency> 配置 <!-- 启用Freemarker模板引擎 --> <bean id="freeMarkerViewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"> <property name="contentType" value="text/html;charset=utf-8"/><!-- 响应编码 --> <property name="suffix" value=".ftl"/><!-- 引用具体的ftl文件时不用写扩展名--> </bean> <!-- 配置Freemarker参数 --> <bean id="freeMarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"> <property name="templateLoaderPath" value="/WEB-INF/ftl"/><!-- 模板文件存放目录 --> <property name="freemarkerSettings"> <props> <prop key="defaultEncoding">UTF-8</prop><!-- 渲染时使用的字符集 --> </props> </property> </bean> 控制器 @Controller @RequestMapping("/freemarker") public class FreeMarkerController { @GetMapping("/f1") public ModelAndView f1(Integer userId){ ModelAndView mav = new ModelAndView("/test"); //templateLoaderPath + /test + suffix User user = new User(); if (userId == 1) { user.setUsername("海绵宝宝"); } else if (userId == 2) { user.setUsername("章鱼哥"); } mav.addObject("user",user); return mav; } } ftl <html lang="en"> <head> <title>test.ftl</title> </head> <body> <h1>hi, &#36;{user.username}</h1> </body> </html> RESTful REST（Representational State Transfer，表述性状态转移）是一种软件架构风格，主要用于设计网络应用程序的分布式系统 资源：一切都被视为资源，每个资源都有一个唯一的URI。 表述：资源的状态可以通过不同的表述形式来传输，例如JSON、XML等。 统一接口：使用标准的HTTP方法（GET、POST、PUT、DELETE）来操作资源。 无状态性：每个请求都是独立的，服务器不保存客户端状态。 可缓存性：服务器的响应可以被客户端缓存。 RESTful是指符合REST架构风格的Web服务或API，遵循REST的原则和约束 RESTful架构强调客户端和服务器的分离 客户端负责用户界面和用户体验，而服务器负责数据存储和逻辑处理, 这种分离使得客户端和服务器可以独立地开发和演进 RESTful API基于HTTP协议，任何支持HTTP的客户端（如Web浏览器、移动应用程序、其他服务器等）都可以轻松地与其集成 传统web应用仅面向支持html的客户端 RESTful API通常使用URL来表示资源，这使得API更加直观和易于理解。 例如，/users表示用户资源，/products表示产品资源。这种设计使得API使用者可以更容易地猜测和理解API的用途。 RESTful开发规范 使用URL作为用户交互入口 只返回数据(JSON | XML), 不包含任何展现 明确的语义规范(GET查 | POST增 | PUT改 | DELETE) 20240506094831.webp RESTful API与客户端的交互 ajax请求返回json类型时中文乱码 在消息转换器中增加application/json;charset=utf-8 @RestController 替代@Controller表示类中所有方法返回的结果直接作为响应体输出,相当于在所有方法上隐式加上了@ResponseBody @PathVariable 路径变量映射到方法参数, 如/article/5中的5 客户端 <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>client.html</title> <script src="/resources/js/jquery-1.11.1.min.js"></script> <script> function op(btn) { var id = $(btn).data("id"); id = id !== undefined && id !== "" ? "/" + id : ""; $.ajax({ url: "/restful/request" + id, type: btn.value, data:{name:"莉莉",age:20}, dataType: "json", success: function (json) { $("#result").text(json.message); } }); } $(function () { $("#btnGet, #btnPost, #btnPut, #btnDelete").click(function () { op(this); }); }); </script> </head> <body> <input type="button" id="btnGet" value="GET" data-id="2"> <input type="button" id="btnPost" value="POST"> <input type="button" id="btnPut" value="PUT"> <input type="button" id="btnDelete" value="DELETE"> <p id="result"></p> </body> </html> RESTful API @RestController @RequestMapping("/restful") public class RestfulController { @GetMapping(value = {"/request", "/request/{id}"}) public String get(@PathVariable(value = "id", required = false) Integer id) { String message = "未找到"; if (id == null) { message = "未提供ID"; } else { String str = "结果为: "; if (id == 1) { message = str + "海绵宝宝"; } else if (id == 2) { message = str + "章鱼哥"; } } return "{\"message\":\"" + message + "\"}"; } @PostMapping("/request") public String post(User user) { System.out.println(user.getName() + ":" + user.getAge()); return "{\"message\":\"数据新建成功\"}"; } @PutMapping("/request") public String put(User user) { System.out.println(user.getName() + ":" + user.getAge()); return "{\"message\":\"数据更新成功\"}"; } @DeleteMapping("/request") public String delete(String name) { System.out.println(name); return "{\"message\":\"数据删除成功\"}"; } } 简单请求与非简单请求 简单请求指标准结构的HTTP请求,对应GET/POST 非简单请求指PUT/DELETE,和扩展标准请求 两者最大的区别是非简单请求发送前需要发送预检请求 在跨域请求中，浏览器会发送一个预检请求（OPTIONS请求），以确定服务器是否允许实际的请求。如果服务器确认允许，浏览器才会发送实际的请求 spring mvc最早是为网页提供服务的只支持post/get请求,无法获取put/delete中的参数, 后期提供了额外的表单内容过滤器来对put和delete请求进行支持 表单内容过滤器 <filter> <filter-name>formContentFilter</filter-name> <filter-class>org.springframework.web.filter.FormContentFilter</filter-class> </filter> <filter-mapping> <filter-name>formContentFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> json序列化 spring一但检测到引用了jackson包会自动使用jackson提供序列化服务,无需任何配置 当方法返回值是实体对象,并使用了@RestController或@ResponseBody, 将自动对其进行json序列化 jackson对于日期类型未进行注解配置时默认返回毫秒数,零时区 <!-- jackson-databind的2.0.0至2.9.10.3版本存在反序列化漏洞。远程攻击者可通过精心构造的恶意载荷利用该漏洞在系统执行任意代码 --> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-core</artifactId> <version>2.16.0</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.16.0</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-annotations</artifactId> <version>2.16.0</version> </dependency> public class User { private String name; private Integer age; @JsonFormat(pattern = "yyyy-MM-dd HH", timezone = "GMT+8") private Date birthday; //.. } @GetMapping("/user") public User findUserById(Integer id) { User user = new User(); if (id == 1) { user.setName("海绵宝宝"); user.setAge(22); } else if (id == 2) { user.setName("章鱼哥"); user.setAge(32); } return user; } @GetMapping("/users") public List<User> listAllUsers() { List<User> userList = new ArrayList<>(); User user1 = new User(); user1.setName("海绵宝宝"); user1.setAge(22); User user2 = new User(); user2.setName("章鱼哥"); user2.setAge(32); user2.setBirthday(new Date()); userList.add(user1); userList.add(user2); return userList; } $("#btnQuery").click(function () { $.ajax({ url: "/restful/users", type: "get", dataType: "json", success: function (json) { for (i = 0; i < json.length; i++) { var user = json[i]; $("#result").append(user.name + ":" + user.age + " " + user.birthday + "<br>") } } }); }); spring mvc跨域配置 这些跨域设置本质上是通过设置 HTTP 响应头来实现的 当服务器响应中包含这些头信息时，浏览器会允许跨域请求。如果没有，则会阻止请求，浏览器会报错 移动应用和小程序不像浏览器，它们通常没有同源策略的限制，因此不需要依赖 CORS 头信息来决定是否允许跨域请求 这意味着即使服务器没有设置跨域头信息，移动应用和小程序依然能够正常发起跨域请求，并接收响应 虽然跨域配置会对所有客户端返回相同的 CORS 头信息，但它实际上只对浏览器有效，因为只有浏览器会阻止没有正确 CORS 头信息的跨域请求。移动应用和小程序通常不受此影响 浏览器的同源策略 同源策略阻止从一个域加载的脚本去获取另一个域上的资源 No 'Access-Control-Allow-Origin' header is present on the requested resource. 只要协议,域名,端口有任何一个不同,都被当作是不同的域 20240506181329.webp html中允许跨域的标签,img,script,link CORS跨域资源访问 CORS是一种机制,使用额外的HTTP响应头Access-Control-* 通知浏览器将产生跨域请求 在跨域请求中，浏览器会向目标服务器发送一个预检请求（OPTIONS请求），以确定服务器是否允许实际的请求。如果服务器确认允许，浏览器才会发送实际的请求 Controller跨域注解 @CrossOrigin 放在类或方法上,放在类上对类中所有方法有效 @CrossOrigin(origins = {"http://localhost:9000","http://localhost:9003"}, maxAge=3600) 允许部分网站的跨域请求 跨域请求会产生两次请求,一次预检一次实际, 为了减少服务器压力,设置maxAge(秒)预检请求的结果可以被缓存多久,在指定的时间范围内，浏览器就不会发送预检请求，直接发送实际请求 @CrossOrigin(origins ={"*"}) 允许任何网站的跨域请求 全局跨域配置 <mvc:cors> <!-- ** 表示任意数量的路径段 --> <mvc:mapping path="/restful/**" allowed-origins="http://localhost:9000,http://localhost:9003" max-age="3600" /> </mvc:cors> spring mvc拦截器组件Interceptor Interceptor底层基于spring AOP, 用于对URL请求进行前置/后置过滤, 与Servlet的Filter用途相似 拦截器是注册在 DispatcherServlet 上的，它们会拦截经过 DispatcherServlet 的所有请求 DispatcherServlet 接收所有进入的 HTTP 请求, 分析请求 URL，根据配置的 HandlerMapping 将请求映射到合适的控制器 在调用控制器方法之前，DispatcherServlet 会调用注册的拦截器链中的preHandle方法(如果返回 false，请求处理将中止) 然后调用控制器方法处理请求, 在进行视图渲染之前, 会调用拦截器链中的postHandle方法 接着会选择适当的视图进行渲染，并将结果返回给客户端, 同时调用拦截器链中的afterCompletion方法 配置了mvc:default-servlet-handler后，Spring MVC 会将所有没有映射到具体控制器的请求转发给容器的默认 Servlet（如 Tomcat 的 DefaultServlet） 通常用于处理静态资源的请求 但即使静态资源请求最终由默认的 Servlet 处理，它们在进入默认的 Servlet 之前仍然会先经过 DispatcherServlet 和其配置的拦截器 例如index.html,包括页面中引用的js,css,图片等都会被拦截 验证时用无痕模式, 浏览器缓存会导致一些静态资源请求不经过服务器 多个interceptor的执行顺序按配置文件中的书写顺序,前置处理时进正序,后置处理时倒序 20240508083649.webp 实现HandlerInterceptor接口 preHandle 在请求被处理之前 postHandle 在请求被处理之后,数据填充到视图之前 afterCompletion 在整个请求完成之后(整个请求的生命周期结束时) public class TestInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { System.out.println(request.getRequestURL()+"准备执行请求"); // 返回 true 表示继续执行后续的拦截器链和目标方法（即 Controller 方法）。 return true; // 返回 false 则表示不再执行后续的拦截器链和目标方法,直接返回当前产生的响应，可以用来中断请求的处理。 //response.setContentType("text/html;charset=utf-8"); //response.getWriter().println("非法访问"); //return false; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { System.out.println(request.getRequestURL()+"请求已处理"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(request.getRequestURL()+"已返回响应"); } } 注册拦截器 <mvc:interceptors> <mvc:interceptor> <mvc:mapping path="/**"/><!-- 对所有请求路径进行拦截 --> <mvc:mapping path="/restful/**"/><!-- 对指定路径进行拦截 --> <!-- 排除指定类型或指定路径 --> <mvc:exclude-mapping path="/**.jpg"/> <mvc:exclude-mapping path="/resources/**"/> <bean class="com.ida.demo11.restful.interceptor.TestInterceptor"/> </mvc:interceptor> </mvc:interceptors> 例-用户访问日志 import org.slf4j.Logger; import org.slf4j.LoggerFactory; //.. public class AccessHistoryInterceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { StringBuilder stb = new StringBuilder(); stb.append(request.getRemoteAddr()).append("|").append(request.getRequestURL()).append("|").append(request.getHeader("user-agent")); logger.info(stb.toString()); return true; } } <?xml version="1.0" encoding="UTF-8" ?> <configuration> <appender name="accessHistoryInterceptor" class="ch.qos.logback.core.rolling.RollingFileAppender"> <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"> <fileNamePattern>C:/Users/ida/Desktop/history.%d.log</fileNamePattern> </rollingPolicy> <encoder> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> <charset>UTF-8</charset> </encoder> </appender> <logger name="com.ida.demo11.restful.interceptor.AccessHistoryInterceptor" level="INFO" additivity="false"> <appender-ref ref="accessHistoryInterceptor"/> </logger> </configuration> servlet-api 在开发过滤器时引入 javax.servlet-api 依赖的主要原因是为了在开发环境中编译和验证过滤器代码. IDE 需要依赖 Servlet API 的类和接口来识别和编译 Servlet 相关的代码 scope 被设置为 provided 不参与发布, 运行时由Servlet 容器（比如 Tomcat）提供 <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency>`,``,`html`,`SSM图书点评`,`20240508101739-_项目例 SSM框架 SSM框架是指Spring + SpringMVC + MyBatis的组合，是一种用于构建Java Web应用程序的常见技术组合 开发者可以使用Spring来管理应用程序的组件，使用SpringMVC来处理Web请求和响应，使用MyBatis来访问数据库。 Spring框架： 提供了一个全功能的IoC（控制反转）容器和AOP（面向切面编程）容器，简化了Java开发中的配置和开发过程。Spring框架还提供了如事务管理、数据访问支持、消息传递等。 Spring 框架的核心模块: spring-core, spring-beans, spring-context, spring-aop, spring-tx, spring-expression (SpEL) SpringMVC框架： 基于MVC（模型-视图-控制器）模式，用于构建Web应用程序的Web层。SpringMVC框架提供了易于扩展和灵活的方式来处理HTTP请求和响应。 Spring MVC 构建在 Spring 核心之上，除了依赖 Spring 的核心模块外，还包括了 spring-web, spring-webmvc 引入 spring-webmvc 依赖时，实际上引入了整个 Spring 框架的核心功能以及 Spring MVC 的所有功能。这意味着你无需单独引入其他 Spring 核心依赖 MyBatis框架： 是一个持久层框架，简化了数据库访问代码的编写。MyBatis使用XML或注解配置SQL映射，将Java方法与SQL语句进行映射，避免了手动编写大量的JDBC代码。 整合步骤 Spring与Spring MVC环境配置 web.xml配置DispatcherServlet 整合freemarker视图, 需要spring-context-support的支持 引入jackson序列化工具, Spring MVC 默认支持 Jackson 作为 JSON 消息转换器，因此通常不需要额外配置 设置请求响应编码 Spring与mybatis整合 mysql驱动 spring-jdbc提供对JDBC事务的管理功能, MyBatis本身不管理事务，它依赖于外部的事务管理器 druid替代MyBatis自带的数据库连接池 mybatis mybatis-spring, 提供了MyBatis 和 Spring 的事务管理集成, SqlSessionFactoryBean简化了配置MyBatis的过程, Mapper 扫描, SqlSessionTemplate 其它组件 spring-test 用于处理 Spring 特性和上下文相关的测试 junit 用于基本的测试结构和执行 表和功能 20240824093004.webp 20240824093005.webp 20240824093740.webp 配置文件 pom.xml <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <springframework.version>5.1.9.RELEASE</springframework.version> <jackson.version>2.16.0</jackson.version> </properties> <dependencies> <!-- spring mvc, 专注于 Web 应用的 MVC 部分，处理请求、响应、视图解析等 --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>&#36;{springframework.version}</version> </dependency> <!-- spring context support,对 Spring 核心功能的扩展支持，特别是在集成其他常见的 Java EE 技术和第三方库时 --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context-support</artifactId> <version>&#36;{springframework.version}</version> </dependency> <!-- spring jdbc --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>&#36;{springframework.version}</version> </dependency> <!-- spring test --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>&#36;{springframework.version}</version> </dependency> <!-- jackson --> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-core</artifactId> <version>&#36;{jackson.version}</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>&#36;{jackson.version}</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-annotations</artifactId> <version>&#36;{jackson.version}</version> </dependency> <!-- mysql, mybatis --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.33</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.9</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId><!-- 与 Spring 的事务管理、依赖注入 (DI) 等功能集成 --> <version>2.0.3</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.2.23</version> </dependency> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus</artifactId> <version>3.3.2</version> </dependency> <!-- freemarker --> <dependency> <groupId>org.freemarker</groupId> <artifactId>freemarker</artifactId> <version>2.3.30</version> </dependency> <!-- logback --> <dependency> <groupId>ch.qos.logback</groupId> <artifactId>logback-classic</artifactId> <version>1.2.3</version> </dependency> <!-- jsoup --> <dependency> <groupId>org.jsoup</groupId> <artifactId>jsoup</artifactId> <version>1.17.2</version> </dependency> <!-- 图形验证码 --> <dependency> <groupId>com.github.penggle</groupId> <artifactId>kaptcha</artifactId> <version>2.3.2</version> </dependency> <!-- 文件上传 --> <dependency> <groupId>commons-fileupload</groupId> <artifactId>commons-fileupload</artifactId> <version>1.4</version> </dependency> <!-- 编解码 --> <dependency> <groupId>commons-codec</groupId> <artifactId>commons-codec</artifactId> <version>1.14</version> </dependency> <!-- 编译时容器 --> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <!-- Maven 编译插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <!-- Maven WAR 插件 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.4.0</version> </plugin> </plugins> </build> web.xml <?xml version="1.0" encoding="UTF-8"?> <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"> <servlet> <servlet-name>springmvc</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>classpath:applicationContext*.xml</param-value> </init-param> <load-on-startup>0</load-on-startup> </servlet> <servlet-mapping> <servlet-name>springmvc</servlet-name> <!-- / 匹配根路径 (/) 和所有没有被其他更具体的 url-pattern 映射的路径, 它不会拦截静态资源的请求 --> <!-- /* 拦截所有的请求，包括根路径 (/)、所有子路径，以及静态资源的请求--> <!-- 两者的区别在于 /* 还会捕获静态资源，而 / 只捕获动态内容的请求，且不干涉静态资源的处理--> <url-pattern>/</url-pattern> </servlet-mapping> <filter> <filter-name>characterFilter</filter-name> <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class> <init-param> <param-name>encoding</param-name> <param-value>UTF-8</param-value> </init-param> </filter> <filter-mapping> <filter-name>characterFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> </web-app> applicationContext.xml <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/task https://www.springframework.org/schema/task/spring-task.xsd "> <context:component-scan base-package="com.ida.demo12"/><!-- 组件扫描 --> <!-- 确保所有无法匹配到控制器的请求（主要是静态资源）能够正常返回，而不会被 DispatcherServlet 拦截或报错 --> <mvc:default-servlet-handler/> <mvc:annotation-driven><!-- 启用Spring MVC注解 --> <mvc:message-converters> <bean class="org.springframework.http.converter.StringHttpMessageConverter"><!-- 处理 HTTP 请求和响应的消息体乱码 --> <property name="supportedMediaTypes"> <list> <value>text/html;charset=utf-8</value> <value>application/json;charset=utf-8</value> </list> </property> </bean> </mvc:message-converters> </mvc:annotation-driven> <task:annotation-driven/><!-- 启用Spring Task的注解模式 --> <!-- 数据源,连接池,事务管理,mybatisplus --> <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/> <property name="url" value="jdbc:mysql://localhost:3306/reader?useSSL=true&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true"/> <property name="username" value="root"/> <property name="password" value="root"/> <property name="initialSize" value="5"/> <property name="maxActive" value="20"/> </bean> <!-- <bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"> --> <bean id="sessionFactory" class="com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean"> <property name="dataSource" ref="dataSource"/> <property name="mapperLocations" value="classpath:mappers/*.xml"/><!-- 映射文件地址 --> <property name="plugins"> <list> <bean class="com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor"/><!-- 分页插件 --> </list> </property> <property name="configuration"> <bean class="com.baomidou.mybatisplus.core.MybatisConfiguration"> <property name="mapUnderscoreToCamelCase" value="true"/><!-- 命名转换 --> </bean> </property> </bean> <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"> <property name="basePackage" value="com.ida.demo12.mapper"/><!-- mapper接口存放目录 --> </bean> <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> <property name="dataSource" ref="dataSource"/> </bean> <tx:annotation-driven transaction-manager="transactionManager"/><!-- 启用声明式事务 --> <!-- 视图解析器 --> <bean id="freeMarkerViewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"> <property name="contentType" value="text/html;charset=utf-8"/> <property name="suffix" value=".ftl"/> </bean> <bean id="freeMarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"> <property name="templateLoaderPath" value="/WEB-INF/ftl"/> <property name="freemarkerSettings"> <props> <prop key="defaultEncoding">UTF-8</prop> </props> </property> </bean> <!-- @Resource注入, private Producer kaptchaProducer; --> <bean id="kaptchaProducer" class="com.google.code.kaptcha.impl.DefaultKaptcha"> <property name="config"> <bean class="com.google.code.kaptcha.util.Config"> <constructor-arg> <props> <prop key="kaptcha.border">no</prop> <prop key="kaptcha.image.width">120</prop> <prop key="kaptcha.textproducer.font.color">blue</prop> <prop key="kaptcha.textproducer.font.size">40</prop> <prop key="kaptcha.textproducer.char.length">4</prop> </props> </constructor-arg> </bean> </property> </bean> <!-- 配置Spring MVC中如何处理文件上传, 指定Apache Commons FileUpload 实现的 CommonsMultipartResolver 作为文件上传解析器 --> <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> <property name="defaultEncoding" value="utf-8"/><!-- 处理文件名或者表单字段中文乱码 --> </bean> </beans> Spring MVC乱码处理 StringHttpMessageConverter applicationContext.xml 中配置的 StringHttpMessageConverter 主要负责在请求和响应过程中处理 String 类型的数据转换，并设置字符编码（如 UTF-8）以避免乱码。 这个配置主要影响 String 类型数据的转换，不会对所有的请求和响应做全局的字符编码处理。 CharacterEncodingFilter CharacterEncodingFilter 是一个 Servlet 过滤器，用于在请求和响应过程中统一设置字符编码。它处理所有请求和响应, 而不仅仅是 String 类型的数据，确保整个应用中的字符编码一致。 虽然 StringHttpMessageConverter 可以处理 String 类型的数据并设置字符编码，但配置 CharacterEncodingFilter 仍然有其必要性 mybatis-plus mybatis-plus在mybatis基础上做了非侵入式增强,自动实现Mapper CRUD SqlSessionFactoryBean替换为MybatisSqlSessionFactoryBean mybatis-config中增加PaginationInterceptor 使用方法 创建与数据表对应的实体类,@TableName(表和实体),@TableId(表的主键),@TableField(表字段和实体字段) @TableField(exist = false) 字段不参与sql自动生成时加此注解 创建对应的Mapper接口继承BaseMapper,创建对应的Mapper XML(里面不需要去写典型的curd) 注入Mapper对象,通过内置API实现CRUD 20240509102535.webp Spring Task Cron表达式 20240804151117.webp 每分钟的0秒执行一次 2000年的时候每小时前5分钟内的0秒或30秒的时候执行一次, [-]范围, [,]或 每周三的9到18时内整点的时候执行一次, 日和星期互斥 @Component public class ComputeTask { @Resource private BookService bookService; @Scheduled(cron = "0 * * * * ?") //需要启用task:annotation-driven public void updateScoreAndQuantity(){ bookService.updateScoreAndQuantity(); try { PrintStream printStream = new PrintStream(System.out, true, "UTF-8"); System.setOut(printStream); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } System.out.println("已更新所有图片评分和评论数量"); } } <update id="updateScoreAndQuantity"> update reader.book b set evaluation_quantity=(select ifnull(count(*),0) from reader.evaluation where book_id = b.book_id and state='enable'), evaluation_score=(select ifnull(avg(score),0) from reader.evaluation where book_id = b.book_id and state='enable') </update> kaptcha @Controller public class KaptchaController { @Resource private Producer kaptchaProducer; //手动放到容器的bean @GetMapping("/verify_code") public void createVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException { String verifyCode = kaptchaProducer.createText(); request.getSession().setAttribute("kaptchaVerifyCode",verifyCode); System.out.println(verifyCode); BufferedImage image = kaptchaProducer.createImage(verifyCode); response.setDateHeader("Expires",0); response.setHeader("Cache-Control","no-store,no-cache,must-revalidate"); response.setHeader("Cache-Control","post-check=0,pre-check=0"); response.setHeader("Pragma","no-cache"); response.setContentType("image/png"); ServletOutputStream outputStream = response.getOutputStream(); ImageIO.write(image,"png",outputStream); outputStream.flush(); outputStream.close(); } } wangEditor <script src="/resources/wangEditor.min.js"></script> <button id="btnRead">读取</button> <button id="btnWrite">写入</button> <div id="divEditor" style="width: 800px;height: 600px"></div> <script> var E = window.wangEditor; var editor = new E("#divEditor"); editor.create(); document.getElementById("btnRead").onclick = function (){ var content = editor.txt.html(); alert(content); } document.getElementById("btnWrite").onclick = function (){ var content = "<li style='color:red'> a <b>b</b> c </li>" editor.txt.html(content); } </script>`,``,`html`,`StrokeIt的使用`,`20240307183503-_工具使用 键名表示 supported Keys from the Keystroke plugin Key Description [BACK] [BACK_DOWN] [BACK_UP] BACKSPACE key [TAB] [TAB_DOWN] [TAB_UP] TAB key [RETURN] [RETURN_DOWN] [RETURN_UP] ENTER key [SHIFT] [SHIFT_DOWN] [SHIFT_UP] SHIFT key [CTRL] [CTRL_DOWN] [CTRL_UP] CTRL key [ALT] [ALT_DOWN] [ALT_UP] ALT key [CAPITAL] [CAPITAL_DOWN] [CAPITAL_UP] CAPS LOCK [ESCAPE] [ESCAPE_DOWN] [ESCAPE_UP] ESC key [SPACE] [SPACE_DOWN] [SPACE_UP] SPACEBAR [PRIOR] [PRIOR_DOWN] [PRIOR_UP] PAGE UP key [END] [END_DOWN] [END_UP] END key [HOME] [HOME_DOWN] [HOME_UP] HOME key [NUMLOCK] [NUMLOCK_DOWN] [NUMLOCK_UP] NUM LOCK>key [SCROLL] [SCROLL_DOWN] [SCROLL_UP] SCROLL LOCK key [LEFT_DOWN] [LEFT_UP] LEFT ARROW key [UP] [UP_DOWN] [UP_UP] UP ARROWkey [RIGHT_DOWN] [RIGHT_UP] RIGHT ARROW key [DOWN] [DOWN_DOWN] [DOWN_UP] DOWN ARROW key [SNAPSHOT] [SNAPSHOT_DOWN] [SNAPSHOT_UP] PRINT SCREEN key for Windows 3.0 and later [INSERT] [INSERT_DOWN] [INSERT_UP] INS key [DELETE] [DELETE_DOWN] [DELETE_UP] DEL key [WIN] [WIN_DOWN] [WIN_UP] Left Windows key (Microsoft Natural Keyboard) [LWIN] [LWIN_DOWN] [LWIN_UP] Left Windows key (Microsoft Natural Keyboard) [RWIN] [RWIN_DOWN] [RWIN_UP] Right Windows key (Microsoft Natural Keyboard) [APPS] [APPS_DOWN] [APPS_UP] Applications key (Microsoft Natural Keyboard) [NUMPAD0] [NUMPAD0_DOWN] [NUMPAD0_UP] Numeric keypad0 key [NUMPAD1] [NUMPAD1_DOWN] [NUMPAD1_UP] Numeric keypad1 key [NUMPAD2] [NUMPAD2_DOWN] [NUMPAD2_UP] Numeric keypad2 key [NUMPAD3] [NUMPAD3_DOWN] [NUMPAD3_UP] Numeric keypad3 key [NUMPAD4] [NUMPAD4_DOWN] [NUMPAD4_UP] Numeric keypad4 key [NUMPAD5] [NUMPAD5_DOWN] [NUMPAD5_UP] Numeric keypad5 key [NUMPAD6] [NUMPAD6_DOWN] [NUMPAD6_UP] Numeric keypad6 key [NUMPAD7] [NUMPAD7_DOWN] [NUMPAD7_UP] Numeric keypad7 key [NUMPAD8] [NUMPAD8_DOWN] [NUMPAD8_UP] Numeric keypad8 key [NUMPAD9] [NUMPAD9_DOWN] [NUMPAD9_UP] Numeric keypad9 key [MULTIPLY] [MULTIPLY_DOWN] [MULTIPLY_UP] Multiply key [ADD] [ADD_DOWN] [ADD_UP] Add key [SEPARATOR] [SEPARATOR_DOWN] [SEPARATOR_UP] Separator key [SUBTRACT] [SUBTRACT_DOWN] [SUBTRACT_UP] Subtract key [DECIMAL] [DECIMAL_DOWN] [DECIMAL_UP] Decimal key [DIVIDE] [DIVIDE_DOWN] [DIVIDE_UP] Dividekey [F1] [F1_DOWN] [F1_UP] F1 key [F2] [F2_DOWN] [F2_UP] F2 key [F3] [F3_DOWN] [F3_UP] F3 key [F4] [F4_DOWN] [F4_UP] F4 key [F5] [F5_DOWN] [F5_UP] F5 key [F6] [F6_DOWN] [F6_UP] F6 key [F7] [F7_DOWN] [F7_UP] F7 key [F8] [F8_DOWN] [F8_UP] F8 key [F9] [F9_DOWN] [F9_UP] F9 key [F10] [F10_DOWN] [F10_UP] F10 key [F11] [F11_DOWN] [F11_UP] F11 key [F12] [F12_DOWN] [F12_UP] F12 key [F13] [F13_DOWN] [F13_UP] F13 key [F14] [F14_DOWN] [F14_UP] F14 key [F15] [F15_DOWN] [F15_UP] F15 key [F16] [F16_DOWN] [F16_UP] F16 key [F17] [F17_DOWN] [F17_UP] F17 key [F18] [F18_DOWN] [F18_UP] F18 key [F19] [F19_DOWN] [F19_UP] F19 key [F20] [F20_DOWN] [F20_UP] F20 key [F21] [F21_DOWN] [F21_UP] F21 key [F22] [F22_DOWN] [F22_UP] F22 key [F23] [F23_DOWN] [F23_UP] F23 key [F24] [F24_DOWN] [F24_UP] F24 key [CANCEL] [CANCEL_DOWN] [CANCEL_UP] Control-break processing [CLEAR] [CLEAR_DOWN] [CLEAR_UP] CLEAR key [PAUSE] [PAUSE_DOWN] [PAUSE_UP] PAUSE key [SELECT] [SELECT_DOWN] [SELECT_UP] SELECTkey [EXECUTE] [EXECUTE_DOWN] [EXECUTE_UP] EXECUTE key [HELP] [HELP_DOWN] [HELP_UP] HELP key \\ BACKSLASH key \\[ square bracket eg //excel删除单元格所属行(整体上移) //shift + 空格(选中单元格所在行), shift + f10(右键菜单),D(删除) [SHIFT_DOWN][SPACE_DOWN][SPACE_UP][SHIFT_UP][SHIFT_DOWN][F10_DOWN][F10_UP][SHIFT_UP]d //excel单元格上方插入新行 //ctrl + shift + =, R(整行) [CTRL_DOWN][SHIFT_DOWN]=[SHIFT_UP][CTRL_UP][ALT_DOWN]r[ALT_UP][RETURN]`,``,`html`,`Struts2`,`20240830175625-_java web Struts 2 是一个基于拦截器的框架，每个请求都会经过一系列的拦截器，然后交由 Action 类处理。拦截器负责处理常见任务，如输入验证、文件上传等 Action 类不是强制性地依赖于框架特定的 API，开发者可以将普通的 Java 类作为 Action 主要依赖于 XML 配置（如 struts.xml）来定义 Action、拦截器、结果视图等。虽然 Struts 2 也支持注解配置，但 XML 仍然是主要的配置方式。 Struts 2 提供了一套自定义拦截器机制，允许开发者在请求处理前后插入自定义逻辑。 它支持与其他框架集成（如 Hibernate、Spring），但需要额外配置和手动管理 Struts 2 支持多种视图技术，如 JSP、FreeMarker、Velocity 等。视图层通过 Action 返回的结果来决定。 truts 2 提供了标签库（Taglib），简化了 JSP 页面开发 相对较旧，使用者较少。对于新手来说，学习曲线较陡峭，特别是在配置和拦截器机制上。社区支持较少，更新频率相对低 在处理每个请求时都会创建新的 Action 对象，这在一定程度上影响了性能，尤其是在高并发情况下。 Struts 2 适合那些已有的老项目或特定需要使用 Struts 技术栈的项目，但新项目一般不建议使用 Struts 2。 Struts 2 的主要优点在于它的灵活性、强大的拦截器机制、丰富的视图支持以及简化的 Action 类设计。尽管在现代开发中被 Spring MVC 等框架所超越，但对于特定项目或已有的 Struts 2 应用，它仍然是一个强大且可靠的选择 Spring MVC 是 Spring 框架的一部分，完全基于 DispatcherServlet 的中央控制器设计模式。它将所有请求分派给具体的控制器（Controller）。 Spring MVC 强调使用注解（如 @Controller, @RequestMapping 等）来简化配置和代码开发。 Spring MVC 自然集成在 Spring 生态系统中，可以轻松与 Spring 的其他模块（如 Spring Data, Spring Security）无缝协作 Spring MVC 也支持多种视图技术，包括 JSP、Thymeleaf、Freemarker 等。开发者可以灵活选择和配置 通过 ModelAndView 或 @ResponseBody 等机制，开发者可以灵活地控制视图的生成和响应 拥有广泛的社区支持和文档资源。由于 Spring MVC 是 Spring 框架的一部分，许多开发者已经熟悉 Spring 的核心概念，因此学习曲线相对较平缓 Spring MVC 的 Controller 是单例的（默认情况下），因此性能相对较好，特别是在高并发环境中表现更为稳定 Spring MVC 更适合现代 Web 开发，特别是如果你已经在使用 Spring 框架或者打算使用 Spring 的生态系统，Spring MVC 是一个更好的选择。`,``,`html`,`The History of Tom Jones, A Foundling`,`20240307183503-双语`,``,`html`,`Thymeleaf`,`20240830182411-_视图 Thymeleaf 是一个现代化的 Java 模板引擎，特别适合与 Spring Framework 集成。它的设计理念使得模板在未经过处理时依然能够作为有效的 HTML 查看 Spring Boot 默认已经配置好了 Thymeleaf，无需进行额外的设置 片段: 使用 th:fragment 定义模板片段，可在其他模板中引用。 布局: 可以使用布局系统（类似于 th:replace 和 th:include）来创建可复用的页面布局。 国际化: 使用 th:text 或其他属性来引用国际化资源文件中的文本。 自然模板: Thymeleaf 模板可以作为有效的 HTML 直接查看，无需服务器处理。 与 Spring 的无缝集成: 支持 Spring MVC 的所有功能，如表单绑定、验证、国际化等。 强大的表达式语言: 支持复杂的表达式、条件判断、循环和文本处理。 灵活性: 支持多种模板模式，如 HTML、XML、文本等。 src/main/resources/templates: 这是 Thymeleaf 模板的默认目录。Spring Boot 会自动从这个目录加载 Thymeleaf 模板文件 改变默认的模板位置 spring.thymeleaf.prefix=classpath:/my-templates/ spring.thymeleaf.suffix=.html 语法 th命名空间声明 所有以 th: 开头的属性都是 Thymeleaf 的自定义属性，而不是普通 HTML 属性, 避免了与 HTML 标准属性的冲突 <!DOCTYPE html> <html xmlns:th="http://www.thymeleaf.org"> 集合对象提取 基本遍历 使用 th:each 属性来遍历集合。可以遍历 List、Set、数组等集合类型 <ul> <li th:each="item : &#36;{items}" th:text="&#36;{item}"></li> </ul> <table border="1"> <thead> <tr> <th>Key</th> <th>Value</th> </tr> </thead> <tbody> <!-- 遍历 Map --> <tr th:each="entry : &#36;{myMap}"> <td th:text="&#36;{entry.key}"></td> <td th:text="&#36;{entry.value}"></td> </tr> </tbody> </table> 循环变量 <!-- 索引从 0 开始 --> <ul> <li th:each="item, iterStat : &#36;{items}" th:text="&#36;{iterStat.index + 1} + '. ' + &#36;{item}"></li> </ul> <!-- 检查当前元素是否是第一个或最后一个, 三目表达式--> <ul> <li th:each="item, iterStat : &#36;{items}" th:text="&#36;{item}" th:classappend="&#36;{iterStat.first} ? 'first-item' : ''" th:classappend="&#36;{iterStat.last} ? 'last-item' : ''"> <!-- 如果当前元素是是最后一个元素, 为其添加last-item类样式--> </li> </ul> 条件判断, th:if, th:unless <ul> <li th:each="item : &#36;{items}" th:text="&#36;{item}" th:if="&#36;{item % 2 == 0}"> </li> </ul> 集合信息 <p th:text="'Total items: ' + &#36;{#lists.size(items)}"></p> <p th:if="&#36;{#lists.isEmpty(items)}">The list is empty.</p> <p th:if="&#36;{not #lists.isEmpty(items)}">The list has items.</p> 片段和局部变量 <ul> <li th:each="item, iterStat : &#36;{items}" th:text="&#36;{item} (&#36;{iterStat.index})" th:classappend="&#36;{iterStat.index % 2 == 0} ? 'even' : 'odd'"> </li> </ul> 嵌套循环,子集合 <table> <tr th:each="row : &#36;{table}"> <td th:each="cell : &#36;{row}" th:text="&#36;{cell}"></td> </tr> </table> <ul> <li th:each="group : &#36;{groups}"> <h2 th:text="&#36;{group.name}"></h2> <ul> <li th:each="member : &#36;{group.members}" th:text="&#36;{member}"></li> </ul> </li> </ul> <ul> <li th:each="outerEntry : &#36;{nestedMap}"> <strong th:text="&#36;{outerEntry.key}">Outer Key</strong> <ul> <li th:each="innerEntry : &#36;{outerEntry.value}"> <strong th:text="&#36;{innerEntry.key}">Inner Key</strong>: <span th:text="&#36;{innerEntry.value}">Inner Value</span> </li> </ul> </li> </ul> Thymeleaf 内置集合对象, #arrays、#lists、#maps、#strings <p th:text="&#36;{#arrays.size(arrayVariable)}">Array Size</p> <p th:text="&#36;{items[2]}">List Item</p> <p th:text="'Size of list: ' + &#36;{#lists.size(items)}"></p> <p th:text="'Is empty: ' + &#36;{#lists.isEmpty(items)}"></p> <p th:if="&#36;{not #maps.isEmpty(sampleMap)}">The map has entries.</p> <p th:text="&#36;{#maps.get(mapVariable, 'key')}">Map Value</p> <p th:text="'Upper case: ' + &#36;{#strings.toUpperCase(name)}"></p> 动态class属性 动态地向 HTML 元素的 class 属性添加 CSS 类 <!-- 如果 item.selected 为 true，selected 类将被追加到 li 元素的 class 属性中--> <ul> <li th:each="item : &#36;{items}" th:classappend="&#36;{item.selected} ? 'selected' : ''"> <span th:text="&#36;{item.name}"></span> </li> </ul> <div class="box" th:classappend="&#36;{isActive} ? 'active' : ''" th:classappend="&#36;{isDisabled} ? 'disabled' : ''"> Content </div> <div th:classappend="&#36;{userRole == 'admin'} ? 'admin' : ''" th:classappend="&#36;{userRole == 'user'} ? 'user' : ''"> Content </div> 片段模板 可以被其他模板引用的 HTML 片段 定义一个片段 <!-- src/main/resources/templates/fragments.html --> <!DOCTYPE html> <html xmlns:th="http://www.thymeleaf.org"> <head> <title>片段示例</title> </head> <body> <div th:fragment="header"> <header> <h1>网站标题</h1> <nav> <ul> <li><a href="/home">首页</a></li> <li><a href="/about">关于</a></li> </ul> </nav> </header> </div> <div th:fragment="footer"> <footer> <p>© 2024 版权声明</p> </footer> </div> </body> </html> 在其他模板中引用片段 th:replace: 移除自身，插入片段的内容 th:include: 插入片段的内容，并为它套上自己所用的标签 <!-- src/main/resources/templates/index.html --> <!DOCTYPE html> <html xmlns:th="http://www.thymeleaf.org"> <head> <title>首页</title> </head> <body> <!-- 引用 header 片段 --> <div th:replace="fragments :: header"></div> <main> <h2>欢迎来到我们的站点</h2> <p>这是主页内容。</p> </main> <!-- 引用 footer 片段 --> <div th:include="fragments :: footer"></div> </body> </html> 定义带参数的片段 <!-- src/main/resources/templates/fragments.html --> <div th:fragment="greeting(name)"> <p>Hello, <span th:text="&#36;{name}">User</span>!</p> </div> 引用带参数的片段 <!-- src/main/resources/templates/index.html --> <div th:replace="fragments :: greeting('World')"></div> 日期格式化 th:text="&#36;{#dates.format(cat.birthday, 'yyyy-MM-dd')} 'dd/MM/yyyy' -> 22/06/2021 'MMMM dd, yyyy' -> June 22, 2021 'EEE, MMM d, ''yy' -> Tue, Jun 22, '21 #dates可以格式化 java.util.Date、java.time.LocalDate #calendars 是一个用于处理 java.util.Calendar 字符串方法 #strings.capitalize : 将字符串的第一个字母转换为大写。 : #strings.capitalize('hello') 结果为 Hello #strings.uncapitalize : 将字符串的第一个字母转换为小写。 : #strings.uncapitalize('Hello') 结果为 hello #strings.abbreviate : 缩短字符串到指定长度，并在末尾添加省略号。 : #strings.abbreviate('This is a long text', 10) 结果为 This is a... #strings.strip : 去除字符串的前后空白字符。 : #strings.strip(' text ') 结果为 text #strings.left : 获取字符串的左边指定长度的子字符串。 : #strings.left('Hello World', 5) 结果为 Hello #strings.right : 获取字符串的右边指定长度的子字符串。 : #strings.right('Hello World', 5) 结果为 World #strings.substring : 获取字符串中指定范围的子字符串。 : #strings.substring('Hello World', 0, 5) 结果为 Hello #strings.contains : 判断字符串是否包含指定的子字符串。 : #strings.contains('Hello World', 'World') 结果为 true #strings.indexOf : 查找指定子字符串在主字符串中的第一次出现位置。 : #strings.indexOf('Hello World', 'World') 结果为 6 #strings.lastIndexOf : 查找指定子字符串在主字符串中的最后一次出现位置。 : #strings.lastIndexOf('Hello World World', 'World') 结果为 12 #strings.equalsIgnoreCase : 判断两个字符串是否相等，忽略大小写。 : #strings.equalsIgnoreCase('Hello', 'hello') 结果为 true #strings.compareToIgnoreCase : 比较两个字符串的顺序，忽略大小写。 : #strings.compareToIgnoreCase('abc', 'ABC') 结果为 0 #strings.isEmpty : 判断字符串是否为空。 : #strings.isEmpty('') 结果为 true #strings.isNotEmpty : 判断字符串是否非空。 : #strings.isNotEmpty('text') 结果为 true #strings.split : 根据指定的分隔符将字符串分割成子字符串数组。 : #strings.split('a,b,c', ',')[0] 结果为 a #strings.join : 将字符串数组或集合连接成一个字符串，使用指定的分隔符。 : #strings.join(['a', 'b', 'c'], ',') 结果为 a,b,c 其它内置对象 <!-- #context --> <p th:text="&#36;{#context.request.contextPath}">Context Path</p> <!-- #httpServletRequest --> <p th:text="&#36;{#httpServletRequest.getParameter('paramName')}">Request Parameter</p> <!-- #httpServletResponse --> <p th:utext="&#36;{#httpServletResponse.setContentType('text/html')}"></p> <!-- #request --> <p th:text="&#36;{#request.getAttribute('attributeName')}">Request Attribute</p> <!-- #response --> <p th:text="&#36;{#response.setHeader('headerName', 'headerValue')}">Response Header</p> <!-- #session --> <p th:text="&#36;{#session.getAttribute('sessionAttribute')}">Session Attribute</p> <!-- #locale 处理国际化（i18n） --> <p th:text="&#36;{#locale.language}">Language</p> <!-- #numbers --> <p th:text="&#36;{#numbers.formatDecimal(12345.6789, 2)}">Formatted Number</p> <!-- #urls 提供 URL 编码和解码功能 --> <p th:text="&#36;{#urls.encode('some value')}">Encoded URL</p> spring boot + thymeleaf + hibernate 20240831164235.webp pom <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <spring-boot.version>2.3.12.RELEASE</spring-boot.version> </properties> <dependencyManagement> <dependencies> <!-- boot版本 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>&#36;{spring-boot.version}</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <!-- starter-web --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!-- starter-validation --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-validation</artifactId> </dependency> <!-- thymeleaf --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> <!-- Spring Boot Starter Data JPA --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <!-- MySQL Connector --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <!-- devtools --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> </dependency> </dependencies> application.properties server.port=8000 # 数据库连接配置 spring.datasource.url=jdbc:mysql://localhost:3306/testdb?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai spring.datasource.username=root spring.datasource.password=root # Hibernate 配置 spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect # 物理命名, 隐式命名策略 spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy spring.jpa.hibernate.naming.implicit-strategy=org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy file.upload-dir=D:/mess/ 表 create table if not exists testdb.user2 ( id bigint auto_increment primary key, name varchar(32) null, birthday date null, gender varchar(32) null, interests varchar(64) null, avatar varchar(128) null ); 实体类 public class Cat { private String name; private Date birthday; private Master master; //getter,setter,constructor } public class Master { private String name; //getter,setter,constructor } @Entity @Table(name = "user2") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = "birthday") private Date birthday; private String name; private String gender; private String interests; private String avatar; //getter,setter } DAO public interface UserRepository extends JpaRepository<User, Long> { } 请求对象 public class FormReq { @NotEmpty(message = "名字不能为空") private String name; @NotNull(message = "不能为空") @Past(message = "出生年不能大于当前时间") @DateTimeFormat(pattern = "yyyy-MM-dd") private Date birthday; @NotNull(message = "不能为空") private String gender; private List<String> interests; private MultipartFile avatar; //getter,setter } 服务类 @Service("userService") public class UserServiceImpl implements UserService { @Resource private UserRepository userRepository; @Value("&#36;{file.upload-dir}") private String uploadDir; @Override public String upload(MultipartFile file) { String fileName = "default_avatar.png"; //如果没有上传图片,使用默认图片 if (file != null && !file.isEmpty()) { // 类路径下的资源通常是只读的，因为它们被打包到 JAR 文件中。 // 在实际应用中，你一般不在类路径下写入文件。如果你需要写入文件，通常使用外部文件系统路径。 String rawFileName = file.getOriginalFilename(); fileName = UUID.randomUUID() + rawFileName.substring(rawFileName.lastIndexOf(".")); File _uploadDir = new File(uploadDir); if (!_uploadDir.exists()) { _uploadDir.mkdirs(); } try { Files.copy(file.getInputStream(), Paths.get(uploadDir, fileName)); } catch (IOException e) { e.printStackTrace(); } } ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = requestAttributes.getRequest(); String baseUrl = request.getRequestURL().toString().replace(request.getRequestURI(), ""); return baseUrl + "/avatar/" + fileName; } @Override public User createUser(User user){ return userRepository.save(user); } @Override public User getUserById(Long id) { return userRepository.findById(id).orElse(null); } } 控制器 BindingResult 当表单提交时如果字段验证失败，错误信息存储在 BindingResult 对象中，与表单对象一起传递给控制器 在控制器中如果 BindingResult 对象包含错误，Spring 会将这些错误信息绑定到模型中 通过像th:if="&#36;{#fields.hasErrors('birthday')}"来检查和渲染错误信息 RedirectAttributes 用于在重定向（redirect）时传递数据。 HTTP 是无状态的，当你在控制器中执行重定向时，任何添加到 Model 中的数据将不会在重定向后的页面上显示 传递闪存属性 闪存属性是在重定向后仍然可用的数据。 使用 addFlashAttribute 方法可以在重定向后临时存储数据，数据会存储在用户的会话（session）中，并在重定向后的页面加载完成后自动从会话中移除。 这是处理用户表单提交后的消息显示（如成功消息或错误消息）的常用方法 redirectAttributes.addFlashAttribute("message", "用户信息已保存！"); return "redirect:/ok"; 在 success.html 模板中，你可以使用 Thymeleaf 的 &#36;{message} 来读取并显示 Flash 属性 传递 URL 参数 使用 addAttribute 方法可以将参数附加到重定向的 URL 中。它适用于需要将简单的参数传递给下一个请求的情况 redirectAttributes.addAttribute("name", John); redirectAttributes.addAttribute("id", 123); return "redirect:/success"; 重定向后的 URL 会变成 /success?name=John&id=123 @Controller public class HelloController { @Resource private UserService userService; @GetMapping("/") public String index(Model model) { model.addAttribute("name","World"); Cat cat1 = new Cat("虎皮猫1号", new GregorianCalendar(2021, Calendar.JUNE, 22).getTime(), new Master("小明")); Cat cat2 = new Cat("虎皮猫2号", new GregorianCalendar(2022, Calendar.JUNE, 22).getTime(), new Master("小丽")); model.addAttribute("cats", Stream.of(cat1,cat2).collect(Collectors.toList())); return "index"; //视图名称无需扩展名, 方法有@ResponseBody时直接写入HTTP响应，而不是作为视图名称去解析 } @GetMapping("/personal_info") public String personal_info(Model model) { // 确保添加了一个空的 FormReq 对象到模型中 model.addAttribute("formReq", new FormReq()); return "form"; } @PostMapping("/submit") public String submit(@Valid FormReq formReq, BindingResult result, RedirectAttributes redirectAttributes) { if (result.hasErrors()) { return "form"; // 返回到表单页面以渲染错误信息, 也可以参考boot电商参数校验错误全局处理 } String avatarUrl = userService.upload(formReq.getAvatar()); User user = new User(); user.setName(formReq.getName()); user.setBirthday(formReq.getBirthday()); user.setGender(formReq.getGender()); user.setInterests(String.join(", ", formReq.getInterests())); user.setAvatar(avatarUrl); user = userService.createUser(user); redirectAttributes.addAttribute("id", user.getId()); return "redirect:/success"; } @GetMapping("/success") public ModelAndView success(Long id) { ModelAndView mav = new ModelAndView("preview"); User user = userService.getUserById(id); mav.addObject("user",user); return mav; } } 路径映射 @Configuration public class WebConfig implements WebMvcConfigurer { @Value("&#36;{file.upload-dir}") private String uploadDir; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler("/avatar/**") .addResourceLocations("file:"+ uploadDir); } } thymeleaf模板 index.html <!DOCTYPE html> <html xmlns:th="http://www.thymeleaf.org"> <head> <title>Thymeleaf 入门</title> </head> <body> <h1>欢迎使用 Thymeleaf!</h1> <!-- 未经过处理时依然能够作为有效的 HTML 显示 Hello, Guest! --> <p th:text="'Hello, ' + &#36;{name} + '!'">Hello, Guest!</p> <!-- 生成动态链接 --> <a th:href="@{/personal_info}">补充个人信息</a> <!-- 遍历列表 --> <ul> <li th:each="cat : &#36;{cats}"> <span th:text="&#36;{cat.name}"></span> 的饲主是 <span th:text="&#36;{cat.master.name}"></span> , 它的生日是 <span th:text="&#36;{#dates.format(cat.birthday, 'yyyy-MM-dd')}"></span><!-- 格式化 --> <span th:if="&#36;{cat.master.name} == '小丽'">, 喜欢抓蝴蝶</span><!-- 判断 --> </li> </ul> </body> </html> form.html <!DOCTYPE html> <html xmlns:th="http://www.thymeleaf.org"> <head> <title>个人信息填写</title> <style>.warn{color: red}</style> </head> <body> <h1>个人信息填写</h1> <!-- th:object 将表单绑定到模型中的 formReq 对象。结合th:field 将字段与 formReq 对象的属性进行绑定, 结合th:errors提示验证失败信息 --> <form th:action="@{/submit}" th:object="&#36;{formReq}" method="post" enctype="multipart/form-data"> <div> <label for="name">名字:</label> <input type="text" id="name" name="name" th:field="*{name}" /> <!-- 提交后如果验证失败, 后台携带失败信息重新渲染此页面 --> <span class="warn" th:if="&#36;{#fields.hasErrors('name')}" th:errors="*{name}">错误信息</span> </div> <div> <label for="birthday">生日:</label> <input type="date" id="birthday" name="birthday" th:field="*{birthday}" /> <span class="warn" th:if="&#36;{#fields.hasErrors('birthday')}" th:errors="*{birthday}">错误信息</span> </div> <div> <label>性别:</label> <div> <label> <input type="radio" name="gender" value="male" th:field="*{gender}" /> 男性 </label> <label> <input type="radio" name="gender" value="female" th:field="*{gender}" /> 女性 </label><span class="warn" th:if="&#36;{#fields.hasErrors('gender')}" th:errors="*{gender}">错误信息</span> </div> </div> <div> <label>兴趣爱好:</label> <div> <label> <input type="checkbox" name="interests" value="reading" th:field="*{interests}" /> 阅读 </label> <label> <input type="checkbox" name="interests" value="traveling" th:field="*{interests}" /> 旅行 </label> <label> <input type="checkbox" name="interests" value="cooking" th:field="*{interests}" /> 烹饪 </label> </div> </div> <div> <label for="avatar">头像:</label> <input type="file" id="avatar" name="avatar" accept="image/*" /> </div> <div> <button type="submit">提交</button> </div> </form> </body> </html> preview.html <!DOCTYPE html> <html xmlns:th="http://www.thymeleaf.org"> <head> <title>Thymeleaf 入门</title> </head> <body> <h1>个人信息预览</h1> <!-- 图片url --> <img width="200px" th:src="&#36;{user.avatar}" alt="用户头像"><br> 名字: <span th:text="&#36;{user.name}"></span><br> 生日: <span th:text="&#36;{#dates.format(user.birthday, 'yyyy-MM-dd')}"></span><br> 性别: <span th:text="&#36;{user.gender}"></span><br> 会员号: <span th:text="&#36;{user.id}"></span><br> 兴趣爱好: <span th:each="interest, iterStat : &#36;{#strings.listSplit(user.interests,',')}"><!-- 字符串分割为数组后遍历, Thymeleaf 3.0.0 及以后的版本中提供的一个方法 --> <span th:text="&#36;{interest}"></span> <span th:if="&#36;{!iterStat.last}"> | </span><!-- 判断是否为最后一个元素 --> </span> <br> <a th:href="@{/}">返回首页</a><br> </body> </html>`,``,`html`,`usb共享代理网络`,`20241121235112-_工具使用 代理软件的桌面端总不如移动端那样稳定持久，于是寻求usb直接共享代理网络的方法，gpt的回复是使用vpnhotspot，需要root，以下记述root的零碎步骤 下载安装usb驱动 设备管理器--添加驱动程序--选择inf所在目录 https://dl.google.com/android/repository/usb_driver_r13-windows.zip 下载SDK组件 解压后目录添加到环境变量 https://dl.google.com/android/repository/platform-tools-latest-windows.zip?hl=zh-cn 解锁BL 手机开发者模式, 允许oem解锁, 允许usb调试 解锁的同时将删除全部个人数据 fastboot devices fastboot flashing unlock 修补镜像 从原始出厂固件中提取boot.img https://developers.google.com/android/images?hl=zh-cn 下载magisk安装包 https://github.com/topjohnwu/Magisk/releases 两者拖到手机下载目录 手机安装magisk, 对boot.img进行修补, 生成的文件拖回桌面 刷入修补后镜像 adb devices adb reboot bootloader fastboot flash boot patched_image.img fastboot reboot 验证是否已root adb shell 在 ADB shell 中，输入su, 如果进入超级用户权限（通常命令提示符会从 $ 变为 #），说明设备已 Root；否则未 Root`,``,`html`,`vscode`,`20240326233524-_工具使用 快捷键 ctrl + shift + p:命令面板 ctrl + enter:向下新行 ctrl+ shift + enter:向上新行 ctrl + x: 剪切行(光标没有选择内容时) ctrl +shift + k: 删除行 alt + ↑/↓: 移动行 shift + alt + ↑/↓: 复制行 ctrl + d:全选光标所在的词,复按向下扩选同名词(扩选到某一处之后按下Ctrl + K跳过该处),然后多处重写 Ctrl + Shift + [/]: 折叠块 Shift + Alt +A: 块区域注释 贴码 制作jar包 对当前剪贴板内容转义,整体缩进 public class Escape { public static void main(String[] args) throws IOException, UnsupportedFlavorException { Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); String text = (String) clipboard.getContents(null).getTransferData(DataFlavor.stringFlavor); text = removeCommonLeadingWhitespace(text); // 处理缩进 text = text.replace("&lt;", "&amp;lt;"); text = text.replace("<", "&lt;"); // replace 适用于简单的字符或字符串替换。不支持正则表达式 // replaceAll 适用于基于正则表达式的复杂替换 // \r 匹配 回车符, 这是在旧式的 Windows 系统中用来表示行结束的字符（通常与换行符 \n 一起使用） // \n 匹配 换行符，这是在 Unix 和现代 Windows 系统中用来表示行结束的字符 // \r?\n 匹配 \r\n（Windows 行结束符）或仅 \n（Unix 行结束符） text = text.replaceAll("(?m)^[ \t]*\r?\n", " \n"); clipboard.setContents(new StringSelection(text), new StringSelection(text)); } // 处理缩进的方法 private static String removeCommonLeadingWhitespace(String text) { String[] lines = text.split("\n"); int minIndent = Integer.MAX_VALUE; for (String line : lines) { int indent = getLeadingWhitespaceCount(line); if (indent < minIndent && !line.trim().isEmpty()) { minIndent = indent; } } if (minIndent == Integer.MAX_VALUE) { return text; // 没有找到缩进 } StringBuilder result = new StringBuilder(); for (String line : lines) { if (line.length() > minIndent) { result.append(line.substring(minIndent)).append("\n"); } else { result.append("\n"); } } return result.toString(); } // 获取行首空白字符数的方法 private static int getLeadingWhitespaceCount(String line) { int count = 0; while (count < line.length() && Character.isWhitespace(line.charAt(count))) { count++; } return count; } } 配置鼠标手势 添加应用程序 按文件名 Code.exe 添加动作 鼠标右键Z 添加命令 1,执行程序 文件: D:\coding\java\jdk\temurin-1.8\bin\java.exe 工作目录: D:\Dropbox\archives\_program\src 运行参数: -Dfile.encoding=UTF-8 -jar escape.jar 运行方式: 最小化 2,工具 - 延迟 1000ms 3,按键 - 快捷键 CTRL + v 设置 { //按下Tab键应用第一个建议 "editor.tabCompletion": "on", //不会显示在工作空间中 "files.exclude": { "collection": true, "Email Attachments": true, "etc": true, "mp3": true, ".dropbox.cache": true }, //标签成对修改 "editor.linkedEditing": true, //显示空格和制表符 "editor.renderWhitespace": "all", //自动保存 "files.autoSave": "onFocusChange", //长文本视区内换行 "editor.wordWrap": "on" } 插件 techer.open-in-browser 右键菜单预览网页 wix.vscode-import-cost 引入包大小计算 ChakrounAnas.turbo-console-log ctrl + alt + l 选中变量之后，使用这个快捷键生成 console.log alt + shift + c 注释所有 console.log alt + shift + u 启用所有 console.log alt + shift + d 删除所有 console.log eamodio.gitlens 哪一行代码，何时、何人提交都有记录 sporiley.css-auto-prefix 追加 CSS 私有前缀,单独css文件中有效 20240327011606.gif pranaygp.vscode-css-peek 定位 CSS 类名,单独css文件中有效 chrmarti.regex 实时预览正则表达式的效果,单独js文件中有效 ctrl + alt + m 启用侧边对比,点击Test Regex... raymondcamden.htmlescape-vscode-extension HTML转义 eprincev-egor.toggle-upper-case 大小写 ctrl+u donjayamanne.jquerysnippets jquery snippets akamud.vscode-javascript-snippet-pack javascript snippet [cd]: console.dir [ce]: console.error [ci]: console.info [cl]: console.log [cw]: console.warn [de]: debugger [ae]: addEventListener [ac]: appendChild [rc]: removeChild [cel]: createElement [cdf]: createDocumentFragment [ca]: classList.add [ct]: classList.toggle [cr]: classList.remove [gi]: getElementById [gc]: getElementsByClassName [gt]: getElementsByTagName [ga]: getAttribute [sa]: setAttribute [ra]: removeAttribute [ih]: innerHTML [tc]: textContent [qs]: querySelector [qsa]: querySelectorAll [fe]: forEach [fn]: function [afn]: anonymous function [pr]: prototype [iife]: immediately-invoked function expression [call]: function call [apply]: function apply [ofn]: function as a property of an object [jp]: JSON.parse [js]: JSON.stringify [si]: setInterval [st]: setTimeout [us]: use strict [al]: alert [co]: confirm [pm]: prompt 正则 <!DOCTYPE html>(.|\n)*?</script>`,``,`html`,`windows对策`,`20240323163755-_工具使用 效率工具 StrokeIt:鼠标手势 SETUNA2:浮动截图 Clibor:剪贴板管理 ABBYY Screenshot Reader:屏幕文字识别 Mouse and Keyboard Recorder:自动点击器 OBS studio:视频编辑 AudioRecorder:拾音器 audacity:音频剪辑 Pointofix:屏幕白板笔 Everything:文件搜索 DeskPins:窗口置顶 mytree:五笔查 ChromeCacheView:缓存查看 cports:端口查看 你要允许来自未知发布者的此应用对.. 新建子项Layers //位置 计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags 新建字符串值 //名称 (本地程序完整路径) C:\Program Files (x86)\RobotSoft\Mouse and Keyboard Recorder\MouseKeyboardRecorder.exe //数据 RunAsInvoker 拒绝新装win11联网要求 shift+f10 oobe\bypassnro`,``,`html`,`XML`,`20240320133304-_数据交换格式 eXtensible Markup Language 可扩展标记语言 基本规则 用于传输和结构化存储而非展示 需要声明XML的版本和编码格式 每个XML文档必须且只能有一个根元素 标签是大小写敏感的, 成对或自闭合 属性用单引或双引 元素内容中 < 和 & 必须转义 属性值中 ", ', <, >, 和 & 必须转义 <escapedCharacters> Less than: &lt; Greater than: &gt; Ampersand: &amp; Double Quote: &quot; Single Quote: &apos; </escapedCharacters> CDATA(Character Data)区块内的内容会被 XML 解析器忽略，不会被解析成 XML 元素或属性。 CDATA 区块内的内容会原样保留，包括空白和换行符 适用于包含 HTML 片段、脚本代码或其他包含特殊字符的文本数据 <note> <to>Tove</to> <from>Jani</from> <heading>Reminder</heading> <!-- <![CDATA[ ]]> --> <body><![CDATA[Don't forget me this weekend! <special>tags</special> and & special characters]]></body> </note> CDATA 区块内不能包含 ]]> 字符序列，因为这会被解析为 CDATA 区块的结束标志。 如果需要包含 ]]>，可以将其拆分, 例如A ]]> B拆分为A ]]和> B <![CDATA[A ]]]]><![CDATA[> B]]> 名字空间 用于避免命名冲突，通过定义前缀来区分不同的元素和属性, 特别是在将多个 XML 文档合并时, 命名空间通过将元素和属性名称限定到一个唯一的 URI上来实现 <root xmlns:h="http://www.w3.org/TR/html4/" xmlns:f="http://www.w3schools.com/furniture"> <h:table> <h:tr> <h:td>Apples</h:td> <h:td>Bananas</h:td> </h:tr> </h:table> <f:table> <f:name>African Coffee Table</f:name> <f:width>80</f:width> <f:length>120</f:length> </f:table> </root> xmlns 是 XML 命名空间（XML Namespaces）的缩写, h 和 f 分别表示两个不同的命名空间。通过命名空间，可以在一个文档中使用同名但属于不同命名空间的元素 无前缀的命名空间声明 当不使用前缀时，可以将命名空间声明为默认命名空间 <!-- note 元素及其所有子元素都属于 http://www.example.com/note 命名空间 --> <note xmlns="http://www.example.com/note"> <to>Tove</to> <from>Jani</from> <heading>Reminder</heading> <body>Don't forget me this weekend!</body> </note> 使用 XML Schema 定义（XSD） .xsd schema 模式 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.example.com/note" targetNamespace="http://www.example.com/note"> <xs:element name="note"> <xs:complexType> <xs:sequence> <xs:element name="to" type="xs:string"/> <xs:element name="from" type="xs:string"/> <xs:element name="heading" type="xs:string"/> <xs:element name="body" type="xs:string"/> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> xs:schema 这是根元素，表示这是一个 XML Schema 定义, xs 是前缀，用于指示元素属于 xs 命名空间即XML Schema, www.w3.org/2001/XMLSchema xmlns:xs="www.w3.org/2001/XMLSchema xmlns 是 XML 命名空间声明的缩写。这个声明为前缀 xs 定义了命名空间 www.w3.org/2001/XMLSchema。此命名空间包含了 XML Schema 定义（XSD）语言的所有元素和数据类型。 这个 URI 是标准的 XML Schema 命名空间，告诉解析器 xs 前缀的所有元素都是来自 XML Schema 定义的标准元素和数据类型 xmlns="www.example.com/note" 这个声明定义了一个默认命名空间，没有前缀，适用于该元素（即根元素xs:schema）及其所有没有显式命名空间前缀的子元素 targetNamespace="www.example.com/note" targetNamespace 属性定义了该 Schema 的目标命名空间，即此 Schema 定义的所有元素和类型的命名空间 www.example.com/note 作为 targetNamespace，意味着所有在这个 Schema 中定义的元素都属于这个命名空间。 targetNamespace 使得该 Schema 中定义的元素和类型在其他文档或 Schema 中引用时能够明确其来源和作用域，避免名称冲突。 命名空间xmlns：XML 命名空间是通过 URI来唯一标识的。它用于区分不同 XML 元素和类型的定义，防止名称冲突。 目标命名空间（targetNamespace）：这是 XML Schema 文件声明的命名空间，它指定了该 Schema 中定义的元素和类型所在的命名空间。 通过使用 targetNamespace，可以确保不同 XML Schema 文件中的元素和类型不会发生冲突。即使它们的名字相同，只要它们的命名空间不同，就可以共存。 当其他 XML 文件引用该 Schema 文件时，可以使用 targetNamespace 的值来指定命名空间前缀和 URI DTD Document Type Definition 定义XML文档的合法构建模块 <!DOCTYPE note [ <!ELEMENT note (to, from, heading, body)> <!ELEMENT to (#PCDATA)> <!ELEMENT from (#PCDATA)> <!ELEMENT heading (#PCDATA)> <!ELEMENT body (#PCDATA)> ]> 声明元素 !ELEMENT 元素名 内容描述 内容描述 #PCDATA: 表示该元素可以包含解析字符数据（Parsed Character Data）。 ANY,元素可以包含任意内容，包括子元素和字符数据 !ELEMENT any-element ANY EMPTY 自闭合标签,不包含子元素和字符数据 ELEMENT1, ELEMENT2, ...: 逗号分隔的元素列表，表示顺序出现。 !ELEMENT person (name, age) ELEMENT1 | ELEMENT2 | ...: 管道符分隔的元素列表，表示选择其中之一。 (ELEMENT)*: 表示该元素可以出现零次或多次。 (ELEMENT)+: 表示该元素可以出现一次或多次。 !ELEMENT persons (person+) (ELEMENT)?: 表示该元素可以出现零次或一次。 声明属性 !ATTLIST 元素名 属性名 属性类型 默认值 属性类型 CDATA: 字符数据。 ID: 唯一标识符。 IDREF: 引用另一个元素的 ID。 IDREFS: 引用多个 ID。适合用于需要建立复杂关联关系的数据管理场景 <!ELEMENT university (students, courses, registrations)> <!ELEMENT students (student+)> <!ELEMENT student (name, age)> <!ELEMENT courses (course+)> <!ELEMENT course (title, instructor)> <!ELEMENT registrations (registration+)> <!ELEMENT registration EMPTY> <!ATTLIST student id ID #REQUIRED> <!ATTLIST course id ID #REQUIRED> <!ATTLIST registration studentID IDREF #REQUIRED courseID IDREF #REQUIRED> <?xml version="1.0"?> <!DOCTYPE university SYSTEM "university.dtd"> <university> <students> <student id="s1"> <name>John Doe</name> <age>20</age> </student> <student id="s2"> <name>Jane Smith</name> <age>22</age> </student> </students> <courses> <course id="c1"> <title>Introduction to Computer Science</title> <instructor>Dr. Brown</instructor> </course> <course id="c2"> <title>Advanced Mathematics</title> <instructor>Dr. Green</instructor> </course> </courses> <registrations> <registration studentID="s1" courseID="c1"/> <registration studentID="s2" courseID="c2"/> <registration studentID="s1" courseID="c2"/> </registrations> </university> ENTITY: 引用外部实体。 <!ELEMENT document (content)> <!ELEMENT content (#PCDATA)> <!ATTLIST content reference ENTITY #IMPLIED> <!ENTITY example "This is an example entity."> <?xml version="1.0"?> <!DOCTYPE document SYSTEM "single-entity.dtd"> <document> <content reference="example"> &example; </content> </document> content 元素具有一个 reference 属性(不是必须)，其类型为 ENTITY。虽然在实际使用中，直接在内容中使用实体引用更为常见，但使用这种方式定义属性也有其特定的应用场景，比如通过属性引用来描述数据之间的关系 ENTITIES: 引用多个外部实体。通过定义实体，可以在多个地方重复使用相同的数据块，提高文档的可维护性和一致性,可以将一些常用的数据（如符号、URL 等）定义为实体，简化文档管理 <!ELEMENT gallery (image+, body)> <!ELEMENT image EMPTY> <!ELEMENT body (#PCDATA)> <!ENTITY letter SYSTEM "letter.txt"> <!ATTLIST image id ID #REQUIRED src ENTITY #REQUIRED> <!ENTITY img1 SYSTEM "image1.jpg"> <!ENTITY img2 SYSTEM "image2.jpg"> <?xml version="1.0"?> <!DOCTYPE gallery SYSTEM "image-entity.dtd"> <gallery> <image id="i1" src="img1"/> <image id="i2" src="img2"/> <body>&letter;</body> </gallery> 在元素内容中使用实体引用时需要使用 &entity_name; 语法, 在属性中直接使用实体名称 NMTOKEN: 表示一个合法的 XML 名称标记（Name Token）,例如用作标识符active/inactive NMTOKENS: 多个名称名称标记。例如用作分类标签(animal cat),多重属性值(admin user) <!ELEMENT item (#PCDATA)> <!ATTLIST item categories NMTOKENS #REQUIRED> <?xml version="1.0"?> <!DOCTYPE items SYSTEM "nmtokens-example.dtd"> <items> <item categories="book tutorial">XML Guide</item> <item categories="video learning">XML Tutorial</item> </items> 默认值 #REQUIRED: 属性是必需的。 #IMPLIED: 属性是可选的。 #FIXED "value": 属性具有固定值。 <!ELEMENT product (#PCDATA)> <!ATTLIST product category CDATA #FIXED "electronics"> <?xml version="1.0"?> <!DOCTYPE product SYSTEM "fixed-attribute.dtd"> <product category="electronics">Smartphone</product> XML 文件中的 product 元素必须具有 category="electronics" 属性值 "value": 默认值。 XML Schema 定义（XSD） 比DTD更强大的XML文档结构定义语言，支持数据类型定义 通过使用命名空间、元素、属性、简单和复杂类型、限制、扩展等功能，可以精确地描述 XML 数据的模式 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"> <xs:element name="note"> <xs:complexType> <xs:sequence> <xs:element name="to" type="xs:string"/> <xs:element name="from" type="xs:string"/> <xs:element name="heading" type="xs:string"/> <xs:element name="body" type="xs:string"/> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> elementFormDefault 如果没有显式指定 elementFormDefault 属性 如果 targetNamespace 存在且被定义，那么隐式的 elementFormDefault="unqualified" 如果 targetNamespace 未被定义，那么隐式的 elementFormDefault="qualified" qualified 表示该 Schema 定义的所有元素在引用时必须有命名空间前缀。 当父元素明确指定了其所属的命名空间, 如果子元素继承自父元素的命名空间，则不需要重复指明命名空间 例如对于如下的 XML Schema 定义 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.com/note" elementFormDefault="qualified"> <xs:element name="note" type="xs:string"/> </xs:schema> 实例 XML 文档中，note 元素必须带有 xmlns 命名空间声明 <note xmlns="http://www.example.com/note">Hello, XML!</note> unqualified XML 实例文档中的元素可以不显式指定命名空间。 此时，XML 实例文档中的元素在未提供命名空间声明的情况下，默认属于无命名空间 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.com/note" elementFormDefault="unqualified"> <xs:element name="note" type="xs:string"/> </xs:schema> <note>Hello, XML!</note> note 元素的默认命名空间是 www.example.com/note 常用组件 简单类型 <xs:element name="age" type="xs:integer"/> 限制和模式 <xs:simpleType name="USState"> <xs:restriction base="xs:string"> <xs:enumeration value="CA"/> <xs:enumeration value="NY"/> <xs:enumeration value="TX"/> </xs:restriction> </xs:simpleType> 扩展和重定义 <xs:complexType name="person"> <xs:sequence> <xs:element name="name" type="xs:string"/> </xs:sequence> </xs:complexType> <xs:complexType name="employee"> <xs:complexContent> <xs:extension base="person"> <xs:sequence> <xs:element name="employeeID" type="xs:string"/> </xs:sequence> </xs:extension> </xs:complexContent> </xs:complexType> 数据类型 字符串 xs:ID 类型的值必须以字母或下划线 (_) 开头，不能以数字开头 20240624110438.webp 数值 20240624110508.webp 日期和时间 20240624110636.webp 其他 20240624110707.webp 属性 xs:element 20240624111323.webp xs:attribute 20240624111556.webp xs:simpleType 和 xs:complexType 20240624111926.webp xs:restriction 20240624112023.webp 关键词 20240624113514.webp 20240624113515.webp 20240624113516.webp 命名空间和根元素： xs:schema：XML Schema 的根元素，定义命名空间、目标命名空间和模式的默认设置。 元素和类型定义： xs:element：定义 XML 文档中的元素，可以是简单类型（如字符串、整数）或复杂类型（包含子元素和属性）。 xs:complexType：用于定义包含子元素和/或属性的复杂类型。 xs:simpleType：用于定义简单类型，可以通过限制（如枚举、最小值、最大值）进行自定义。 子元素结构： xs:sequence：定义子元素的顺序，所有子元素必须按指定顺序出现。 xs:all：定义子元素可以以任何顺序出现，每个子元素最多出现一次。 xs:choice：定义一组选项中的一个可以出现。 属性和限制： xs:attribute：定义元素的属性。 xs:restriction：定义简单类型的限制，可以通过枚举、最小值、最大值、模式等进行约束。 xs:enumeration：用于定义枚举值，限制属性或元素的值只能是预定义的枚举值之一。 xs:minInclusive、xs:maxInclusive：用于定义数值或日期的最小值和最大值。 xs:minLength、xs:maxLength：用于限制字符串或列表的最小和最大长度。 xs:pattern：使用正则表达式限制字符串的模式。 文档说明： xs:annotation：为模式中的元素、类型等添加注释。 xs:documentation：在注释中添加具体的文档说明。 扩展和导入： xs:extension：基于现有的类型进行扩展，增加新的元素或属性。 xs:import：导入其他命名空间中的模式定义。 xs:include：包含其他模式文件的定义。 键和唯一性约束： xs:key、xs:keyref、xs:unique：用于定义唯一键约束和键引用，确保特定元素或属性的唯一性，并建立关系。 列表和联合： xs:list：定义元素或属性为某类型的列表。 xs:union：定义元素或属性可以是多种类型中的一种。 XML、DTD 和 XSD DTD 是 XML 的一种早期文档类型定义语言 DTD文件并不是严格意义上的 XML 格式文件, 尽管它们使用 XML 语法来定义文档的结构和验证规则, 但它们有一些限制和特殊的语法规则，与一般的 XML 文档不完全相同 DTD 文件必须以 !DOCTYPE 声明开头，用于指示关联的 XML 文档使用的 DTD； 而普通的 XML 文档可以没有 !DOCTYPE 声明或者使用其他类型的文档类型定义 虽然DTD在功能和表达能力上相对有限，但仍然有广泛的支持和应用。现代的XML处理工具通常会提供对DTD的基本支持 XSD 是 XML 的另一种文档类型定义语言 XSD 使用 XML 格式本身定义文档结构、数据类型和约束条件，提供比 DTD 更丰富和精确的数据模型 XSD 文件本身就是 XML 格式，这意味着它们可以像任何其他 XML 文档一样进行解析、编辑和处理。 这种一致性使得 XSD 文件能够利用现有的 XML 工具和库来处理。 验证器 用于验证XML文档或其相关文档类型定义（DTD、XML Schema等）的工具或库。 其主要功能是检查文档是否符合特定的语法和语义规则，并且可以捕获和报告不合规的部分 当 XML 文件包含 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 声明时，解析器就会知道它可能包含与 XML Schema 实例相关的属性 解析器和验证工具实现了 XML Schema 规范，从而知道如何识别和处理 xsi:schemaLocation 等属性 XML文档验证 检查XML文档的结构、元素、属性、值等是否符合其相关的DTD或XML Schema定义。 这包括检查元素是否按照定义的顺序出现，属性是否正确声明和使用，以及元素的值是否符合定义的数据类型等。 在进行XML文档验证时，获取相关的DTD或XML Schema定义信息的方式取决于XML解析器或验证器的具体实现和配置 本地文件引用 最常见的方式是在XML文档中通过DOCTYPE声明引用本地的DTD文件或者通过schemaLocation属性引用本地的XML Schema文件 当解析器解析XML文档时，会根据这些引用从本地文件系统加载DTD或XML Schema文件，并使用它们来验证文档 <!DOCTYPE note SYSTEM "note.dtd"> SYSTEM 是一种标识符，用于指定外部 DTD 文件的位置 <note xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="note.xsd"> <person> <name>John Doe</name> <age>30</age> </person> <product> <name>Laptop</name> <price>1200</price> </product> noNamespaceSchemaLocation属性用来指定 XML 文档的 XML Schema 位置，但前提是 XML 文档本身没有显式声明命名空间 指定多个 XML Schema 文件时，可以通过空格或换行将它们分隔开来 person和product元素没有显式指定命名空间，即没有前缀和命名空间URI关联, 因此它们属于默认的命名空间，也就是没有命名空间。 其约束由 noNamespaceSchemaLocation 或者其他方式指定的 XML Schema 文件来定义和验证 网络引用 解析器在验证XML文档时会从指定的网络地址下载DTD或XML Schema文件 <!DOCTYPE note SYSTEM "http://www.example.com/note.dtd"> <root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.example.com/ns1 schema1.xsd http://www.example.com/ns2 schema2.xsd" xmlns:ns1="http://www.example.com/ns1" xmlns:ns2="http://www.example.com/ns2"> <ns1:exampleElement>This element belongs to ns1 namespace.</ns1:exampleElement> <ns2:anotherElement>This element belongs to ns2 namespace.</ns2:anotherElement> <!-- 其他XML内容 --> schemaLocation属性用于指定 XML 文档中各命名空间的 XML Schema 位置。使用这个属性来告知 XML 解析器每个命名空间对应的 XML Schema,格式是以命名空间 URI 和对应的 XML Schema 文件位置成对出现，用空格或换行符分隔 xsi: 这是一个命名空间前缀，noNamespaceSchemaLocation,schemaLocation 是 xsi 命名空间中定义的属性 xmlns:xsi 声明可以省略如果不使用 xsi:schemaLocation 或 xsi:noNamespaceSchemaLocation 内联定义 XML文档本身也可以内联定义DTD或XML Schema，而不是通过外部引用。适用于简单的XML文档或者需要独立性的情况 <!DOCTYPE note [ <!ELEMENT note (to, from, heading, body)> <!ELEMENT to (#PCDATA)> <!ELEMENT from (#PCDATA)> <!ELEMENT heading (#PCDATA)> <!ELEMENT body (#PCDATA)> ]> <root>..</root> <?xml version="1.0" encoding="UTF-8"?> <note> <!-- 内联定义XML Schema --> <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.com/note" xmlns="http://www.example.com/note" elementFormDefault="qualified"> <xs:element name="note"> <xs:complexType> <xs:sequence> <xs:element name="to" type="xs:string"/> <xs:element name="from" type="xs:string"/> <xs:element name="heading" type="xs:string"/> <xs:element name="body" type="xs:string"/> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> <!-- XML文档内容 --> <to>John</to> <from>Jane</from> <heading>Reminder</heading> <body>Don't forget the meeting tomorrow.</body> </note> 编程方式指定 在某些情况下，特别是在使用编程语言处理XML时，可以直接通过API或配置方式指定DTD或XML Schema的位置或内容。这种方式适用于动态生成或处理XML文档的场景 DTD验证 验证XML文档是否符合DTD定义的结构和规范。 它会检查XML文档中使用的元素和属性是否在DTD中正确定义，以及是否遵循DTD中规定的约束条件。 XML Schema验证 用于验证XML文档是否符合XML Schema（XSD）定义的结构和数据类型。 XML Schema相比于DTD提供了更强大和灵活的类型定义能力，可以定义复杂的数据结构和约束条件。 验证过程 加载XML文档及其相关的DTD或XML Schema定义。 解析XML文档，将其转换为内部数据结构（如DOM或SAX）。 使用验证器对文档进行验证，验证器会逐行或逐节点地检查文档的内容。 如果发现错误或不合规的部分，验证器会生成相应的错误或警告信息，指出具体的问题所在。 开发人员根据验证器返回的信息来修正XML文档中的问题，直到文档通过验证为止。 工具和库 常见的XML验证器包括Java平台上的Xerces、SAX、DOM等库，以及其他编程语言中的各种XML处理工具和框架。 IDE（集成开发环境）也通常提供XML验证功能 XML外部实体（XXE）攻击 通过XML的实体扩展机制利用XML解析器的漏洞进行攻击, 可能导致敏感数据泄露、拒绝服务（DoS）攻击，甚至在某些情况下，可以远程执行代码 XML实体是XML文档中的一种变量，用于定义和重用文本片段。 外部实体引用（External Entity Reference）允许实体指向外部资源，如文件或URL。 这就可能被攻击者利用来访问本地文件系统或发送请求到远程服务器。 在这个示例中，外部实体xxe指向了本地文件系统中的/etc/passwd文件。如果一个不安全的XML解析器解析了这个XML文档，它会尝试读取并包含/etc/passwd文件的内容。 <?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM "file:///etc/passwd" > ]> <foo>&xxe;</foo> 攻击者可以通过外部实体读取本地文件或环境变量，获取敏感信息 通过定义深度嵌套的实体或大量实体，可以使解析器耗尽资源，导致拒绝服务 可以通过外部实体引导服务器发送恶意请求 通过禁用外部实体解析、验证和过滤输入、使用安全库以及保持软件更新，可以有效防范XXE攻击。理解XXE攻击的工作原理和防护措施，对于确保XML数据处理的安全性至关重要。 XPath XML Path Language 是一种用于在 XML 文档中查找和操作元素和属性的语言 XPath 作为一种查询语言，主要设计用于嵌入在其他语言或工具中使用，以便于在 XML 文档中查找和操作节点。 尽管 XPath 可以独立描述路径表达式，但它通常并不会单独作为一个独立的编程语言来使用，而是通过嵌入在其他环境中来发挥其作用 某些数据库系统(如mysql)支持使用 XPath 来查询存储在 XML 数据类型中的数据 首先将 XML 文件的内容读入内存，然后将其插入到 MySQL 表的一个字段中，通常是 TEXT 或 BLOB 类型的字段 然后使用 MySQL 的 XML 函数来解析和查询这些 XML 数据 ExtractValue()用于从 XML 字符串中提取值 UpdateXML()用于更新 XML 文档中的值 涉及查询时优先使用xpath, 简化查询难度和编码数量 基本概念 节点：XML 文档的基本组成部分，包括元素节点、属性节点、文本节点、命名空间节点、处理指令节点、注释节点和文档节点。 节点集：XPath 表达式的返回值通常是一个节点集。 路径表达式 绝对路径 以斜杠 / 开头，从根节点选取。 /bookstore/book 选取根节点 bookstore 下的所有 book 子节点。 相对路径 不以斜杠 / 开头，从当前节点选取。 book 选取当前节点的所有 book 子节点。 / 从根节点选取。 // 选取匹配选择器的节点，而不考虑它们的位置。 //book 选取文档中所有 book 节点。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 /bookstore/book/@price 选取所有 book 节点的 price 属性。 常用函数 <root> <element>123</element> </root> <!-- string(/root/element) 将参数转换为字符串 --> <!-- number(/root/element) 将参数转换为数字 --> <root> <first>John</first> <last>Doe</last> </root> <!-- concat(/root/first, ' ', /root/last) John Doe --> <root> <element>XPath functions</element> </root> <!-- contains(/root/element, 'functions') true --> <!-- starts-with(/root/element, 'XPath') true --> <root> <element>Hello World</element> </root> <!-- substring(/root/element, 1, 5) Hello --> <!-- substring-before(/root/element, ' ') Hello --> <!-- substring-after(/root/element, ' ') World --> <root> <value>1</value> <value>2</value> <value>3</value> </root> <!-- sum(/root/value) 6 --> <!-- /root/element[last()] <value>3</value> --> <!-- /root/element[position()=2] <value>2</value> --> <!-- count(/root/element) root 元素下名为 element 的子元素的数量 3 --> <!-- /bookstore/book[last()]/title <title>Learning XML</title> --> <root> <element>123.456</element> </root> <!-- floor(/root/element) 123 --> <!-- ceiling(/root/element) 124 --> <!-- round(/root/element) 123 --> <root> <element>false</element> </root> <!-- boolean(/root/element) false --> <!-- not(/root/element) true --> <root> <element id="unique">Content</element> </root> <!-- id('unique') 选取具有指定 ID 的元素 <element id="unique">Content</element> --> <bookstore> <!-- This is a comment --> <book category="children"> <title lang="en">Harry Potter</title> <author>J.K. Rowling</author> <price>29.99</price> <description>This is a children's book about a wizard.</description> </book> <book category="fiction"> <title lang="en">The Hobbit</title> <author>J.R.R. Tolkien</author> <price>34.95</price> <description>This is a book about a hobbit's adventure.</description> </book> <?editor note="Review for accuracy"?> <book category="learning"> <title lang="en">Learning XML</title> <author>Erik T. Ray</author> <price>39.95</price> <description>This is a book about learning XML.</description> </book> /bookstore/book/node() 选取每本书的所有子节点，包括元素和文本节点 /bookstore/book/title/text() 选取每本书的 title 元素的文本内容 /bookstore/comment() 选取 bookstore 元素下的所有注释 /bookstore/book[1]/title 选择第一本书的标题 /bookstore/book[price > 30] 选择价格大于 30 的书 /bookstore/book[title[@lang='en'] and price > 35] /books/book[count(*)=2] 选择具有特定数量子节点的节点 /books/book[@category='fiction' or @price > 20] /books/book[not(@category)] 选择 books 元素下没有 category 属性的所有 book 元素 轴（Axes） //title/ancestor::book 选择每个 title 元素的父节点 book //title/ancestor-or-self::book 选择每个 title 元素以及其父节点 book（但 title 不是 book 的祖先，因此结果与 ancestor 相同） //book/@category 选择所有 book 元素的 category 属性 /bookstore/book/child::title 选择每个 book 元素的 title 子节点。 /bookstore/descendant::title 选择 bookstore 元素下的所有 title 元素 /bookstore/descendant-or-self::book 选择 bookstore 元素及其所有子节点中的 book 元素（但 bookstore 不是 book） //title/following::price 选择每个 title 元素之后的所有 price 元素 //book/following-sibling::book 选择每个 book 元素之后的所有 book 元素（即第二个和第三个 book 元素） //title/parent::book 选择每个 title 元素的父节点 book //price/preceding::title 选择每个 price 元素之前的所有 title 元素 //book/preceding-sibling::book 选择每个 book 元素之前的所有 book 元素（即第一个和第二个 book 元素） //title/self::title 选择每个 title 元素 //title/ancestor::node() 选择每个 title 元素的父节点 book 和祖先节点 bookstore //title/ancestor-or-self::node() 选择每个 title 元素及其父节点 book 和祖先节点 bookstore /bookstore/book/child::node() 选择每个 book 元素的所有子节点（title、author、price） /bookstore/descendant::node() 选择 bookstore 元素下的所有节点（包括所有 book 元素及其子节点） /bookstore/descendant-or-self::node() 选择 bookstore 元素及其所有后代节点（包括所有 book 元素及其子节点） //title/following::node() 选择每个 title 元素之后的所有节点 //book/following-sibling::node() 选择每个 book 元素之后的所有兄弟节点。 /bookstore/book/namespace::node() 选择 bookstore 元素下的所有命名空间节点 //title/parent::node() 选择每个 title 元素的父节点 book //price/preceding::node() 选择每个 price 元素之前的所有节点 //book/preceding-sibling::node() 选择每个 book 元素之前的所有兄弟节点 //title/self::node() 选择每个 title 元素 Dom4j JAXP： sun公司提供的解析器，支持dom和sax两种思想 dom文档对象模型: 文档,根节点,节点,文本,属性 基于事件的解析方式，逐行读取XML文档，并在遇到特定的标记（如开始标签、结束标签、文本等）时触发事件处理器。 DOM4J(Document Object Model for Java)： 将整个XML文档加载到内存中，创建一个树状结构，然后通过这个结构来操作和查询XML数据。 是dom4j组织提供的一个用来解析处理XML、 XPath和XSLT开源框架, 提供了对 XPath 的支持 将XML视为Document对象,xml标签被定义为Element对象 test_Schema.xsd <?xml version="1.0" encoding="UTF-8"?> <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"> <!-- 定义部门类型 --> <xs:complexType name="departmentType"> <xs:sequence> <xs:element type="xs:string" name="dname"/> <xs:element type="xs:string" name="address"/> </xs:sequence> </xs:complexType> <!-- 定义员工类型 --> <xs:complexType name="employeeType"> <xs:sequence> <xs:element type="xs:string" name="name"/> <xs:element name="age"> <xs:simpleType> <xs:restriction base="xs:integer"> <xs:minInclusive value="18"/> <xs:maxInclusive value="60"/> </xs:restriction> </xs:simpleType> </xs:element> <xs:element type="xs:short" name="salary"/> <xs:element type="departmentType" name="department"/> </xs:sequence> <xs:attribute type="xs:short" name="no" use="required"/> </xs:complexType> <!-- 定义根元素 --> <xs:element name="hr"> <xs:complexType> <xs:sequence> <xs:element type="employeeType" name="employee" maxOccurs="unbounded" minOccurs="0"/> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> test_DTD.dtd <?xml version="1.0" encoding="UTF-8" ?> <!ELEMENT hr (employee*)> <!ELEMENT employee (name,age,salary,department)> <!ATTLIST employee no CDATA #REQUIRED> <!ELEMENT name (#PCDATA)> <!ELEMENT age (#PCDATA)> <!ELEMENT salary (#PCDATA)> <!ELEMENT department (dname,address)> <!ELEMENT dname (#PCDATA)> <!ELEMENT address (#PCDATA)> <?xml version="1.0" encoding="UTF-8" ?> <hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="test_Schema.xsd"> <!-- <!DOCTYPE hr SYSTEM "D:\Dropbox\workspace\try\src\main\java\ xml\test_DTD.dtd"> <hr> --> <employee no="3309"> <name>张三</name> <age>31</age> <salary>4000</salary> <department> <dname>会计部</dname> <address>B103</address> </department> </employee> <employee no="3310"> <name>李四</name> <age>23</age> <salary>3000</salary> <department> <dname>工程部</dname> <address>B104</address> </department> </employee> </hr> 依赖包 <!-- dom4j 对 XML 文档进行解析、创建、遍历、查询和修改等操作 --> <dependency> <groupId>org.dom4j</groupId> <artifactId>dom4j</artifactId> <version>2.1.4</version> </dependency> <!--jaxen：Xpath表达式解释器--> <dependency> <groupId>jaxen</groupId> <artifactId>jaxen</artifactId> <version>1.2.0</version> </dependency> public class Demo { @Test public void read() { InputStream file = Demo.class.getClassLoader().getResourceAsStream("test_Schema.xml"); //SAXReader是读取xml文件的核心类,用于将xml解析后以树的形式保存在内存中 SAXReader saxReader = new SAXReader(); try { Document doc = saxReader.read(file); Element root = doc.getRootElement();//获取根节点 List<Element> emps = root.elements();//获取根节点下的标签集合 for (Element emp : emps) { Element name = emp.element("name");//获取标签 System.out.println(name.getText());//获取标签内容文本 System.out.println((emp.elementText("age")));//直接获取标签内容文本 Attribute attr = emp.attribute("no");//获取属性 System.out.println(attr.getText());//获取属性文本 } } catch (DocumentException e) { throw new RuntimeException(e); } } @Test public void write() { String file = Demo.class.getClassLoader().getResource("test_Schema.xml").getFile();//获取文件路径 SAXReader saxReader = new SAXReader(); try { Document doc = saxReader.read(new File(file));//用 new File(file) 而不是 file 本身，因为 file 是字符串路径 Element root = doc.getRootElement(); Element employee = root.addElement("employee"); employee.addAttribute("no", "3312"); employee.addElement("name").setText("王五"); employee.addElement("age").setText("31"); employee.addElement("salary").setText("3600"); Element department = employee.addElement("department"); department.addElement("dname").setText("人事部"); department.addElement("address").setText("B106"); // 配置OutputFormat以使输出自动缩进 OutputFormat format = OutputFormat.createPrettyPrint(); format.setEncoding("UTF-8"); //此处BufferedWriter不能以try-resources的方式 //问题的关键在于 try-with-resources 关闭了 BufferedWriter，而 XMLWriter 在它的 write() 方法中仍然需要使用这个 BufferedWriter。 //这种顺序上的不匹配导致了写入时的错误 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8")); //使用 XMLWriter 类来写入文件,XMLWriter 类在写入 XML 文件时提供了灵活的选项和高效的处理方式, 提供了更好的错误处理机制，特别适合需要格式化输出和处理编码的情况 XMLWriter xmlWriter = new XMLWriter(writer, format); xmlWriter.write(doc); writer.close(); } catch (DocumentException | IOException e) { throw new RuntimeException(e); } } } public class dom4j_XPath { public static void main(String[] args) { // inquire("/hr/employee"); // inquire("//employee"); // inquire("//employee[salary<4000]"); // inquire("//employee[name='李四']"); // inquire("//employee[@no=3309]"); // inquire("//employee[1]"); // inquire("//employee[last()]"); // inquire("//employee[position()<2]"); inquire("//employee[1] | //employee[3]"); } public static void inquire(String xpathExp) { String file = dom4j_XPath.class.getClassLoader().getResource("test_Schema.xml").getPath(); SAXReader reader = new SAXReader(); try { Document document = reader.read(file); List<Node> nodes = document.selectNodes(xpathExp);//执行xpath查询 for (Node node : nodes) { Element employee = (Element) node; System.out.println(employee.attributeValue("no")); System.out.println(employee.elementText("name")); System.out.println(employee.elementText("age")); System.out.println(employee.elementText("salary")); } } catch (DocumentException e) { e.printStackTrace(); } } }`,``,`html`,`Zookeeper`,`20240614164337-_中间件 ZooKeeper特点 ZooKeeper是一个分布式协调服务 (无单点问题的分布式协调框架) 它选择了一致性和分区容错性CP(放弃A, 不保证每次服务请求的可用性), 当信息还没同步完成时, 不对外提供服务(丢弃请求) 它解决了两个问题, 第一是单机不可靠(使用集群), 第二是集群同步时间长(尽可能压缩同步时间) 20240820155051.webp client发送请求到任意一个server,该server将请求转发给leader,leader处理完后将结果同步到所有server(主从同步,Master/Slave) 一致性 确保在任何时刻，客户端读取到的数据都是一致的。它使用了分布式一致性算法（如 ZAB 协议）来确保数据一致性。 可靠性 通过复制数据到多个节点来提供高可用性，即使部分节点出现故障，系统仍能正常运行。 原子性 所有操作都是原子的，要么成功执行，要么失败，没有中间状态。 顺序性 保证客户端发出的所有更新请求将按照请求发送的顺序依次执行，确保了事件的顺序性。 高性能 设计用于读多写少的场景，能够在这种场景下提供高性能的服务。 应用 主要集中在大数据和分布式存储领域 分布式服务注册与订阅 尽管 ZooKeeper 可以用于服务发现，但这并不是它的主要设计目标 统一配置文件 20240820160715.webp 例如redis的连接信息,client不需要频繁地去主动查询最新的信息,而是订阅（通过 Watcher机制）特定的节点数据或节点结构的变化,当这些节点发生变化时，ZooKeeper 会主动通知订阅方 Watcher 是一次性的，当事件触发后，Watcher 自动失效。如果需要继续监听，需要再次注册 Watcher 20240614190036.webp 生成分布式唯一ID 单库单表下自增主键是唯一的, 而在分布式情况下用主键做唯一标识则不适用 UUID, Snowflake, Redis的incr, Zookeeper的顺序节点 在分布式系统中生成 UUID 很简单，不依赖于中心化服务，每个节点都可以独立生成, 但是UUID 较长不易读 使用 Zookeeper 的顺序节点特性来生成唯一 ID, 能保证全局顺序和强一致性, 但性能不如其他方法 Master节点选举 每个参与选举的节点都会尝试创建一个临时顺序节点，并且在这些节点中，最小的节点被选为 Master ZooKeeper 可以防止多个 Leader 并存的脑裂问题(如果网络发生分区，不同的分区可能选出不同的 Master) 分布式锁 各个服务内部的锁机制在分布式场景下会失效, 因为会存在各服务同时向同一目标写数据的情况, 单个服务内部的锁机制无法跨服务实例进行协调 基于 Redis 的分布式锁: 使用 Redis 的 SETNX 命令实现原子操作，并结合过期时间来防止死锁 基于 Zookeeper 的分布式锁: 利用 Zookeeper 的顺序节点和临时节点特性，确保只有一个客户端能够获取锁 基于数据库的分布式锁: 通过数据库的唯一性约束或者乐观锁机制实现分布式锁 Hadoop 使用 Zookeeper 来进行集群管理和任务调度。 HBase 使用 Zookeeper 来进行分布式协调，包括表的分片、Master 节点选举等。 Kafka 使用 Zookeeper 来管理集群的元数据，包括 Broker 信息、主题信息等。 Dubbo 使用 Zookeeper 作为服务注册中心，管理服务的注册和发现。 znode节点 特点 树形结构,可以理解为linux的文件目录 每一个节点都是znode,可以同时包含数据和子节点 每个znode都有版本号,每当数据变化,版本号会累加(乐观锁), 删除或修改节点,版本号不匹配时会报错 每个节点存储的数据不宜过大,几K即可 节点可以设置权限限制用户的访问 读和写都是原子操作,每次读写操作都是对数据的完整读取或完整写入 类型 (节点创建后类型不可变更) 永久节点(需要手动删除) 临时节点(session失效客户端断开后,临时节点消失,此特性用于服务注册发现) 顺序节点(生成分布式唯一ID, [10位数字]) 永久节点和临时节点可以是顺序的或非顺序的 版本属性 (新增初始值0) dataVersion, 每次对节点进行set操作时加1, 无论修改的值是否与原值一样 cversion, 每次新增或删除子节点时加1, 修改了子节点的内容时不会发生变化 aclVersion, 每次修改权限时加1 ACL权限控制 access control list, 权限通常不是开发所关心的,因为运维会帮助搞定 使用权限位来允许/禁止对节点及其作用域的各种操作 ACL仅与特定的znode有关,与子节点无关 setAcl [-s] [-v version] [-R] path acl ACL 权限控制字符串由三个部分组成：schema,id,permissions 常用的 schema world： 这是最简单的 schema，只有一个 id：anyone，表示所有用户。 例如：setAcl /node world:anyone:r auth： auth 认证是基于客户端的整体认证，而不是针对具体的节点。它表示只要客户端通过了认证，这个认证就适用于所有具有 auth ACL 的节点 setAcl /example auth:guest:guest ALL 任何已经通过身份验证的客户端（不论认证方式是什么(如digest)）都可以对 /example 节点执行所有操作（如读取、写入、删除等） digest： digest 认证主要针对具体的节点。它要求客户端提供用户名和密码的哈希值，只有提供了正确凭证才能访问节点 使用用户名和密码认证 “增加”用户实际上就是为节点设置合适的 ACL 例如为/t1预设一个用户名为user1,密码为123的用户 先使用System.out.println(DigestAuthenticationProvider.generateDigest("user1:123"))生成编码后的字符串 然后代代替下面的[xxx]进行权限设置 setAcl /t1 digest:user1:[xxx]:rwa 对/t1节点操作前先进行认证 addauth digest user1:123 get /t1 ip： 基于客户端 IP 地址的认证。 例如：setAcl /node ip:192.168.1.1:rwa super: setAcl /node super:user1 允许user1对指定节点的所有操作 permissions：指定权限列表，可以是以下一个或多个字符的组合： r：读权限 w：写权限 c：创建子节点权限 d：删除子节点权限 a：管理权限 *：所有权限 使用场景 区分开发/测试/运维环境,防止误操作 可以针对不同IP而产生具体的配置 Zookeeper安装配置 #建夹下载解压, 未安装wget时使用curl -L -O -J mkdir /usr/local/zookeeper cd /usr/local/zookeeper curl -L -O -J https://downloads.apache.org/zookeeper/zookeeper-3.7.2/apache-zookeeper-3.7.2-bin.tar.gz #解压后无须安装,直接配置使用 tar zxvf apache-zookeeper-3.7.2-bin.tar.gz #另拷一份配置 cd apache-zookeeper-3.7.2-bin cp conf/zoo_sample.cfg conf/zoo.cfg vi conf/zoo.cfg #dataDir=/tmp/zookeeper 将临时目录改为持久化目录 /var/lib/zookeeper #安装java环境 #查看仓库中的jdk yum search jdk #java-1.8.0-openjdk与标准jdk是一致的 yum install -y java-1.8.0-openjdk.x86_64 #具体版本, 安装位置 java -version which java #启动,状态,停止 ./bin/zkServer.sh start ./bin/zkServer.sh status ./bin/zkServer.sh stop #放行2181 firewall-cmd --zone=public --permanent --add-port=2181/tcp firewall-cmd --reload firewall-cmd --list-all powershell测试连通 Test-NetConnection -ComputerName 192.168.149.136 -Port 2181 常用命令 #以客户端身份连接, 本机时可以不跟-server及之后内容 ./bin/zkCli.sh -server 127.0.0.1:2181 #查看命令列表 help #查看ls命令的参数形式, [可选] ls #查看节点 ls / ls /zookeeper ls /zookeeper/quotal #查看节点信息 # ephemeralOwner值为16进制0表示该节点是一个持久节点, 非0则为临时节点 # cZxid节点创建时的事务 ID (Zxid) # ctime节点的创建时间 # mZxid节点最后一次被修改的事务 ID # mtime节点最后一次修改的时间 # pZxid与此节点相关的父节点的 Zxid stat / #创建不带值节点 create /a1 #创建带值节点 create /a1/b1 ha #查看节点值 get /a1/b1 #修改节点 set /a1/b1 haha #不支持一次创建多级目录 create /a1/b2 #-s创建顺序节点, 节点名后自动附加编号, 编号以直接父节点为基准递增 create -s /a1/b2/c #Created /a1/b2/c0000000000 #-e临时节点, 客户端会话关闭临时节点删除有一个短暂的延迟,手动删除节点是最快的删除方式，可以立即看到效果 #临时节点无法创建子节点 create -e /a2/b1 he #条件更新,乐观锁,只有当-v参数值与dataVersion一致时才能成功更新 set /a2/b1 he set /a2/b1 hehe set /a2/b1 hehehe stat /a2/b1 #dataVersion = 2 set -v 1 /a2/b1 hehehehe #version No is not valid : /a2/b1 set -v 2 /a2/b1 hehehehe #delete不能直接删除带子节点的节点, 和set一样支持-v条件删除 delete /a2/b1 delete /a2 #删除节点及其子节点 deleteall /a1 ZK原生java操作 curator规则混乱监听不靠谱 依赖 <dependency> <groupId>org.apache.zookeeper</groupId> <artifactId>zookeeper</artifactId> <version>3.7.2</version> </dependency> <dependency> <groupId>ch.qos.logback</groupId> <artifactId>logback-classic</artifactId> <version>1.2.3</version> </dependency> ZKConnection public class ZKConnection { private static final String SERVER_PATH = "192.168.149.136:2181"; // 当客户端在 TIMEOUT 时间内没有向 ZooKeeper 服务器发送心跳（或其他请求），就会认为客户端已经失去连接，并关闭这个会话并清理与该会话相关的临时节点 // 短暂的网络波动可能会导致连接重试。如果怀疑网络延迟，适当增大 TIMEOUT 值 private static final int TIMEOUT = 10000; private static final CountDownLatch connectedSignal = new CountDownLatch(1); private static ZooKeeper zk; public static ZooKeeper getConn() throws IOException, InterruptedException { //客户端和服务端之间是异步连接 zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKWatcher()); System.out.println("Connecting to ZooKeeper..."); connectedSignal.await(); System.out.println("Connected to ZooKeeper"); return zk; } public static void releaseConn() throws InterruptedException { if (zk != null) { zk.close(); } } } ZKWatcher public class ZKWatcher implements Watcher { private static final String SERVER_PATH = "192.168.149.136:2181"; // 当客户端在 TIMEOUT 时间内没有向 ZooKeeper 服务器发送心跳（或其他请求），就会认为客户端已经失去连接，并关闭这个会话并清理与该会话相关的临时节点 // 短暂的网络波动可能会导致连接重试。如果怀疑网络延迟，适当增大 TIMEOUT 值 private static final int TIMEOUT = 10000; private static final CountDownLatch connectedSignal = new CountDownLatch(1); private static ZooKeeper zk; public static ZooKeeper getConn() throws IOException, InterruptedException { zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKWatcher()); System.out.println("============= Connecting to ZooKeeper..."); connectedSignal.await(); System.out.println("============= Connected to ZooKeeper"); return zk; } @Override public void process(WatchedEvent event) { System.out.println("============= Received event: " + event); if (event.getState() == Event.KeeperState.SyncConnected) { connectedSignal.countDown(); } try { switch (event.getType()) { case NodeCreated: System.out.println("============= Node created: " + event.getPath()); break; case NodeDeleted: System.out.println("============= Node deleted: " + event.getPath()); break; case NodeDataChanged: System.out.println("============= Node data changed: " + event.getPath()); // 获取数据并重新注册监听器 byte[] newData = zk.getData(event.getPath(), true, null); System.out.println("============= Data updated: " + new String(newData)); break; case NodeChildrenChanged: System.out.println("============= Node children changed: " + event.getPath()); // 获取子节点列表并重新注册监听器 zk.getChildren(event.getPath(), true); break; default: break; } } catch (Exception e) { e.printStackTrace(); } } } Demo public class Demo { public static void main(String[] args) { ZooKeeper zk = null; try { zk = ZKWatcher.getConn(); // 注册节点存在性监听器 Stat exists = zk.exists("/t1", true); if (exists == null) { System.out.println("============= 节点不存在"); } // 创建节点 zk.create("/t1", "hello".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); //world:anyone // 注册数据变更监听器 //zk.getData("/t1", true, zk.exists("/t1",false)); zk.getData("/t1", true, null); // 注册子节点变更监听器 zk.getChildren("/t1", true); // 创建子节点 zk.create("/t1/child1", "child".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // 删除子节点, -1 作为版本号参数表示忽略版本检查 zk.delete("/t1/child1", -1); // 修改节点数据 zk.setData("/t1", "hello2".getBytes(), zk.exists("/t1",false).getVersion()); // 删除节点 //zk.delete("/t1", zk.exists("/t1",false).getVersion(), new DeleteCallBack(), "上下文信息"); zk.delete("/t1", -1); // 确保delete被捕获处理 Thread.sleep(1000); // 保持程序运行以监听事件 // 服务端命令行验证watcher事件 [zk: localhost:2181(CONNECTED) 121] set /t1 "666" //while (true) { // Thread.sleep(1000); //} } catch (IOException | InterruptedException | KeeperException e) { e.printStackTrace(); } finally { try { ZKConnection.releaseConn(); } catch (InterruptedException e) { e.printStackTrace(); } } } static class DeleteCallBack implements AsyncCallback.VoidCallback { @Override public void processResult(int rc, String path, Object ctx) { System.out.println("============= 删除节点: " + path); System.out.println("============= 上下文: " + ctx); System.out.println("============= 结果代码: " + rc); if (rc == KeeperException.Code.OK.intValue()) { System.out.println("============= 删除成功"); } else { System.out.println("============= 删除失败，错误码: " + rc); } } } }`,``,`html`,`Zootopia`,`20240307183503-影摘 朱迪的“blood! blood! blood!” 表演很有趣 仓鼠排队买冰棍 我很吵,但是不要指望我们为此向你道歉 fluff butt farm girl bunny bumpkin corrot face fuzzy bunny 树獭 教父 try everything`,``,`html`,`七种武器之孔雀翎`,`20250128220340-影摘 一个人不过就一张嘴, 一个身子, 要那么多银子干什么 各花入各眼 可以过养花莳䓍与世无争的日子 莳，汉语二级字，读作shí或shì，其本意为移植；栽种。 不过几具臭皮囊, 下辈投胎找具更好的也就是了 人生没有回头路, 何必伤神想过去呢`,``,`html`,`三少爷的剑`,`20250103195358-影摘 正所谓莫问收获先耕耘 她老是欺负我, 斗蟋蟀斗输了, 就发郡主脾气还把我的蟋蟀踩死了, 简直就是个刁蛮不讲理的郡主 如果是铁锤, 当奋力敲击, 如果是铁砧, 当稳如磐石 忘年之交 指年龄辈分不相同的人结交而成的朋友`,``,`html`,`不可饶恕`,`20240307183503-影摘 克林特·伊斯特伍德 Clint Eastwood 没有人有权利去判断一个人该不该死，罪恶是一个人内心的承担，而不是别人外在的指责`,``,`html`,`中国典故大辞典1`,`20250323213555-书摘 哀梨 南朝宋刘义庆《世说新语·轻诋》：“桓南郡每见人不快，辄嗔云：‘君得哀家梨，当复烝食不？”’桓南郡：桓玄。嗔：发怒，生气。哀家梨：刘孝标注：“旧语：秣陵有哀仲家梨甚美，大如升，入口消释。”熙：同“蒸”。后比喻说话或文章流畅爽利，听者阅者感到“如食哀家梨”。也用“哀梨蒸食”比喻不知好歹，把好东西胡乱地糟蹋了。 在唐朝之后的古典小说《幽梦影》中有一段用哀家梨来作形容的话语是这样写的，“今举集中之言，有快若并州之剪，有爽若哀家之梨，有雅若钧天之奏”，可见哀家梨名声之大。 矮人看场 20250228234122.webp 爱妾换马 20250228234108.webp 爱吾庐 20250228234107.webp 爱惜分阴 20250228234110.webp 爱媵贱女 20250228234109.webp 拔葵去织 20250228234041.webp 拔山扛鼎 20250228234040.webp 霸陵醉尉 20250228234159.webp 白发三千丈 20250228234118.webp 白兔捣药 20250228234117.webp 白猿剑术 20250228234119.webp 百万化鱼 20250228234120.webp 板荡 20250228234054.webp 半臂怜姬 20250228234007.webp 半闲堂 20250228234008.webp 宝窗选婿 20250228234024.webp 宝珠穿蚁 20250228234023.webp 报竹平安 20250228234038.webp 抱璧 20250228234039.webp 初，公自城上，见己氏之妻发美，使髡之，以为吕姜髢，既入焉，而示之璧，曰，活我，吾与女璧，己氏曰，杀女，璧其焉往，遂杀之，而取其璧，卫人复公孙般师而立之。[1] 卫庄公从城上看到己氏的妻子头发漂亮，派人让她剪下来，作为吕姜的假发。前478年（鲁哀公十八年、卫庄公三年）十一月十二，石圃带领工匠讨伐卫庄公，卫庄公投奔戎州己氏，把玉璧给己氏看，说：“你救我的命，我给你玉璧。”己氏说：“杀了你，玉璧会到那里去？”杀死了卫庄公，得到玉璧。卫国人让公孙般师回国为君。 补天手 20250228234143.webp 捕鹞 20250228234045.webp 有一天，信陵君魏无忌正在吃饭时，有一只斑鸠飞到桌子下，魏无忌派人四处看了看，看见一只鹞鸟飞离屋顶，随后他们就把斑鸠赶出屋外。不久，斑鸠便被鹞鸟捕杀了。傍晚，魏无忌吃不下饭，他难过的说：“斑鸠是为了躲避鹞鸟的追捕才躲到我的饭桌下，而我却把它赶了出去，因而被鹞鸟捕杀，是我害了它，我一定要捉到这只杀鸠的鹞鸟。”他派左右的人捕捉了二百多只鹞鸟。本来，他准备杀掉所有的鹞鸟，但害怕伤及无辜，于是他按着剑走到鸟笼前，大声的问：“谁杀了斑鸠？”有一只鹞鸟低着头，不敢抬头看魏无忌。魏无忌便杀了那只鹞鸟，其余尽数放走。从此，魏无忌仁爱的声名远播，天下的人都称许他。（《艺文类聚・卷九十一》） 匪石之心 20250228234006.webp 焚车 20250228234106.webp 风雨如晦 20250228234203.webp 风月债, 风月无边 20250228234202.webp 浮瓜沉李 20250228234100.webp 釜中游鱼 20250228234158.webp 腐草为萤 20250228234130.webp 腹稿 20250228234131.webp 高凤自秽 20250228234208.webp 高行割鼻 20250228234209.webp 高阳酒徒 20250228234210.webp 割炙之报 20250228234005.webp 歌罢钱塘, 赋罢高唐 20250228234056.webp 《高唐赋》是战国末期辞赋家宋玉创作的一篇赋。此赋在序中通过对话写了楚顷襄王之前的某位楚王（“先王”）梦遇巫山神女的故事。 庚宗之祸 20250228234032.webp 刘宽雅量 20250228234001.webp 公路绝粮 20250228234000.webp 狗彘不若 20250228234111.webp 姑妄言之 20250228234020.webp 鼓盆之戚 20250228234220.webp 鼓腹游 20250228234221.webp 故剑 20250228234047.webp 20250228234048.webp 及瓜而代 20250228234009.webp 宋·李心传《建炎以来系年要录》卷一八五：“瓜时而往，及瓜而代。二年一替，军人往之久矣。今将及期而改，是上失信而下失望也。遂令更成如期。”[1] 春秋时期，齐国的国君襄公曾会同宋、鲁、陈、蔡四国进攻卫国。周庄王发兵救卫，也吃了败仗。齐襄公怕周王兴师问罪，便派连称为大将、管至父为副将，前往葵丘，领兵防守。[3] 连、管二将奉命出发的时候，小心请示：“守卫边境的艰苦任务，我们不敢推辞。但是，您什么时候派人来代替我们，让我们交班返回呢？”那时正是夏季，襄公一边吃瓜，一边随口答道：“及瓜而代”襄公的意思是说：今年瓜熟的时候你们出发，到明年瓜熟之时我派人去代替你们。 第二年夏季，连称和管至父在葵丘吃到了瓜，想起襄公“及瓜而代”的那句话，便打发人到临淄（当时齐国的都城）去，探听襄公是否快要派人来代替他们了。可是探听的人回来说：襄公不在临淄，到谷城（今山东东阿县）去已经一个月了。连称非常生气，就要去杀死襄公。管至父不同意动武，主张就以瓜作礼物，先派人去献给襄公，趁机提醒他“瓜时”已到，请他实现去年所许的诺言。[3] 连称同意了管至父的主张，他们就这么办了。可是，襄公却反而大怒，说道：“代不代替，调不调回，都必须凭我作主，怎么可以自己来请求呢？再等下一次瓜熟吧！”连、管二将听了这个回音，对于不守信义的襄公大为不满。[3] 连称为此非常恨齐襄公，便和管至父一起秘密谋划，想找机会杀死齐襄公。齐襄公的父亲齐僖公有一个侄儿名叫公孙无知，很得僖公宠爱衣服、礼仪方面的待遇和嫡子一样。可是齐襄公即位以后，降低了公孙无知的待遇，他对此极为不满，心里怨恨齐襄公。连称就以公孙无知的族号发动叛乱，带领武士攻进宫里，杀死守卫兵士，接着找到躲藏在门内的齐襄公，一刀将他杀死。管至父、连称拥立公孙无知为国君。[2] 瓜田李下 20250228234112.webp 挂角 20250228234043.webp 挂瓢 20250228234042.webp 亦作“许由一瓢”。尧时高士许由以多一瓢为烦扰而丢弃的故事。汉代蔡邕《琴操．箕山操》“许由者，古之贞固之士也，尧时为布衣。夏则巢居，冬则穴处，饥则仍山而食，渴则仍河而饮。无杯器，常以手捧水而饮之，人见其无器，以一瓢遗之，由操饮毕，以瓢挂树，风吹树动，历历有声，由以为烦扰，遂取捐之。 许由 夏天在树上巢居，冬天在山洞穴处。饿了就在山上找食物吃，渴了就去河边饮水，也没有杯子，经常用手捧着喝。有人见他没有器具，送给他一只瓢。许由用瓢喝完水，把它挂在树上，风吹树动，瓢摇晃作响，许由认为这响声令人生烦，于是取下把瓢摔掉不要。 许由弃瓢 许由用手捧水喝，别人给他瓢，他喝过水挂在树上，嫌风吹有声音，把瓢扔掉。后遂用“一瓢挂树、挂瓢、弃瓢、风瓢、许由瓢”等写隐逸傲世，又“许由瓢”亦指别人施赐之物；用“弃瓢翁、弃瓢叟”等称隐逸傲世的人；用“挂瓢风树、一瓢喧”等喻烦扰。 贯虱 20250228234141.webp 贯朽栗腐 20250228234152.webp 灌水浮毬 20250228234103.webp 龟三顾, 左顾龟 20250228234222.webp 《晋书•孔愉传》：“愉尝行经余不亭，见笼龟于路者，愉买而放之溪中，龟中流左顾者数四。及是，铸侯印，而印龟左顾，三铸如初。印工以告，愉乃悟，遂佩焉。”后以“左顾龟”指官印。 龟息 20250228234223.webp 鬼可卖 20250228234212.webp 贵妃捧砚 20250228234153.webp 含饭之恩 20250228234011.webp 韩卢逐逡 20250228234200.webp 韩卢的解释 亦作“ 韩子卢 ”。亦作“ 韩獹 ”。. 战国 时 韩国 良犬，色墨。《战国策·秦策三》：“以 秦 卒之勇，车骑之多，以当 诸侯 ，譬若放韩卢而逐蹇兔也。” 鲍彪 注：“韩卢，俊犬名。《博物志》：‘ 韩 逡的解释 逡 qū n退让，退却：逡巡。 部首 ：辶。 韩寿偷香 20250228234201.webp 郑生窃玉 暗通款曲 好好 20250228234019.webp 味道贺雪, 仲冕吟雷 20250228234012.webp 红线盗盒 20250228234128.webp 呼牛呼马 20250228234013.webp 壶公 20250228234016.webp 虎媒 20250228234140.webp 虎丘剑光 20250228234138.webp 20250228234139.webp 护花铃 20250228234037.webp 花鸟使 20250228234133.webp 花雨 20250228234132.webp 骅骝捕鼠 20250228234205.webp 画皮 20250228234116.webp 画中人 20250228234114.webp 20250228234115.webp https://www.ntdtv.com/gb/2018/11/23/a1400510.html 怀璧 20250228234036.webp 怀刺漫灭 20250228234034.webp 怀橘 20250228234035.webp 还剪 20250228234155.webp 衣不经新何由得故 20250228234142.webp 三荆欢同株, 四鸟悲异林 20250228233958.webp 黄金入柜 20250228234218.webp 黄金与土同价 20250228234217.webp 黄梁梦 20250228234216.webp 黄钟与瓦釜 20250228234219.webp 潢潦无源 20250228234102.webp 挥金陌上 20250228234044.webp 毁玉解诉 20250228234057.webp 昏定晨省 20250228234049.webp 喙长三尺 20250228234014.webp 饥用饱扬 20250228234204.webp 机械者流 20250228234052.webp 鸡虫得失 20250228234215.webp 鸡犬新丰 20250228234214.webp 鸡五德 20250228234213.webp 积善余庆, 积恶余殃 20250228234123.webp 嵇侍中血 20250228234030.webp 羁鸟 20250228234129.webp 及肩之墙 20250228234010.webp 巧者一决而不犹豫, 是以疾雷不及掩耳 20250228234031.webp 棘刺情 20250228234055.webp 藉寇兵赍盗粮 20250228234137.webp 不弃踦履 20250228233959.webp 计日受奉 20250228234150.webp 记事珠 20250228234151.webp 季伦园 20250228234022.webp 蓟子历家 20250228234136.webp 髻中鸟卵 20250228234211.webp 骥服盐车 20250228234206.webp 20250228234207.webp 夹袋选才 20250228234017.webp 嫁杏 20250228234021.webp 故事说的是一个人家堂前的杏树只开花而不结子，有个媒婆替杏树遣嫁，为杏树披上嫁衣，设酒宴祝祷，明年，杏树果然开花结子了，这就是「嫁杏」 一丛花·伤高怀远几时穷 【宋】张先 伤高怀远几时穷？无物似情浓。离愁正引千丝乱，更东陌、飞絮蒙蒙。嘶骑渐遥，征尘不断，何处认郎踪？ 双鸳池沼水溶溶，南北小桡通。梯横画阁黄昏后，又还是、斜月帘栊。沉恨细思，不如桃杏，犹解嫁东风。 “沉恨细思，不如桃杏，犹解嫁东风。”主要意思是写女子以桃杏都能嫁得一年一度按时归来的春风,感叹自己空闺独守,青春年华白白消逝。而此词中的她,在相思中消磨着美好的年华,其遭际远不如桃花,桃花快要凋谢的时候还懂得嫁给东风，有所归宿，自己却只能形影相吊中消尽青春。说“桃杏犹解”，言外之意是怨嗟自己未能抓住“嫁东风”的时机，以致无所归宿。 奸人妇人之泣 20250228234018.webp 尖头奴 20250228234027.webp 曾经太武帝拓拔焘前往河西打猎，诏命尚书令古弼为随从骑士选送良马，古弼却把劣马供给他们使用。太武帝大怒，要杀古弼，古弼却说：“吾为人臣不使人主盘于游畋其罪小不备不虞乏军国之用其罪大。吾为国远虑，虽死何伤！”拓拔焘听了，叹曰：“有臣如此，国之宝也。”古弼头颅上尖下圆，像毛笔的笔尖。太武帝给他取绰号叫“笔头”，生气时叫他“尖头奴”。 坚瓠 20250228234015.webp 剪彩为花 20250228234002.webp 剪春韭 20250228234003.webp 剪翎送笼 20250228234004.webp 剪翎送笼中, 使看百鸟翔 见猎心喜 20250228234144.webp 渐台水死 20250228234101.webp 田单火牛，江逌爇鸡 20250228234113.webp 战国时齐将田单于公元前279年，在即墨（今山东平度东南）用“火牛阵”大败燕军，一举收复70余城，恢复齐国的故事，为大家所周知。然而，东晋时江公式用“火鸡阵”破敌的事，却鲜为人知。 据《晋书》记载，东晋时武将殷浩与姚襄素不和。晋穆帝永和九年（公元353年），殷浩闻前秦有内乱，出兵北上，以姚襄为前锋，谋取洛阳。姚襄趁机反晋，在山桑（今安徽蒙域北）袭击晋中军将军殷浩防地。当时，姚襄兵力雄厚，阵地坚固，殷浩命部将江公式率兵出击。江公式亲临现场侦察，发现姚兵堑栅坚固，而自己“马瘦兵单”，如果硬拼，难以取胜，便想出了一个“火鸡阵”的计谋。于是，他命部下捉来高大雄鸡数百只，用长绳将其连在一起，并把硫黄等易燃物系在鸡身上。出击时，把鸡带到姚襄兵营寨前，将系在鸡身上的易燃物点着后向姚兵营驱赶。顿时，因身上着火而受惊的群鸡直冲姚襄兵营，鸡翅拍击，煽风助火，火势更烈，引得姚营寨烟火大作，姚兵不知何故，乱作一团。此时，江公式乘势率军攻入混乱中的姚营，一举击败姚军，取得大胜。这也可算作鸡为战争所做的一次“贡献”吧。 将军换马 20250228234026.webp 《瓮牖闲评》说得一清二楚：军主不可自表暴，以防敌之窥伺也。这也是为保证作战胜利的要求。不仅仅是白马，其他一切导致主将暴露的醒目标识，都可能会带来灾难性的结局，史书中这方面的记载层出不穷。 《资治通鉴》记载，南北朝时期名将殷孝祖，上阵时喜欢随身携带鼓乐和伞盖，他所到之处敲锣打鼓，伞盖高举，只要不聋不瞎，一眼就能看见他。 殷孝祖的部下私下给他起个外号，叫“死将”，议论说：“今与贼交锋，而以羽仪自标显，若善射者十人共射之，欲不毙，得乎？”认为他迟早吃亏。果然在泰始二年的作战中，被敌军一箭射死。有的武将深明此理，比如《北史》记载，名将王思政“久经军旅，战唯著破衣敝甲”，一上阵就穿的破破烂烂，一身旧衣服旧盔甲。在河桥之战中战败，他身负重伤，躺在地上动弹不得，敌兵从他身边过去，一看他衣衫褴褛，以为他是小兵，理都没理他，结果幸免于难。 当然凡事无绝对，有的人就敢标新立异。《三国志》记载，军阀公孙瓒上阵就喜欢骑白马，人称白马将军。不过他一不傻二不愣，他手下的精锐部队“白马义从”，士兵们清一色都是骑白马，所以他骑白马并不显眼，反而成了保护色，他要骑其他颜色战马，反而会成了靶子。 浇瓜之惠, 卑梁之衅 20250228234058.webp 20250228234059.webp 梁国的大夫宋就，曾做过边县县令，边县与楚国相邻。梁国的边亭，与楚国的边亭，都种瓜，各自对地里的瓜的多少都有数。住在梁国边亭的百姓，勤劳，常常给瓜灌水，瓜因此长得好。楚国边亭的百姓偷懒，很少为瓜浇灌，瓜长得甚差。 负责管理楚国边亭的县令看见梁国边亭的瓜长得那么好，非常恼怒自己边亭的瓜如此之差。楚亭人由此妒恨梁亭人，就在夜里去把梁亭的瓜捣毁了一些。梁亭人发现后就请来兵尉，也想去毁掉楚亭之瓜，兵尉就去请示宋就。宋就说：“恶是造成怨祸的根源。别人恶你也恶，就更坏了。若我教子，必定每天晚上让人偷偷地为楚亭浇瓜，而不让他们知道。” 于是梁亭人就每天晚上偷偷地去给楚亭瓜浇水。白天时，楚亭人也去为瓜灌溉，瓜的长势一天天的好起来。楚亭人很奇怪，就暗中观察，发现是梁亭人所为。楚县令听说后非常高兴，就将此事报告给楚王了。楚王知道后，感到非常惭愧，告诉官吏说：“毁瓜者，难道没罪吗？这是梁人在退让。”于是楚王以重金相谢，向梁王示好。由宋就开始，梁楚交好。 春秋时期，吴国边城卑梁（今安徽天长）与楚国边城钟离（今安徽凤阳）毗邻，两国经常为了边境上的一点小事，摩拳擦掌。 一日，因为采摘桑叶，一个吴国小女孩和一个楚国小女孩起了争执。原因是，在卑梁、钟离两城界碑之间，不偏不倚生长了一棵桑树，两人都认为这棵桑树是自己国家的财物。 楚国小女孩先出手打了吴国小女孩，并从其手上夺走了所有的桑叶。吴国小女孩气鼓鼓地跑回家向父母告状，其父母遂抄家伙领着村里众人越过边境去找楚国小女孩算账。 两家人由此爆发冲突，结果，数名卑梁人客死钟离，矛盾瞬间升级为区域冲突。卑梁大夫爱民如子，哪里忍得了楚国人杖杀自己辖下百姓，遂组织地方部队进攻钟离。这下，区域冲突上升成了国家矛盾。 听闻钟离被攻打，楚平王勃然大怒，直接率兵平了卑梁。吴王僚也不甘示弱，待楚兵班师，他就率军西征，先夺回卑梁，再拿下钟离、占巢（今安徽巢湖），以泄其心头之愤。 为了一棵桑树，两国不惜兵戎相见，由此诞生了一个成语：卑梁之衅。但，这场类似于“蝴蝶效应”的战争，又从侧面反映了桑蚕文化对中国农业的影响有多深远。 解剑拜仇, 归田息诉 20250228234145.webp 韩延寿于神爵三年被选调入京试任左冯翊，一年后因为称职而转正。此后一年多，他一直不肯巡行视察所属各县，其属官多次劝他说：“您应该巡视郡中，这样可以了解民间风俗，考察地方官员的治理情况。”韩延寿说：“各县都有贤明的县令长，又有督邮在各县监察，巡视各县恐怕没有什么益处，反而会给地方增加麻烦。”属下们皆认为目前正值春月，出去巡视可以鼓励农民努力农业生产。韩延寿不得已，只好外出巡视，当巡视到高陵县时，有兄弟二人因争夺田产来告状，韩延寿十分痛心，说道：“我有幸充数为官，成为郡民的表率，但我却没有使百姓明白政风教化，致使骨肉之间发生这样的争执，既有伤风俗教化，更使得当地贤明的长吏、啬夫、三老、孝悌等蒙受耻辱，责任完全在我，我应当首先辞职反省。”当天他即托辞有病，不再处理公务，在传舍中闭门思过[1]。 全县的人都不知道该怎么办，县令、县丞、啬夫、三老都将自己捆绑着等待接受处分。这样一来，争讼的族人互相责备，两兄弟也深感悔恨，都自己剃去头发，袒露上身，表示甘愿伏罪，两人皆愿把田产相让，至死也不敢再有争议。韩延寿闻讯大喜，开门接见，拿出酒肉款待，和他们一同进餐，好言劝勉，并叫他们把意思转告给当地乡亲，以此来表彰鼓励悔过自新的百姓。韩延寿这才开始处理政事，接见县乡各级官吏，向他们表示感谢和慰问。这样，郡中和睦安定，百姓们无不相互告诫勉励，不敢再有类似的事情发生。韩延寿的恩德与威信遍及二十四县，再没有为了争执是非而向他申诉的。韩延寿推心置腹，以诚相待，吏民们都不忍欺骗他[1]。 解连环 20250228234147.webp 解铃系铃 20250228234148.webp 解围为小郎 20250228234146.webp 解颐 20250228234149.webp 金屋藏娇 20250228234157.webp 金针度人 典出唐·冯翊的《桂苑丛谈·史遗》：说唐朝有一女子名叫郑采娘，能做一手细腻的针线活，但她希望技艺得到进一步提高。某年七月初七（凡间妇女向织女乞巧，又称“乞巧节”），采娘设案焚香，向天上的织女祈告说：你是织布的圣手，能否把针绣的窍诀传授于我呢？不多会儿，天光洞开，出现一溜精致的华车，居中那辆坐着一位仪态端庄的女子，身披彩云似的轻纱衣裳。只见她走下车来，笑着说“我就是织女”，便递给采娘一根一寸多长的金针，嘱咐她务必把针缀在纸上，或别在裙带上，三天之内不要说一句话，就会得到针绣的奇巧了。采娘依循织女的交代，三天后果然遂愿，从此飞针走线，技艺大进。后人遂以“金针度人”作为倾囊相授、与人方便的寓意。 景阳宫井, 胭脂井 20250228234050.webp 酒入舌出 20250228234156.webp 董昭救蚁, 毛宝放龟 20250228234135.webp 居甬东 20250228234028.webp 据胡床指点银瓶 20250228234046.webp 屦及剑及 20250228234029.webp 郑国人明白懂事，宋国人昏聩糊涂，去晋国的使者不会被伤害，我却一定会被杀死。 华元说：“经过我国而不请求借路，这是把我国作为楚国边境内的县城。把我们当作县城，这是视我为被灭亡之国。杀了楚国的使者，楚国必然会进攻我国，进攻我国也不过是被灭亡。反正一样是灭亡。”就杀死了申舟。 灭烛绝缨 20250228234104.webp 20250228234105.webp 美人空自绝冠缨, 岂为娥眉失虎臣 汉·韩婴《韩诗外传》卷七第十四章：“楚庄王赐其群臣酒，日暮酒酣，左右皆醉。殿上烛灭，有牵王后衣者。后扢冠缨而绝之，言于王曰：‘今灭烛，有牵妾衣者，妾扢其缨而绝之愿趁火视绝缨者。’王曰：‘止’。立出令曰：‘与寡人饮，不绝缨者，不为乐也。’于是冠缨无完者，不知王后所绝冠缨者谁。于是王遂与群臣欢饮，乃罢。后吴兴师攻楚，有人常为应行合战者，遂取大军之首而献之。王怪而问之曰：‘寡人未尝有异于子，子何为于寡人厚也？’对曰：‘臣先殿上绝缨者也。当时宜以肝胆涂地。负日久矣，未有所效。今幸得用于臣之义，尚可为王破吴而强楚。’”[1] 矍铄翁 20250228234121.webp 君家果 梁国杨氏子九岁，甚聪惠。孔君平诣其父，父不在，乃呼儿出。为设果，果有杨梅。孔指以示儿曰：“此是君家果。”儿应声答曰：“未闻孔雀是夫子家禽。” 　　梁国一户姓杨的人家家里有一个九岁的儿子，非常聪明。孔君平来拜见他的父亲，恰巧他父亲不在，于是便叫他出来。他为孔君平端来水果，水果中有杨梅，孔君平指着杨梅给孩子看，并说：“这是你家的水果。”杨氏子马上回答说：“没听说孔雀是先生您家的鸟。” 朝菌不知晦朔, 蟪姑不知春秋 20250228234051.webp 趋炎附热, 看人眉睫 20250228234154.webp 康猧乱局 20250228234033.webp 糠秕在前, 沙砾在后 20250228234127.webp 苛政猛于虎 20250228234134.webp 操刀宰天下 胡旦晚年失明，闭门闲居。一日史馆共议作一贵侯传，其人少贱，尝屠豕。史官以为讳之即非实录，书之又难为辞，相与见旦，旦曰：“何不言某少尝操刀以割，示有宰天下之志。”莫不叹服。 最自信的状元 宋太宗元年，有一书生到山东某县游览。知县大人得知该书生颇有文采，便设宴款待。知县的公子很蔑视那书生，问其有何特长，书生说工诗。公子便让他诵读一首，书生诵了一首，最后一句是：“挑尽寒灯梦不成。”公子一听，大笑说：“此乃一瞌睡汉。”书生十分气愤。这书生便是吕蒙正，第二年，吕蒙正一举夺魁。他写信给那公子：“瞌睡汉如今中了状元啦。”公子看了他的信，冷笑一声：“待我明年第二人及第，输你一筹。”第二年，新科状元正是这位公子——胡旦。综观科举史，有如此自信者，胡旦当属第一。 空器馈 20250228234124.webp 杞梁之妻 20250228234053.webp 根据历史学家的追溯，“孟姜女哭长城”的故事原型，其实是发生在春秋时期的“杞梁之妻”。 根据《左传》的记载，齐庄公四年（前550年），齐国大夫杞梁率兵讨伐卫、晋，次年回师途中，又奉命讨伐突袭莒国，结果不幸战死沙场。 后来齐莒讲和罢战，齐人将杞梁尸身运回临淄，杞梁妻子迎丈夫灵柩于郊外，恰好遇到齐庄公派人前来吊唁，杞梁妻认为丈夫有功于国，齐庄公派人在郊外吊唁既缺乏诚意，又仓促草率，因此予以回绝。齐庄公得知后，于是亲自前往杞梁家中吊唁，并把杞梁安葬在齐都郊外。 齐杞梁殖之妻也。 庄公袭莒，殖战而死。庄公归，遇其妻，使使者吊之于路。杞梁妻曰“今殖有罪，君何辱命焉。若令殖免于罪，则贱妾有先人之弊庐在下，妾不得与郊吊” 于是庄公乃还车诣其室，成礼然后去。杞梁之妻无子，内外皆无五属之亲。既无所归，乃就其夫之尸于城下而哭之，内諴动人，道路过者莫不为之挥涕，十日，而城为之崩。既葬，曰“吾何归矣？夫妇人必有所倚者也。父在则倚父，夫在则倚夫，子在则倚子。今吾上则无父，中则无夫，下则无子。内无所依，以见吾诚。外无所倚，以立吾节。吾岂能更二哉！亦死而已” 遂赴淄水而死。 君子谓杞梁之妻贞而知礼。 诗云“我心伤悲，聊与子同归”此之谓也。 颂曰： 杞梁战死，其妻收丧，齐庄道吊，避不敢当，哭夫于城，城为之崩，自以无亲，赴淄而薨。 宽猛相济 20250228234025.webp 窥宋 20250228234125.webp 20250228234126.webp 王昌，即东家王昌，诗词中常与宋玉并列，一般认为是魏晋南北朝时人。唐朝诗人认为，乐府诗歌中的洛阳女儿莫愁倾慕于王昌。 鱼玄机《赠邻女(寄李亿员外)》 羞日遮罗袖，愁春懒起妆。易求无价宝，难得有心郎。 枕上潜垂泪，花间暗断肠。自能窥宋玉，何必恨王昌。`,``,`html`,`中国典故大辞典2`,`20250419094834-书摘 校人欺子产 昔者有馈生鱼于郑子产①，子产使校人②畜之池。校人烹之，反命曰：“始舍之，圉圉（yǔ）③焉，少则洋洋焉，攸然而逝。”子产曰：“得其所哉！得其所哉！” 校人出曰：“孰谓子产智，予既烹而食之，曰：‘得其所哉！得其所哉！’” 故君子可欺以其方，难罔④以非其道。 注释： ①子产：春秋时期郑国著名的政治家。 ②校人：管理池沼的小吏。 ③圉圉（yǔ）：鱼在水中疲弱而游不太灵活的样子。 窥御激夫 20250419094855.webp 夔怜蚿 20250419094802.webp 随以鞭捶, 随以斧钺, 莱妻 20250419094921.webp 烂柯人 20250419094839.webp 传说在西晋时有个叫王质的青年农民，一次上山打柴，来到王乔仙洞口。王质胆大好奇，心想，人家都说洞里有仙人，我何不进去看个究竟？因洞口很小，只能通过一个人，洞深三丈余，宽余高各丈许。王质刚进洞中什么也看不见。顷刻之间，洞顶好像透进来光线，只见两个小孩正在下围棋。王质素好下棋，被两位小孩精湛的棋艺一下子给吸引住了。两位小孩好像未发现有人进洞似的，边下棋边吃大枣，有时也顺手把枣递给王质吃。看完一局棋后，小孩对王质说：“你也该回家了。”王质俯身去拾斧子，想不到斧柯（斧柄）已经烂朽，只剩下铁斧了。王质回到村里，怎么一个人也不认识了，询问自己的父母，才知道他们已经死去一百多年了，从此，后人就把这座山叫“烂柯山”。 王质在山中逗留了片刻，人世间已经发生了巨大的变化。这故事因此常常被人们用来形容人世间的巨变。唐代诗人刘禹锡《酬乐天扬州初逢席上见赠》中 "到乡翻似烂柯人"一句，就引用了这个典故。诗人用王质自比，表达了他遭贬离开京城二十多年后，人世的沧桑巨变所带给他的恍如隔世的感觉。 空尸相位, 浪子宰相 20250419094854.webp 栎釜 20250419094827.webp 十斛麦 20250419094749.webp 20250419094750.webp 老拳毒手 20250419094906.webp 老妪解诗 20250419094905.webp 罍满罄瓶 20250419094902.webp 稜等登 20250419094853.webp 离朱之明 20250419094852.webp 骊姬之乱 20250419094933.webp 晋献公娶了六个妻子，生了五个儿子。其中，齐姜生了太子申生，戎国大戎狐姬生了重耳，她妹妹小戎子生了夷吾。骊戎族人许配了骊姬给晋献公，骊姬生下一子，取名奚齐，她陪嫁的妹妹生了卓子。 当初，晋献公想立骊姬为夫人，他占卜了两次，先“卜”后“筮”，第一次“卜”结果不吉利，第二次“筮”结果吉利。虽然占卜之人认为“卜”比“筮”准确，献公依然决定按照第二次的结果办事。[1] 骊姬受到晋献公的宠爱，她希望立奚齐为太子，让他继承君位。她贿赂晋献公宠信的大夫梁五和东关嬖五，使他们说服献公让太子申生、重耳和夷吾离开京城。那两个大夫对献公说戎族人和狄族人经常侵犯晋国，需要派长子捍卫领土，使戎狄再也不敢侵犯国家。献公让太子住在曲沃（今山西闻喜县东），重耳住在蒲城（今山西隰县西北），夷吾住在二屈（今山西吉县）。蒲与二屈在边境，近狄人之地，两个大夫借用保卫国家安全的名义，请献公派重耳及夷吾至边境，以强其疆，从而来阻止献公的长子当国君。[2] 前656年，骊姬施展阴谋，陷害太子申生，让申生到曲沃去祭祀亡母，而且把用来拜神的肉和酒拿回来献给他父亲献公。骊姬在酒肉偷偷地下了毒，又进言希望试验一下食品安全，晋献公把肉给狗吃，狗被毒死了，又给小臣吃，小臣也被毒死了，所以献公发现酒肉有毒，以为是申生想谋杀他。申生逃回曲沃，晋献公杀了申生的师傅杜原款。 有人建议申生为自己申辩，向献公揭露骊姬的阴谋，申生回答：“我父君如果没有骊姬，寝食不安，如果为自己辩护，骊姬会受到惩罚，父君年纪那么大，我又不能使他快乐。”那个人就劝告申生快点逃走，申生不肯。于是，十二月十七日，申生自缢于曲沃，人称恭太子。 骊姬野心勃勃，也陷害太子申生的弟弟重耳和夷吾，献公攻打蒲城讨伐重耳，重耳带着贤士赵衰、狐偃（咎犯）、贾佗、先轸等往狄族人的地方逃走。 前655年，晋献公派贾华等人往二屈讨伐夷吾，夷吾往梁国逃走。 前651年九月，晋献公逝世，立十五岁的奚齐为国君，拜荀息为相国，希望其鼎力相助。十月，晋国大夫里克杀了刚刚即位的奚齐，当时晋献公还没有安葬。荀息立奚齐的弟弟卓子为君。十一月，里克又杀了卓子和骊姬，荀息悬梁自尽。[3] 里克迎接了重耳回国即位，重耳害怕危险，以“负父之命，出奔，父死，不得修人子之礼侍丧，重耳何敢入！”谢绝，所以里克立了重耳弟弟夷吾。 冯唐易老, 李广难封 李猫 20250419094826.webp 李勉负心 20250419094825.webp 立雪 20250419094856.webp 连璧, 连城璧 20250419094917.webp 练裳竹笥 20250419094859.webp 两京春荠 20250419094738.webp 蓼莪咏废 20250419094913.webp 临淄掾吏 20250419094739.webp 灵蛇髻 20250419094838.webp 刘海戏蟾 20250419094745.webp 刘桢有气 20250419094744.webp 真骨凌霜, 高风跨俗 龙文鞭影 “龙文”，是古时良马的名称。只要见到鞭影就疾驰，不用鞭笞 龙阳泣鱼 20250419094948.webp 陇水呜咽 20250419094919.webp 陋巷箪瓢 20250419094920.webp 卢郎妻怨 20250419094759.webp 卢充幽婚 20250419094758.webp 鲁姑弃子 20250419094936.webp 陆贾分金 20250419094918.webp 吕太后筵席 20250419094800.webp 捋髭钱 20250419094816.webp 绿珠坠楼 20250419094900.webp 绿衣使者 20250419094901.webp 罗浮梦 20250419094904.webp 罗威饲犊 20250419094903.webp 卓茂解骖 《后汉书．卓茂传》：“卓茂字子康，南阳宛人也。……时尝出行，有人认其马。茂问曰：‘子亡马几何时？’对曰：‘月余日矣。’茂有马数年，心知其谬，默解与之，挽车而去，顾曰：‘若非公马，幸至丞相府归我（茂时为丞相府史）。’他日，马主别得亡者，乃诣府送马，叩头谢之。茂性不好争如此。” 东汉卓茂不愿与人争竞，有人错认他的马为自己丢失的马，他便解驾把马交给误认者。后因用为与人无争之典。 清．李晖吉、徐灒《龙文鞭影二集》下卷：“罗威饲犊，卓茂解骖。” 麻姑搔背 20250419094939.webp 20250419094940.webp 20250419094941.webp 马肥致远 20250419094931.webp 马前泼水 20250419094927.webp 马腹避火 20250419094932.webp 马去奔郑 20250419094928.webp 20250419094929.webp 《左传．宣公二年》载：郑伐宋。宋 华元等迎战，羊斟为华元御，华元杀羊以飨士卒，而不送给羊斟吃。将战，斟曰：“畴昔之羊，子为政；今日之御，我为政。”乃驰入郑师，宋遂大败。后因以“羊斟惭羹”为记恨小事的典故。唐 郑薰《赠巩畴》诗：“淡薄贵无味，羊斟惭大羹。”比喻以私害公的人。 马少游语 20250419094930.webp 致求盈余, 但自苦耳 买邻 20250419094741.webp 买金偿 20250419094742.webp 卖友埋母 20250419094751.webp 20250419094752.webp 卖薪买酒 20250419094753.webp 买笑 20250419094740.webp 蛮触之争 20250419094914.webp 成语告诉人们，历史很长，人生很短；宇宙很大，人很渺小。如果为蝇头微利去自寻烦恼，为荣辱得失去厮杀，迷失了为人的本性，丧失了做人的乐趣，那么等于是空来人世一遭 芒履易米 20250419094907.webp 猫儿狗子 20250419094845.webp 没奈何 20250419094834.webp 梅花落额 20250419094828.webp 梅香窦臭 20250419094829.webp 扪虱而言 20250419094814.webp 孟子出妻 20250419094807.webp 梦生八翼 20250419094831.webp 梦鱼与梦鸟 20250419094832.webp 梦中梦 20250419094830.webp 日磾之明 20250419094817.webp 20250419094818.webp 糜竺收资 20250419094858.webp 麋鹿荒台 20250419094937.webp 靡不有初, 鲜克有终 20250419094923.webp 觅虱 20250419094916.webp 不修威仪, 作风随便 面朋口友 20250419094924.webp 妙手空空 20250419094806.webp 篾片 20250419094857.webp 明镜不疲 20250419094822.webp 明刑不戳 20250419094819.webp 明珠暗投 20250419094821.webp 《史记•鲁仲连邹阳列传》：臣闻明月之珠，夜光之璧，以投入于道路，人无不按剑相眄者，何则?无因而至前也 我听说世上最稀有的宝物是明月珠和夜光璧。要是暗中将它们扔在路上，人们会按着剑，斜着眼看它，而不敢去拿。为什么呢?这是由于谁也不知它突然出现的原因 明珠买妾 20250419094820.webp 磨镜客 20250419094850.webp 20250419094734.webp 木奴千头 木雁, 材与不材 20250419094824.webp 牧豖听经 20250419094843.webp 苜蓿盘 20250419094908.webp 南户窥郎 20250419094757.webp 年已破瓜 南山可移 20250419094756.webp 南塘一出 20250419094755.webp 南塘是当时富户的聚居地，相当于别墅小区，祖逖是带着人去“零元购”了一趟。 南史不曲笔 20250419094754.webp 麑母 20250419094938.webp 牛不服箱, 斗不挹浆 20250419094842.webp 奴爱主才 20250419094805.webp 弄璋之喜 20250419094812.webp 弩不为鼠发机 20250419094813.webp 女娲戏土 20250419094804.webp 盘中诗 20250419094848.webp 出有日, 还无期 庞公采药 20250419094810.webp 20250419094811.webp 庞公者，南都襄阳人也。居岘xian4山之南，未尝入城府，夫妻相敬如宾。荆州刺史刘表延请，不能屈，乃就候之，曰：“夫保全一身，孰若保全天下乎？”庞公笑曰：“鸿鹊巢於高林之上，暮而得所栖；鼋鼍（yuán tuó）穴於深渊之下，夕而得所宿。夫趣舍行止，亦人之巢穴也，且各得其栖宿而已，天下非所保也。”因释，耕於垄上，而妻子耘於前。表指而问曰：“先生苦居畎亩，而不肯官禄，后世何以遗(读作yí时其本意为遗失；读作wèi时其本意为给予；馈赠)子孙乎？”庞公曰：“世人皆遗之以危，今独遗之以安。虽所遗不同，未为无所遗也。”表叹息而去。后遂携其妻子登鹿门山，因采药不反。 庞公是南都襄阳人，住在岘山的南面，从来不进城府做官，和妻子相处时互相尊重，像宾客一样。荆州刺史刘表曾经多次邀请他出仕，他始终不肯答应。刘表便亲自去拜访他，对他说：“一个人若能保全自己，怎能比得上保全天下呢？” 庞公听了笑着回答：“大雁喜鹊栖息在高高的树林里，傍晚时都能找到落脚的地方；鼋鼍藏身在深深的水渊下，夜晚时也能找到栖身之所。人们在追求去留、行动与止步时，其实也像是在寻找属于自己的巢穴罢了。我只是找到适合自己的安身之处而已，至于天下，不是我能保全的。” 说完后，他继续在田垄上耕作，妻子和孩子则在前面除草。刘表指着这一幕问他：“先生宁愿辛苦地耕作田地，也不愿接受官职俸禄，将来你打算给子孙留下什么呢？” 庞公回答：“世上的人都想给子孙留下财富地位，其实多是留下危险；我只留下安稳的生活给子孙。虽然别人和我所留下的东西不同，但也不能说我什么都没留给他们。” 刘表听后叹息着离开了。后来庞公带着妻子儿女一起登上鹿门山，靠采药为生，从此再也没有回到人间世。 烹小鲜 20250419094840.webp 烹文挚 20250419094841.webp 蓬间雀 20250419094912.webp 蓬山不远 20250419094911.webp 霹雳弦 20250419094922.webp 鸱chi1 有一点 飘风不终朝, 骤雨不终日 20250419094926.webp 血流漂杵 20250419094915.webp 飘瓦 20250419094925.webp 田子方诫子击 20250419094847.webp 平原十日饮 20250419094809.webp 魏齐（？—前265年），战国时期魏国的宗室，在魏昭王时担任相国[1]。 魏国中大夫须贾出使齐国，知齐襄王赠礼予副使范雎，见误以为其收贿泄密，命其返还，并于归国后和时任相国魏齐告发范雎。魏齐重笞范雎，范雎诈死；被裹于席子中，丢至厕所，任由宾客朝他身上撒尿羞辱。范雎在守卫、郑安平与秦国使臣王稽的帮助下逃到秦国，化名为张禄[2]，官至秦昭襄王相国[3]。 日后，魏派遣须贾至秦，范雎让须贾转告魏王：速送魏齐头来，否则将血洗大梁。魏齐害怕被范雎报复，逃到赵国平原君处[4]。秦昭襄王欲为范睢报其仇，故邀平原君出使秦国，却将平原君软禁，以威胁赵孝成王[5]。 赵孝成王派兵至平原君宅邸欲逮魏齐。魏齐得知消息后，连夜遁逃，拜访赵相虞卿。虞卿尝说服赵孝成王无果后，卸相印同魏齐抄小路奔至魏国，想透过信陵君前往楚国。但信陵君畏秦，犹豫再三，初未肯见；后因听取侯嬴意见方迎之，却为时已晚。魏齐在得知信陵君不愿见自己之时，便怒而自刎。 赵王得知后，将魏齐枭首，头颅送至秦国，秦国方释平原君还归赵国[6]。 不龟手药 20250419094736.webp 20250419094737.webp 屏风误点 20250419094808.webp 补拙成巧 瓶磬罍耻 20250419094846.webp 麟止星落, 月死珠伤, 瓶馨罍耻, 芝焚蕙叹 菩萨低眉 20250419094909.webp 剖石采玉, 小儿市瓜 20250419094748.webp 破瓮得妇 20250419094849.webp 蒲葵竞市 20250419094910.webp 曝禈当屋 20250419094823.webp 七人 20250419094735.webp 漆园说剑 20250419094837.webp 齐丘画灰 20250419094944.webp 齐人乞墦 20250419094945.webp 20250419094946.webp 齐人攫金 20250419094947.webp 祁奚之举 20250419094851.webp 奇货可居 20250419094803.webp 歧路亡羊 20250419094833.webp 骑鹤上扬州 20250419094935.webp 骑者善堕 20250419094934.webp 泣荆 20250419094835.webp 牵萝补屋 20250419094844.webp 前倨后卑 20250419094746.webp 前车覆, 后车诫 20250419094747.webp 黔驴之技 20250419094942.webp 20250419094943.webp 浅深揭厉 20250419094836.webp 遇到浅水，撩起衣裳，拉起裤管，便可以涉水而过。遇到水深过膝，反正非被水浸湿不可，干脆不撩也不拉，湿衣渡过。 倩女离魂 20250419094743.webp 墙里佳人 20250419094801.webp 花褪残红青杏小, 燕子飞时, 绿水人家绕, 枝上柳棉吹又少, 天涯何处无芳草, 墙里秋千墙外道, 墙外行人, 墙里佳人笑, 笑渐不闻声渐消, 多情却被无情恼 抢榆枋 20250419094815.webp 小鸟抢榆枋, 大鹏激三千`,``,`html`,`中国历史故事集林汉达`,`20240307183503-书摘 可是鲁国的兵马已经到了齐国地界，齐国就发兵去抵抗。鲁庄公就是泥人儿，也有土性子，这一气呀，可就跟齐国打起来了。没想到打了个败仗，鲁国的大将差点儿丧了命。鲁国的兵马败退下来，齐国还夺去了鲁国的一大片土地。 鲁庄公吃了败仗，正没法儿收拾，齐国又打上门来了，要鲁国杀了公子纠，交出管仲，才跟以前一样地和好，要不，决不退兵。齐国多强啊，鲁国没有法子，都依了，就逼死了公子纠，拿住管仲。鲁国的谋士施伯说：“管仲本事大，别放他活着回去。”齐国的使者央告说：“他射过国君，国君要报一箭之仇，非亲手把他杀了不能解恨。”鲁庄公只好把管仲装上囚车，连同公子纠的人头交给了齐国的使者，让他押回齐国去。 齐桓公打了败仗，自己认了输，向管仲认错，愿意听他的话。管仲就请齐桓公对外跟列国诸侯交好，对内整顿内政，发展生产。齐国又跟鲁国讲了和，还把从鲁国夺来的田地退还给人家。接着，齐国就一个劲儿地开铁矿，造农具，开荒地，多种庄稼，由公家大量地晒盐，鼓励老百姓下海捕鱼。齐国的东边就是海，晒盐捕鱼，极其方便。离海岸较远的诸侯国，没有鱼吃倒也罢了，没有盐那可怎么过日子呐？他们只好向齐国交好，拿粮食去换齐国的盐。齐国因为齐桓公重用了管仲和鲍叔牙，越来越富强了。没有几年工夫，齐桓公当真做了诸侯的首领。 公元前663年，齐国的大军到了燕国，山戎早已逃回去了，抢走了一批壮丁女子和无数值钱的东西。管仲说：“山戎没打就走，等到咱们一走，他们准又进来抢劫。要安定北方，非打败山戎不可。”齐桓公就决定再向前进。燕国的国君燕庄公，要带领燕国的人马作为前队，打头阵。齐桓公说：“贵国的人马刚跟山戎打了仗，已经辛苦了，还是放在后队吧。”燕庄公说：“离这儿八十里地，有个无终国（在河北玉田），跟我们一向很好。要是请无终国出兵帮助我们，我们就有了带路的了。”齐桓公立刻派使者带着礼物去请无终国的国君。无终国答应了，愿意做向导，派了一位大将带着一队人马来支援燕国和齐国。 秦穆公原来立夷吾为晋国国君，就是晋惠公。晋惠公忘恩负义，反倒发兵去打秦国，可打了个大败仗，自己做了俘虏。秦穆公的夫人穆姬（jī）是晋惠公的异母姐姐，她替晋国求情。晋惠公也向秦穆公认了错，割让了河外五座城，又叫太子圉（yǔ）到秦国做抵押的人质，秦晋两国这才重新和好。秦穆公为了联络公子圉，把自己的女儿怀嬴（yíng）嫁给他。 这时候赵盾的儿子赵朔，带了家丁来接他父亲。那个武士把赵盾放在车上，回头跟追来的人拼命。追来的人一瞧赵家的人多，才向后转了。赵盾问那武士：“他们全来害我，你怎么反倒救了我？你是谁？”他说：“我叫灵辄（zhé），是个卫兵。我可看不惯屠岸贾的鬼把戏。相国快走吧，别问了。路见不平，拔刀相助，并不是太稀罕的事。”赵盾和他的儿子只好逃到国外去避难。他们还想带着灵辄一块儿去，他可早已溜了。 伍子胥为了进攻楚国，给他父亲报仇，他推荐了当时的大军事家孙武给 阖闾。阖闾从朝堂上跑下来迎接孙武。接着就问他用兵的法子。孙武把自己 写的十三篇兵法献给他。阖闾叫伍子胥从头到尾一篇一篇地念，讲的原来是 怎么用计谋，怎么定战略，怎么行军，怎么进攻，怎么利用地形，怎么使用 武器，讲得头头是道，非常透彻。伍子胥每念完一段，阖闾不住嘴地称赞。 他对伍子胥说：“这十三篇兵法又扼要又仔细，真是好极了。可有一样，吴 国没有那么些个士兵，怎么办呐？”孙武说：“有了兵法，只要大王有决心， 不光男子，就是女子也行。男男女女，全能够打仗，还愁什么人马不够吗？” 阖闾笑着说：“女人哪儿能打仗呐，这不是笑话吗？”孙武一本正经地说： “大王要是不信的话，请先拿宫女们试一试瞧瞧。我要是不能把她们训练得 跟士兵们一样，情愿认罪受罚。”阖闾派了一百五十名宫女，叫孙武去训练。 孙武请阖闾挑出两个心爱的妃子当队长。阖闾也答应了。末了，孙武请 求说：“军队中最要紧的是纪律。虽说拿宫女们试试，也得有纪律。请大王 派个执掌军法的人，再给我几个武将做助手。不知道大王答应不答应？”阖 闾全都答应了。 一百五十个宫大都穿上军衣，戴上头盔，拿着兵器，到操场上集合。孙 武先出了三道军令：“第一、队伍不许混乱，第二、不许吵吵闹闹；第三、 不许存心违背命令。”跟着，他就把宫女们排成队伍，操练起来了。哪儿知 道那两个妃子队长还以为她们穿上军衣，拿着长枪短刀，是出来玩儿玩儿的， 先就嘻嘻哈哈地不听号令。别的宫女一见领队的这个样儿，大伙儿跟着笑成 一团，有的坐着，有的蹲着，有的学着姿态，有的还来回奔跑，乱七八糟， 简直不象一回事。孙武就传令，叫她们归队立正。其中还有人说说笑笑，不 听命令。孙武传了三回令，谁知道那两个妃子队长和宫女们还是嘻皮笑脸地 不听话。她们都是阖闾所宠爱的，孙武敢把她们怎么样，高兴了，操练着玩 玩，不高兴就回宫去，怕什么！孙武可忍不住了。他大声地对那个执掌军法 的人说：“士兵不听命令，不服管，按照军法应当怎么处罚？”军法官赶紧 跪下说：“应当砍头！”孙武就发出命令，说：“先把队长正法，做个榜样。” 武土们就把那两个妃子绑上。这一下吓得宫女们全都变了脸色。 阖闾在高台上远远瞧着她们操练，忽然瞧见两个妃子给武士绑了，立刻 打发一个大臣传令去救。那个人臣急急忙忙地见了孙武，传出阖闾的话说： “大王已经知道将军注重纪律的道理了。这两个妃子看在头一次犯错误，饶 了她们吧！”孙武说：“操练军队不是闹着玩儿。要是不把犯法的人办罪， 以后谁还能指挥军队呐？”他就下令叫武士把那两个队长砍了。宫女们全都 变了脸色，一声也不敢言语了。孙武又挑了两个宫女当队长，重新操练起来。 这批宫女经过孙武那么严厉的训练，居然练成了一支很象样的军队。 公元前500年，齐景公打算联络鲁国和别的诸侯国，把齐桓公当年的霸主事业重新干一下。他写信给鲁国的国君鲁定公，约他到两国边界的夹谷（在山东莱芜）开个会议，准备订立盟约。那时候，诸侯开会，还得有个大臣作重要助手。这种国君的助手称为“相礼”。这会儿，鲁定公问大臣们：“我去夹谷开会，谁当相礼呐？”有一位大夫推荐大司寇（官名，管司法）去做相礼。这位鲁国的大司寇就是鼎鼎大名的孔夫子。 孔夫子简称孔子。他父亲是个地位并不高的武官，叫叔梁纥（姓孔，名纥，字叔梁；纥hé）。孔子出生之前，叔梁纥已经有了九个女儿和一个儿子。他儿子的脚有毛病，也许是个瘸子。叔梁纥虽然上了年纪，可是还想生个文武全才的儿子。他又娶了个小姑娘叫颜征在。他们曾经在曲阜东南的尼丘山上求老天爷赐给他们一个儿子，后来果然生了个儿子，以为是尼丘山上求来的，就给他取名叫孔丘，又叫仲尼（“仲”就是“老二”的意思）。 孔子三岁上死了父亲。母亲颜氏受人歧视，孔家的人连送殡都不让她去。后来，娘儿俩被孔家轰出来了。颜氏很有志气，带着孔子离开老家，搬到曲阜去住，日日夜夜辛勤操作，靠着双手来抚养孔子。孔子小时候，没有什么可以玩儿的东西，只见过他母亲每逢父亲的生日或去世的周年，总是摆上一些酒食盘儿祭祀一番，静悄悄地哭一顿。他也就老摆上小盆小盘什么的，玩着祭天祭祖那一套东西。 孔子十七岁那一年，母亲也死了。因为他父亲下葬的时候，孔家的人不许他母亲送殡，娘儿俩一直不知道他父亲的坟在哪儿，孔子只好把他母亲的棺木埋在曲阜。后来有一位老太太告诉他，说他父亲葬在防山（在山东曲阜东），孔子才把母亲的坟移到那边。 那一年，鲁国的大夫季孙氏请客，招待读书人，说是只要有学问，谁都可以去。孔子想趁着机会露露面，认识认识当时的名人，也去了。季孙氏的家臣阳虎瞧见了这位没有地位的青年人，就作威作福地骂了他一顿，还说：“我们这儿请的都是知名人士，你来干吗？”孔子只好红着脸，别别扭扭地退了出去。他受了这番刺激，格外刻苦用功，一定要做个有学问有道德修养的名士。他住在一条叫达巷的胡同里，学习六艺，就是礼节、音乐、射箭、驾车、书写、计算等六门课程。这是当时一个全才的读书人所应当学的六种本领，所以叫“六艺”。达巷里的人都称赞他，说：“孔家小子真有学问，什么都会。”孔子很谦虚地说：“我会什么呐？我总算学会了赶大车。” 孔子在二十六七岁的时候，担任了一个小小的职司叫“乘田”，工作是管理牛羊。他说：“我一定把牛羊养得肥肥的。”果然，他所管理的牛羊都很肥壮，又繁殖得快。后来他做了“委吏”，干的是会计工作。他说：“我一定把账目弄得清清楚楚。”果然，他的账目一点不出差错。孔子快到三十岁的时候，名声大起来了。有人愿意拜他为老师。他就办了一个书房，招收学生，贵族学生、平民学生，他都收。过去只有给贵族念书的“官学”，孔子办了“私学”以后，贵族独占的文化教育也多少可以传给一般的人了。孔子一面教学生，一面留心国家的事，主张用礼的一套管理国家，希望有机会做个官。 鲁国的大夫孟僖子（僖xī）嘱咐他两个儿子孟懿子和南宫适（适kuò）到孔子那儿去学礼。后来南宫适向国君鲁昭公请求派他和孔子一同去考察周朝的礼乐。鲁昭公给了他们一辆车、两匹马和仆人，让他们到周朝的都城洛邑去。 那一年，孔子正三十岁（公元前522年）。他早听说都城那里有个特别有学问的老人，管理着周朝的藏书室。老人姓李名耳，字聃（dān），大伙儿敬重他。都叫他老子。孔子就想借这个机会拜会老子，向他请教。到了洛邑，他特地送了一只大雁给老子作为见面礼，向他请教礼乐。老子的年纪比孔子大得多。他见孔子向他虚心求教，很喜欢，还真拿出老前辈的热心肠，很认真地教导了孔子一番。孔子对老子佩服的没法儿，见人就说：“我不知道龙是怎么样驾云升天的，这回见到老子，他也许就是龙吧！” 孔子在三十五岁的时候，鲁昭公被大夫季孙氏轰走了。鲁国有三家最有势力的大夫，孟孙氏、叔孙氏和季孙氏，互相争权，把鲁国闹得很乱。孔子对他们很不满，听说齐景公正想继承齐桓公做一番事业，他就到了齐国，想实现自己的理想。齐景公待他很客气，也许还打算用他。他先探听探听晏平仲的意见。晏平仲虽然很佩服孔子的人品和学问，可是两个人的主张不同，合不到一块儿去。晏子对孔子的态度是：恭敬他，可是不接近他。齐景公见晏子不那么热心，到底没用孔子。 孔子在齐国待了将近三年，又回到了鲁国。他把全副精力放在教育上。据说他的门生之中成就最高的就有七十二人。他们老师和门生之间好像一家人那么亲密，大伙儿对孔子非常尊敬，把他当作他们的父亲一样。 到了公元前501年，孔子已经五十一岁了。他在鲁国做了中都宰（中都，鲁国大城，在山东汶上；宰，官名，就是长官的意思）。第二年，他做了司空（官名，管生产建设），又由司空做了大司寇。这回，齐景公约鲁定公到夹谷去开个会议，鲁定公就请孔子当相礼，准备一块儿到齐国去。 孔子对鲁定公说：“齐国仗着兵力强盛，屡次侵犯我边疆，这次约会讲和，也得有兵马防备着。从前宋襄公开会的时候，没带兵车去，到了儿受了楚国的欺负。这就是说，光讲和平没有武力可不行。请把左右司马都带去。”鲁定公听了他的话，请他去安排。孔子就让鲁定公派申句须和乐颀（qí）两员大将带领五百辆兵车跟着上夹谷去。 到了夹谷，两员大将把军队驻扎在离会场十里地的地方，自己带着几个随身的卫士跟着鲁定公和孔子一同上会场去。开会的时候，齐景公有晏子当相礼，鲁定公有孔子当相礼。举行了开会仪式之后，齐景公就对鲁定公说：“咱们今天聚在一起，实在不容易，我预备了一种很特别的歌舞，请您看看。”说话之间，他就叫乐工表演土人的歌舞。一会儿，台底下打起鼓来，有一队人扮作土人模样，有的拿着旗子，有的拿着长矛，有的拿着单刀和盾牌，打着呼哨，一窝蜂似的拥上台来，鲁定公吓得脸都白了。 孔子立刻跑到齐景公跟前，反对说：“中原诸侯开会，就是要有歌舞表演，也不应该拿这种土人打仗的样子当作歌舞。请快吩咐他们下去吧！”晏平仲也说：“说得是啊！我们可不爱看这种歌舞。”他哪儿知道这是齐国的大夫黎弥和齐景公两个人使的诡计。他们想拿这些“土人”来吓唬吓唬鲁定公，好叫他在会议上让些步。给晏平仲和孔子这么一说，齐景公也觉得怪不好意思的，就叫他们下去。 黎弥躲在台下，本想叫这些“土人”上去之后，等他们一动手，自己准备在台下带着士兵一齐闹起来。没想到这个计策没办到，只好另想办法。散会以后，齐景公请鲁定公吃饭。正在宴会的时候，黎弥叫了一班抹粉搽胭脂的乐工来，在齐鲁两国的君臣跟前唱着下流的歌儿，表演下流的动作，侮辱鲁国的君臣。 孔子气得拔出宝剑来，瞪圆了眼睛，对齐景公说：“这种下贱人竟敢戏弄诸侯，应当办罪！请贵国的司马立刻把他们杀了！”齐景公没言语，乐工们还继续唱着演着。孔子忍不住了，就说：“齐鲁两国既然和好，结为弟兄，那么鲁国的司马就跟齐国的司马一样可以执行处分。”跟着他就扯开了嗓子向堂下说：“鲁国的左右司马申句须和乐颀在哪儿？”那两员大将一听见孔子叫他们，跑上去就把那两个领头的乐工拉出去了。别的乐工吓得慌慌张张地全跑了。齐景公吓了一大跳，晏平仲很镇静地请他放心。这时候，黎弥才知道鲁国的大将也在这儿，还听说鲁国的大队人马都驻扎在附近的地方，吓得他缩着脖子退出去了。 宴会之后，晏平仲狠狠地数落了黎弥一顿。他又对齐景公说：“咱们应当向鲁侯赔不是。要是主公真想做霸主，真心实意地打算和鲁国交好，就应当把咱们从鲁国霸占过来的汾阳地方的三块土地还给鲁国。”齐景公听了他的话，真的把三个地方都退还给鲁国。鲁定公向齐景公道了谢，带着孔子和随从人员回国去了。 孔子在夹谷会上给鲁国挣了面子，鲁定公和三家的大夫都信任孔子，请他主持管理朝政。鲁国自从让孔子治理以后，据说仅仅三个月工夫就变成了一个很像样的国家了。要是有人在路上丢了什么，他可以到原地方去找，准能找得着。因为没有主儿的东西，就没有人捡。夜里敞着门睡觉，也没有小偷儿溜进去偷东西。这么一来，别的国看见鲁国强大起来，反倒担了一份心。尤其是贴邻的齐国，又是恨又是怕，就有人出来想法去破坏鲁国的内政。 晏平仲虽说不愿意跟孔子一块儿做事，也不赞成孔子的主张，他可并不干涉别国的事。等到晏子一死，齐国的大夫黎弥掌了权，他就变法儿想打击鲁国的势力。他劝齐景公给鲁定公和季孙氏送一班女乐去。这种女乐正合糊涂君臣的口味。要让孔子瞧见，他准得头疼。齐景公同意了，就送给鲁定公最漂亮的歌女八十名。 鲁定公挑了三十个赏给季孙氏，其余的歌女留在宫里。从此鲁定公和季孙氏就天天玩乐了。孔子未免劝他们几句，他们也就恭恭敬敬地躲着他了。孔子的弟子子路说：“老师，鲁君不办正事，咱们还是走吧！”孔子也觉得再待下去没意思，就辞去了官职，到别的国家找自己理想的地方去了。 孔子离开鲁国的时候，已经五十五岁了。此后好多年，他带着门生周游列国。他到过卫国、曹国、宋国、郑国、陈国、蔡国、楚国。可这些国家的国君都不能用他。他流浪了七八年，到卫国的时候，已经六十三岁了。卫国的国君想请他做官，他推辞了。正好鲁国派人来请孔子，孔子就回到本国，不打算再上各处去奔波了。晚年，他一心一意把精力放在编书上头。他编了几本书，其中最主要的一本叫《春秋》，记载从鲁隐公元年到鲁哀公十四年，就是公元前722年到公元前481年的大事。后来，这一段两百多年的时期，在中国历史上就叫“春秋时期”。 周游列国 公元前500年，齐景公打算联络中原诸侯，恢复齐桓公当年的事业。他 写信给鲁国国君鲁定公，约他到两国交界的夹谷[在山东省莱芜县]开个会 议，准备订立盟约。那时候，诸侯开会，还得有个大臣做助手。这种助手叫 做“相礼”。这次鲁定公到夹谷开会，做相礼的就是司寇孔丘。 孔丘的父亲是个地位并不高的武官，在他三岁那一年就死了。母亲颜氏 带着孔丘离开老家，搬到曲阜去住。十七岁上，母亲也死了。 有一天，鲁国的大夫季孙氏请客，招待读书人，说只要有学问，谁都可 以去。孔丘想趁机露露面，认识认识当时的名人，也去了。季孙氏的家臣瞧 见这个没有地位的年轻人，就骂了他一顿，还说：“我们这儿请的都是知名 之士，你来干么？”孔丘只好红着脸，别别扭扭地退了出去。他受了这番刺 激，格外刻苦用功，一心要当个名士。他学的是礼节、音乐、射箭、驾车、 书写、计算，合在一块儿叫做“六艺”，都是当时做官的人必须有的本领。 种庄稼啦，种蔬菜啦，这些本领他一概不学，也瞧不起。他说，学好了“六 艺”，当上了官，自然就有饭吃。当个庄稼汉，不把肚子饿扁了才怪呐。 孔丘快到三十岁的时候，名声大起来了。有些人想学做官的本领，愿意 拜他为老师，他就办了一个书房，招收学生。贵族学生、平民学生，他都收。 在这些学生中，他最得意的有七十二人。 孔丘五十一岁上，在鲁国做了一个小小的地方官。第二年升了官，做了 司空，又做了司寇。鲁定公这次去夹谷跟齐景公开会，就请孔丘跟去做相礼。 齐景公的相礼就是那个挺能干的相国晏平仲。 在夹谷会议上，齐景公看孔丘挺有能耐，想要用他，就和相国晏平仲商 量。晏平仲知道孔丘有些学问，可是他反对孔丘的作风。他对齐景公说：“孔 丘那一派讲究学问的人，有两种毛病。一种是自命不凡；一种是太注重礼教。 把自己看得高人一等，怎么能够跟别人弄得到一块儿呐？这是一点。太注重 礼教了，就顾不到老百姓的生活。咱们齐国人，一天忙到晚，还得要处处节 省。才能够对付着活着。哪儿有那么些闲工夫，那么多富余钱，去琢磨那些 琐琐碎碎的礼节跟那些又细致又麻烦的仪式呐？您没见孔丘出来的时候，车 马的装饰可讲究了；吃饭的时候，对于饭食的样式那份讲究就甭提了。走路 得有一定走法；上台阶也得有一定的步法。人家连衣裳都穿不上，他还在那 儿讲究丝弦礼乐；人家没房子住，他还叫人讲究排场，死了人要倾家荡产地 去办丧事。要是咱们真把他请来治理齐国，老百姓可就让他弄得更穷了！” 齐景公听了，觉得挺对，就不再提用孔丘的事儿了。 没隔多少日子，晏平仲死了，大夫黎弥掌了齐国的大权。黎弥伯孔丘在 鲁国得到重用，想了一条计策，劝齐景公给鲁定公送去一班女乐[古代的女 子歌舞团]。他说：“鲁定公准会迷上这些能歌善舞的女孩子，准会把孔丘 这个道学先生气跑。”齐景公同意了，就选了几十个漂亮的女孩子，派人送 到鲁国去。鲁定公一瞧，果然就入了迷，以此天天听唱歌，看跳舞，任什么 事情都到不了他的心里去。孔丘未免要唠叨几句，鲁定公就恭恭敬敬地躲着 他了。他的学生子路看不惯，对他说：“老师，咱们走吧！”孔丘叹了口气 说：“我哪儿不想走呐，我想等过了祭祀再说，主公也许还是能够遵守大礼 呐。不是到了没法儿的时候，我总舍不得走。” 到了祭祀那天，鲁定公到场应个景儿，就回宫里欣赏歌舞了。依照当时 ----------------------- Page 56----------------------- 的规矩，祭祀用过的肉应当由国君很隆重地分给大臣们。可是鲁定公把这件 事推给大夫去办，大夫又推给家臣去办，家臣又推给底下的人去办，底下人 正乐得拿来自个儿受用，索性谁也不分了。孔丘祭祀完了回到家里，眼巴巴 地等着祭肉，一直等到晚上也没见送来，直叹气。子路说：“老师，怎么样？” 孔丘说：“唉，我干不下去了！命里该的！命里该的！”这回他决心离开鲁 国，就带着子路、冉有[冉，rán]，还有别的几个学生，一块儿走了。 孔丘到了卫国。卫灵公正想把卫国弄得强大起来，一听鼎鼎大名的孔丘 来了，抱着一肚子希望去迎接。他向孔丘讨教怎样操兵练马，怎样打仗。没 想到孔丘冷冰冰地说：“我就懂得礼节、道德这些事，没学过打仗的亭。” 卫灵公一听这话，心里也就凉了。 孔丘在卫国不能发挥自个儿那一套，打算到陈国去。他也不告辞，带着 学生就走了。他们路过一个叫匡的地方[在河南省长垣县西南]，那边的人 把孔丘当做了阳虎，就把他们包围起来了。阳虎也是鲁国人，因为谋反失败， 逃跑了。他早先欺负过匡人，匡人都恨他。可巧孔丘的相貌有点儿象阳虎， 匡人就来找孔丘报仇。幸亏卫灵公派人来请孔丘回去，匡人才知道找错了人。 孔丘白白地受了五天罪。 孔丘又回到了卫国。这回给卫灵公的夫人南子知道了。她想利用这位道 学先生，就打发人去请他。南子在卫国的名声挺不好。孔丘一听卫灵公的夫 人请他，就一本正经地去拜见南子。南子见孔丘向自己行礼，就笑不唧唧地 还礼问好。孔丘见南子长得真标致，心里想：“长得漂亮的人，难道就一定 没有德性吗？”他心里还迷迷糊糊的，学生子路可已经气坏了。一见老师出 来，就挺生气地怪孔丘不应当跟这种女人见面。孔丘急得冲天发誓说：“我 要是有不合情理的地方，老天爷会罚我的！老天爷会罚我的！” 孔丘自从见了南子以后，卫灵公象对待南子一样地对待孔丘。出去的时 候，卫灵公让南子一块儿坐在车里，还叫孔丘陪着。他带着天下无双的美人 儿跟独一无二的道学先生，得意洋洋地在街上经过，觉得挺体面。卫国的老 百姓见了，个顶个都觉得恶心得要吐，大伙儿唱着： 漂亮夫人！ 道学先生！ 上手坐着夫人， 下手坐着先生， 道学先生受到了尊敬吗？ 看起来还不如漂亮的夫人。 孔丘听见了，绷着脸儿，心里不是个滋味，只好又离开了卫国，上曹国 去了。在曹国也不能安身，又跑到了宋国。在宋国的地界，他跟几个学生坐 在一棵大树底下歇口气。宋国的一个大臣怕国君重用孔丘，想办法要把他轰 出去。他叫人把那棵大树砍倒了，先给孔丘一个警告。孔丘没法子，只好离 开宋国，上郑国去了。 到了郑国，孔丘跟他的学生失散了，垂头丧气地在东门口站着。他的学 生子贡沿路打听他老师的下落。有一个人告诉他说：“在东门口站着一个老 头儿，模样儿例象个传说中的圣贤，可精神恍惚，好象一只无家可归的野狗， 不知道是不是你老师。”子贡到东门口一瞧，果然是老师。他就把那个人所 说的话，一五一十告诉了孔丘。孔丘听了苦笑着说：“要说我是一只无家可 归的野狗，这倒挺象，挺对！” ----------------------- Page 57----------------------- 后来孔丘到了陈国，在一个同情他的大官家里一气儿住了三年。这时候， 晋国跟楚国争夺陈国，紧接着吴国又来攻打。孔丘住不下去，就想还是回到 卫国去。 到了卫国，卫灵公已经死了，他的儿孙为争夺王位，正打得热闹。孔丘 只好回转身来，想通过陈国，到蔡国去。 楚昭王听说孔丘到了陈、蔡一带，就打发人来请他。陈国跟蔡国正恨着 楚国，一听楚国来请孔丘，就把孔丘当做了敌人，两国都发兵把孔丘围住。 幸亏孔丘的学生中也有一些是能打仗的，保护着他。孔丘给人家围在里头， 三天没吃上饭，只好饿着肚子弹琴解闷。到了第四天头上，楚国的兵马到了， 才解了围，把孔丘接到了楚国。 楚昭王挺恭敬地招待孔丘，还想封给他一块地方。楚国的令尹子西反对 这件事，他对楚昭王说：“大王可千万别小看了孔丘。跟他的那班人里有文 的，有武的，要是有了地盘，慢慢地往大里发展，到那时候，大王想管他可 也管不住了！”子西这么一说，楚昭王一片热火劲儿，可就凉下去了。 孔丘知道楚国也不能够用他了，只得又垂头丧气地走了。他从五十多岁 开始周游列国，到了七八个诸侯国，没有一个国君给他官做。他的一套主张 没有多少人听。这时候他已经快七十的人了，哪里还有力气再到处奔波呐？ 未末了，他回到了鲁国。孔丘碰了这么多钉子，他就决心发奋著书立说，一 心一意地把精力放在编书上头。他编了几本书，最主要的一本叫做《春秋》， 记载了公元前722年到公元前481年的大事，后来，在中国历史上，就把这 两百多年叫做“春秋时期。” 扁鹊原来是上古时代黄帝时期（黄帝是传说中的一个帝王）的一位医生。桓公午招待的这位扁鹊是齐国人，姓秦，名越人，比上古的那位扁鹊晚生了两千多年。因为秦越人治病的本领特别大，人们都尊称他为“扁鹊”。后来谁都叫他扁鹊，他原来的名字秦越人，反倒很少人知道了。 扁鹊治病的方法是多种多样的。医药、针灸（jiǔ）、按摩都采用，看情况而定。他周游列国，替老百姓治病。到了赵国的都城邯郸，他看到那边的人一般都重视妇女，他就做了妇科大夫，给妇女治病。到了周天王的都城洛邑，他看到那边的人一般都尊敬老年人，他就做了耳目科和治疗神经麻痹（bì）、风湿症的大夫，给老年人治病。到了秦国的咸阳，他看到那边的人一般都爱护儿童，他就做了小儿科的大夫，给儿童治病。总之，他到了哪儿，哪儿的人最需要看什么病，他就治什么病。 有那么一天，驺忌早上起来，穿好衣服，戴上帽子，对着镜子瞧瞧，觉得自己长得很漂亮，心里很得意。他就问他的妻子说：“我跟城北的徐公比起来，哪个漂亮？”原来那位徐公漂亮出了名，全国的人都把他当作美男子。听驺忌这么一问，他的妻子说：“徐公哪儿比得上您呐！” 驺忌不大相信，又问他的小妾：“我跟徐公比，到底哪个漂亮？”那个小妾说：“徐公怎么能跟您比呐？当然是您漂亮了。” 过了一会儿，来了一位客人，两个人就坐着谈天。那位客人是来向驺忌借钱的。谈话当中，驺忌问他：“我跟徐公比，哪个漂亮？”那个客人说：“您漂亮，徐公比不上您！” 第二天，巧极了，城北徐公来访问驺忌。驺忌一看徐公，愣了。天下真有这么漂亮的男子！他觉得自己比不上徐公。他偷偷地照照镜子，再瞅瞅徐公，照照瞧瞧，越发觉得自己比徐公差得远了。 到了晚上，驺忌躺在床上琢磨来琢磨去，到底给他悟出了一个道理来。第二天一清早，他去见齐威王，把他是怎么问的，妻子、小妾、客人是怎么答的，自己怎么和徐公比美，说了一遍。齐威王听得笑了起来，问驺忌说：“那么你自己说说看，你跟徐公相比，到底谁漂亮呐？”驺忌说：“我哪儿比得上徐公呐！我的妻子说我美，是因为她偏向着我；我的小妾说我美，是因为她平日怕我；我的朋友说我美，是因为他有事情向我要求。”齐威王点点头：“你说得很对。听了别人的奉承话，是得好好想一想，要不就可能受到蒙蔽。”驺忌说：“是呀，我想齐国有一千多里土地，一百二十个城邑。王宫里的美女和伺候大王的人，没有一个不想讨大王喜欢的；朝廷上的臣下，没有一个不害怕大王的；全国各地的人，没有一个不想得到大王的照顾。从这些情况看来，大王是很容易受到蒙蔽的。” 齐威王听了驺忌的话，觉得很有道理。他立刻下了一道命令：“不论朝廷大臣、地方官吏和老百姓，能当面指出我的过错的，得上等赏；能用书面指出我的过错的，得中等赏；就是在背后议论我的过错，也给他下等赏。” 驺忌不但这么规劝齐威王，他还细心查问各地的官吏，要弄清楚他们办事办得怎样。朝廷里的很多官员回答他说：“中等的太多了，不知道从哪儿说起。我们只知道太守里头最好的是阿城（在山东阳谷东北）大夫，最坏的要数即墨（在山东平度东南）大夫了。”驺忌就照样地告诉了齐威王。齐威王问起自己的左右，也有不少人说阿城大夫是太守里头数一数二的好人，说那个即墨大夫是太守里头的败类。齐威王只怕受到蒙蔽，暗地里派人到阿城和即墨去实地调查，到了儿让他知道了真实情况。 过了不久，齐威王把阿城大夫和即墨大夫召回来。朝廷上的大臣们一琢磨，这还用说吗，一定是叫阿城大夫来领赏，叫即墨大夫来受处分。那些给阿城大夫说好话的都暗暗高兴，阿城大夫升了官，他们也有好处。那个不懂人情世故、默默无闻的即墨大夫，准得撤职查办了。 就在那天，文武百官都来朝见齐威王。齐威王叫即墨大夫上来。众人瞧见殿上放着一口大锅，烧着满满一锅开水，都静悄悄地站着，替即墨大夫捏着一把汗。齐威王对即墨大夫说：“自从你到了即墨，天天有人告你，说你怎么怎么不好。我就派人上即墨去调查。他们到了那边，就瞧见地里长着绿油油的庄稼，老百姓安居乐业。这都是你治理即墨的功劳。你专心一意办事，不来跟这儿的大官们联络，也不送礼给这儿的人，他们就天天说你坏话。像你这种老老实实、勤勤恳恳、不吹牛、不拍马的大夫，咱们齐国能找得出几个呐？今天我特意叫你来，加封你一万家户口的俸禄！” 那些给即墨大夫说坏话的人，都觉得自己脸上热乎乎的，脊梁骨冒着凉气，恨不得钻到地底下去。 齐威王回头对阿城大夫说：“自从你到了阿城，天天有人夸奖你，说你怎么怎么能干。我就派人到阿城去调查。他们到了那边，就瞧见庄稼地里长满了野草，老百姓面黄肌瘦，连话都不敢说，只暗地里叹气。这都是你治理阿城的罪恶！你为了欺压小民，装满自己的腰包，接连不断地给我手下的人送礼，叫他们替你说好话。他们就恨不得把你捧上天去。像你这种专仗着行贿（huì）、巴结上司的贪官污吏，要是再不惩办，国家还成个体统吗？——把他扔到大锅里去！” 武士们就把阿城大夫扔到大锅里煮了。这么一来，吓得那些受过阿城大夫好处的人好像自己也给扔到大锅里一样，一个个站不住了。他们一会儿换换左脚，一会儿换换右脚，一会儿擦擦脑门子上的汗珠，一会儿挠挠脖颈子（颈gěng），愁眉苦脸地站在那儿。 齐威王回头叫那些平日颠倒是非的人过来，责备他们说：“我在宫里怎么能知道外边的事情？你们就是我的耳朵，我的眼睛。可是你们贪赃受贿，昧着良心，把坏的说成好的，把好的说成坏的。这不是比堵住了我的耳朵更坏吗？你们简直是打算扎瞎我的眼睛！我要你们这些臣下干什么？——快把他们都给我煮了吧！” 这十几个人吓得跪在地下直磕响头，苦苦地哀求着。齐威王就挑了几个最坏不过的，把他们办了罪。 这么一来，贪官污吏都害怕了。他们担心国君暗地里派人来调查，怕自己给扔到大锅里去。有的确实不敢再为非作歹了；有的不敢再在齐国待着，跑到别国去了。 驺忌又对齐威王说：“从前齐桓公、晋文公当霸主，都是借着天王的名义号召列国诸侯的。当今周室虽说是衰弱了，可是还留着天王的名义。大王要是去朝见天王，奉了他的命令去号令诸侯，就能当上霸主了。”齐威王撇着嘴说：“我已经称为王了，哪儿还能去朝见另一个王呐？”驺忌说：“他是天王啊。只要在朝见的时候，您暂且称为齐侯，天王必然高兴，您还不是要怎么着就怎么着吗？”齐威王就亲自上成周去朝见了周烈王。周烈王果然挺高兴的，赏给他几件珍宝。齐威王从成周回来，沿路都是称赞他的话，乐得他满面笑容，装着一肚子的得意回到齐国。 忽然前面的士兵回来报告，说：“前面山道给木头堵住了。”庞涓骂着说：“这也值得喊叫吗？齐国人打算往北逃回本国去，怕咱们今天晚上追上他们，就堵住了道儿。大伙儿一齐动手把木头搬开不就结了？”庞涓上前亲自指挥士兵搬，就见道旁的树全砍倒了，只留着一棵最大的没砍。他奇怪为什么单单留着这一棵呐，就上前细细瞧去。那棵树一面刮去了树皮，露出一条又光又白的树瓤（ráng）来，上面影影绰绰（chuò）好像还写着几个大字，就是看不清楚。庞涓就叫小兵拿火来照。有几个小兵就点起火把来。庞涓在火光之下，看得非常清楚。上面写的是：“庞涓死此树下！”庞涓心里一急，连忙说：“哎呀！又上了瘸子的当了！”回头对将士们说：“快退！快……”第二个“退”字还没说出来，也不知道有多少支箭，就像下大雨似的，冲他身上射过来，他就这么送了命。原来孙膑成心天天减少炉灶的数目，引诱庞涓追上来，早就算准了庞涓到这儿的时辰。他在左右埋伏着五百名弓箭手，吩咐他们说：“一见树下起了火光，就一齐放箭。” 屈原有个姐姐叫屈须。她听说兄弟的遭遇，老远地跑到湘南去看他。她找到了屈原，一见他披头散发、脸庞又黄又瘦，不由得掉下眼泪来，说：“兄弟，你何必这样呐？楚国人哪一个不知道你是忠臣？大王不听你的话，那是他的不是。你已经尽到了心了。老悲伤又有什么用呐？”屈原说：“我伤心的不是我自己的遭遇。楚国弄到这个样儿，我心里像刀割一般！”屈须说：“可是君王不肯听你的话，反对你的人又有势力，你孤孤单单的一个人，怎么斗得过他们呐？你的脾气太耿直，我担心你会吃亏，如今果真落到这个地步。叫我怎么放心呐！”屈原说：“我知道我忠心耿耿会招来不幸。可是我怎么能够眼看着国家的危险不管呐！只要能救楚国，就是叫我死一万次我也愿意。如今把我放逐到荒山野地，国家大事我没法儿管，我的主张没处去说，我大声呼喊君王，君王也听不到。我痛苦得真要疯了。这样儿下去，还不如死了好。”屈须摇摇头，说：“别傻了！要是你一死，国家就能够好起来，那我也愿意跟你一块儿死。可是你这么糟蹋自己，对国家不但没有什么帮助，反倒还会带累别人也这样消沉下去。”屈原叹了口气，说：“那么怎么办呐？”屈须说：“将来君王也许会明白过来，那时候你还可以给国家出力。” 屈原在流放中，经常和老百姓生活在一起，还交上了一个打鱼的朋友。这个朋友，大伙儿都叫他“渔父”。渔父很敬佩屈原的学问，可就是不赞成他那种唉声叹气的脾气，就对他说：“您怎么会弄到这步田地呐？”屈原就说：“天下全是脏的，我是干净人；大伙儿都喝醉了，只有我还醒着。因此我被送到这儿来了。”渔父撇了撇嘴，说：“您既然知道天下都是脏的，就不该自认清高；大伙儿都醉了，您为什么不喝几盅？别人都糊涂，您独自清醒，倒是糊涂了。”屈原红着脸反对说：“这是什么话？难道说上就是下，下就是上？凤凰就是乌鸦，乌鸦就是凤凰？君子就是小人，小人就是君子？”渔父笑着说：“您要分得那么清楚，难怪和别人合不到一块儿。您要改变黑暗，就得跑到黑暗里去，慢慢发出光来。哪儿能把人间看成脏的，把人全看成糊涂的，自己站在半空中呐？”屈原说：“叫我洗干净了再跳到烂污泥里去，这我可办不到！”渔父说：“那您就应当跟我学。我打我的鱼，您种您的地。君王不需要咱们，咱们也不需要君王。干什么要自寻苦恼啊？” 屈原不能同意渔父的说法，可也没有别的办法。百姓们一年到头辛辛苦苦种地，还是经常受冻挨饿，生病没钱医，死了没钱葬，遇到天灾人祸，就弄得妻离子散，家破人亡。这种悲惨的情景，更加深了屈原的痛苦。他一直喜欢写诗，这会儿诗写得更多。《离骚》这首有名的长诗，就是他在这个时期写成的。 日子过得挺快，十几年过去了，屈原还没有得到楚王召他回去的消息。他忧虑国家的前途，常常夜里睡不着觉。好容易睡着了，梦里老是回到了郢都，可是醒来仍旧是一场空。他想借山川景物来排解忧愁，结果反而更加伤心：楚国的政治这么腐败，这秀丽的河山总有一天会成了秦国的土地。 屈原想立刻回郢都去，再劝劝楚王。正好有一个朋友来看他。朋友劝他说：“你已经被革了职，回去也做不了什么。现在楚王不用你，你为什么不到别的国去呢！你这样有才学，不论到哪一国，还怕他们不重用你，何必留在楚国受这份罪呢！”屈原说：“一个人难道可以为了自己的富贵扔了父母之邦，扔了家乡吗？”那个朋友说：“话不是这么说的。现在楚王不用你，又不是你不肯为楚国出力。你把自己的才华埋没了，多可惜！”屈原说：“鸟飞倦了，想回到自己的老枝上去歇息；狐狸死了，头还向着土山。我不能离开楚国。” 屈原对楚国爱得这么深，看着掌权的人越来越腐败，国家一天一天衰落下去，自己偏偏得不到救国救民的机会。他痛苦到了极点，仍然只能写写诗歌来发泄他的悲哀，陈说他对朝廷大事的想法。他的诗，后人叫楚辞，写得自由豪放，是古代诗歌的一次大进步。 公元前278年，秦国派大将白起去攻打楚国，打下了楚国的国都。屈原听到这个消息，伤心得放声大哭。他已经是六十多岁的老人了，知道楚国已经没有希望了，可不愿意眼看着楚国被毁。据说在五月初五那一天，他就抱着一块大石头，跳到汨罗江里去了。 渔民和附近的庄稼人得到了这个信儿，赶紧划着小船去救屈原。不大一会儿工夫，好些小船争先恐后地赶来了。可是汪洋大水，哪儿有屈原的影儿呐？他们在汨罗江上捞了半天，到了儿也没把屈原找着。渔民挺难受，他们对着江面祭祀了一会儿，把竹筒子里的米饭撒在水里，算是献给屈原的。 到了第二年的那一天，大伙儿想起这是屈原投江的周年了，又划着船，用竹筒子盛上米饭撒到水里去祭祀他。到后来，人们把盛着米饭的竹筒子改成粽子，划小船改为赛龙船，把五月初五称为端午节，也叫端阳节。这吃粽子和赛龙船，慢慢就变成全中国的一种风俗了。 泾阳君为了建立自己的势力，在齐国的时候就跟孟尝君交上了朋友。这会儿一听说秦王把孟尝君软禁了，还想谋害他，就替他想办法。泾阳君带了两对玉璧送给秦王最宠爱的燕姬，请她帮助。燕姬拿三个手指托着下巴颏儿，斜着眼睛，装腔作势地说：“叫我跟大王说句话倒是不难，你把这两对白玉带回去，别的谢礼我一概不要，我只要一件银狐皮袍子就够了。” 泾阳君把她的话告诉了孟尝君，孟尝君皱着眉头说：“我就有那么一件，已经送给秦王了，哪儿还能要回来呐？”当时有个门客说：“我有办法。”他立刻去跟那个管衣库的人瞎聊天儿，看准了门路。当天晚上，这位门客从狗洞爬进宫里去，找着了衣库去偷那件皮袍子。他掏出好些钥匙，正在开门的时候，看库的人惊醒了，咳嗽了一声。那个门客就装狗叫，“汪汪”地叫了两声。看衣库的人就放了心，又睡着了。那个门客进了衣库，开了箱子，拿出那件银狐皮袍子，然后又锁上箱子，关上库房，从狗洞钻了出去。 孟尝君得到了这件皮袍子，送给了燕姬。燕姬就甜言蜜语地劝秦王把孟尝君放回去。秦王到了儿依了她，发下过关文书，让孟尝君回齐国去。 冯 回来，把收账的经过报告给孟尝君。孟尝君听了，脸上变了颜色，说：“那我这三千多人可吃什么呐？您怎么花了这些钱，又打酒又买肉的，还把债券烧了！我请您去收账，您收了些什么回来呐？”冯 说：“您别生气，我说给您听。那些实在穷得还不了的，您就是留着债券也没用，再过五年，十年，利钱越来越多，一辈子也还不了，反倒逼他们跑到别的地方去。这些债券简直没有用，不如烧了倒干脆。您要是拿势力去逼他们，利钱也许能够多少收点儿，可是民心丢了。您说过，这儿短什么，就买些什么。我觉得这儿短的就是民心。我就买了民心回来。我敢说，收回民心要比收回利钱强得多！”孟尝君无可奈何地向他拱了拱手，说：“先生眼光远大，佩服！佩服！” 冯 到了咸阳，对秦昭襄王说：“如今天下有才干的人，不是投奔秦国，就是投奔齐国。上秦国来的都想叫秦国强，齐国弱；上齐国去的都想叫齐国强，秦国弱。可见当今之世，不是秦得天下，就是齐得天下。这两个大国是势不两立的。”秦昭襄王听了他的话，跪起来说（当时的人是坐在地上的）：“先生有何妙计能叫秦国强大，请先生指教！”冯 连忙请他坐了，说：“齐国把孟尝君革职了，大王知道吗？”秦王装模作样地说：“我听说倒是听说了， 可不大清楚。”冯 说：“齐国能够有现在这样的地位，全仗着孟尝君呐。如今齐王听了谣言，革了他的官职，收回了相印。齐王这么以怨报德地对付孟尝君，孟尝君当然也怨恨齐王。大王趁着他怨恨齐王的时候，赶快把他请来。要是他能够给大王出力，还怕齐国不来归附吗？齐国要一归附，天下可就是秦国的了。大王赶快打发人用车马带着礼物去请他，还来得及。万一齐王一反悔，再拜他为相国，齐国可又要跟秦国争高低了。” 这时候，正巧秦国老丞相死了，秦昭襄王正需要帮手，就依了冯 的话，打发使者带了十辆车，一百斤金子，用迎接丞相的仪式上薛城去迎接孟尝君。冯 辞别了秦昭襄王，他说：“我先回去告诉孟尝君一声，免得临时匆促。” 冯 离了咸阳，就急急忙忙地照直到了临淄，求见齐湣王，对他说 ：“齐国和秦国是势不两立的两个大国，谁要是得到人才，谁就能号令天下。我在道儿上听到秦王暗中去拉拢孟尝君，打发使者带了十辆车、一百斤金子，用迎接丞相的仪式上薛城去迎接他。孟尝君真要是做了秦国的丞相，临淄、即墨不就危险了吗？”齐湣王真没防到这一招儿，很着急地说：“怎么办呐？”冯 说：“不能再耽误了，趁着秦国人还没到，大王赶紧先恢复孟尝君的官职，再加封他一些土地，孟尝君一定感激大王。他做了相国，难道说秦国没得到大王的认可，就可以随便接走人家的大臣吗？” 齐湣王答应重新重用孟尝君，可是心里还有点儿疑惑。他背地里打发心腹到边境上去探听秦国的动静。派去的人一到了边界上，就见那边秦国的车马已经来了，他立刻赶回临淄，上气不接下气地向齐湣王报告。齐湣王立刻吩咐冯 去接孟尝君来做相国，另外又封给他一千户的土地。赶到秦国的使者到了薛城的时候，孟尝君已经官复原职了。秦国的使者白跑了一趟，秦昭襄王只怪自己晚了一步。 信陵君下了一道命令：“父亲和儿子都在军队里的，父亲可以回去；哥哥和弟弟都在军队里的，哥哥可以回去；独子可以回去养活老人；有病的或者身子弱的，也可以回去。”大概十成里有两成的士兵请求回去。信陵君重新编排队伍，总共有八万精兵。信陵君亲自出马跑到最前面，指挥将士们向秦国的兵营冲杀过去。秦国的将军王龁没想到魏国的军队突然会来攻打，手忙脚乱地抵抗了一阵。平原君开了城门，带着赵国的军队杀出来。两边夹攻，打得秦国的军队就像山崩似的，倒了下来。多少年来，秦国没打过这么一个大败仗。秦昭襄王赶紧下令退兵，已经死伤了一半人马。郑安平的两万人给魏国的军队切断了退路，变成了孤军。他叹了一口气，说：“我本来是魏国人，还是回到本乡本土去吧。”他带领两万人马投降了信陵君。 李信和蒙武碰到楚国的大将项燕，打了败仗，将军死了七个，士兵死伤无数，接连往后退回来。秦王政大怒，把李信革了职，亲自跑到王翦那儿，请他再辛苦一趟。王翦说：“我已经老了，请大王另派别人吧。”秦王政直向他赔不是，说：“上回是我错了，这回非请将军出马不可，将军千万别再推辞。”王翦说：“那么，还是非要六十万人不可。楚是大国，地广人多，楚王号令一出，要发动一百万人马也不太难。我说六十万，还怕不太够。再要少，那就不行了。” 秦王政用自己的车马亲自把王翦接到朝廷里来，当时就拜他为大将，交给他六十万兵马，仍旧派蒙武为副将。出兵的那天，秦王政亲自送到灞上（在陕西长安东），在那儿摆上酒席，给王翦送行。王翦斟了一杯酒，捧给秦王政，说：“请大王干了这杯，我要请求点儿事。”秦王政接过来，一口喝完，说：“将军尽管说吧。”王翦从袖子里掏出一张单子来，上头写着咸阳上等的田地几亩，上等的房子几所，请秦王赏给他。秦王政看了说：“将军成功回来，难道还怕受穷吗？”他完全答应下来，心里想：“这位老将军真有点儿太小家子气了。” 王翦率领着六十万大军去打楚国，路上又打发一个手下人回去，向秦王政请求给他修一个花园。又过了几天，又派人去恳求秦王政，还想要个水池子，里头好养鱼。副将蒙武笑着说：“老将军请求了房屋、田地也就是了，为什么还要花园、水池子？打完了仗，将军还怕不能封侯吗？”王翦咬着耳朵对他说：“哪个君王不猜疑？你能保证咱们的大王不这样吗？他这回交给了咱们六十万大军，简直把全国的兵马全交给咱们了。我左一个请求，右一个请求，为的是让大王知道我惦记着的不过这点儿小事，好让他安心。”蒙武这才明白过来，点点头说：“老将军的高见真叫我佩服得没法儿说。” 原来项羽跟着卿子冠军宋义往北去救巨鹿，在安阳就停留了四十六天，打败了王离的军队以后，又跟秦军的主力三番五次地展开了血战。刘邦这时候奉楚怀王命令，就从南路往西进军。他到了高阳（在河南杞县），得到了一个谋士叫郦食其（lìyìjī）。郦食其是高阳人，他遇见了刘邦手下的一个骑兵，也是本地人，就对他说：“听说沛公傲慢得很，可是挺了不起的。我倒愿意去帮助他。请你替我说：‘我有个老乡郦先生，六十多了，是个读书人，很有学问，可以帮助您成一大事。’你推荐我，我忘不了你。”那个骑兵摇摇头，说：“不行，不行！沛公最不喜欢读书人。他老说读书人没出息，您还去见他呐？”郦食其说：“你就说我是高阳酒徒，去说说吧。” 英布一出兵，就打死了荆王，打跑了楚王，把荆楚一大片土地都夺过去，急得汉高祖马上发兵去对敌。他亲自出马，碰到英布的军队，一看他布的阵势跟项羽的一样，就有点担心。他在阵前责备英布，说：“我已经封你为王，你何苦造反？”英布反问一句：“项羽也曾经封你为王，你为什么造反呐？你造反，做了皇帝；我造反，也想做皇帝呀！” 汉文帝又下了一道诏书，开始救济各地的鳏、寡、孤、独（鳏guān，死了妻子的年老人；寡，寡妇；孤，孤儿；独，没有儿女的年老人）穷苦的人。规定八十岁以上的老人按月发给米、肉、布帛，还规定地方长官必须按时按节去慰问年老的人。 公元前167年，有个十几岁的小姑娘上书给汉文帝。事情是这样起来的： 齐国临淄（在山东；淄zī）有个读书人，名叫淳于意（姓淳于，名意；淳chún）。他喜欢医学，替人治病很有把握，因此出了名。后来他做了齐国太仓县的县令。他有个脾气，不愿意跟做官的人来往，更不会拍上司的马屁。所以过了不久，他辞了官职，仍旧去做医生。 有个大商人的妻子患了病，请淳于意医治。那女人吃了药不见好转，过了几天死了。大商人就告他是庸医杀人。当地的官吏把他判成“肉刑”。那时候的肉刑包括脸上刺字，割去鼻子，砍去左足或右足三种。因为淳于意曾经做过官，就把他解到长安去受刑罚。淳于意有五个女儿，可没有儿子。临走的时候，他叹着气说：“唉，生女不生男，有了急难，一个有用处的也没有！” 女儿们低着头直哭。那个最小的女儿叫缇萦（tíyíng），又是伤心又是气愤。她想：“为什么女儿就没有用？难道我不能帮助父亲吗？”她决定跟着父亲一同上长安去。她父亲到了这时候反倒疼着她，劝她留在家里。解差也不愿意带上小姑娘，多添麻烦。缇萦可不依，寻死觅活地非去不可。解差怕罪犯还没送去先出了命案，只好带着她一块儿走了。 缇萦到了长安，要上宫殿去见汉文帝。管宫门的人不让她进去。她就写了一封信，到宫门口把信递给守宫门的人。他们把她的信传上去，汉文帝一看，才知道上书的是个小姑娘，字写得歪歪扭扭，可是挺动人的。那信上写着： 我叫缇萦，是太仓县令淳于意的小女儿。我父亲做官的时候，齐地的人都说他是个清官。这会儿犯了罪，应当受到肉刑的处分。我不但替父亲伤心，也替所有受肉刑的人伤心。一个人砍去了脚就成残废；割去了鼻子，不能再安上去。以后就是要想改过自新，也没有办法了。我愿意给公家没收为奴婢替父亲赎罪，好让他有个改过自新的机会。恳求皇上开开恩！ 汉文帝不但同情小姑娘这一番孝心，而且深深地觉得过去的肉刑实在太不合理。他召集大臣们，对他们说：“犯了罪，应当受罚，这是没有话说的。可是受了罚，得到了教训，就该让他重新做人才是。现在惩办一个犯人，在他脸上刺了字，或者毁了他的肢体，这就太过分了。这样的刑罚怎么能劝人为善呐？我决定废除肉刑，你们商议个代替肉刑的办法吧。” 大臣们商议下来，拟定了三条办法：废除脸上刺字的肉刑，改为做苦工；废除割去鼻子的肉刑，改为打三百板子；废除砍去左足或右足的肉刑，改为打五百板子。 汉文帝同意了，下了一道诏书，正式废去肉刑。小姑娘缇萦不但救了自己的父亲，也替天下的人做了一件好事情。汉文帝减轻刑罚，有人就怕这么下去，犯法的人一定会增加。可是正相反，犯罪的人越来越少了。据说一年里头，全国犯重罪的案子一共只有四百件。这是因为汉文帝采用了一系列减轻人民负担的政策。 冯异到了长安，把人马埋伏好，就向赤眉军下战书，没想到第一仗就打败了。冯异带着人马来到崤山（在河南渑池西）打下埋伏。赤眉军因为缺吃的，要往东撤退，一到崤山就中了埋伏，拼死拼活打了一天，死伤了一大半。冯异让一些士兵也在眉毛上涂上红颜色，打扮成赤眉的士兵，混进赤眉的队伍。赤眉军正进退两难，冯异的将士们大叫大喊：“赶快投降！投降不杀！”那些假装赤眉的士兵马上响应：“咱们投降！咱们投降！”赤眉军一下子军心大乱，好多人放下了武器，归顺了汉军。 隗嚣正在为难，马援来信了，责备他不该反复无常，劝他及早回头，归附汉光武帝。隗嚣火儿了，调动人马，准备再跟汉兵交战。马援带着五千骑兵，在隗嚣的队伍中来来往往，劝将士们归附汉朝，就有一些将士听了他的话，离开了隗嚣。隗嚣见人心大变，只好写信向汉光武帝求和。汉光武帝这会儿就不再那么客气了，回答说：“空话我也听烦了，或是真心，或是假意，随你的便。”隗嚣知道汉光武帝已经看透了他，就投降了公孙述。公孙述封他为王，还派兵去帮他对抗汉朝。 汉光武帝在路上给围攻西城和上邽的将军们写了一封信，信上说：“那两个城要是打下来了，你们马上带领兵马往南去征伐蜀地。人的毛病就在于不知足，我的毛病也在于‘得陇望蜀’（平定了陇右，又希望去平定蜀地）。每发一回兵，我的头发胡须总是白了一些。可是不这么干，天下怎么能够统一呐？” 陈蕃还不死心，又请汉桓帝去接安阳名士魏桓。魏桓跟徐穉他们一样，也不肯动身。朋友们劝他说：“就是到京师里去走一趟也好嘛。”魏桓说：“读书人出去做官，总得对得起百姓，对得起国家。现在后宫里多到几千人，请问能减少吗？供玩儿的马多到一万匹，请问能减少吗？皇上左右的那一大批宦官，请问去得了吗？”大伙儿听了都叹气说：“恐怕都办不到。”魏桓说：“对呀！那你们干吗还要劝我去呐？要是我活着去，死了回来，对大伙儿有什么好处呐？”大伙儿这才没有话说 。 徐璜的侄儿徐宣做了下邳令。已经死了的汝南太守李嵩，家就在下邳，他的女儿给徐宣看上了。徐宣派人到李家去，要小姑娘做他的姨太太。李家不答应，徐宣就派人把她抢了来。小姑娘一死儿不依。徐宣火冒三丈，叫人把她绑在柱子上，毒打了一顿，再问她依不依。小姑娘骂他是畜生。徐宣龇着牙一笑。他拿出一张弓，拣了十几支箭，一边喝酒，一边把她当作箭靶子，就这么喝一口酒，射一支箭，把小姑娘活活射死了。 太尉陈蕃上了一个奏章，替党人辩护。汉桓帝就把陈蕃革了职。李膺在监狱里想了个办法，要治治这些宦官。他传出话来，说不少宦官的子弟都是他的同党。宦官们果然吓坏了，没法儿了，他们只好对汉桓帝说：“现在天时不正，应当大赦天下。”汉桓帝反正只听宦官的，就把两百多名党人都放了，可“禁锢”他们终身，就是永远不准他们做官。 董卓虽说请了一些有名望的人来做官，可是他根本不懂得怎么跟这些人打交道。笼络自己的将士，他倒是有一套土霸王的办法。他放这些刚进京城的将军和士兵随便抢财物，抢美女。洛阳城里一条街挨着一条街，买卖人家挺多，还有不少皇亲国戚，贵族富豪。董卓的将士闯进去，见什么抢什么，还有个名目，说这叫“搜牢”，就是保护治安的意思。这么“保护”下去，谁受得了哇？将士们把抢来的财物美女交给董卓，他就分给他们一部分，好让大伙儿享受享受。他还叫人刨开了汉灵帝的坟，把里边藏的珠宝都拿出来分了。这么一来，将士们都竖起大拇指，夸董卓真够意思。 司马懿是温城人（温城在河南温县），打小就会算计，碰到什么难事就爱装个糊涂。后来成了曹操的心腹，又当了魏国的大将军。他和诸葛亮打了几仗，老是吃亏，干脆请魏明帝下命令，让将士们坚守营寨，不准出战。诸葛亮怕的就是老这么耗下去，那要什么时候才能打到中原呐？他接二连三地派人给司马懿下战书，约他出来对阵。司马懿拿稳了老主意，愣不出来。诸葛亮又让士兵到魏军的军营前面挑战，什么“胆小鬼”、“没皮没脸”的直骂。骂着骂着，果然把魏军将士骂火儿了。他们找到司马懿，要求去跟蜀军拼命。司马懿可装没听见，怎么也不答应。`,``,`html`,`书剑恩仇录`,`20241222152630-影摘 病向浅中医，谚语，意思是治病应在刚得病时就医治。 我难得潇洒, 自由自在, 娶妻干什么 知易行难 面对着有如玉城雪岭的大潮, 才感觉到什么叫雄伟壮大, 与朝廷为敌就有如石子, 要和潮水对抗一样, 只有被淹没的下场 情深不寿, 强极则辱, 谦谦君子, 温润如玉 情深不寿：君子之交淡如水，情义真挚深沉无需繁饰，就如这质朴天成的美玉一样，无需百般刻镂，细琢精雕。此处的“寿”字，作镌刻、雕镂解。（寿：镌刻；见《医史·李杲传》：“制一方与服之，乃效，特寿之于木。”） 强极则辱：刚强至极，必然遭挫，犹如木秀于林，风必摧之。此处的“辱”字，作挫、折、弱化、压下去解。（辱：压下去,挫；见《银雀山汉墓竹简·孙膑兵法》：往者弗送,来者弗止,或击其迂,或辱其锐。） 每遭鬼神之忌 携恩图报之人 人也变得沉寂多了 人生在世不称意, 明朝散发弄扁舟 披了袈裟, 不一定是和尚, 人与人之间基于一个情字 满怀心腹事, 尽在不言中 哎, 偷看人洗澡的大哥, 怎么走得这么快啊 我累的时候, 就睡在花的旁边, 我肚子饿的时候, 就吃花 姐姐, 你不累吗, 太阳每天晚上也会休息的 权嘛, 它本身就像一把刀, 刀本身就是工具, 可以为善, 也可以为恶, 问题在于握刀的人怎么用它 刀可以救人, 也可以杀人 杀人或救人, 也得把刀先握着 从前还没有喜欢上他的时候, 我以为情情爱爱, 是那些傻瓜干的傻事 毕竟树大有枯枝 不要再砌词敷衍 河水顺势而流, 一直流到大海, 河水就没有烦恼, 白云随风而动, 时散时合, 白云也没烦恼, 随遇而安啦 你是什么人, 就做什么事, 只要不做违背良心的事, 那就不会有太多烦恼了 夜了, 大哥要回宫了`,``,`html`,`体况`,`20240307183503-户外 行进 能大步走就不小走。这样几十公里下来可以少万许多步。疲劳时应用放松的慢步来休息, 而不是停下来。 膝盖负重倍数 躺下来的时候，膝盖的负重几乎是0。 站起来和走路的时候，膝盖的负重大约是体重的1~2倍。 上下坡或上下阶梯的时候，膝盖的负重大约是体重的3~5倍。 跑步时，膝盖的负重大约是体重的4倍。 打球时，膝盖的负重大约是体重的6倍。 蹲和跪时，膝盖的负重大约是体重的7~8倍。 脱水 出发前十五分钟喝一杯水，上路之后，以每二、三十分钟喝至一杯半的速率。 不要等口渴感觉做为什么时候该喝水的凭据。 登山脱水会导致失去方向感、头痛、以致精神不集中。 别等口渴才喝水，口渴是开始脱水的征兆。 登山健康的基本要求之一是大量喝水，不想也要逼自己喝。 登山前大量喝水可增强体力和耐力，攀登二十四小时前大量喝水可增进体能。夏季攀登或是长途时要多喝运动饮料。 尿液黄色代表身体依然呈脱水状态 保暖 体温一旦过低便会神智不清，失去正常的思维能力和产生幻觉（很多冻死的人的表情并不痛苦便是这个原因） 贴身内衣的重要性：保暖首重排汗，因为湿衣服贴在皮肤上会使体热散失，其散失的体热是干衣服的二十倍。 二分之一以上的体温是由头部逸失的。多戴一顶帽子和多穿一件毛衣一样的保暖。 将干草塞衣服保暖 带厚衣物，没有厚衣服时，多穿几件薄衣服，甚至将塑料袋塞到衣服里面也可以起到相同的作用． 如果在寒冷地带，走路很多脚照样出汗，等你停下来时，潮湿的棉袜保暖性很差，会冻伤脚。 一般来说，羊毛袜子是比较好的选择。为什么不选棉的呢？主要原因是因为棉受潮以后干的很慢。 户外的羊毛袜一般含80%左右的毛，还加有20%的尼龙增强伸缩性。这种混织的袜子比纯毛的袜子更结实耐用。羊毛的保暖性能出色，即使湿了以后，它仍有较好的保暖性。 热衰竭 出现昏倒、皮肤湿冷、恶心等。出现后使其双脚抬高，头部稍放低，置于阴凉处。 炎热和寒冷的耐受力 20221112140920.webp 冷水浸透处理 20221112142118.webp 假性止血 20221112142108.webp 模拟作战环境 20221112141835.webp`,``,`html`,`克隆`,`20240616183123-_java 复制对象：当需要创建一个对象的独立副本时，可以使用克隆来快速复制对象，而不必手动复制每个属性。 缓存数据：在某些情况下，需要缓存一些数据，但是不希望改动缓存中的数据影响到原始数据。克隆可以用于将数据缓存到另一个对象中，从而保持缓存数据的独立性。 多线程环境：当多个线程需要访问相同的对象时，为了避免对原始对象进行并发修改，可以使用克隆来创建每个线程的独立副本。 浅克隆 浅复制(默认): 只对对象及变量值进行复制,引用对象地址不变 基本数据类型的成员变量拷贝值，引用类型的成员变量拷贝引用地址 //Hero实现cloneable接口 public Hero clone(){ Hero hero=null; try { hero=(Hero)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return hero; } 深克隆 深复制: 不仅对对象及变量值进行复制,引用对象也进行复制 基本数据类型的成员变量拷贝值，引用类型的成员变量递归的调用 clone() 方法 //重写Clone方法 @Override public Hero clone(){ Hero hero=null; try { hero=(Hero)super.clone(); //给weapon属性也给克隆一下 setWeapon(getWeapon().clone()); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return hero; } 如果在拷贝一个对象时，要想让这个拷贝的对象和源对象完全彼此独立，那么在引用链上的每一级对象都要被显式的拷贝。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而这个对象没有实现clone方法， 那么在它之后的所有引用的对象都是被共享的。 举例来说，如果被Head引用的Face类是第三方库中的类，并且没有实现Cloneable接口，那么在Face之后的所有对象都会被拷贝前后的两个Body对象共同引用。假设Face对象内部组合了Mouth对象，并且Mouth对象内部组合了Tooth对象 public class Main { static class Body implements Cloneable{ public Head head; public Body() {} public Body(Head head) {this.head = head;} @Override protected Object clone() throws CloneNotSupportedException { Body newBody = (Body) super.clone(); newBody.head = (Head) head.clone(); return newBody; } } static class Head implements Cloneable{ public Face face; public Head() {} public Head(Face face){this.face = face;} @Override protected Object clone() throws CloneNotSupportedException { //return super.clone(); Head newHead = (Head) super.clone(); newHead.face = (Face) this.face.clone(); return newHead; } } static class Face implements Cloneable{ @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } public static void main(String[] args) throws CloneNotSupportedException { Body body = new Body(new Head(new Face())); Body body1 = (Body) body.clone(); System.out.println("body == body1 : " + (body == body1) ); System.out.println("body.head == body1.head : " + (body.head == body1.head)); System.out.println("body.head.face == body1.head.face : " + (body.head.face == body1.head.face)); } } //body == body1 : false //body.head == body1.head : false //body.head.face == body1.head.face : false 对象序列化实现深克隆 public class Dancer implements Cloneable,Serializable{ private String name; private Dancer partner; //getter,setter public Dancer deepClone() throws IOException, ClassNotFoundException { ByteArrayOutputStream bos = new ByteArrayOutputStream();//ByteArrayOutputStream 作为字节存储容器 ObjectOutputStream oos = new ObjectOutputStream(bos);//ObjectOutputStream 作为写入工具 oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());// 获取存储在 ByteArrayOutputStream 中的字节数组。ObjectOutputStream 本身不存储这些字节，因此不能从 oos 获取字节数组 ObjectInputStream ois = new ObjectInputStream(bis); Dancer dancer = (Dancer) ois.readObject(); return dancer; } public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException { Dancer d1 = new Dancer(); d1.setName("Lili"); System.out.println("d2's partner: " + d1.hashCode()); Dancer d2 = new Dancer(); d2.setPartner(d1); //浅克隆 Dancer d2_shallow_copy = (Dancer) d2.clone(); //标记Cloneable System.out.println("d2_shallow_copy's partner: " + d2_shallow_copy.getPartner().hashCode()); System.out.println(d2_shallow_copy.getPartner().getName()); //深克隆 Dancer d2_deep_copy = d2.deepClone();//标记Serializable System.out.println("d2_deep_copy's partner: " + d2_deep_copy.getPartner().hashCode()); System.out.println(d2_deep_copy.getPartner().getName()); } /* d2's partner: 1975012498 d2_shallow_copy's partner: 1975012498 Lili d2_deep_copy's partner: 1828972342 Lili */ } HashMap clone()方法 在HashMap类中，clone()方法被重写和实现了 但方法返回的是HashMap对象的浅拷贝，而不是深拷贝。 这意味着，当HashMap对象的值是对象时，副本与原始对象共享相同的对象引用。 因此需要小心对待对象值是对象的情况 数组对象的 clone() 方法 数组对象的 clone() 方法的行为和其他对象并无差别，即都是浅拷贝 当数组是一维基本数据类型的时候，简单的浅拷贝即可实现拷贝对象的需求 当数组是一维引用数据类型的时候，因为是浅拷贝，所以拷贝数组中的元素和被拷贝数据中的元素是同一个对象 当数组是二维基本数据类型的时候，二维数组相当于是一维数组的数组，而数组是引用数据类型，所以二维基本数据类型 clone() 方法的行为相当于一个一维引用数据类型的行为 // 基本数据类型二维数组 int[][] intArr = new int[2][2]; intArr[0][0] = 0; intArr[0][1] = 1; intArr[1][0] = 2; intArr[1][1] = 3; int[][] copy_intArr = intArr.clone(); intArr[1][0] = 4; System.out.println("intArr:"); for (int[] i : intArr) { System.out.println(Arrays.toString(i)); } System.out.println("copy_intArr:"); for (int[] i : copy_intArr) { System.out.println(Arrays.toString(i)); } ------------------------ intArr: [0, 1] [4, 3] copy_intArr: [0, 1] [4, 3]`,``,`html`,`内部类`,`20240616183123-_java 成员内部类 内部类在外部使用时无法直接实例化,需借外部类信息完成 Outer.Inner inner = new Outer().new Inner() Outer.Inner inner = outer.new Inner() Outer.Inner inner = outer.获取内部类的方法 public class Person { class Heart { public void beat() {} } public Heart getHeart() { return new Heart(); } public static void main(String[] args) { new Person().getHeart().beat(); } } 内部类的访问修饰符,可以任意,但是访问范围会受到影响 内部类可以直接访问外部类的成员 如果出现同名属性,优先访问内部类中定义的,可以使用外部类.this.成员的方式访问外部类中同名属性 外部类无法直接访问内部类信息,需要通过内部类实例new Heart().成员 内部类编译后命名方式为外部类$内部类.class 静态内部类 静态内部类和非静态内部类一样,都是在被调用时才会被加载 只能访问外部类的静态成员(外部类.属性),如果需调用外部非静态成员(方法,属性),可以用对象实例,如new 外部类().方法 如果出现同名属性,优先访问内部类中定义的,可以使用new 外部类().成员的方式访问外部类中同名属性 public class Outer { static int n = 1; static {System.out.println("外部类静态块");} public static void OuterMethod() { System.out.println("外部类静态方法"); } public static class Inner{ static {System.out.println("静态内部类静态块");} public static void InnerMethod() { System.out.println("静态内部类静态方法"); } } public static void main(String[] args) { // System.out.println("1");//外部类静态块, 1 // Outer.Inner.InnerMethod();//外部类静态块, 静态内部类静态块, 静态内部类静态方法 // Outer.OuterMethod();//外部类静态块, 外部类静态方法 } } class A { public static void main(String[] args) { //调用类的静态方法时会触发类加载 Outer.OuterMethod();//外部类静态块, 外部类静态方法 } } class B { public static void main(String[] args) { Outer.Inner.InnerMethod();//静态内部类静态块, 静态内部类静态方法 } } class C { public static void main(String[] args) { //访问类的静态成员变量会触发类的加载 System.out.println(Outer.n);//外部类静态块, 1 } } 创建该类或子类的对象会触发类加载。 访问类的静态成员变量时会触发类加载。 JVM虚拟机只会为静态变量分配一次内存，在加载类的过程中完成对静态变量的内存分配； 调用类的静态方法时会触发类加载。 对类或接口的静态字段执行读写操作（即执行getstatic、putstatic指令）；不过final修饰的静态字段的除外(已经赋值，String和基本类型，不包含包装类型)，它被初始化为一个编译时常量表达式 注意 ：操作静态字段时，只有直接定义这个字段的类才会被初始化；如通过其子类来操作父类中定义的静态字段，只会触发父类<clinit>的初始化而不是子类的初始化 使用java命令执行有主方法main的类，也会触发类的加载 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 方法内部类 定义在方法内部,作用范围也在方法内 和方法内部成员使用规则一样,class前面不可以添加public,private,protected,static 类中不能包含静态成员 类中可以包含final,abstract修饰的成员 匿名内部类 应用场景 给类命名并不会导致代码更容易被理解 只用到类的一个实例 类在定义后马上用到 无法编写构造方法,可以添加构造代码块 可以实现接口也可以继承父类,但是不可兼得 不能出现静态成员 无法使用private,public,protected,abstract,static修饰 编译后的文件命名: 外部类$数字.class`,``,`html`,`准备`,`20250505105224-户外 对于户外装备有关的新技术，都需要花时间来学习如何最好地使用它 提前同步好相关路线和航点, 出发点手动开始记录, 然后路线导航或航点导航, 回到出发点结束记录 每次上山要认识几种动植物(形态特性) 体验 盐晶制取 钓鱼烤鱼 陶器烧制 陷阱布置 木屋搭建 ---------------------------------------------- 腰包 (forclaz 7L) 手机 (超级省电模式) 手持GPS (garmin etrex solar) 瓶装水 (1.5L, 溶入2g盐, 10g糖) 压缩饼 直饮器 (sawyer mini) 医疗包 小刀 (m390粉末钢) 哨子 火石 手电 (fenix c5) 望远镜 (celestron 单筒10x24) 避蚊胺 (jiadebao 10%deet) 护袖 湿巾 ---------------------------------------------- 医疗包 碘签, 创可贴, 止血带(带敷料) 碘伏和75酒精区别 碘伏杀菌速度较慢，但杀菌谱广，能持续杀菌一段时间, 刺激性弱, 可用于开放性伤口 酒精杀菌速度快，但挥发快，持续作用时间短，对部分病毒（如诺如病毒）效果较弱, 刺激性强, 不能直接用于开放性伤口 阿莫西林 (广谱抗生素) 轻度伤口感染 在户外难免会被划伤、摔伤、动物咬伤、虫咬等，细菌可能会进入伤口，引发感染。 如果伤口出现红肿、疼痛、化脓，可考虑使用阿莫西林，防止感染扩散 呼吸道感染（咽炎、扁桃体炎） 户外气候变化大，如果受凉、淋雨，可能引发嗓子痛、发烧、咳嗽、黄痰等细菌性咽炎或扁桃体炎。 如果咳嗽有黄痰、发烧超过 38.5°C，可能是细菌感染，可考虑使用阿莫西林 肠胃感染（细菌性腹泻） 野外饮水不洁或误食变质食物，可能导致细菌感染引起的腹泻（如大肠杆菌、沙门氏菌感染）。 主要症状：腹痛、腹泻（稀水便）、发烧。 只对细菌性腹泻有效，如果是病毒性胃肠炎（如诺如病毒）则无效 橡胶管`,``,`html`,`分布式`,`20240601114319-_微服务 集群 Cluster 侧重于通过多台计算机协同工作来提高性能和可用性，适用于需要高性能和高可用性的系统。 同一个业务,部署在多个服务器上,分散压力 分布式 Distributed System 通过多个独立节点协同工作来实现资源共享和并行处理，适用于需要高扩展性和容错性的系统。 一个业务分拆多个子业务,部署在不同的服务器上, 自治,不共享主内存,通过发送信息进行合作 分布式是系统部署方式 微服务 Microservices 通过将应用程序分解为独立服务来提高灵活性和部署效率，适用于需要高灵活性和快速迭代的应用。 分散能力 微服务是架构设计方式 20240601140941.webp CAP CAP theorem也称为布鲁尔定理，是分布式系统中的一个基本原理。它描述了在分布式计算环境中，三个核心属性之间的权衡关系： 一致性 (Consistency): 所有节点在同一时间看到的数据是一致的。即每次读取操作都返回最新的写入操作的结果。 可用性 (Availability): 每个请求都能得到响应，无论成功还是失败。即系统始终可以接受读写请求，并返回结果。 分区容错性 (Partition Tolerance): 系统在网络分区的情况下仍能继续操作。即系统能够处理网络分割或节点失效时的操作。 这三个属性只能同时满足两个, 在面对网络分区或通信故障时，系统必须在一致性和可用性之间进行权衡 CA：系统保证一致性和分区容错性，即所有节点上的数据一致，并且系统能够处理网络分割，但这可能会牺牲系统的可用性，即系统可能会因为某些节点无法响应请求而变得不可用 CP：在网络分区的情况下，系统保证一致性和可用性，即所有节点上看到的数据是一致的，并且系统对所有请求做出响应。但这可能会在网络分区的情况下牺牲系统的可用性，即某些节点可能无法响应请求 AP：系统保证可用性和分区容错性，即即使在网络分割的情况下，系统仍然能够响应请求并继续操作，但这可能会牺牲一致性，即不同节点上的数据可能会不同步 对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地 数据库事务一致性需求 很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求并不高。允许实现最终一致性。 数据库的写实时性和读实时性需求 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。 对复杂的SQL查询，特别是多表关联查询的需求 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。 BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。`,``,`html`,`初始化顺序`,`20240616183123-_java 1.父类静态属性(略过声明而未赋值的),静态代码块.二者依书写顺序执行 2.子类静态属性(略过声明而未赋值的),静态代码块.二者依书写顺序执行 3.父类成员属性(略过声明而未赋值的),构造代码块.二者依书写顺序执行 4.父类构造方法 5.子类成员属性(略过声明而未赋值的),构造代码块.二者依书写顺序执行 6.子类构造方法`,``,`html`,`动物伤害`,`20240510103255-户外 蛇 棍子探路, 避草丛石头, 遭遇时缓慢退出而不是突然动作 蛇虽然没有耳膜，但可以通过地面震动感知猎物或天敌的活动。 蛇对低频声音（震动）非常敏感 猎物在附近爬行时的震动（如老鼠、小鸟在地上走动）。 人类脚步，特别是当你在丛林或草地里行走时，蛇可以提前察觉并做出反应（通常是逃跑）。 部分蛇类（如蟒蛇、蝮蛇）可以通过“热窝”感知温血动物的热量，就像戴着红外线夜视仪 蛇的热感应可以精准到0.003°C 的温度变化，这意味着即使是猎物呼出的热气，也能被蛇感知 蛇的分叉舌头相当于“嗅觉雷达”, 可以感知气味的方向，用于寻找猎物或逃避危险 蟒蛇通过缠绕猎物，并感知猎物心跳，确保死亡后才松口。 人工饲养的蛇从小习惯人类气味，因此比野生蛇更温顺。`,``,`html`,`南宋传奇之蟋蟀宰相`,`20250319201757-影摘 官场如同屠宰场, 拿人头不当人命啊 小人, 不能当, 坏人不该当, 好人, 可好人我也当不了啊, 一刀, 你就让我清清闲闲的做个闲人吧 借梯登高 虽说郑大人对举子的虫经屡有微辞, 举子并不以为过 沉缅于子曰诗云久矣 直言犯上, 卖直取宠 --你为何以德报怨呢 小的是个养虫之人哪, 早就见惯了虫子们之间的争相恶斗, 你我撕咬, 小的举一反三, 触类旁通, 早已炼就一颗平常之心, 皇上, 大到国, 小到家, 无非虫戏, 弄得你死我活, 遍体鳞伤, 游戏尚可呀, 要动真格的, 那可实在是不值, 您就说小的吧, 我也吃五谷杂粮, 也历饥寒饱暖, 自然也有喜怒哀乐, 我就不这样, 我不跟他们一般见识, 对不对皇上, 刚才我在半部虫经里写道, 人人争斗, 何故, 妒也, 虫圣与小蛐区别何在, 度也, 妒, 生气, 度, 生量, 是也 --讲得好, 好一个妒生气, 度生量 一颗雄心, 两种准备 不是臣妾故作姿态, 是臣妾的小弟实在是不可造就 药棰去势, 选为阉奴 桃从心中烂 还搬出祖宗之法来压朕, 不提祖宗之法还好, 一提朕就来气, 偌大的江山, 传到朕的手里还剩下什么了, 成天叫嚷着收复河山, 收复河山, 这不是白日做梦吗 是不是你听说这贾虫, 成了御批人才, 心动了, 我呀, 告诉你吧, 他现在要是再来认你, 我就是一只满地爬的母王八, 咱们烟花巷中人, 靠的是卖笑吃饭, 自力更生, 你别听那些嫖客的甜言蜜语, 你别管他是员外公子, 还是油郞车夫, 全都是提了裤子不认人的主儿 有福之人不用忙, 无福之人跑断肠 统帅大军非同儿戏, 老臣是担心他这根嫩竹扁担, 挑不起这副重担啊 --有道是千军易得, 一将难求 话不在多, 说到点子上就行 嚼得菜根, 喝得稀粥, 这是成大业者必备的营养食品嘛, 明辉, 孔子怎么说的, 孔圣人饿饭于蔡, 肉食者, 鄙, 不得远谋 “肉食者鄙，未能远谋”, 肉食者：吃肉的人,引伸为有权位的人。这句话出自《曹刿论战》，位高禄厚的人目光短浅，不能作长远打算 赖三啊, 不就是把脑袋搁在案板上砍吗 你少跟我扯这些没油没盐的事儿 粉税骤减 您啊, 就是爱操心, 怪不得又老了不少, 留那么多钱干嘛, 不紧着吃不紧着喝, 一撑腿全没了, 阎王爷那儿不需要那么多好东西 --混帐, 你给我闭嘴, 我到这儿来不是听你胡说八道的 20250313190560.webp 尺蠖之躯, 一伸一屈 匹夫见辱，拔剑而起，挺身而斗，此不足为勇也。天下有大勇者，卒然临之而不惊，无故加之而不怒。此其所挟持者甚大，而其志甚远也。 出自宋代苏轼的《留侯论》 我看那赖四嘴上满口是国家, 可眼珠子出溜溜地乱转, 一副贼眉鼠眼的样子, 不像是什么爱国救国之人 --孟尝君的三千门客, 不乏鸡鸣狗盗之徒嘛 赖三, 外面加岗了没有, 这半夜三更的闯进个无名氏来, 让人砍了脑袋, 这可没处伸冤去 --您放心, 我给您加了三道岗 打过机锋, 不分伯仲 铸剑为犁 你说这个忽必烈也是, 你是饭不够吃还是觉不够睡, 你干嘛非要灭我们大宋, 你何苦这是 驾长车踏破贺兰山阙 我跟咱们皇上是一个脾气, 有书法练着, 有虫玩着, 有女人搂着, 这不就行了吗, 打什么仗呢, 这真是 20250314222305.webp 历史就是抓住机会, 纵观历史, 那就是一部机会史 难道真是世无英雄, 使竖子成名 大厦将倾, 独木难撑 多大岁数了, 还这么心浮气躁, 怎么跟只小公鸡似的 够了, 尔等老朽已经退出了历史舞台, 就不要再干涉朝政, 实话告诉你, 老了就是老了, 没人待见你们, 跟不上趟就是跟不上趟 老爷子, 祝你多活两天, 瞪大了你昏花的老眼, 看着我是怎么用虫经治国的, 不愿回去坐那儿歇会吧 相爷, 你们家老太爷, 背过气去了 你不是挺经折腾的吗, 这么两下子就玩完了, 老胳膊老腿的, 逞什么能, 真不经折腾 20250315235437.webp 我贾似道死了爹, 他个老棺材瓤子跟着激动什么 潘姑娘, 你这是 --老太爷不是今天出殡嘛, 我作为贾家没过门的儿媳妇, 当然应该送送了, 可我在官道上等了半天, 怎么没见到殡车过呢 相爷啊, 怕出事, 就叫了一辆车从小路上走了 --哎呀, 这该死的贾虫, 他怎么什么话都没跟我说呢, 我还傻等了半天, 准备卯足了劲儿哭呢 我就希望好好地玩, 好好地乐, 千万别对不起自己这一身臭皮囊 这男人一日不成家, 就一日不像是个正经人, 无着无落的 潘菜心的口头禅, 我掐死你 众卿想必知道, 朕从来就不是个残暴之人, 平生崇尚理学, 讲的是个忍字, 道的是个让字, 非到逼急眼了, 从未下过狠心啊 20250319201945.webp 死了张屠户, 就吃带毛猪了`,``,`html`,`反射`,`20240413004212-_java 一般用来解决Java 程序运行期间，对某个实例对象一无所知的情况下，如何调用该对象内部的方法问题 优点：动态代理（在不修改原来代码的情况下，通过代理对象对原对象的方法进行增强）、注解处理、框架 缺点：使用反射基本是解释执行，对程序执行速度有影响。 正因为反射不受类的访问权限限制，其安全性低，很大部分的java安全问题都是反射导致的。 相对于正常的对象的访问调用，反射因为存在类和方法的实例化过程，性能也相对较低 破坏java类封装性，类的信息隐藏性和边界被破坏 动态语言 是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。如Object-C、C#、JavaScript、PHP、Python、Erlang。 静态语言 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。 Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性 反射机制是Java实现动态语言的关键，也就是通过反射实现类的动态加载。 静态加载：编译时就加载相关的类，如果程序中不存在该类则编译报错，依赖性太强。 动态加载：运行时加载相关的类，即使程序中不存在该类，但如果运行时未使用到该类，也不会编译错误，依赖性较弱。 public static void main(String[] args) { Scanner sc = new Scanner(System.in); int key = sc.nextInt(); switch(key) { case 0: Cat cat = new Cat(); break; case 1: // 通过反射创建一个Dog 类对象，不提供代码，只是文字说明 break; } } 上面代码中，根据 key 的值选择创建 Cat/Dog 对象，但是在代码编译时，编译器会先检查程序中是否存在 Cat 类，如果没有，则会编译报错；编译器不会检查是否存在 Dog 类，因为 Dog 类是使用反射的方式创建的，所以即使程序中不存在 Dog 类，也不会编译报错，而是等到程序运行时，我们真正选择了 key = 1 后，才会去检查 Dog 类是否存在。 反射与封装 如果使用反射可以获取private字段的值，那么类的封装还有什么意义？ 答案是一般情况下，我们总是通过p.name来访问Person的name字段，编译器会根据public、protected和private这些访问权限修饰符决定是否允许访问字段，这样就达到了数据封装的目的。 而反射是一种非常规的用法，使用反射，首先代码非常繁琐；其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标对象任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。 如果 JVM 运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证 JVM 核心库的安全。 类的加载时机 创建该类或子类的对象会触发类加载。 访问类的静态成员变量时会触发类加载。 JVM虚拟机只会为静态变量分配一次内存，在加载类的过程中完成对静态变量的内存分配； 调用类的静态方法时会触发类加载。 对类或接口的静态字段执行读写操作（即执行getstatic、putstatic指令）；不过final修饰的静态字段的除外(已经赋值，String和基本类型，不包含包装类型)，它被初始化为一个编译时常量表达式 注意 ：操作静态字段时，只有直接定义这个字段的类才会被初始化；如通过其子类来操作父类中定义的静态字段，只会触发父类<clinit>的初始化而不是子类的初始化 使用java命令执行有主方法main的类，也会触发类的加载 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 类的加载过程 类的加载是由类加载器在程序运行期间动态进行的，一个类只会被加载一次,将类的字节码文件加载到内存中，过程包括加载、连接（验证、准备、解析）和初始化三个阶段。 在加载阶段，类加载器从文件系统,jar包,网络或其他来源加载类的字节码文件，并创建一个代表该类的Class对象。 在连接阶段，虚拟机将对类的字节码进行验证、准备和解析 验证：校验class字节流是否符合当前jvm规范 准备：为 类变量 分配内存并设置变量的初始值( 默认值 )。如果是final修饰的对象则是赋值声明值 解析：将常量池的符号引用替换为直接引用 在初始化阶段，虚拟机对类进行初始化，包括执行静态变量的赋值和静态代码块的执行。 类加载和实例化对象是两个不同的概念。实例化对象是根据类的定义创建一个类的实例。 实例化对象时，虚拟机会为对象分配内存，并调用类的构造方法进行初始化。 使用new关键字 使用Class类的newInstance方法 使用Constructor类的newInstance方法 使用clone方法 使用反序列化 public class Main { public static void main(String[] args) { if (args.length > 0) { create(args[0]); } } static void create(String name) { Person p = new Person(name); } } JVM在执行 Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载 当执行Main.java时，由于用到了Main类，因此，JVM 首先会把Main类对应的Class类对象Main.class加载到内存中。 然而，并不会加载Person.class，除非程序执行到create()方法，JVM 发现需要加载Person类时，才会首次加载Person类对应的Class类对象Person.class。 如果没有执行create()方法，那么Person.class根本就不会被加载。这就是 JVM动态加载class的特性。 ClassLoader类加载器 负责加载类的对象,通过Class对象的getClassLoader方法获得, 每个类都有一个类加载器 将类的字节码文件从硬盘中加载到内存，并以此在内存中创建一个Class对象。 类的字节码二进制数据，是存放在方法区的，又称为类的元数据（包括方法代码、变量名、方法名、访问权限等等） Class类对象 一个类加载完后，在堆内存中就会产生该类的唯一一个 Class 对象，这个Class 对象包含了该类的完整结构信息，包括类名、包名、父类、实现的接口、所有方法、字段等, 这种通过Class实例获取类class信息的方法称为反射 获取一个类的Class实例 public class ClassExample { public static void main(String[] args) { // 1. 通过类名直接获取 Class<String> stringClass = String.class; System.out.println("String class: " + stringClass.getName()); // 2. 通过对象获取 String str = "Hello"; Class<? extends String> strClass = str.getClass(); System.out.println("String object class: " + strClass.getName()); // 3. 通过类的完整类名获取 try { Class<?> clazz = Class.forName("java.lang.String"); System.out.println("Class.forName: " + clazz.getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } // 4. 通过基本数据类型获取 Class<Integer> intClass = int.class; System.out.println("int class: " + intClass.getName()); // 5. 通过基本数据类型的包装类获取 Class<Integer> type1 = Integer.TYPE; System.out.println("Integer.TYPE: " + type1.getName()); // 6. 基本数据类型和对应包装类获取到的Class对象是同一个 System.out.println(int.class == Integer.TYPE); // true System.out.println(char.class == Character.TYPE); // true System.out.println(boolean.class == Boolean.TYPE); // true } } 判断一个对象是否是某个类型时，正常情况下，使用instanceof操作符 如果是两个Class类对象，可以调用isAssignableFrom()方法, 判断一个类是否是另一个类的父类或接口 public static void main(String[] args) { String str = "Hello"; if (str instanceof String) { System.out.println("str is an instance of String"); } Class<?> numberClass = Number.class; Class<?> integerClass = Integer.class; if (numberClass.isAssignableFrom(integerClass)) { System.out.println("Number is assignable from Integer"); } } Constructor Constructor类对象只含有当前类定义的构造方法，和父类无关，因此不存在多态的问题 // 获取当前类中public的构造函数 Constructor getConstructor(Class<?>... parameterTypes) // 获取当前类中所有public的构造函数 Constructor[] getConstructors() // 获取某个Constructor，包括public、protected、default（package）和private Constructor getDeclaredConstructor(Class<?>... parameterTypes) // 获取所有Constructor，包括public、protected、default（package）和private Constructor[] getDeclaredConstructors() Person p = Person.class.newInstance() //类对象.newInstance()只能调用该类的public无参构造方法 Constructor cons1 = Integer.class.getConstructor(int.class); Integer n1 = (Integer) cons1.newInstance(123); System.out.println(n1); Constructor cons2 = Integer.class.getConstructor(String.class); Integer n2 = (Integer) cons2.newInstance("456"); System.out.println(n2); Constructor<T> constructor = MyClass.class.getConstructor(String.class, int.class); T object = constructor.newInstance("example", 42); Field // 获取某个public的field（包括父类的public field） Field getField(String name) // 获取所有public的field（包括父类的public field） Field[] getFields() // 获取当前类的某个field，包括public、protected、default（package）和private，不包括父类的field Field getDeclaredField(String name) // 获取当前类的所有field，包括public、protected、default（package）和private，不包括父类的field Field[] getDeclaredFields() public final class String { private final byte[] value; } Field f = String.class.getDeclaredField("value"); f.getName(); // "value" f.getType(); // class [B 表示byte[]类型 int m = f.getModifiers(); //获取修饰符 Modifier.isFinal(m); // true Modifier.isPublic(m); // false Modifier.isProtected(m); // false Modifier.isPrivate(m); // true Modifier.isStatic(m); // false public class Main { public static void main(String[] args) throws Exception { Person p = new Person("Xiao Ming"); Class c = p.getClass(); Field f = c.getDeclaredField("name");// 获取 private String name; f.setAccessible(true); Object value = f.get(p); System.out.println(value); // "Xiao Ming" f.set(p, "Xiao Hong");// 设置 p 的 name 的值 System.out.println(p.getName()); // "Xiao Hong" } } class Person { private String name; public Person(String name) { this.name = name; } } Method // 获取某个public的Method（包括父类的public method） Method getMethod(String name, Class<?>... parameterTypes) // 获取所有public的Method（包括父类的public method） Method[] getMethods() // 获取当前类的某个Method，包括public、protected、default（package）和private，不包括父类的method Method getDeclaredMethod(String name, Class<?>... parameterTypes) // 获取当前类的所有Method，包括public、protected、default（package）和private，不包括父类的method Method[] getDeclaredMethods() getName(): 返回方法的名称 getReturnType(): 返回方法的返回值类型，也是一个 Class 实例，例如：String.class； getParameterTypes(): 返回方法的参数类型，是一个 Class 数组，例如：{String.class, int.class}； getModifiers(): 返回方法的修饰符，它是一个 int，不同的 bit 表示不同的含义。 Class clz = Class.forName("com.ida.entity.Employee"); Constructor constructor = clz.getConstructor(int.class,String.class,Float.class,String.class); Employee employee = (Employee) constructor.newInstance(1001,"张三",5000f,"销售"); Field[] fields = clz.getDeclaredFields(); for (Field field : fields) { if (field.getModifiers() == 1) {//公有 Object o = field.get(employee); System.out.println(o); } else if (field.getModifiers() ==2) {//私有 String m = "get"+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1); Method method = clz.getMethod(m); Object o = method.invoke(employee); System.out.println(o); } } public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; System.out.println(stdClass.getMethod("getScore", String.class)); System.out.println(stdClass.getMethod("getName")); System.out.println(stdClass.getDeclaredMethod("getGrade", int.class)); //public int Student.getScore(java.lang.String) //public java.lang.String Person.getName() //private int Student.getGrade(int) } } class Student extends Person { public int getScore(String type) { return 99; } private int getGrade(int year) { return 1; } } class Person { public String getName() { return "Person"; } } public class Main { public static void main(String[] args) throws Exception { // String 对象: String s = "Hello world"; // 获取 String substring(int)方法，形参为 int: Method m = String.class.getMethod("substring", int.class); // 在 s 对象上调用该方法并获取结果: String r = (String) m.invoke(s, 6); // 打印调用结果: System.out.println(r); } } invoke() Object invoke(Object obj, Object... args) 如果底层方法是静态的，那么可以忽略指定的 obj 参数。该参数可以为 null 如果底层方法所需的形参数为 0，则所提供的 args 数组长度可以为 0 或 null 如果方法正常完成，则将该方法返回的值返回给调用者 如果该值为基本类型，则首先适当地将其包装在对象中。 如果该值的类型为一组基本类型，则数组元素不被包装在对象中,返回基本类型的数组 调用静态方法 如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。我们以Integer.parseInt(String)方法为例： public class Main { public static void main(String[] args) throws Exception { // 获取 Integer.parseInt(String) 方法，参数为 String: Method m = Integer.class.getMethod("parseInt", String.class); //Method methodMain = clazz.getMethod("main", String[].class)，main方法形参的类型String[].class // 调用该静态方法并获取结果: Integer n = (Integer) m.invoke(null, "12345"); // 打印调用结果: System.out.println(n);// 12345 } } 调用非 public方法 由于 Method 对象的 setAccessible(true) 调用是在运行时进行的，并不会在 ClassLoader 被销毁后自动恢复原来的访问权限。因此，即使 ClassLoader 被销毁，权限修改也会继续生效。 正确的做法是在使用 setAccessible(true) 修改访问权限后，执行完操作后再恢复原始状态，以避免潜在的安全问题 public class Main { public static void main(String[] args) throws Exception { Person p = new Person(); Method m = p.getClass().getDeclaredMethod("setName", String.class); boolean accessible = m.isAccessible(); // 保存当前的访问权限状态 m.setAccessible(true); // 设置为可访问 m.invoke(p, "Bob"); m.setAccessible(accessible); // 恢复原始的访问权限状态 System.out.println(p.name); // Bob } } class Person { String name; private void setName(String name) { this.name = name; } } 父类 Integer的父类类型是Number，Number的父类是Object，Object是祖先类 如果一个类没有显式地指定继承自哪个类，那么它默认继承自 Object 类 除了接口外，所有类都有父类 接口和类是不同的概念，虽然接口可以继承其他接口，但这并不等同于类的继承，但在继承的语境下，并不能说接口有父类这个说法。 public class Main { public static void main(String[] args) throws Exception { Class i = Integer.class; Class n = i.getSuperclass(); System.out.println(n); Class o = n.getSuperclass(); System.out.println(o); System.out.println(o.getSuperclass()); } } ------------------- class java.lang.Number class java.lang.Object null 接口 对接口调用 getSuperclass()总是返回 null，获取接口的父接口要用 getInterfaces() 如果一个类没有实现任何interface，那么getInterfaces()返回空数组 getInterfaces()方法只返回当前类直接实现的接口，不包括其父类实现的接口 public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class; Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } } } ----------------- java.lang.Comparable java.lang.constant.Constable java.lang.constant.ConstantDesc public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class.getSuperclass(); Class[] is = s.getInterfaces(); //class java.lang.Number的接口 for (Class i : is) { System.out.println(i); } } } ----------------- interface java.io.Serializable 绕过泛型检查 public class Main { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { List<Student>l=new ArrayList<>(); Class c=l.getClass(); Method m=c.getDeclaredMethod("add",Object.class); m.invoke(l,"字符串"); m.invoke(l,"不是Student却加入了容器"); System.out.println(l); } } 泛型运行在编译期间，检查你的源程序是否有语法错误，如果没有就将其翻译成字节码文件, 在编译后的.class文件中是没有泛型的。 像ArrayList这种能够存储所有类型的数据类型的容器，底层一般都是用Object实现。 如果使用反射就可以直接越过实例化这一步，先调用add方法，最后指定这个方法是附属于某个实例就可以了,这就是反射能够绕过泛型检查的原因 多态 public class Main { public static void main(String[] args) throws Exception { // 获取Person的 hello方法: Method h = Person.class.getMethod("hello"); // 对 Student实例调用 hello方法: h.invoke(new Student()); //输出 Student:hello } } class Person { public void hello() { System.out.println("Person:hello"); } } class Student extends Person { public void hello() { System.out.println("Student:hello"); } } 捕获被反射调用的方法内部抛出的异常 @Retention(RetentionPolicy.RUNTIME) @Repeatable(Annos.class) @interface Anno { int a() default 1; int b() default 0; int c() default 0; } @Retention(RetentionPolicy.RUNTIME) @interface Annos { Anno[] value(); } class Op { @Anno(b = 2, c = 3) @Anno(a = 0, b = 2, c = 4) private static void add(int a, int b, int c) { if (c != a + b) throw new ArithmeticException("error"); } } public class Demo { public static void main(String[] args) { for (Method m : Op.class.getDeclaredMethods()) { if (m.isAnnotationPresent(Annos.class)) { System.out.println(m.getName()); Anno[] annos = m.getAnnotationsByType(Anno.class); for (Anno anno : annos) { System.out.println(anno.a() + " " + anno.b() + " " + anno.c()); try { boolean accessible = m.isAccessible(); m.setAccessible(true); m.invoke(null, anno.a(), anno.b(), anno.c()); m.setAccessible(accessible); } catch (InvocationTargetException e) { //捕获被反射调用的方法内部抛出的异常 //要特别处理 InvocationTargetException，因为该异常会包装被调用方法抛出的任何异常。 //可以使用 InvocationTargetException.getCause() 来获取被调用方法内部抛出的异常,getCause() 方法返回的类型是 Throwable //如果明确知道被调用方法可能抛出的异常类型，并且想要进行特定的处理，可以先用 Throwable 接收，然后进行类型检查 Throwable cause = e.getCause(); if (cause instanceof ArithmeticException) { System.out.printf("Test [%s] failed: %s %n", m, cause.getMessage()); } else { System.out.printf("Test [%s] failed: %s %n", m, e); } } catch (Exception e) { System.out.printf("Test [%s] failed: %s %n", m, e); } } } } } } /* add 1 2 3 0 2 4 Test [private static void com.ida.temp.Op.add(int,int,int)] failed: error */ 应用例1 package com.ida.reflect.lang; public interface Lang {void say();} package com.ida.reflect.lang; public class Zh implements Lang{ @Override public void say() { System.out.println("你好"); } } package com.ida.reflect.lang; public class En implements Lang{ @Override public void say() { System.out.println("hello"); } } import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStreamReader; import java.net.URLDecoder; import java.util.Properties; public class Demo { public static void main(String[] args) { Properties properties = new Properties(); //language=Zh //#language=En try { //使用 ClassLoader.getResourceAsStream() 和 Class.getResource() 是两种常见的读取资源文件的方法 //ClassLoader.getResourceAsStream(String name)：返回一个 InputStream 对象，用于读取资源文件的内容。更适合直接读取资源文件的内容，比如读取配置文件、文本文件等。 //Class.getResource(String name)：返回一个 URL 对象，用于定位资源文件的位置。更适合获取资源文件的路径或对资源文件进行其他操作（如传递给其他 API ）。 //target/classes/com/ida/reflect/Demo.class //target/classes/config.properties //String path = Demo.class.getResource("../../../config.properties").getPath(); //getPath() 返回的路径可能会被编码，特别是当路径中包含特殊字符或空格时 //path = URLDecoder.decode(path,"UTF-8"); //properties.load(new FileInputStream(path)); ClassLoader classLoader = Demo.class.getClassLoader(); properties.load(new BufferedReader(new InputStreamReader(classLoader.getResourceAsStream("config.properties")))); //此处反射的作用体现在 //当新增了一种语言支持时,Demo2不用重新修改编译,只需将新语言类的.class文件上传到服务器同时修改配置文件即可 Class clz = Class.forName("com.ida.reflect.lang."+properties.getProperty("language")); Lang lang = (Lang) clz.newInstance(); lang.say(); } catch (Exception e) { throw new RuntimeException(e); } } } 应用例2 interface OP{ int operation(int x, int y);} class Add implements OP{ @Override public int operation(int x,int y) {return x+y;} } class Sub implements OP{ @Override public int operation(int x,int y) {return x-y;} } public class ReflectSample { @Test public void case1(){ Scanner scanner = new Scanner(System.in); System.out.println("第一个数"); int x = scanner.nextInt(); System.out.println("第二个数"); int y = scanner.nextInt(); System.out.println("操作类名"); String m = scanner.next(); OP op = null; if (m.equals("Add")) {//在不修改方法的情况下只能操作Add op = new Add(); } int result = op.operation(x, y); System.out.println(result); } @Test public void case2(){ Scanner scanner = new Scanner(System.in); System.out.println("第一个数"); int x = scanner.nextInt(); System.out.println("第二个数"); int y = scanner.nextInt(); System.out.println("操作类名"); String m = scanner.next(); OP op = null; try { ClassLoader classLoader = getClass().getClassLoader(); Class cls = classLoader.loadClass("com.ida.reflect."+m);//在不修改方法的情况下可以OP子类,Add和Sub op = (OP) cls.newInstance(); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) { throw new RuntimeException(e); } int result = op.operation(x,y); System.out.println(result); } }`,``,`html`,`反斗神鹰`,`20240307183503-影摘 20231203100344.webp 20231203100353.webp 20231203100357.webp “我没法走路，他们把我的鞋带绑在了一起……” “还打了死结……真混蛋。`,``,`html`,`古时幽默`,`20240307183503-碎片 石学士 	 学士石曼卿好酒善诗，谈吐幽默。一次，出游报宁寺，马夫疏忽，马受惊跃起，石学士被摔下马来。随从慌忙将他扶起。许多看热闹的人以为他定要大骂马夫了。不料他只是指了指马夫说：“亏得我是石学士，要是瓦学士，还不是摔得粉碎？” 风流骸骨 王辅云字勾，人长得很瘦但穿着讲究，朋友戏称他“风流骸骨”。 北宁崇宁癸未年，在金陵府召集所有官府婢女，有一位也长得精瘦，府尹朱世昌见后，对旁边的人说：“你认识这‘生色骷髅’吗？” 旁人说：“认得。这人雅号正可与王勾相对。” 雪诗解闷 宋哲宗到晚年时易发怒，侍奉者想不出办法让他高兴，只得向往来的各国使臣要诗，献给哲宗解闷。一天大雪，又去问人家有什么新作，一个使臣刚刚吟得两句诗：“谁把鹅毛满天帚，玉皇大帝贩私盐。”就急献哲宗。 皇帝一看，果然哈哈大笑。 面似猿猴 刘文树口才很好，只是貌似猿猴。一次。唐明皇开玩笑，令黄幡绰嘲讽他。刘文树最忌恨别人叫他猿猴，就暗里对幡绰说，不要讲他面似猿猴。 幡绰答应，对皇上进语说：“文树面孔不似猢孙，猢孙面孔酷似文树。”皇帝大笑。 请酒不醉 刘伶的妻子常为丈夫贪酒而害苦，一次．就跟刘伶的小妾商量好，要谋害刘冷，于是，酿好了一大缸酒。 酒还未完全酿好，刘伶已急得不断向妻子讨酒吃，妻子说：“等到酒酿成后，一定让你吃个醉。”等酒熟后，就把刘伶喊来大喝，待半醉之时，刘伶的妻、妾合力把他推到大酒缸中，用盖子盖好，再用很大的木头压住缸盖。心想：这样一定要淹死在酒缸中了。 过了三天，听听缸中一点声音也没有，妻子想，一定已经死了，就打开缸来，一看大惊，只见一缸酒已干，刘伶喝得大醉，坐于酒糟之上。 过了许久，刘伶酒醒，抬起头来说：”你不是答应我吃个醉么，如今让我在此闲坐干什么？” 杀生妙计 有个行善者，从不肯杀生，就是扫地也要避开蚂蚁，有一回在河边捉到一只甲鱼，听说甲鱼味很鲜美，就想吃它可又不忍自己杀生。想来想去， 终于想出个两全其美之计。大善人烧好一锅开水，在锅上架了一根细竹竿。然后一本正经地说：“可爱的甲鱼，人们都说你会爬竿，比猴子还灵巧，就让我开开眼界吧。如 果爬过去，我就放你。” 甲鱼明知善人要杀害它，但仍抱着一线希望，因此抖擞精神，使出全身解数，小心地爬了过去。这一来，出乎大善人所料，他急忙改口说：“果然名不虚传！只是我刚才没看清，请你再来一回吧！” 吃冷茶去 强渊明任命挂帅长安，跟蔡太师告辞。蔡公戏说道：“君要吃冷茶去了。”强渊明一点也不理解，但又怕见笑，不敢随便问。后来，去问熟知长安风物的亲友。亲友笑着道：“长安的女子，步子极小，行走相当慢。所以蔡公用吃冷茶相戏。” 泛舟彭蠡 郁离子跟客人一起在彭蠡泽中划船游玩，红日高照，绿波荡漾，游鱼戏水，气象开阔。船儿随意划行。客人高兴地说：“划船乐趣无穷，我如能依托这山光水色度此一生，也就心满意足了。” 不久，乌云堆积，大风陡起，白浪滔天。小船颠簸。那客人东倒西歪，站立不稳，低头呕吐，魂飞魄散，脸如死灰，他有气无力他说：“咱们快离开这里吧！我一辈子不敢再来啦！” 出头被捉 黄雀、蚊子、酒虫相会，各吹自己的本领。 黄雀说：“六月新凉，五谷登场。主人没吃，我已先尝。” 酒虫笑道：“王孙一弹打来，看你还得意洋洋？” 黄雀说：“古人早就说了：‘人为财死，鸟为食亡。’” 蚊子说：“幽闺深院度春风，黄昏寂寂没人踪，红罗帐里佳人睡，被我偷来一点红。” 鳖听了风流之事，就爬上岸问：“佳人睡觉，一掌打下，看你怎么办？” 蚊子说：“见此好风光，死也值得。” 酒虫说：“酒熟我先尝，良朋千万聚；沉醉倒金樽，才子扶我起。” 鳖说：“才子不扶起，可不要浸杀你！”酒虫说：“荷钟曾捉月，姓名千古说。” 过路人听见就来查看，雀、蚊、酒虫连忙飞去，鳖被捉住，叹道：“是非只为多开口，烦恼皆因强出头。” 劳心劳力 后魏高祖给儿子起名为询、愉、悦、怪。大臣崔光给儿子起名为励、勖、勉。 高祖对崔光说：“我儿名旁皆有心，哪儿名旁皆有力。” 崔光笑道：“这就是所说的：“君子劳心，小人劳力啊！” 话中有话 宋太祖曾当面许诺要封张融为司徒长史，但文件一直未了。 一天，张融乘骑一匹瘦马，宋太祖见了，问：“你的马为何这样瘦，每日喂粟多少？” 张融答：“一石。” 皇帝问：“喂这么多为何还如此瘦？” 张融说：“臣许诺给一石，但并没有给。” 宋太祖知他话中有话，第二天就发文任命他为司徒长史。 出卖考题 明朝弘治年间，程敏政出任礼部主考。他接受贿赂，出卖考题，引朝野公愤。 一天，明孝宗在内庭设御宴招待群臣，演员们针对程敏政表演了一出即兴小戏：一人捧着一盘猪蹄子，边走边叫：“卖蹄啊。”有人问他价钱， 卖主答道，“一个1000两银子。”问价人说：“怎么这么贵？”答：“都是熟蹄。” 大臣们听到这里，都会意地哄堂大笑：原来，“熟蹿”是“热题”的谐音。 生得太晚 卢公晚年死了妻子，又续娶女子祝氏。祝氏年轻美貌，由于与丈夫年纪相差较大，心情抑郁，终日皱眉。 卢公见了便问：“你莫非怨我年纪太大？”祝氏说不是。卢公说：“要么恨我官职太低？”祝氏又说不是。卢公说：“那么为啥不痛快？” 祝氏答道：“不恨卢郎年纪大，不恨卢郎官职低，只恨我身生太晚，不见卢郎少年时。” 为国爱命 戎夷背叛齐国逃到鲁国去，正巧碰上大冷天，鲁国城门又关闭了，只得同弟子在城外露宿。深夜寒气贬骨，戎夷对弟子说：“你把衣服脱给我穿，我就能不被冻死；我把衣服脱给你穿，你也能活命。我是国家的人才，为了天下民众我要爱惜自己的生命，你是不肖的小人，不必爱惜自己的身躯，你还是把衣服脱给我穿吧。”弟子答道：“我是不肖小人，怎能有高尚的品格，肯将衣服脱给你这个国家的人才穿呢?”戎夷长叹一声：“唉!我的社会理想看来实现不了啦！”说完，将衣服脱下送给弟子，半夜活活冻死，弟子却活了下来。 为人献身 孟尝君对门客夏候章待遇很好，给他四、五百人的伙食费。可是夏候章还常常在背后毁谤孟尝君。有人向孟尝君揭发，孟尝君说：“我常有事请教夏公的，不要说他。”蘩菁就把此话转告夏候章，夏说：“我没有一点小功劳，孟尝君就成了宽厚待人的君子、长者，而我就成了刻薄忘恩的小人、无赖，我这是用自己的人格和名誉为孟尝君效劳啊，你还要我说什么呢?” 钝槌利锥 晋时，祖士言常与钟雅嘲嘻。一天，钟雅道：“我汝颖之士利如锥，卿燕代之士印如槌。” 祖士言说：“用我的钝槌，打你的利锥。” 钟说：“这是神锥，不能打到。” 祖说：“既有神锥，也有神槌。” 钟雅无语可再辩。 狗枷犊鼻 王义恭癖爱古物，到处向朝中的官员求讨。侍中（官名，略低于宰相）何已送给他过，但王义恭还是向他要个不休，何被搅得很不高兴。一次何出行，看到丢弃在路上的狗戴的项圈和破的围裙，就命手下人捡了回去，用箱子装好后送给王义恭，附信说：“承蒙你一再要古物，现奉上李斯（秦时宰相）狗枷，相如（战国时赵国上卿）犊鼻。… 墨池皮棚 王僧彦的父亲名师古，他常常喜好给某物起个别称，比如把“砚”称为“墨池”，“鼓”说成“皮棚”。师古镇守岭南郡时，有个叫李彦古（“彦古”与“砚鼓”音近）的路过该郡，拜见师古时，就故意戏耍师古说：“永州司户参军李墨池皮棚等候参拜。” 泰山之力 唐玄宗李隆基委派中书令张说为“封禅使”，带领人马到泰山筑坛辟基，举行祭祀天地的大典。根据唐代惯例，祭把好天地后，自太尉、司徒、司空以下文武百官，一律晋升一级。 张说的女婿郑镒原是个九品官，依靠丈人势力，一下晋升为五品官，红袍加身，威风凛凛。宴会上，李隆基见郑镒猛升到五品官，很诧异，便问他是怎么升上来的。郑镒心虚，半天也答不上来。 艺人黄幡绰对李隆基说：“此乃泰山之力也。”此后“泰山”便成了丈人的代名词。又因泰山是五岳之一，所以人们将丈人叫“岳父”。 美女丑夫 宋徽宗宣和年间，毗陵有个成郎中，满脸胡须其貌不扬。岳母对他说：“我女美如菩萨，却嫁了你这个麻胡。”命成郎中以此为题写诗。 成郎中作打油诗：“一床两好世间无，好女如何得好夫？高卷朱帘明点烛，试教菩萨看麻胡。” 丈夫变羊 有个读书人的妻子特别凶狠，对丈夫动不动就咒骂、抽打。丈夫在家时，就用长绳拴在丈夫的脚上，她一拉绳子，丈夫就必须马上走到她跟前听候吩咐。丈夫实在受不了，就去找巫婆替他想办法。 一天，趁妇人睡觉时，丈夫按巫婆教的，把脚上的绳子拴在羊脖子上。然后躲起来。妇人醒后，一牵绳子，走来的却是一只羊，她吓坏了，立刻请巫婆来问。 巫婆说：“只因为你作恶大多，祖宗责怪下来，把你丈夫变成了羊。如果你愿意悔改，我可帮你解救。” 妇人抱羊大哭，发誓不再虐待丈夫。巫婆便让她请斋7日，全家回避，然后，煞有介事地念起咒来。她丈夫趁机偷偷溜回来。 妇人见丈夫回来，便问道：“你变成羊那么几天，辛苦不辛苦啊？” 丈夫说：“只记得干草不好吃，现在肚子还疼哩！”妇人更加伤心，从此再也不虐待丈夫了。 丞相草书 张丞相喜欢写草体字，但又写得不合体统，别人讥笑他，丞相却不以为然。一天，他突然想到了名句，便要来纸墨奋笔疾书，满纸的草字龙飞凤舞。过后让他的侄儿把诗句抄录下来，抄至笔划怪异之处，侄儿看不出，就捧着稿子去询问他。张丞相仔细辨认了很久，连自己也不认识，就责骂侄儿说：“你为什么不早些来问？以致使我忘记了。” 细布包柑 唐朝时，盖州每年向朝廷进贡柑子，都是用纸包着的。后来，长吏认为这样做显得不够敬重，就改用布包柑，过后，又常常担心细布是否会磨损坏柑子。 不久，有个叫甘子布的御史来盖州，长吏以为是来追究用布包柑子的事，十分惊慌，说：“果然被追究了！” 等到甘子布到达驿站，长吏出迎时就一直反反复复他讲述用布包柑子是表示敬重。甘子布起初不明白他为什么老是解释这个问题，听多了才省悟到是跟自己的名字有关系。旁边听讲的人都大笑不已。 神仙大足 女皇武则天爱“吉兆”，喜好话。 有年，被关在大理寺里的300多个犯人，唯恐秋分过后受大刑，便用计在监狱的围墙角边，假做一个足有5尺长的大脚印。待半夜时分，一齐叫喊起来。宫内侍卫追问下来，犯人们说：“昨夜有神仙出现，高3丈余， 满面金光，对我们说：‘你们都是冤枉，不要害怕。当今皇帝能活万年，准对你们开恩，赦放你们。’” 侍卫们听后，再看地上，果然见有个巨大脚印。回宫后即报武则天，女皇当即下旨大赦天下，为纪念神仙的“大脚印”，改年号为“大足元年”。 仿吹火诗 某人看到邻居有户人家的夫妇关系很和谐，丈夫从外面回来，正好见妻子在吹火烧灶，就作一诗，赠给妻子说：“吹火朱唇动，添薪玉腕斜。遥看烟里面，恰似雾中花。” 邻居家的男子回到家，妻子告诉他说：“邻家夫妇感情很好，刚才又见丈夫作诗称赞妻子，您难道就不能学学吗？” 丈夫说：“那诗怎么说。”妻子就照着念了一遍。 丈夫对妻子说：“您也吹火，我也做首诗来赠给你。”妻子开始照着邻 妇吹起火来，丈夫作诗道：“吹火青春唇动，添薪黑腕斜。遥看烟里面，恰似鸠盘茶（恶鬼名）。 先见之明 一次，蔡京请张进士教孙子读书。 张进士布馆后，既不教读书，又不教写文章，只是教孩子们学跑步。 起初孩子们贪玩还照着去做，可几天下来就不耐烦了，便向老师请求学功课。 张进士摇头说：“不必了，还是继续练跑步吧！” 孩子们问：“为什么？” 张进士说：“你的祖父、父亲都是又奸诈，又骄奢，把老百姓害苦了， 百姓总有一天要找他们来算账。你们是孩子，没有过错，要是跑得快，也许还能保住性命。此外，可没有别的办法了。” 夫人裙带 蔡卞的妻子六夫人是王安石的女儿。她知识广博，蔡卞每逢遇有政务要事，总是隔夜预先在床上跟她商量妥当，然后在朝廷上宣布执行。当时执政官僚们都说：“我等每天奉命办事，都是她咳吐的余液啊。” 蔡卞被拜为丞相后，大摆家宴庆贺，戏子们唱曲道：“右丞相今天大拜，都是夫人裙带啊（讽谕夫人参政）。”一时中外将此事传为笑柄。 春秋笔法 有个专攻《春秋》的读书人陈生，同宋门一个妓女亲近厮混。 一天，他俩又在曹门幽会，陈生一时兴起，仿照《春秋》简练笔法在墙上题写文章：“春正月，会吴姬（吴地的女子）于宋。夏四月，复会于曹。”。 有人见了，就在下面续写道：“秋饥；冬大雪，公薨（死）。”游客见了大笑。 帝怕妒妇 房玄龄的夫人生性妒忌、泼辣，房玄龄很怕老婆，不敢再讨小老婆。 太宗命令皇后召见房夫人，告诉她：大臣迎娶媵妾（小老婆）都有制度，皇帝将把美女赏赐给房玄龄。房夫人坚决不同意。 太宗便派人斟满一杯酒恐吓她：“你这是违抗圣旨，应该喝完这杯毒酒。” 房夫人举起酒杯就喝得点滴不剩。太宗叹息道：“这样刚烈妒忌的女人，我见了都有些怕，何况玄龄呢？” 竹笋炒肉 曾经有人抄录东坡诗句：“无肉令人瘦，无竹叫人俗。”后续两句：“若教不瘦又不俗，顿顿有碗笋炒肉。” 瓜贩作诗 有个叫顾骑龙的，相貌长得很丑陋，可性格温和，喜好读书，哪怕是缺损书角的书，也宝贝得像玉璧似的。他喜欢写诗，往往随口说出就极有味道。 一次，他贩西瓜卖，有人用《卖瓜》作题目考他，谁知他应声吟咏道：“郎君今日卖西瓜，西瓜只只都不差。包拍大红兼蜜练，竹炉不用再煎茶。” 人们听了赞叹不已，顾骑龙兴致更高，把他的近作也朗声读了出来：“佳人独宿千千万，才子孤眠万万千；老天若肯行方便，两处牵来一处眠。”人们不禁大笑。 判牛断鹅 两农家养水牛。一次，牛角斗起来，一牛触死，告到官府，县官判说：“两牛相触，一死一生；死者同食，生者同耕。” 又有一养鹅者，鹅吃了邻居所晒的稻谷被打死，鹅主告邻居。官断案道：“鹅嘴如梭，吃谷不多；鹅主偿谷，谷主赔鹅。” 误行酒令 席间行酒令，某人先出一令：“春雨如膏”。 另一人疑“膏”为“糕”，说：“夏雨如馒头。”第三个误把“夏雨”当“夏禹”， 说：“周文王像大饼。” 双斧劈柴 某人因酒色过度而病。医生关照他说：“你若再如此，就如双斧劈柴，会很快完的。” 这人的妻子在一旁听后斜瞪了医生一眼，医生看出了她的不满，即改口说：“即使不能戒色，亦须戒酒，这酒最伤人。” 病者说：“色害甚于酒害，还是应该首先戒掉色害。”妻子止住丈夫道：“先生的话不听，如何能使病好起来？” 宝家三井 有人把婚事比作宝家三井，说：“人想娶妻而未得时，叫寻河觅井；结婚而料理繁忙的家事，叫担雪填井；等到孩儿长大，男婚女嫁之时，财礼嫁奁，种种操办，事势迫促，叫做投河奔井。 定不出来 某人怕老婆，一日被妻子打，无奈只得钻到床下。妻子在床前喝道：“快快出来！” 丈夫觉得床下安全，嘴硬起来，说：“男子汉大丈夫，说不出来，定不出来。” 总占便宜 小镇上有个尖尖钻式的人，别人不管有啥东西，只要让他看到，他都要想法沾便宜。知道他这种品行的人，只要手里拿着物件，都绕道避过他家。一天，有人拿着一块砂石走过他家门口，心想：“这东西他总沾不到便宜了吧！”谁知竟给“尖尖钻”拉到家里，从厨房拿出菜刀，在砂石上狠狠磨了几下，然后推开他说：“好了，你可以走了。” 棉被太热 有个人在大热天还盖着夹被睡觉，别人问他为什么盖夹被，他说：“因为棉被太热了。” 讨好遭打 唐朝有个刺史穆宁，高高在上，作威作福，还要几个做官的儿子轮流供养他，稍有半点 不称心，就要责骂他们。 一次，一个儿子将熊油与鹿肉煮成菜肴孝敬他，穆宁觉得味道鲜美，吃得十分开心。其他几个儿子以为父亲定会大大夸奖，心里很羡慕。 谁知穆宁吃饱后，反把儿子揍了一顿，骂道：“哼，这么好的东西，为啥直到现在才弄给我吃？” 逸马杀犬 欧阳修在翰林院时，常常与同院他人出游。一次，见有匹飞驰的马踩死了一只狗。欧阳修说：“你们说一下这事。” 一人说：“有犬卧于通衢，逸马蹄而杀之。” 另一人说：“有犬卧于通衢，卧犬遭之而毙。” 欧阳修笑说：“像你们这样修史，一万卷也写不完。” 那二人说：“那你说呢？” 欧阳修道：“逸马杀犬于道。”那二人脸红地相互笑了起来。 报以战栗 梁时，萧琛有辩才，梁武帝未称帝时与他交情很好。某日，武帝请宴，萧琛醉倒，梁武帝用枣投萧琛，萧琛便取了颗栗子掷武帝，正击中面部，武帝有些光火，萧琛便解释说：“陛下投臣以赤心，臣不敢报以战栗吗？” 嫂赠趣诗 一个女人新出嫁，遭到小姑的欺侮。她便写了首诗给小姑：“小姑休把嫂来欺，阿嫂曾经做女儿。前船便是后船样，小姑也有嫁人时。”小姑读诗后满面羞惭。 僧人不语 有个僧人号“不语禅”，见识甚少，平日全凭二侍者代他答问。 一日，侍者外出，碰巧有个游方和尚来参拜并请教。问：“不语禅，何为佛？”不语禅哪里能答，一会儿东看看，一会儿西看看。又问：“何为法？” 不语禅不语，看上看下。又问：“何为僧？”不语禅无奈，就闭眼不答。再问：“何为加持？”不语禅急得伸出两手来了。 游僧满意地走了，路遇侍者，就告诉他们说：“我去见过长老了，问他佛，禅师东顾西顾，意思是人有东西，佛无南北也；我问法，禅师看上看下，意思为法平等，没有高下；我问僧，他闭上眼睛，告诉我：向云深 处卧，便是一高僧；再问加持，他伸手出来，意谓接引众生。这大师真可称是明心见性啊！” 侍者回到寺庙，不语禅大骂道：“你们哪里去了？也不来帮我。他问佛，教我东看你不见，西看你又不见；他又问法，教我上天无路入地无门；他又问僧，我无奈，只好作假睡；他又问加持，我自愧诸事不知，还做什么长老，不如伸手沿门去叫化也罢了。” 嘲发酒疯 一只老鼠躲在油房里，一只老鼠藏在酒房里，二鼠经常来去，互食所有。 某次，酒鼠吃完油，就邀请油鼠到酒房吃酒，并以口衔其尾，垂吊着偷吃。油鼠吃得很快乐，连连对酒鼠说：“好酒！好酒！” 酒鼠客气，应声回道：“不敢！不敢！”哪知刚一开口，油鼠就跌入酒缸内了，翻滚多时爬不起。 酒鼠长叹一声，说：“你少饮些不就得么，如何要吃到这般发酒疯！” 妻子变妾 有个女人妒忌而聪明，丈夫每次谈到要讨小妾她就说： “你家境贫穷，哪来的钱买小妾呢？如果你有钱，我就答应。” 不久，丈夫便从别人那儿借到了钱，回家告诉妻子说： “钱在这儿，请允许我讨小妾。” 妻子夺过钱藏入自己衣袖里，下拜道：“我今天情愿做小妾，这钱就算买下了我吧。” 笑话太淡 广西全州有个叫王椽的幕僚擅长说笑话。 一天，武官们聚会，怂恿王椽说笑，又故意贬低他，动不动就评价道：“这话太淡。” 意思是没趣味。 王椽便说：“今早我在城门看到一个挑粪的人，不小心失脚，一担粪泼了一地。” 武官们说：“这也淡。” 王椽说：“你们都没尝过，怎么知道淡？”众人大笑。 打是不打 宋朝临安（今杭州）有个叫丘浚的下级官吏，一天，去拜见一位叫释珊的和尚。和尚见他官职小，只是爱理不理地敷衍了几句。过了一会儿，有个将军的公子来到，和尚赶紧出庭 迎接，表现得十分殷勤。 丘浚十分气愤。耐着性子等那位公子走后，便责问和尚道：“你接待我时那样傲慢，可见了将军公子，怎么这样谦恭呢？” 和尚滑头地说：“你呀，不知道我的脾气，凡是我恭敬的就是不恭敬，不恭敬的才是真恭敬。” 丘浚脸都气得胀紫了，举起拐杖照着和尚的秃头猛敲了几下，说：“和尚你不要见怪，你不知道我的脾气，打你就是没打你，没打你才是真打你！” 冬天没裤 大雪天，老和尚穿着皮袍，骑马要出门。寺里的烧火和尚没有裤子穿，冻得舌头也僵了，他问道：“老师父，这样冷的天，你还到哪里去？” 老和尚讲说学去，烧火和尚也要去听讲。老和尚骂道：“胡说，你懂得什么？” 烧火和尚指指自己腰下说：“我要听听你讲的佛书，人在寒冬腊月里该不该有裤子穿？” 补针鼻子 有个人走在路上，肚子饿了，便到人家去骗饭吃，他说：“我能把破了的针鼻子修补好。可是，要吃了饭才能补。” 主人立即盛饭给他吃。之后，找出许多破鼻子针让他补．这人吃饱饭，便慢悠悠地说：“把那半边的针鼻子再找出来吧。” 十七字诗 正德年间徽郡天旱，太守祈雨，但几天后仍是晴空万里。有人作十六字诗讽嘲：“太守出祷雨，万民皆喜悦；昨夜推窗看，见月。”太守命令将那人捉来，重打十八大板后说：“你能再作十六字诗就饶恕你，否则要用大刑。” 那人应声道：“作诗十六字，被责一十八；若上万言书，打杀。”太守只得将他释放。`,``,`html`,`君子协定`,`20240307183503-影摘 你的努力会被否定的,依我们的经验,有臭味的东西,加上盖子是最好的办法 她和你是水和油`,``,`html`,`喜气洋洋猪八戒`,`20241018212724-影摘 20241018212740.webp 20241018212741.webp 20241018212742.webp`,``,`html`,`四季之人`,`20240307183503-影摘 没有什么是基于友谊而说的 当一个人发誓言的时候,他就像把自己捧在手心,像捧着水一样,如果他分开手指,他就再也无法找回自己了`,``,`html`,`圆月弯刀1997`,`20240307183503-影摘 两年，我只有两年的时间`,``,`html`,`基本运算`,`20240616183123-_java 数字类型 int octal = 037; //int类型变量存放八进制数 long longNumber = 0xa2cdf3ffL; //长整型变量存放十六进制数 double d = 47e47 //指数记数4.7E48 float f = 1.39e-43f //1.39E-43 float和double转化为int时,总是对该数字截尾,如需舍入需调用Math.round() 默认值 基本数据类型： byte: 0 short: 0 int: 0 long: 0L float: 0.0f double: 0.0d char: '\u0000' (空字符) boolean: false 引用类型： null 原码 符号位加上真值的绝对值 [+1]原= 0000 0001 [-1]原= 1000 0001 有符号的8位二进制数的取值范围(第一位不表示值，只表示正负)为[1111 1111 , 0111 1111],即[-127 , 127] 反码 正数的反码是其本身 负数的反码是在其原码的基础上，符号位不变，其余各个位取反。 [+1] = [0000 0001]原= [0000 0001]反 [-1] = [1000 0001]原= [1111 1110]反 补码 正数的补码就是其本身 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1) [+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补 [-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补 机器数 无符号的二进制8位范围从00000000－11111111，即0到255 一位16进制数最多只表示到15（16进制的F,2进制的1111），要表示到255，就还需要第二位 一个数在计算机中的二进制表示形式,叫做这个数的机器数,机器数是带符号的,最高位存放符号,正0负1 计算机字长为8位时,十进制转机器数 +3 为 0000 0011, 真值为 +000 0011 -3 为 1000 0011, 真值为 -000 0011, 真正数值是-3,而非形式值131(1000 0011l转十进制为131) 对于一个数，计算机要使用一定的编码方式进行存储，原码、反码、补码是机器存储一个具体数字的编码方式 计算机可以有三种编码方式表示一个数 对于正数因为三种编码方式结果都相同 [+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补 对于负数原码反码和补码是完全不同的 [-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补 原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？ 因为人可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。 但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单，计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂 于是人们想出了将符号位也参与运算的方法。 我们知道，根据运算法则减去一个正数等于加上一个负数，即：1-1 = 1 + (-1) = 0， 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。 于是人们开始探索将符号位参与运算，并且只保留加法的方法。 计算十进制的表达式： 1 - 1 = 0 如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。 1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原 = [1000 0010]原 = -2 为了解决原码做减法的问题， 出现了反码： 1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原 = [0000 0001]反+ [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 用反码计算减法，结果的真值部分是正确的。 而唯一的问题其实就出现在"0"这个特殊的数值上 虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。 于是补码的出现，解决了0的符号问题以及0的两个编码问题： 1-1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原 = [0000 0001]补+ [1111 1111]补 = [1 0000 0000]补 = [0000 0000]补 = [0000 0000]原 注意：进位1不在计算机字长里。 这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。 而且可以用[1000 0000]表示-128：-128的由来如下： (-1) + (-127) = [1000 0001]原+ [1111 1111]原 = [1111 1111]补+ [1000 0001]补 = [1000 0000]补 -1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补就是-128， 但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。 (对-128的补码表示[1000 0000]补，算出来的原码是[0000 0000]原，这是不正确的) 使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。 这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。 由于0的特殊情况，没有办法表示128，所以补码的取值范围是[-128, 127] 因为机器使用补码，所以对于编程中常用到的有符号的32位int类型，可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。 取反 对n(正数负数和零均适用)按位取反,得到的结果为 -(n+1) ~10 原码 0000 1010 补码 0000 1010 取反 1111 0101 由于符号位是1，系统认为这是一个负数的补码 负数输出时，先将补码减一得1111 0100，再取反得1000 1011 结果为-11 ~（-5） 原码 1000 0101 补码 1111 1011 取反 0000 0100 由于符号位是0，系统认为这是一个正数的补码 正数补码即原码，最终输出0000 0100 结果为4 使一个数的最低位为零，可以表示为：n&~1。 ~1的值为1111111111111110，再按“与”运算，最低位一定为0。 因为“~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 除法 13/5=2 //分子分母均为整数时,结果为整除后的结果 13.0/5=2.6 3*0.1 == 0.3 //false 浮点数不能完全精确的表示出来. 由于小数的运算可能导致精度丢失问题，那么要解决这个问题，可以将其转换为整数后再进行运算，运算后再转换为对应的小数 int a = (int) (3 * 0.1 * 1000); int b = (int) (0.3 * 1000); System.out.println(a == b);// true 移位 << 左移位,低位补0 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。12<<1为24 >> 有符号右移,若符号为正,则高位插入0,负插入1 操作数每右移一位，相当于该数除以2。12>>1为6 >>> 无符号右移,无论正负,都在高位插入0 int型的移位右操作数介于0~31，任何int数移32位还是本身。 long型的移位右操作数介于0~63，任何long数移64位还是本身。 对于char,byte,short类型的数值在移位前会被转为int类型, 并且得到的结果也是一个int类型的值 若对一个long类型值进行处理,最后得到的结果也是long <<=,>>=,>>>=,与等号联用,操作符左边的值会移动由右边的值指定的位数,再将得到的结果赋给左边的变量 int n = 2;n<<=3; //n=16 在进行无符号右移位结合赋值操作时,会遇到如果对byte,short值进行这样的移位运算,得到的可能不是正确的结果, 它们会先被转成int,再进行右移操作,然后被截断,赋值给原来的类型 7*8可写为 7<<3; 2的3次方为8 5*16可写为 5<<4; 2的4次方为16 等号 +=操作符会进行隐式自动类型转换,会对右边的表达式结果强转匹配左边的数据类型 &=,|=,^=都是合法的,~(取反)由于是一元操作符所以不可与=联用 浮点数与整数进行比较(5.0f和5),只要值相等就返回true 具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。`,``,`html`,`外国幽默`,`20240307183503-碎片 我要让她发疯 福林德斯夫人决定让人给她画肖像。她告诉那位肖像画家说：“画 我带着钻石耳环、钻石项链、祖母绿手镯，还有红宝石垂饰。” “但你现在没带这其中的任何一样饰品。” “我知道。”福林德斯夫人说，“万一我先我丈夫死去，我肯定他 会立刻再婚。我要让那个女人为寻找这些珠宝而发疯。” 青蛙的电话 青蛙拨打通灵热线。电话中说：“你将遇到一位美丽的年轻女子， 她要了解你的一切。” 青蛙说：“这太棒了！我会在舞会上遇见她，还是——？” “不，”通灵者说，“是在下个学期她的生物课上。” 精神病院 某精神病院新来护士一名，此女初来乍到，见院中有一病人围着 一口古井打转，口中念着：＂13,13,......＂ 小护士心中颇为奇怪， 想不出这个"13"是何含义，连续观察几日，均是如此。她总想上前问 个究竟，但害怕病人发作，始终不敢。 　　一日，小护士终于安捺不住好奇心，慢慢的走到那个病人身边， 探头向井中观望。突然那个病人报住护士的双腿，向上一掀，把她扔 进了井里，随后在井旁边跑边念：＂14,14,14,......" 我要出去 在凌晨两点，酒吧店主锁了店门，回家睡觉。他刚躺下几分钟，这 时电话响了。“你早上几点营业？”他听到一位明显已醉醺醺的男子的 声音。 店主非常气愤，砰地一声挂上电话又上床去睡。几分钟后又有一个 电话，他听到还是那个声音问同样的问题。“听着，”店主嚷道，“不 要问我什么时候营业，因为我不会让你这种人进——” “我不是想进来，”那人打断他的话，“我要出去。” 鸟窝与头发 我姐姐是一位小学老师。一次一个学生告诉她说一只鸟儿在教室外 的树上垒了个窝。 “是什么鸟呢？”我姐姐问她。 “我没看到鸟儿，老师，只看到鸟窝。”那孩子回答说。 “那么，你能给我们描述一下这个鸟巢吗？”我姐姐鼓励她道。 “哦，老师，就像你的头发一样。” 咖啡问题 一位男子来到医生的办公室。“医生，每次我喝咖啡，我的右眼都 有刺痛感。您说我该怎么办？”他问道。 “把勺子从咖啡杯里拿出来。”医生回答说。 工作技巧 在瓦湖岛上度假时，我们坐在旅游车里等候掉队的人。一位男子， 明显不是和我们一起的，朝旅游车走来并要上车。司机会怎么处理这种 情况呢？我们都拭目以待。司机拉长了脸，向车门靠过去，问道：“先 生，是去天体营吗？” the nudist colony 裸体主义者聚居地 “哦，不，”刚想乘车的男子回答说，迅速转身而逃。 “每次都管用，”司机眨巴了一下眼睛说。 让人无奈的孩子 我五岁的儿子和他的表弟在一起的时候，总要招来大乱。一个星期 六，我开始抗议了。“好啦，你们两个，”我严厉地说，“不许叫喊， 不许乱拿，不许哭闹，不许乱敲，不许取笑，不许扯淡，不许弄坏玩具， 不许乱抓，不许打架。” 我刚转身要走，就听我儿子说：“来，斯蒂文，我们来把自己弄脏 吧。” 十二张卡片 一个夏天，我十多岁的女儿在她祖父母家过了几周。她准备回家时， 祖父给了她十二张卡片。 “每月给我们来个短信，”他说。 几个月过去了，可卡片一直放在那儿没用——直到有一天来了这样 一封信： “亲爱的詹妮芙： 生活是一系列阶段组成的。 还是个孩子的时候，我期待着成为一个青少年——我如愿以偿了。 还是个年轻人的时候，我期待着遇到一个年轻的女人，恋爱、结婚 ——我如愿以偿了。 结了婚，我便期待着成为一个父亲——我如愿以偿了。 作为父亲，我期待着成为一个祖父，有漂亮、聪明的孙儿孙女—— 我也如愿以偿了。 接着，我期待着有一天他们能给我写信——我却还没有如愿以偿。 爱你的祖父” 倔强的马 大作家疯了，但现在似乎还有恢复的希望。六个月以来，他都坐在 打字机旁用力地敲一部小说。终于，他宣称书已写好并把它拿到精神病 医生那里。医生急切地大声朗读起来： “杰克逊将军跨上他的忠实的马，喊道：‘驾，驾，驾，驾..’” 医生翻了翻剩下的手稿。“五百页纸竟全是‘驾，驾’！”他惊奇地说。 “是匹倔强的马，”作家解释道。 大婴儿 “今天你得照看孩子，”女人对丈夫说，“我身体不舒服。” “亲爱的，那你呆在床上休息，”丈夫说，“我很高兴照顾我们的 孩子。” “谢谢。今天我将清静一下了，我很快就会好点的。” “我为你去买东西，好吗？” 她很高兴地说：“这帮我很大忙呢。我给你列个要买的东西的单子。” 她列好单子，递给他。 “在超级市场你能买到这些东西，”她说。 “你把孩子放在购物手推车里，就不用把孩子留在外面了。” 男人带着孩子到超市，把他放在推车里。然后推着车子沿着货架走， 寻找单子列出的东西。 开始一切都进行得很顺利，接着孩子开始哭起来。 然后孩子开始尖声喊叫。 尖叫。 又尖叫。 “保持镇静，乔治，”男人说，“不要冲动。不要喊叫，乔治。不 要发脾气，乔治。” 一个女人在超市听到他说的这些话。她走到他跟前。 “我觉得你真不错，“她说，”你对你的小乔治真有耐心。” “夫人，”男人说，“我是乔治，他是爱德华。” 回应 我是医药技师，在工作中频繁地洗手，再加上阿拉斯加的恶劣天气， 使我的皮肤非常干燥。一天晚上，我准备睡觉前用凡士林霜搓了手并带 上一双旧白色手套。 我坐在床上戴着手套读书，我丈夫洗完澡走进来。他擦干身子，走 到壁橱选了一条领带开始带上。“你在干什么？”我问。 “哦，”他回答说，“既然你想正式点，我也想这样。” 退后两英里 一位农夫和他的儿子乘坐轻便马车来到一段窄路，他们遇到一个开 车的人向相反的方向去。两个方向的两英里以内都没有地方可以使他们 相擦而过。驾车人甚是着急，按响了喇叭。 “如果你不后退，”农夫说着撸起了袖子，“我可不喜欢我将不得 不做的事。”司机吃惊不小，挂上倒挡，向后退了两英里，让轻便马车 先过去。 “刚才在那儿你说过的你不喜欢要做的事是什么？”农夫的儿子问 道。 “退后两英里，”农夫回答道。 那男子是谁 一位小旅行社的老板看到漂亮的一男一女正在他的旅游广告牌前驻 足观看。他突然灵机一动，跑上前去告诉他们他的主意：“我为你们提 供一次免费的旅游，作为交换条件，你们必须在广告中称赞我的旅行 社。”他们当场表示同意。 三周后，他在机场见到他们。那位男子在检查行李时，这位旅行经 纪人问那女子旅行情况。“游船上的食物很好，”她说，“而且飞越科 罗拉多大峡谷实在刺激。不过我确实想问一个问题，那每天晚上我都必 须和他睡在一起的男人是谁？” 嗓音的优点 每当我驾驶我那辆旧车时速超过55 英里时，它就剧烈地震动起来， 所以我决定卖掉它。我的第一位买主想买这辆车。围绕是否告诉他这辆 车的问题，我经历了一番与良心的较量。终于我做对了。 我想他会放弃这个交易，却对他的回答吃了一惊。 “那没什么，”他说，“我是给我女儿买这车的。如果她抱怨震动 的话，那我就知道她开得太快了。” 委婉提醒 婚后已久，我丈夫往往在一个特别事情上需要委婉的提醒。在我们 结婚35 周年纪念的早上，我们正坐在早餐桌旁，我暗示道：“亲爱的， 你意识到我们在这两个相同的座位上已坐了整整35 年了吗？” 他放下报纸，眼睛直直地望着我：“因此，你想交换座位吗？” 准确数字 一位游客在新墨西哥游览。他对随处可见的恐龙化石甚感惊奇。 “这些化石有多长的历史？”游客问一个上了年纪的当地美国人。 他是作向导的。 “整整十亿零三年了。” “你怎么这么肯定？”游客问道。 “哦，”向导回答道，“一个地质学家来过这儿，他告诉我说这些 化石有十亿年了，再加上那是整整三年前的事了。” 插在何处 一位母亲十分善于利用每一个机会对孩子进行教育。她的儿子只有 三岁。一天，她拿着一个插头对儿子说：“看，这里有两个铜片，那它 一定要插在有两个孔的地方。你说它应该插在哪儿呢？”母亲期待着儿 子的回答。 “插在鼻子里！”儿子回答说。 直到免费为止 我岳父打算买些砖来修整一下后院。他到砖厂拉砖，当问到砖价时， 售货员回答说：“买得越多，价格越低。” “真的吗？”我岳父说，“那么往我的卡车上猛装吧，一直装到免 费为止。” 妇女的回答 一位丈夫对他的妻子说：“为什么上帝把妇女创造得如此美丽却又 愚蠢呢？” “噢，”他的妻子立刻回答道，“原因很简单。上帝使我们如此美 丽，男人才会爱我们。上帝使我们如此愚蠢，我们才会嫁给他们。” 三人同舟 三位男子在公园的长椅上坐着。中间的一个在读报纸，另外两个在 假装钓鱼。他们给想象的鱼钩上鱼饵，放线，并卷线把鱼抓上来。 一位过路警察驻足观察了这个景象，他问中间的那个男子是否认识 其他两位。 “喔，认识，”他说，“他们是我的朋友。” “那样的话，”警察告诫说，“你最好把他们从这里弄走。” “好的，警官。”那男子回答说，接着就开始疯狂般地做起划桨的 动作来。 一封感谢信 有一次，我收到一封感谢信，是一个我曾帮助过的朋友寄来的。信 封内有五张彩票，都被刮过了，露出了数字。“非常感谢您的帮助，” 信上写道，“作为礼物，我给您买了些彩票——真遗憾，您没中奖。” 捎杯牛奶 半夜两点，科尔肯太太确信听到客厅有贼，便对丈夫说：“别开灯， 蹑手蹑脚下楼，别让贼发觉，悄悄靠近他。” 科尔肯先生披上外套，责无旁贷地去捉贼。刚走到卧室门口，他妻 子又补充说：“回来时给我捎杯牛奶。” 什么更重 人们问一个男孩，一公斤铅和一公斤羽毛哪个更重，男孩毫不犹豫 地回答，一公斤铅重，人们立刻向他解释，他错了，两个一般重，可是男孩 仍然坚持他的看法。 “为了证明这一点，”他说，“我到阳台上去，从那里先往您的头上扔一 公斤羽毛，然后再扔一公斤铅，咱们瞧瞧，到那时你怎么说。” 可怜的老先生 一天，一位老先生沿街缓慢地行走，看见一个小男孩正要拉一个门 铃，但门铃太高，他够不到，老先生心地善良，他停下步子对孩子说，“我 来给你打铃吧。”然后他使劲打铃，整个房子里的人都听到了铃声。 那个孩子对老先生说：“现在咱们走吧，快，” 老先生：“……” 怎么发现的 贝蒂：“妈妈是怎么发现你没有洗澡的？” 贝莉：“我忘了把肥皂弄湿了。” 找姐姐 “维佳叔叔，为什么您经常找我姐姐？您没有自己的姐姐吗？” 正好留给您 一天，华盖尔先生带领小汤姆到餐厅用餐，服务员端来两块猪排，汤 姆立即拣了一块大的放在自己的盘子里。 华盖尔先生见了很不高兴，说：“你怎么这样不礼貌？” “那如果让您先拣，您挑哪块？”汤姆问。 “当然是小的。” “那不是正好吗，小的那块我正好给您留下了。” 好客的小汤姆 一位熟客突然上门，女主人以没有奶酷的苹果馅饼招待，而连连向这 人表示歉意，女主人的小儿子汤姆见了，忙跑出房间，很快拿来一块奶酷， 放在客人的盘子里。 客人微笑着把那块奶酷放进嘴里，然后说：“孩子，你的眼力一定比你 妈妈的好，你是从哪里找到这块奶酷的？” “在捕鼠夹上，先生。”汤姆回答说。 是指挥官 考试开始了，汤姆举起手，老师走了过来。 “我没带铅笔。”汤姆说。 “如果一个士兵上战场却忘记带枪，你说他算什么士兵。” “我想他是个指挥官。” 不爱动脑 小毕那走进杂货店，店员问道：“你要买什么？” “买10磅15个法郎一磅的糖，加4磅90法郎一磅的咖啡再买2磅 27法郎一磅的奶油，然后再加30法郎的面包。”小毕那说。 “594法郎。”店员说。 “假如我给你一张1000法郎的钞票，你该找给我多少？” “406个法郎，快一点，我没有时间跟你磨蹭。” 小毕耶一面走出店门，一面说：“这是老师要我明天交的作业，我还不 会算呢，实在太谢谢你了。” 像绅士一样 7岁的卡尔和5岁的妹妹在阿姨家做客。 阿姨把卡尔叫到厨房里，给他一把餐刀和一个香喷喷的蛋糕， 对他说： ‘拿着，切一半给你的妹妹。记住，你要做得像个绅士！’ 卡尔问：“绅士怎样做？” 阿姨说：“绅士总是把较大的半块给别人。” “噢，”卡尔想了一会，把蛋糕端到妹妹跟前，递过餐刀，说：“妹 妹，请你像绅士一样把蛋糕切成两半。” “小天使”的愿望 巴克老爹到公园里，坐在长木靠椅上养神。有个小孩站在他旁 边，一直不走。巴克很纳闷，他问： “小天使，你为什么老站在这里？” 小孩说：“这长椅刚刷过油漆，我想看看你站起来以后是什么 样子。” 两个老顽童 某花园别墅的主人恼火地站在门口，对迎面走来的警察说： “您有没有看到什么小孩子按了我的门铃，然后又跑开？” 警察说：“小孩子？我明明看到是两个老人，他们还一边走， 一边哈哈大笑哩！” 百战百胜 斯托克看到自己的儿子与邻居的强壮的小孩角力，就鼓励他 说：“加把油！赢了我给你5毛钱。” 后来，儿子回家告诉爸爸他果然赢了，斯托克便给了他5毛 钱。以后儿子又胜了几次，斯托克照样每次都给5毛。 但斯托克思考再三，总觉得儿子敌不过邻居的孩子，所以又 问：“你果真能赢他吗？” “当然，百战百胜。”儿子自豪他说。 “那你用了什么技巧呢？” “这简单，”儿子回答，“每次给他1角钱，他准败。” 不用害怕 加州一个小镇上的警察发现一个独自在大街上徘徊的金发碧 眼的小女孩，她只有2岁半，长得非常迷人，但她既说不出叫什么 名字，也弄不清家住在什么地方，最后无可奈何的警察开始翻她的 衣兜，希望能找到有关身份的线索，小女孩没反抗，却嫩声嫩气地 说：“别害怕，我没带枪！” 主席的发言 “有人曾经对我说，南非的一个部落对待发言人有一个很好的习惯，这 部落认为，冗长的讲话对讲话者本人和听众都有害处，因此，他们制定了一 条规则：发言人应该单脚站立，只要他的第二只脚一触地，就得终止自 己的发言。如果我们尊敬的发言者们不把这个晚会拖得很晚的话，我想今 天我们就用不着采用这一聪明的习惯。” 不会淹死 “我估计你在水中游泳有极好的先决条件，不会淹死。” “这话怎讲？” “你的女朋友对我们说，你跳舞的时候像块木头。” 踩人为已 剧场里演出正在进行，玛丽站起来，顺着两排间的空档儿挤出去，走 进休息室。10分钟后，当她回来时，她低下头，向坐在这排的第一个观众 说：“喂，我刚才是不是踩着您的脚了？” “是的，没关系，现在已经不疼了。” “不，我不是这个意思。我只是想证实一下我是否坐在这排。” 上座踊跃的奥秘 演出季节开始以来，这家剧院连连爆满。这一天又挂出了“票已售完” 的牌子，有两人在议论：“这出戏有这么大的吸引力？” “因为剧中女主角频频更换服装，这吸引了许多女观众，而且她每次 都是在台上当众更换，这就吸引了更多的男观众……” 火车准点弄到 有一位年近花甲的男士，虽然讨厌电视，但他每星期六晚总要坐在电 视机前面，观看周未播出的“大溪风光”，这个片里有一段美女脱衣服 入溪戏水的情节，但当这位美如天仙的女子将要脱去最后的裤叉时，一列 火车开过，把美女遮往了，这位男士连续看了7个星期，每次都如此，他怒 不可遏地指着电视骂道：“怎么这火车老是那么准时的。” 住房 一位游客问伦敦人：“为什么你家的狗，尾巴不是左右摇摆，而是上下 摆动？” “这完全是环境造成的，我家地方太窄了。” 念菜单 一位妇女带着小女孩到一家快餐店用餐，“要点什么？服务员问。” 回答是这样一串话：‘汉堡包，乳酷饼，大小烤牛排，鸡茸三明治，普通 油炸食品，大油炸食品，苹果馅饼，巧力饮料，香草饮料，草莓饮料，可口可 乐，百事可乐，桔子苏打水，” 工人们把这些食物装了好些袋子，当给她送去时，她说：“我还没有点 呢，刚才我在给女儿念菜单。” 庆祝加薪 老板：“杜丘，上班时间，你怎么在办公室里喝香槟酒？” 杜丘：“我这是在庆祝我最后一次加薪20周年啊。” 酒的度数 房主用自制的烧酒招待一个在偏僻小镇度夏的丹麦人，喝过一杯后。 丹麦人面色苍白，吃力地说道：“这酒多少度？” “多少度我不知道，但是，喝一瓶可以打12场架和搞一次凶杀……” 在水果摊 一位雍荣华贵的太太在水果摊上挑选水果，她的哈巴狗乘她不注意的 当儿用舌头舔苹果，摊主很不高兴，终于以礼貌的态度请女主人注意她的 哈巴狗。 女顾客以严厉的口吻向她的狗喝道：“安哈，不准再舔，这些苹果还没 有洗过。” 在珠宝店 有一个上了年纪的男子出身于乌普萨拉的有名的百万富翁家庭，一 天，他来到斯德哥尔摩，不知不觉地走进一家珠宝店。在店里他问售货员 拴在天花板上的那个水晶吊灯值多少钱。 售货员瞧了瞧这个穿着非常简单的男人，断然认为他没有能力买这 个水晶吊灯，尽管那人站在那里很想知道价钱，售货员就是对他置之不 理。 这时那人拿起自己的手杖把水晶吊灯打碎，然后说：“现在我可以知 道这个吊灯的价钱吗？” 伤心的结尾 有三个人来到纽约度假。他们在一座高层宾馆的第45层订了一个套 间。 傍晚，三人外出到剧院看戏，回到旅馆时已是夜深人静了。“真对不 起，”旅馆服务员说：“今晚我们所有的电梯都出了毛病。若诸位不打算徒 步走回房间，我们会想点办法，给你们在大厅找个安顿的地方。” “太谢谢您了。我们不想在大厅里过夜，自己走上去可以了。” 然后，一位同伴说：“爬到45层楼，谈何容易，不过我知道怎样使之从 难变易，一路上，我负责给你们讲笑话。然后安迪，你给咱们唱几支歌，还 有你，彼德，给咱们讲几个有趣的故事。” 于是，三人动身往上走，汤姆讲笑，安迪唱歌，好不容易爬到第34层， 大家疲惫不堪，决定先休息一下。 “喂，现在要有趣味，最后来个使人伤心的故事。”彼德说，“故事不长， 却使人伤心极了：我们把房间的钥匙忘在一楼大厅啦……” 解围 旅游者向人们讲述他的墨西哥之行，他说：“当时，有那么多印第安人 围着我，简直可怕极了，我的左面是印第安人，右面也是印第安人，前面是 印第安人，后面也是印第安人。” “那你怎么办呢？怎样才能解围呢？” “我只好买了一件他们向我出售的皮褥子。” 也是怪兽 有个人到苏格兰观光，来到尼斯湖，希望一睹湖内驰名世界的怪兽。 “怪兽一般在什么时候出现呢？”他问一个向导。 “一般是在你喝下5杯苏格兰威士忌后，怪兽就出现了。 死前不要错过良机 导游带着一群旅游者从悬崖峭壁的一条小道上走过时对游客们说： “请大家多加小心，这里是危险地带，如果谁不慎从悬崖上掉下去时，不妨 顺便看看左边，那一派奇异的景色在这里是看不到的。” 骷髅 导游带着一批旅游者参观古堡，在很深的地道里他们发现了几具骷 髅。 “这些骷髅是怎么回事？他们生前都是些什么呢？”旅游者问。 导游说：“我想他们一定是些舍不得花钱请导游的旅游者。” 多得小费之谜 餐馆服务员在一起聊天。 “马歇尔，为什么你收的小费总比别人多？为什么那些女顾客总爱多 给你小费？” “这很简单，一见到女顾客我总要对她们说：“您好，太太，”当她们离 开时，我就对她们说：“再见，小姐。” 危在旦夕 一个花花公子去一家理发店理发，替他修指甲的女郎长得非常漂亮， 他请她当晚一同去吃饭和看电影，“我想我不应当接受你的邀请，”那女郎 一本正紧说，“我已经结婚了。” “和你丈夫讲一声好啦，”花花公子替她出主意说，“我相信他一定不会 介意。” “你自己问他好了。”女郎说，“他正在给你刮脸呢。” 林务员和牧师 牧师问林务员：“怎么很久不见你来教堂了。施特鱼普先生？” “我要一来，听您讲道的教民可就少了，牧师。” “您在取笑我？” “这是真的，教民们看到我来教堂，那至少一大半都会跑到森林里去， 放心大胆地偷猎一通。” 吵架 一个男子走进一间酒吧对女招待说：“在吵架之前，给我来一杯可 可。” 酒吧女郎慌忙递给他一杯，几分钟后，那人又对女招待说：“吵架之 前给我送点牛排和炸土豆来。”女招待更加吃惊了，但还是把菜送来了。 就这样，10分钟过去了，酒吧女郎好奇地问道：“可是，你说的那个吵 架是怎么一回事？究竟什么时候开始？” “马上就开始。”男人回答道：“因为我没钱付可可和菜钱。” 报复 我酷爱看侦探剧，从戏开幕的第一分钟起，我就在找寻凶手，不漏过 一个可疑的词，不放过一处伏笔，这天，我又去看一出戏，叫《公园街谋杀 案》。当包厢侍者引我到座位上时，大幕正好拉开。 “您对座位满意吗？先生。”“当然，谢谢。”“我把您的帽子送到衣 帽间好吗？”“不，谢谢，”我想他该走了。但是并没有。“您要一份节目 单吗？”“不，谢谢。”“那上面带剧照。”“谢谢，”“或者一个望远镜？ 我生气地拒绝了。” 侍者又问要不要巧克力饼，要不要一瓶香槟，剧情开始紧张了，我又气 又急：“不，什么也不要，你见鬼去吧。” 他终于发现在我这儿赚不到一文小费，于是给了我一个可怕的报复，他 伸手指着舞台，用充满仇恨的声调在我耳边说：“凶手就是园丁。” 神秘的信 特德夫妇收到一封神秘的信，里面夹着两张粉红色的上等音乐会的 票，这可是他们想买而没有买着的票，然而信里没留只言片语，他俩怎么 也猜不着谁这样关心，热爱他们。 音乐会精采极了，特德夫妇高兴非常。可当他们兴致勃勃地回家，只 见房门大开，钱财被洗劫一空。是谁给他们的信，自然不必问了。 兔子所以不戴眼镜 “医生，我多吃胡萝卜视力真的会有改善吗？” “当然，您什么时候看到过兔于有戴眼镜的？” “没忘寄信吧” 琼斯先生有个健忘的毛病。有一次他妻子要他寄一封信，并嘱 咐他：“千万要在上班前寄出去。” 他急急忙忙赶去上班，一位素不相识的先生拍着他的肩膀，笑 着说道：“先生，可别忘了寄信罗！” 琼斯赶忙把信寄了。 可当他往前走时，又有人对他说：“先生，你没忘寄信吧！” 琼斯点点头。 当他走到办公室，他旁边的一位女同事又微笑着问他：“琼斯， 您没忘记寄信吧！” “没有。” 琼斯感到奇怪，难道全世界的人都知道他今天要寄一封信？他 微笑地问女同事：“你怎么知道我有信要寄呢？我早把它丢到邮筒 了。” 女同事哈哈大笑道：“这下，我可以帮您把这张字条撕下了。” 原来，他妻子在他衣服上贴了一张字条。上面写着—— “请提醒我的丈夫寄一封信。” 人　口 一个印度人在头生子出世时大放爆竹。在爆竹的噼啪声中，楼下有两个儿童对话：“楼 上发生了什么事？” “人口爆炸。” 如此区分 两个美国大兵看着一个女孩用手抓住自己头上的帽子从身边走过。 “那个女孩子不是从乡下来的。”一个大兵说。 “何以见得？” “当刮大风的时候，你马上可以区别乡下的女孩和城里的女孩。”他继续说，“乡下的 女孩会扯紧她的裙子，而城里的女孩就抓着她的帽子。” 幸　福 一个A国人、一个B国人和一个C国人在一起讨论什么是幸福。 A国人说：“在你下班回家感到很疲乏时，你发现你的拖鞋已搁在炉子边烤得暖暖的， 这就幸福。” B国人说：“你们A国人就是缺乏浪漫气息。幸福嘛，就是你出差时邂逅一位年轻美貌 的女郎，她既温柔又殷勤。你们痛痛快快地玩了一场，最后好聚好散。” C国人说：“你们两位都错了。真正的幸福是，清晨4点在你睡得迷迷糊糊时听到敲门 声。一打开门，秘密警察站在你面前，对你说：D先生，你被捕了。你说对不起，您要找的 D先生住在隔壁。” 有趣的情书 一个年轻人写了一封信：“亲爱的米拉，我爱你，而且希望你嫁给我， 如果你同意，你就回答我。如果你不同意，就连这封信也不用拆开。” 以狐皮大衣为号 艾丽萨在报上读到一则男人征婚启事，她立即给那人写信：“很高兴 同您一晤，以求在互爱互敬的基础上结成终生伴侣，见信后，请于星期日 下午3点在电影院前等我。为了让我认得出您，请用左手挎一件46码的 狐皮大衣。” 电话 一个小伙子每天晚上在安格吉莎对面单元的窗口用望远镜看她，这 使她很生气，有一天清晨，她打电话给那个小伙子。 “你好，我就是对面单元里的姑娘，你还记不记得，昨晚我脱下长 筒袜子放在哪里了。” 侦察 在莫斯科一辆拥挤的公共汽车里，站着的一个男子拍了拍另一个男子 的肩膀，然后低声说：“你是克格勃成员吗？” “不是。” “你的家庭里有什么人是克格勃成员吗？” “没有。” “你的邻居呢？” “他们一个也不是。” “你的朋友和熟人呢？” “我认识的人中没有哪个是克格勃成员。” “那么请你别踩我的脚，好吗？”第一个说。 吃鸟食 “索菲娅，亲爱的，我的丈夫今天早晨是怎么回事？我还从没有见过他 上班这样高兴过，吹着口哨，跟只小鸟叫一样。” “夫人，恐怕这是我的过错。今天早晨我搞错了一包东西，把鸟食当成 普通的早饭给他吃了。” 统计学家 有个从未管过自己孩子的统计学家，在一个星期六下午妻子要外出 买东西时，勉强答应照看一下4个年幼好动的孩子。当妻子回家时，他交 给妻子一张纸条，上写： “擦眼泪11次；系鞋带15次；给每个孩子吹玩具气球各5次，每个 气球的平均寿命10秒钟；警告孩子不要横穿马路26次；孩子坚持要穿过 马路26次；我还想再过这样的星期六0次。” 生日礼物 细菌学家对自己的妻子说：“亲爱的，我已经准备好了一件意外的礼 物在你的生日那天送给你。” 妻子：“好极了，是什么呢？” “以你的名字命名的病毒。” 跳蚤变聋 一位生物学家把一只跳蚤放在手中对它说：“跳！” 跳蚤跳了起来。然后，这位先生折断了跳蚤的腿，又将它放在手中并 命令道：“跳！” 当然，跳蚤不跳了。 于是，这位生物学家写道：“当人们将一只跳蚤的腿折断后，跳蚤便 成了聋子。” 语言 两位学者坐在窗前喝水，有个美丽的姑娘姗姗走过。其中一位看到他 的同事那种痴望的神态，便揶揄他说：“老弟，她也和我们一样，75％是 水。” “是的，”同事说，“老兄，可是你看看人家的表面张力！” 生死辩证法 学生：“先生，您知道人什么时候生，什么时候死吗？” 先生：“天堂里满了，人就死；地狱里满了，人就生。” 安装电话有妙法 一家小报的编辑搬到一所新住宅。 第二天，他给电话公司的经理打了个电话：“您的工作人员说，三个 月以后才能给我安装电话。我觉得，他们向我提供了写文章的好题材。” 第三天，电话安上了。 广播员的机智 在60年代，在无人驾驶宇庙飞船“双子座2号”的发射现场，有一 个无线电台的实况广播员是在事先就把他的广播稿写好的。发射前的倒 数刚一结束，广播员就念道：“宇宙飞船起飞了。巨人般的火箭腾空而 起，升到了佛罗里达州的蔚蓝色的天空，直向大西洋上空飞去。火箭发出 雷鸣般的吼声震耳欲聋。” 当他抬头一看，那巨人般的火箭仍然一动不动地留在发射台上。他灵 机一动说：“突然，奇迹出现了，有四条长长的金属手臂伸出去抓住了火 箭，把它拉回到了发射台上！” 难以控制 某年春天，德国北莱茵西发里亚省长迈那斯博士，在盐湖发表演说 前说：“各位女士。各位先生，我的英语说得不好，请各位原谅。我和英 语很像我和我的太大：我爱他，可是控制不了她。” 万能处方 病人去做体检，大夫用他常人难辩的字迹开了张处方，病人把处方揣 进袋里，忘了去拿药。有两年的时间，他每天早晨把处方当作铁路通行证 出示给检票员；还用它进了两次电影院，一次棒球场和一次交响音乐会； 用它冒充老板的字条得到一次提升。一天，这个人把处方弄丢了，他的女 儿捡到后，在钢琴上照其演奏，结果获得了进公立音乐学院的机会。 让我再想一想 “如果你拒绝我，艾丽莎，那我就卧轨。” “你让我再想一想，反正离开今天的末次火车到站时间还早着呢。” 真心诚意地求婚 他俩是昨天晚上舞会上认识的，约好翌日黄昏在公园相会。小伙子拉 起姑娘的手说道：“你是天上的月亮，地上的清泉。没有你，我无法生活， 我真心诚意地向你求婚，做我的妻子吧。亲爱的柳芭。” 姑娘惊叫着：“我不是柳芭，我叫玛莎。” 最有防备 丈夫：“亲爱的，你既然这样爱我，为什么我第一次你求婚的时候， 你不马上答应呢？” 妻子：“因为我要看拒绝后，你的反应是怎样啊。” 丈夫：“哦，可是如果当时我掉头就走，那你怎么办？” 妻子：“放心，你走不出去的，因为我早把大门锁上了。” 订婚 在一个订婚宴会上，年轻的小姐希望给未婚夫的亲友留下很好的印 象。只见她端庄地出来，微笑地招待贵客时，不慎绊在桌子脚上跌了个四 脚朝天。 他未婚夫急了，想向前扶她，只见她翻身起来说：“先生们，女士们， 我给你们表演的武术怎么样？” 复婚 “我听说，你又准备同你丈夫复婚了，是吗？” “是的，我绝不能让这个恶棍在家里一个人自享其乐。” 等待秋天 夫妇两人一起去参加美术展览，当他们面对一张仅以几片树叶遮羞 的裸体女像油画时，丈夫立刻张口注目地盯着那幅画，呆了半晌仍不想走 开。 妻子揪住丈夫吼道：“喂，你是想着到秋天，待树叶落了才甘心吗？” 将计就计 一个女人在饭馆里责骂她的丈夫，最后，她尖声叫道：“在世界上所有 可耻的人中，你是最卑鄙的一个。”这时，饭馆里所有的人都吃惊地看着他 们。 她丈夫察觉后，马上提高声音说：“骂得太好了，亲爱的，你还对他讲 了些什么？” 小小误会 一位旅客乘一辆出租汽车出游，半路上他轻拍司机肩膀想问点事。司 机吓得“哇——”地叫了起来。 “喔，对不起，”旅客抱歉地说道，“没想到会吓了你……” “没关系，小小的误会。”司机答道，“我一向是开灵枢车的，刚改换驾 出租车。” 车跳的原因 公路上行驶着一辆小轿车，它很滑稽地每隔30秒钟就往上颠一下， 警察拦住汽车问司机：“喂，你这车子怎么啦。” “车子没事，呃。”司机说：“它跳是因为我在打嗝。” 轧狗还是轧人 主考官问参加考汽车驾驶执照口试的比奇：“假如你看到一条狗和一 个人在前面，你是轧狗还是轧人？” 比奇毫不犹豫地答道：“当然轧狗。” 主考官摇了摇头说：“你下次再来吧。” 比奇不服气，反问道：“我不轧狗，难道你要我去轧人。” “你应该急刹车。”主考官慢条斯理地说。 出色的演员 一辆有两名乘客的汽车闯红灯，被警察叫住。 “我非常遗憾，”司机很快明白过来。说，“但是，我是个医生，急着把这 个病人送进精神病医院。” 警察怀疑司机是欺骗他，但是乘客也是一个相当聪明的小伙子，他用 天使般的目光瞅着这位维护秩序者，微微一笑，小声说：“吻我一下吧，我 亲爱的。” 警察马上痛痛快快地放了他们。 携手合作 据说在比利时，当你闯红灯后，警察并不对你大声训斥，而是默不作 声地挽起你的手臂，在横道线口等待行人通过的绿灯，然后挽着你的手臂 一同穿过马路。如此身体力行的携手合作，将重复20次。 汽车配件 大轿车司机车经过一个山村时向一位居民打听： “请问，此地哪里可以找到汽车配件？” “往前走，过了那个急转弯处有个峡谷，那下边多的是。” 默契 抽象派画家的妻子对她要好的女友说：“我同丈夫配合默契。每天，他 画画，我做饭，然后，我来猜他画的是什么；末了呢，猜我准备的是什么 饭。” 先见之明 一个身材不高、有点神经质的人走进一家店铺。他对老板说：“我想 把您的烂水果和臭鸡蛋统统买走。” “那好哇。您大概打算到马戏团去看新小丑吧？”老板眨着眼睛说。 “嘘……小声点。”买主四下打量着，悄声说，“我就是那个新来的小 丑。” 只有四副降落伞 一架飞机上有5个人：飞行员、教士、聪明人、商人和登山运动员。飞行员突然走进客 舱宣布，飞机出了故障，并抱歉地说，机上只有4副降落伞，但他需要向地面汇报坠机原 因，说着便拿了个降落伞跃出舱门。 教士说他要拯救教区5000信徒的灵魂，上帝之托不可亵渎，便抓住第二副伞跳出机舱。 聪明人声称不久将参加世界智力竞赛，为了祖国的荣誉他不得不珍惜自己的生命。说 完，抢起一个包便跳了出去。 商人愁眉苦脸地问登山运动员怎么办。运动员笑着回答说：“别发愁，那位聪明人抢走 的是我的背包。” 毛拉评诗 伊朗流传着毛拉·纳斯尔丁的趣味故事。 一天，国王写了一首颂诗，拿给毛拉看，毛拉看后说： “诗写得不怎么样。” 国王闻言大怒，当即下令把毛拉囚禁起来，饿了他一天一夜。 事过不久，国王又写了一首颂诗，要毛拉发表评论。毛拉什么话也没说，站起来就要 走。国王问道：“你到哪儿去？” 毛拉答道：“去监狱。” 理应如此 毛拉去澡塘洗澡，招待员态度冷漠，照顾得很不周到。临走时，毛拉掏出10个第纳尔的小费，招待员受宠若惊，连忙表示感谢。 过了一个星期，毛拉又去洗澡。这次可忙坏了招待员，又是递毛巾，又是点烟送茶，照 顾得无微不至。临走时，毛拉却只给了他一个第纳尔的小费。招待员十分恼火，就问毛拉：“上次你给了许多小费，这次怎么就给这么点儿？”“道理很简单。”毛拉说，“我上次给的是这次的小费，这次给的是上次的小费，难道不应该这样做吗？” 人身保险 父子俩在晚市上买完东西往回走，途中，一强盗把枪口对准年青人：“把 钱放下。” 老头子一下子扑到强盗身上，告诉他儿子：“快跑。” 强盗说：“你这老家伙不要命啦。” “对，你开枪吧，我有人身保险。” “邮寄”到梦乡 对于年轻的母亲来说，有时说服小孩子上床睡觉也许是一件令人头 痛的事，然而有个名叫凯瑞的母亲却想出了一个幽默的主意，她对儿子 说：“你的小床就是一只信封，而你就是一封写着好消息的信。” 孩子听了高兴地跳上了床，钻进了被子，让母亲把他放入“信封”，贴 上“邮票”，井将他“邮寄”到一个甜蜜的梦乡。 赡养 一个失去妻子的丈夫买了5个面包，回来的路上遇到了一位朋友，便 笑着对朋友说：“瞧，我又买了5个面包。一个我吃，两个还债，另两个借 贷。” “什么意思？”朋友问。 “两个给父母吃，是还债，两个给孩子吃不是借贷吗？” 不应该钓鱼的原因 老师：“你为什么迟到？” 学生：“我本来要去钓鱼。但是爸爸不许我去，我哭了，所以来晚了。” “你爸爸做得很对，关于你为什么应该上学，不应该去钓，爸爸一定对 你解释清楚了吧？” “对，爸爸解释过，他说蚯蚓太少，要是两个人去钓就不够……” 决不侵犯 地板上放着一盆待洗的衣服，拉拉杂杂的家务活摆在眼前。妻子抱着 未满周岁的孩子，急得团团转，她恳求丈夫：“这么多活你就不能帮我干 点。” 她丈夫慢悠悠地说：“你的权益我决不能侵犯。” 生日礼遇 他从来不帮太太做家务，妻子生日那天，他心血来潮地对太太说：“你 今天不用洗碗碟了。” 太太喜出望外地说：“真是太好了，谢谢你帮忙。” 先生回答说：“你留着明天再洗吧。” 儿女们 父亲下班回家。他的儿女围拢过来，按次序汇报自己在家干了些什么 活。 “我把所有的碗碟都洗干净了。”老大说。 “我把它们都抹干了。”老二说。 “我把它们放到碗柜里去了。”老三说。 最后，轮到年纪最小的女孩子，她怯生生地说：“我，我把碎片都收拾 起来了。” 奇　迹 80岁的施梅勒娶了一个年轻的妻子。奇迹出现了：她生了一个孩子。施梅勒满腹狐疑 地去请教拉比：“拉比，这怎么可能呢？” 拉比说：“我给你讲一件事：有一个人打着太阳伞在非洲的沙漠中散步，突然来了一头 狮子！那人赶紧定住神把收起的太阳伞搁在狮子脑袋上喝道：‘呸！’只见狮子应声倒地死 了。” “这怎么可能呢？” “那个散步的人背后有个持枪的士兵，他就在那节骨眼上放了一枪。” 只需识字 作家应征入伍，班长问：“你念过小学吗？” 他答：“念过。我还念过中学，而且在大学取得了三个学位，还有 ......” 班长点点头，高举一块像皮印在纸上印下了两字：“识字”。 果断回答 一位年轻军官想打个电话，但他没有零钱，于是他拦住一位过路老 兵：“你手头有没有零钱？上士。” “我给你找找看。”老兵伸手去掏他的钱包。 “你是这样回答少尉的吗？重来一遍。你手头有没有零钱？上士！” “报告长官，没有！”老兵果断地答道。 官兵有别 视察军舰的海军上将和舰上士兵闲谈，他问水兵汤姆：“如果有士兵 失足落水，你怎么办？” 汤姆立刻答道：“我会立刻发警报并抛个救生圈给他。” “如果是个军官，譬如说我呢？”海军上将继续问。 汤姆迟疑了一下，然后答道：“我坚信你们自我解决问题的能力比士 兵强。” 仿照 有一人在空军服役，他有一个非常漂亮的妻子，每天早上丈夫离开家 去飞机场。一小时后，他的妻子就带着一条纯白围巾也离开家，到海滨去 散步，丈夫驾驶的飞机每天都从这里经过，当她看到丈夫的飞机时，就把 白围巾高举起摇晃着，丈夫看见后，便会把飞机的左翼或右翼降低一下。 降左翼的意思是说：我今天非常忙，不能回家；降右翼的意思说：8小时 后，我将把你抱在怀里。 有一天，这个人与其他8个飞行员驾驶的8架飞机一同飞行，当他看 见妻子后就把右翼降一下，其余8架飞机不知其故，也都照样将右翼降了 一下。 士兵的哲学 新兵们在接受战术训练，内容是空手夺刀和空手夺枪，接着教官还为 他们做了示范动作。课后，教官想了解他们对课程掌握的程度，于是向士 兵们提了一个问题：“现在，你们知道了，一个不带武器的人如何对付一 个携带武器的人，那么，假如你夜里独自一人守卫一座桥，手里拿着枪。 突然发现一个赤手空拳的敌人向你扑来，你怎么办呢？” 被问的一位新兵经过几秒钟认真思考后回答：“我认为首先必须把手 里的枪扔到河里，这样敌人就不会为了夺枪而杀我了。” 刷锅水 苏亚雷斯将军非常关心战士的生活。一天他跑到厨房，想亲自尝一下 战士吃的饭菜。 他走近汤锅前说：“给我一勺。” 一个士官小心翼翼地说：“但是，将军……” “闭嘴！”他打断了那个士官的话，抄起勺子，一连喝了好几勺。最后 他叫道：“这是什么汤，简直是刷锅水！”大家都愣在那儿，不知所措。 最后那个士官嗫嚅着说：“对，将军，这就是刷锅水。” 休假证 两个水兵在营外酗酒，掉进河里，回营后，司令官把他们大骂一顿， 并收回他们的休假证，司令官说等他们的证件干了之后，自然发还给他 们。 他们等了整整一星期，才敢再到司令官的办公室，敲门之后，他们往 里面一看，发觉司令官不在里面，但休假证却在他办公桌的一盘水里浸 着。 士兵的家信 一个荒漠上服役的士兵在给父母写信，他在信中写道： “这里简直可怕极了！到处都是灼热刺眼的阳光，只有唯一的一棵孤 零零的小树。我们几个人靠摔跤决定胜负，谁赢了才能躲在这棵小树的树 荫下待一会儿……” 反进 一个在前线打仗的士兵收到家乡的女友的绝交信，说她要和一位商 人结婚，并请这位士兵寄还她以前送给他的照片。士兵想了想，便从战友 那里借来二十张女人照片，连同他女友的照片一同装进一只木箱，寄给 了她。 女友接到木箱后，发现箱子里有一张纸条，上面写着：“请您挑出自 己的照片，其余的务必寄回！” 家信之谜 年轻的士兵收到了一封家乡来信，当他拆开信封，从里面取出的却是 一张白纸。 “这是怎么回事呢？”朋友问。 “事情是这样的，”士兵说，“在我离开家乡时我同未婚妻吵了一架，从 那以后，我们一直谁都不跟谁讲话。” 聪明的指挥官 一次军事演习正在进行，一位指挥官的吉普车陷进了泥里。他看见附 近几个士兵正懒洋洋地坐在地上。便叫他们来帮忙。 “很抱歉，先生，我们已经阵亡了，什么也不能干。” 指挥官转向他们的司机：“卫兵！赶快从这些死尸里拖两具出来填到 轮子底下，好让我们快点上路。” 士兵们马上从地上跳了起来。 正在游泳 在军事演习的时候，上校在一座桥上设了一块牌子，上面写着：“桥 已被炸毁。” 上校在指挥部里通过望远镜，看到一群步兵仍毫无顾忌地过了河。他 十分生气。一怒之下，他乘着吉普车来到桥边，准备狠狠训斥那些士兵。 到了河边，上校吃惊地看到，一个士兵手里举着的牌子上写着：“我 们正在游泳。” “假如这是一枚炸弹” 一位海军将官在舰上散步，他为了考验一下正在值班的新兵在紧急 情况下的应变能力，于是对着值班士兵说：“值班官！”他随手把自戴着 的帽子脱下放在甲板上，说：“假如这是一枚炸弹，你该如何处理？” 那值班士兵看了一下，一言不发，一脚把那顶绣了金丝的将军帽踢下 大海去。 将军与士兵 克里茨将军到前线视察，他刚到前线，敌方狙击手射出的子弹就打掉 了他制眼上的一颗纽扣。将军大惊失色，扑倒在地。而随他而来的官兵们 却无动于衷。 将军生气了，他对离他最近的一名士兵嚷道：“你为什么没想到去把 这该死的狙击手消灭掉呢？” “报告将军阁下，”士兵挺了挺胸脯，“因为我担心敌人会换上一个枪 法更准的狙击手。” 全部消灭 第二次世界大战期间，德国一名高级军官曾问一名瑞士军官：“你们 有多少人可以作战？” “50万吧。。 “如果我派100万大军进入你们的国境，你们怎么办？” “那我们只好每人打两枪。” 座位不同 "怎么啦,服务员,今天的饭菜怎么这样少?.昨天可是很多的!""先生,你昨天坐在窗旁,街上行人都能看到盘中的饭菜呀!" 山庄孤店 顾客：“天哪！怎么两瓶啤酒就值１０元钱！难道这儿啤酒就这么稀罕？”侍者：“不，先生！这儿稀罕的不是啤酒，而是顾客。” 高招 一名乞丐在街上对一个妇女说：“快给钱，夫人。您想想，如果这把 水枪里的水冲掉您脸上的化妆品，后果会怎么样。” 高兴太早 一男青年将被征入伍，军队医院眼科医生给他做视力检查，青年边接受检查边表白自己是个近视眼。检查完毕，大夫说：“是的，你说得对，是近视眼。”青年听到这句话非常高兴。“尊敬的大夫，那么我可以免服兵役了？”大夫摇摇头说：“不......我写上了可参加肉搏战。 拉生意 一架飞机发生了严重故障，机长通过杨声器要求乘客和机组人员系上保险带准 备紧急着陆。３分钟后机长又通过无线电问空姐长是不是大家全部都系上了保险带。 “全都系上了，只有一位律师还在分发他的名片。” 巧识罪犯 法官问出庭作证的警察： “罪犯化妆成女人，你是怎么认出来的？” “很简单，他走过三家珠宝店和五家时装店，连瞧都没瞧一眼。” 临近下班时一个男人闯进某大银行的分行。他将帽沿压得很低，握着 手枪以命令的口气吼道：“都给我躺下，谁也不许出声！” 大家都一声不吭地躺到地上。科长看见迈耶小姐躺的姿式，严厉斥责道： “迈耶小姐，请您躺文明些！这是银行抢劫，不是去郊游！” 在苏格兰一个乡村里，有一男子被压道机压死，男子穿着裙子，上半身被压在压道机底下，只露出了下半身。这时，恰巧有三名女子过路看到了。 女子A：（掀起裙子）还好，不是我丈夫。 女子B：（也掀起裙子）也不是我丈夫。 女子C：（还是掀起裙子）他不是我们村儿的。 还有几天就要开庭了，被告对自己的律师说：“这次如果输了，我这一辈子就完啦！我们给法官送一条高级香烟怎么样？”“法官是个耿直的人，他一向讨厌香烟，更憎恶送礼的人，你还是不送的好。”律师答道。 开庭日期终于到了，被告意外地胜诉了。走出法庭，被告感激地对律师说：“谢谢你提醒我香烟的事。”律师道：“如果你送了烟，我们肯定赢不了这次官司。”被告反笑：“我送了香烟！”律师很惊讶。被告神秘地说：“正是香烟帮我们打赢了官司，我在香烟上附上了原告的名片！” 胖瘦无常 有位化学家，每次外出时，总要在脏衣上套 上一件新衣。第 一次，套上一件，第二次，又套 上一件，第三次，再套上一 件，这样他身上常常 套着五六件新衣。到后来实在不能将就 时，就一 齐脱下来。他的朋友们莫名其妙地议论道；“我们 的化学家一会儿那么胖，一会儿又瘦得那么厉 害，这到底是 怎么回事？” 重蹈覆辙 某人要去海滨度假，临行前，他托付女房东 把他朋友的寄来的 信件及时转寄给他，女房东一 口应承下来。 一个月过去了， 却没收到一封信。他感到奇 怪：他有那么多朋友；他与他们向 来通信频繁， 怎么会收不到他们的信呢？于是，他打电话问女 房东：“为什么不把信转给我？” “先生，你没留下信箱的钥 匙呀，叫我怎么 转呢？”女房东答道。 他恍然大悟：“瞧我， 多糊涂！是啊，没有 钥匙怎么开信箱呢？”他立即把钥匙放进 信封里寄去了。 又过了一个月，他还是一封信也没收到。度完 假回来后，他生气地问女房东：“我把钥匙寄 给了你，你怎么 ——” “女房东说：“先生，你寄来的钥匙，不是也和其他信 件一样，丢进信箱里了吗？” 但愿是血 有个苏格兰人，后裤袋里插着一瓶威士忌， 在街上行走，不巧，他 被车撞倒了。他一边起身 一边摸摸口袋。他感到有点潮湿。“啊呀！” 他 咕哝了一声，“但愿是血！！” 甘输服罚 “布劳，我往你身上倒一罐水，你的衣 服还不会湿，你相信吗？” “废话，这怎么可能！” “那我们赌一克朗，怎么样？” 格伦打来了一罐水，然后把水往布劳头 上倒，布劳急叫：“停、停、停！我的衣 服都湿透了！” “那就算我输了吧！” 客户牢骚 “好呀！使我头痛的那个供货商人的老 婆一下生了三个小子，活该！他应该尝尝 一个人得到的货超过他的订数是个什么滋 味！” 虚惊一场 某人到银行却况支票，刚刚跨进门，迎面遇 上一个夹着大皮包的人，那人从旁闪过，向门 口走去。后面有个保卫员紧紧跟了上去，一把 逮住那人，夺过他的皮包，给他戴上手铐，把 他推到里面去了。 这位目睹者吓破了胆，自言自语地说；“呀， 我生平第一次差点儿遭劫！” 他向窗口内时一步打听刚才抢劫银行的匪徒 是怎样行劫的。窗口的职员笑了笑，说：“啊， 没那么严重。那只是我们对提前下班的职员实 行一种实质性的处分。” 心 病 难 医 一个精神病人多年来总说他胃里有个啤酒瓶。当他患盲肠炎要到 医院开刀时，外科医生和精神病医生商议，趁机会消除他这个古怪的 幻想。病人慢慢苏醒过来，医生高举一个啤酒瓶说：“我们总算把它 拿出来了。”“你们拿错了。”病人尖声喊叫，“我肚子里的啤酒瓶 不是这个牌子的。” 一个教区里,有个老头吝啬到令人难以置信的程度, 他从来没有往募捐箱里放过钱.虽然他每个礼拜都去教 堂,但总是坐在最后一条椅上,以为这样人们就不会发现 他从没有放过钱. 有一个礼拜天,牧师说: "今天收集到的钱,都将用来拯救堕落女人." 这个老头第一次往募捐箱里放钱,为此大家都非常吃 惊,以为是因为他坐在后边听不清楚或者听错了的缘故. 有一天,老头碰见牧师,居然问道: "牧师,我们凑钱买的那些姑娘什么时候能送来?" 派差使 ＂谁喜欢音乐，向前走三步！＂班长发出命令。六名士兵出列。＂很好，现在请 你们把这架钢琴抬到三楼会议厅去。 惩罚 你知不知道对于女人最大的惩罚是什么？＂＂不知道．＂让她穿 上美丽的衣服， 然后把她关到没有镜子的屋子里．＂ 特殊疗法 一个修女从医疗室里猛冲出来，还没有付款就跑了．接待员感 到很惊讶．医生 出来时，她问道：＂这是怎么回事？＂医生答道： ＂我告诉她怀孕了．＂＂天 啦！＂接待惊呼，＂这是不可能的．＂ 当然不可能，＂他说，但我用这种方法 治好了她的打嗝．＂ 喇叭和枪 话说美国枪械没有严加管制。某个卖枪的因镇上治安太好而卖不出枪。终於他又兼卖 另一样东西喇叭！某天，某人买了个喇叭结果第二天就有三、四人来买枪。後来他又 卖出喇叭，第二天又有人来买枪。基於好奇心的驱使下，他问其中一位买枪的客人。 客人说∶我家对面那「狗娘养的」昨天吹了一天的喇叭，我全家都快受不了了！所以， 我才来买枪……。 智能 约翰在机场侯机，闲来无聊站到一台体重机上，荧屏上马上出现你是约翰，体重８７ 公斤，飞往纽约的字样。约翰十分惊奇，他十分钟以后戴着墨镜又站到这台机器上， 荧屏上马上又显出你是约翰，体重８７公斤，飞往纽约，约翰更加感到神奇了，他跑 进盥洗室刮掉胡子，换掉衣服又来到这机器前，荧屏上马上显出你仍是约翰，你的体 重仍是８７公斤，你的飞机已于２０分钟前飞走了。 爸爸 周末早上，丈夫还在拥被高卧，他的朋友托尼却已来访， 我连忙对三岁的女儿说“快，快去叫爸爸。” 女儿望着我，迟疑了一会儿，走到托尼面前，怯生生地喊了一声：“爸爸” 军事家庭 杰克是个典型的军人，他的家庭也有浓厚的军事色彩。例如，厨房门口写着“食堂”， 客厅门口写着“会议室”，儿子的卧室写着“男兵宿舍”，女儿的卧室写着“女兵宿 舍”。客人们想夫妻的卧室一定挂着司令部的牌子，出人意料的是牌子上写着：“新 兵培养中心”。 富翁想徵聘一位司机，他问每个求职者能驶向悬崖多近而不至掉下去。『三十厘米，』 第一个说。『十五厘米』第二个说。『八厘米，』第三个说。但是下一个求职者说： 『我会尽量不驶近那个地方，越远越好。』『我就雇用你，』富翁当即决定。 一个纽约人来到赌城拉斯维加斯开会，顺便带了９岁大的儿子去看表演。舞台上几个 女郎身上只有几片蓝色和灰色的布片，９岁的儿子叫道：哇！哇！好棒啊！父亲急得 不知如何处理这局面，但这男孩又兴奋地叫道：她们穿的和我们的校服一样颜色！ 飞机上，一位乘客问邻座：刚才机长说了些什么？邻座回答：机长说，拉斯维加斯就 要到了，请大家系好钱袋。 他想干什么 两对夫妻打了好几个小时的桥牌。这时，其中一个男人站起身去了卫生间。和他打对 家的妻子叹了口气，说：“今天晚上，我这还是第一次明白他想干什么。” 改变习惯 吉米说他实在看不惯他妻子的有些行为。他真想让她彻底改变一种习惯——呼吸。 准备早餐 “亲爱的，你只要再准备一下烤面包和咖啡，我们就可以吃早饭了，”新娘含情脉脉 地对新郎说。 “早饭都有点什么？”新郎问。“烤面包和咖啡。” 守法司机 交通警察看到一个司机在大街上吃力的推着汽车，就走过去问：“先生，是不是出了什么故障或者是没汽油了？” “哦，不是这样的，只是因为刚才我发现忘记带驾驶执照了。” 宁死不招 加州的一个小镇发生了一宗银行抢案，抢匪才刚刚把钱藏好，就被警长逮捕了。由於抢匪是从太平洋的那一边偷渡过来的，又不会讲英文，警长只好去请麦克阿＄来当翻译。 经过一阵疲劳轰炸式的拷问，抢匪坚持不肯说出钱藏在那里。没办法，警长只好扮起黑脸，咆哮地叫麦克阿＄告诉抢匪：“再不说，把他毙了！”麦克阿＄忠实地把警长的意思传达出去。大概翻译得太好了，抢匪吓得语无伦次：“钱在镇中央的井里，求你叫他饶我一命。” 麦克阿＄转过头来，神情凝重地告诉警长：“这小子有种，宁死不招。他叫你毙了他吧。” 产后去世 有个赌徒从家里拿了一千法朗去赌, 几小时后, 他回来了. 妻子忙问:"那张大票子 生孩子没有?" "生了, 生了,"赌徒从衣袋里掏出两张十法朗的钞票, 哭丧着脸说, "不幸的是, 它们 的母亲去世了." 对话 时间: 1996年十月. 地点:加拿大纽芬兰省海域内. 事件:美国海军与加拿大人对话. 美国人: 请改变你的航道,向北偏15度,以免相撞. 加拿大人(语气温和):建议你向南改变航线15度,以免相撞. 美国人(语气强硬): 这是美国一艘军舰的舰长在说话.我再说一遍,改变你的航向. 加拿大人:我再说一遍,改变你的航道. 美国人(怒):这是美国密苏里号航空母舰,我们是美国海军火力强大的战舰.命令你 马上改变你的航道! 加拿大人(语调坚定):这里是灯塔,我们不能改变航道!请回答.....听见没有,喂喂, 喂喂,....(对话消失). 女儿在厨房洗碟子，电话铃响了，她拿起电话，回答说：“妈妈大概在洗澡，请 你等我去看看。” 她伸手扭大热水龙头，马上传来一声尖叫，她关上水龙头说： “是的，她还在洗澡。” 倒霉 詹妮小姐下夜班，看见一个男子大张着双手向她 走来。“流氓！”詹妮小姐 骂道，一脚向那男子 的腹部踢去。只听哗啦一声，男子大叫：“天那 ！第三 块玻璃还是没能拿回家！” 作用 一主妇指这柜台上的美容用品问中年老板: "这玩意儿到底有啥用?" "有啥用?"老板理直气壮地叫来一位年轻售货员,"妈,让这位太太瞧瞧您 的皮肤!" 神父 有个神父甚爱打golf,但球技甚烂,每次球没打进洞里, 就会大骂一声"Fuck!又没打中!!" 有一天,一个修女实在看不过去了,劝告神父说: "神父啊!!我们神职人员不可以说脏话的.不然上帝会用雷电劈你喔!!" 神父心里虽明白,但是就是改不掉这个坏习惯.... 有一天,神父又在打golf了,这一次,神父还是没进,他一气之下又冲口而出: "Fuck! 又没打中!!" 修女闻言正欲劝解,谁知霎时间阴风惨惨,云如涌浪,天地为之色变,草木为之愁颜, 不多时,只见天上一道疾电破空而下,劈中虔诚的..........修女!!!!! 躲过一劫的神父在一旁惊魂未定,突然从天上传来一声: "Fuck!又没打中!!" 指挥员 一名游击队员在给孩子们讲战斗故事。 他忽然向一个12岁的男孩提问：“科诺普卡，假如你是游击队的指挥员， 为了不让敌人使用铁路，游击队应该采取什么行动？” 科诺普卡站起来大声回答：“必须迅速占领售票处，并烧毁全部车票！” 劫机 一名歹徒拿一包炸药劫持了飞机，飞机在飞行中油料耗尽必需紧急降落。 机长对劫机犯说:"赶快把炸药扔出飞机，在迫降中会有剧烈振动会爆炸的。" 劫机犯喝道:"少废话! 我还没听说过沙丁鱼罐头会爆炸." 健驴 阿拉贡骑着他心爱的毛驴去城里, 他的好朋友开着车路过, 请他坐到了车里, 毛驴自己跟在车后, 车开到了30km/h, 毛驴在后面紧紧跟着, 一会车速到了60km/h, 朋友担心的问:"你的驴恐怕不行了, 它的舌头都伸出来了." "向哪边伸?" "左边." "保持方向, 它要超车了." 勇敢和谨慎 晚饭后，汤姆和妻子简坐在长沙发上悠闲地交谈着。 “亲爱的，勇敢和谨慎的区别是什么中呢?”妻子问道。 汤姆想了一会儿，然后说： “让我举一个例子来说明吧，一个人在大饭店用餐后却不给侍 者任何小费，这就是勇敢。” “我明白了，那么谨慎呢?” “第二天换另一家饭店那就是谨慎。” 阿尼克 殷勤补过 旅馆经理对全体侍者命令道：“今天，对每一 个顾客都要客客气气，要热情侍候。” 　“怎么回事？要来重要人物？”一名侍者轻声 问道。 　“不是，”经理说，“因为今天的米饭烧糊了 。” 积少成多 “格林太太，你丈夫过生日，你打算送什么 礼物？” “噢，一百支雪茄。” “这得花多少钱？” “不花 一文。我只不过每天从他的烟盒里取 出两支积攒起来 罢了。” 有两个男人和一个美女，沉船後游到一个荒岛上，他们之间会发生甚麽事呢？ 如果那两个男的是意大利人，他们会大打出手，然後赢了的那个占有美女； 如果那两个男的是法国人，他们会相安无事，然後分享那位美女； 如果那两个男的是英国人，他们会设法谋杀那位美女，然後他们自己搞在一起； 如果那两个男的是新加坡人，他们甚麽都不干，专心等候李先生的指示。 妻子怀疑先生有外遇..请私家侦探跟踪他 以下是侦探提供的报告.. 「今天下午..你先生到过一家美容院.一家时装店.一家茶店」 「他一定有不轨行为」 「不..夫人.他在跟踪你」 律师的儿子回家迟了,邻居问他:"你回家 迟了,会挨你爸爸打吗?" "不会的,我爸爸是律师,如果要打我,我母 亲就会申请缓刑,再向我祖母提出上诉,就可宣无罪." 午夜迟归的约翰，刚巧遇到小偷从他家中出来， 他很轻易地抓住那小偷，并从他身上搜出很多自己太 太穿戴用的饰物．金戒指．钻石之类。 约翰：“朋友，假如你能够回答我一个问题，我就 不把你送去警察局。” 小偷：“什么问题？” 约翰：“你能不能告诉我，你是如何偷进卧室，而 不惊醒我太太的？” 一位先生在酒吧喝了一杯白兰地.结帐的时候,女 招待仔细看了看付的钱,沉下脸来说:"先生,您这钱是 假的"! 那位先生抬起头,漫不经心地问:"你们这白兰地 是真地吗?" 妙舌生花 某作家写了个剧本，得到一位上了年纪的富孀资助演出。排演的时 候，他随口问她贵庚几何。 “你问这个干什么？”对方冷冷地反诘。 “夫人，”他立即解释，“我只是想知道，女人风韵最佳的时候究竟是 多大年纪。 为了700人 一位女作家在海上度假时，在日记上这样写着： 第一天：我遇见了船长。 第二无：船长要我和他同桌共进晚餐，我真荣幸。 第三天：船长带我四处去看，甚至还带我到船的驾驶室去。 第四天：船长带我看他的房间，向我提出要了要求；这简直不像他这 种身份的人做出来的。 第五天：他又坚持了，不说如果我不答应，他要把船弄沉。 第六天：我救了700人。 生活 一位不得志的作家在报告中反复提到“生活”。 一入学生问他：“什么叫生活？” 他回答说：“生活就是死亡前的灾难。” 白跑 马里什同爸爸去看田径赛。 “爸爸，为什么这些叔叔都跑得这么快呢？” “这是在比赛，谁跑第一谁就是冠军，还可以拿到奖品。” “可后面那些人为什么还跑呢？他们能得到什么呢？” 显然是新手 美国人甲：“听说你们州长当选了？” 美国人乙：“你会不知道，我们美国人对政客只有一句评语，” “怎么说的？” “如果说一个政客是正直的话，那么，他显然是个新手。” 决不受礼 某承包商因为生意上的原因，准备用一辆新型、豪华的小轿车向一位 议员行贿。这位议员却板起脸说：“先生，通常的行为准则以及我本人的 基本荣誉感，都不允许我接受这样的礼物！” 承包商说：“阁下，我很理解您所处的地位，这样吧，我以10美元的 价格把这辆车卖给你。” 议员考虑了片刻，断然答道：“既然如此，我就买两辆。” 当了女主人 卡嘉上里达家里做客，看见里达正围着围裙在厨房里做饭，她感到十分奇怪： “怎么回事，你自己做饭啦？” “现在我只得自己做饭了。” “为什么？你的女仆呢？” “她结婚了，现在当了女主人啦。” “是吗，跟谁结的婚？” “跟我。” 得奖来的 “你这手表不错，在哪买的？” “不是买的，是赛跑得第一名，得奖来的。” “是吗，有多少人跟你一起赛跑？都是些什么人？” “连我一共三个人。警察得第二名，丢表的人得第三名。” 猫 卡特夫人家的小猫在外面乱窜，一会屋顶，一会地窖。受扰的邻居敲开卡特夫 人的门：“你家的猫怎么这么疯跑？” “是这样，”卡特夫人解释：“我让兽医刚给他做了手术，最近正忙着到处取 消原先订好的婚姻。” 传 令 据说，美军 1910 年的一次部队的命令传递是这样的: 营长对值班军官: 明晚大约 8点钟左右，哈雷彗星将可能在这个地区看到，这种 彗星每隔76年才能看见一次. 命令所有士兵着野战服在操场上集合，我将向他们解 释这一罕见的现象. 如果下雨的话，就在礼堂集合，我为他们放一部有关彗星的影片. 值班军官对连长: 根据营长的命令，明晚8点哈雷彗星将在操场上空出现. 如果 下雨的话，就让士兵穿着野战服列队前往礼堂，这一罕见的现象将在那里出现. 连长对排长: 根据营长的命令，明晚8点，非凡的哈雷彗星将身穿野战服在礼堂中 出现. 如果操场上下雨，营长将下达另一个命令， 这种命令每隔 76 年才会出现一次. 排长对班长: 明晚8点，营长将带着哈雷彗星在礼堂中出现，这是每隔 76 年才有 的事. 如果下雨的话，营长将命令彗星穿上野战服到操场上去. 班长对市士兵: 在明晚8点下雨的时候，著名的 76 岁哈雷将军将在营长的陪同下 身着野战服，开着他那"彗星"牌汽车，经过操场前往礼堂. 不同任务 有一次，海军妇女队队长问谁愿意参加唱诗班。 “你来如何?” 她问一位金发尤物。 “我不会唱歌。” “不要紧，”她说，“你的任务是使水兵两眼向前看。” 美国有一年经济危机, 失业率很高.一个人工作找了很久,也没 找到.一天他在街上转悠,忽然一个人从建筑工地的楼上掉了下 来.他急忙跑到工头那儿问:"那个刚掉下来的人的工作我可以 接替吗?" 工头说:"不行,他的工作已经有人接替了.""谁呀?" 就是把他推下来的那个人呗! 您搞错了 在公园的长椅上坐着年轻貌美的威廉夫人，怀里抱着一个可爱的婴儿。一位中年绅士走 了过来。 “多么可爱的小姑娘啊！”绅士拉着婴儿的手自作多情地说，“白白的、嫩嫩的，像个富有魅力的贵妇人的手。” 威廉夫人把婴儿往怀里拉了拉，冷冷地说：“先生，您搞错了两件事：其一，这孩子是 个男孩，其二，您握的是我的手。” 本性难改 “亲爱的，我非常爱你，”丈夫对妻子说，“但是你不要再对每件事都挑毛病了。这 都快使我发疯了。哎，我敢打赌，你不能有一分钟不挑毛病。” “好吧，咱们现在开始。”妻子说道。 一会儿，她脱口而出：“这房子里热得像地狱一样。你为什么总是把空调器开得很小 呢？”“哈！我就知道你不能有一分钟不挑毛病。”丈夫不禁喊出声来。 “就算这样，”妻子承认说，“我坚持了多长时间?”“三秒钟。” “三秒钟，去你的吧！”妻子对丈夫吼道，“难道我没有告诉过你不要买外国表？那 些表根本不准！”下班后约翰夫人在她丈夫下班回来时还在打扫房间，她的衣服又脏又旧， 头发乱蓬蓬的，一脸灰尘。她丈夫说：“我劳累了一天回来，见到的你竟是这样？”他们 的邻居，史密斯夫人恰巧也在场。她听到约翰先生的话，赶忙跑回家，仔细地梳洗打扮一 番，等丈夫回来。 史密斯先生回到家时已经很晚了，慢慢地推开门，见到妻子一怔，随即气愤地吼道： “今天晚上，你要干什么去?” 许诺与胡话 拥有百万家产的富翁欧里病倒了，卧床不起，看样子病得不轻。 他对医生说：“大夫，如果我康复了， 我捐５０万美元给您的新医 院。” 医生很高兴，竭尽全力为他看病。几个月后欧里恢复了健康， 医生说：“您感觉良好，这使我很高兴，我想和您谈谈应为新医院 捐款的事儿。” 欧里很惊奇地说： “是我答应的？” “是啊，您亲口对我许诺的。” “我病得多厉害呀！甚至说起胡话来了！” 留 言 一个人从商场出来，发现他停在停车场上的汽车的侧面被撞瘪了， 雨刷下夹着一张留言条，他赶忙去看。条子上写着：“当我写这 张条子的时候，有十来个人在周围看着我，他们想我正在写下我 的姓名、电话和保险公司，但是我没有。” 小儿麻痹 有一次在日本的地下铁中, 有位小儿麻痹的乘客在月台慢慢地走向另一头. 此时有个调皮的年轻人在後头学他一跛一跛的姿势走了起来, 不但从後头追上他, 甚至与他并肩同行了一段距离. 小儿麻痹的乘客不想理他, 仍旧依自己的步伐前进, 年轻人索性超前他, 然後 再放慢步调等他赶上来. 此时, 一位穿着西装打领带理平头, 看似日本黑社会分子的男子从後头奔来, 一脚踢在小儿麻痹的乘客的身上, 大骂: "人家小儿麻痹已经很可怜了, 你还学人家!" 接着拳头如雨点下...... 而那年轻人见景则迟迟不敢恢复正常, 始终保持原姿势前进... 星空 福尔摩斯和华生医生一同外出野营，吃完晚餐后他们疲倦地睡着了。 几小时后，福尔摩斯醒过来轻轻推了推他忠实的伙伴，“华生，看看 天空，告诉我你看到了什么”华生回答说：“我看到了成千上万的星星” “你可以由此推理出什么呢？” 华生沉思了一阵，“从天文学上，它告诉我宇宙中有上百万的星系和 亿万颗星球。从星相学上，我观察到土星在狮子座，推断出现在的时间大 约是三点一刻。从神学上，我看到了上帝的全能，而我们是多么地渺小和 微不足道。从气象学上，我认为明天会有很好的天气 -- 你又由此推断出 什么呢？” 福尔摩斯沉默了一会儿，“华生，你这个傻瓜，有人偷走了我们的帐 篷了！” 各国人的看法 有名记者问3国人民：请问你们对世界缺乏粮食有何个人意见? 美国人说：我不明白什麽叫缺乏? 埃塞俄比亚人说：我不明白什麽叫粮食 新加坡人说：我不懂什麽叫个人意见 一辆军用卡车陷入泥潭,幸亏后面来了一辆吉普车,车上跳下几名军官,他们费了 九牛二虎之力才把卡车推出泥潭. "My God!",其中一位军官气喘嘘嘘地说:"你的车够沉的,车子里是些什么东西? "28名新兵."司机回答. 喝醉了 有两人喝醉了,被警抓到了.有人问:"警官,你怎麽 知道他们醉了呢?" 警官说:"一人正在扔钞票." 那人问:"另一人呢?" 警官说:"把钞票捡起来,还给那人." 法国人说：“美国人的爷爷的爷爷，就不知是哪国人了。” 美国人回：“法国人的孙子的孙子，就不知是哪国人了。” 法国人喜欢讥笑美国历史太短，说：美国人回想自己家族的历史， 总是想到祖父那一辈就想不上去了。美国人回敬说：当法国人思考 这个问题时，常常为谁是他的父亲而感到迷惑。 剧院里正在上演悬念剧,观众中突然有个人 站起来大叫"凶手究竟在哪里?要快点找出来!!" 一个男人在他后面历声喝道"如果你还不坐下, 凶手就在你后面!!!!" 种 地 一个山民因冤狱被关进牢里，春天，他收到妻子的 来信，信中描述了生活的种种困难，最后写道：“眼下 就该播种了，可咱家的地却没人翻。” 山民看了很是难过，思量了一夜，第二天给妻子回 信道：“种地的事不急，我进来之前在地里埋了一坛元 宝，等我出去以后咱们不用靠种地过活了。” 犯人的信看守都要检查，这封信也不会例外。 几天后，山民的妻子又来信道：“昨天，来了一帮 人，把咱们的地全翻了个遍，比你在家时翻得还要深。 他们是你的朋友吗？” 山民马上回信道：“不要管那么多，现在可以种地 了，明年的日子还要靠秋天的收成呢。” 绝 望 护士小张：“35床的病人彻底绝望了。” 护士小丁：“不会吧？他还年轻，病也还有救，刚 才他还握着我的手，兴奋地聊了好久呢。” 护士小张：“就是因为这样。他太太看到了这一切， 要知道，他的医疗费都是他太太出的。” 自己买 有一个农夫,天天喂他的猪吃馊水，结果被"动物保护协 会"罚了一万块。因为孽待动物. 后来农夫改喂猪吃天山雪莲，结果被"动物保护协会"罚 了一万块。因为浪费食物. 有一天又来巡视农夫,就问农夫喂什么给猪吃. 农夫说:"我不知道喂什们才好,我就每天给它一百块, 让它自己出去吃." 无题 在一偏僻的道路上，游客驾车与一辆本地的货车相撞，两人下车查看毁损情形。 「看来损坏的不严重，我们何不喝点酒压压惊。」本地人看了之后说，便从破旧 的货车上拿出酒瓶，拔开盖子递给游客。游客喝了一大口後把酒瓶还给本地人， 那人把瓶子大力拍上，把酒瓶放回车上。「你自己不喝点吗？」游客问。 本地人摇摇头：「待会我等警察来过再喝」 找长筒袜 一个小伙子每天晚上在安格吉洛对面单元的窗口用望远镜看她。这使她很 生气。有一天清晨，她打电话给那个小伙子。 “您好！我就是你对面单元里的姑娘。你还记不记得，昨晚上我把长筒袜 子放在哪里了？ 威胁 邮递员为要划船才能把一张生日卡送交灯塔管理人，心里很是不高兴。 “如果你再嘀嘀咕咕”，灯塔管理人说，“我就要订阅日报了”。 足球的贡献 记者问俄可拉荷马大学足球教练布得认为足球对体育锻炼有哪些贡献。 “绝对没有。”布得立即回答。 “绝对没有？”吃惊的记者问，“为什么？” “足球是22个需要休息的人在场上拼命地跑，而四万个需要运动的人却坐在那里看！” 头发问题 汤姆：“妈妈，爸爸的头发怎么那样少？” 妈妈：“那是由于他用脑过度。” 汤姆：“你的头发怎么这么多？妈妈！” 妈妈：“因为...... 印地安人的忠告 阿波罗计划中，美国的宇航员在印第安纳的航天基地训练。几个 印第安人很好奇，就问他们是在干什么，宇航员告诉他们说是要飞向 月球。印第安人聚在一起商量了一番，就提出要宇航员给月球上的人 带个字条，宇航员们觉得有趣，就答应了。一会儿，印第安酋长亲自 送来了字条，是用印第安语写的。宇航员看到这么郑重其事的样子感 到很有趣，想知道这些印第安人都说了些什么，就找去找人翻译。结 果字条上写的是：不要相信这些人，他们是来抢夺你们的土地的。 房顶上的标语 一个建在机场旁的电影制片厂，为了避免飞机嗓音的干扰，在房 顶上写了一条大标语：“请安静！”每个字母有八尺见方。 结果，这条标语带来了更大的噪声，因为飞行员们个个都想看清楚房 顶上写的是什么，竞相都把飞机飞得更低了。 今日客满 一位打扮得很入时的小伙子来到一家高级饭店，一进门就递给招待员一个先令。 招待员不解地用手掂着这个先令，讪笑着说：“怎么，你是要用这钱订酒席吗？” 小伙子忙解释说：“不，不，呆会儿我陪一位姑娘来，请你大声对我们说： ‘今日客满，请到别处’就行了，谢谢啦！” 电话 一名男子在上班时打电话回家。 接电话的是一位陌生女子。 男子说，『你是谁?』 『我是这里的女佣。』女子回答。 『我们没有请女佣啊。』 『今天早上这间屋子的女主人叫我来的。』 『喔，那我是她先生。她在吗？』 『可是...她和一个我以为是她先生的男人 在楼上的房间里....做..做..做一些夫妻才能做的事。』 男子听了非常火大。他对女佣说， 『听著，你想不想赚$50,000元?』 『我要你去把我书桌里的枪拿出来 然后把那两个奸夫淫妇给毙了!』 女佣把电话放下。 男子听到脚步声，接著两声枪声。 女佣回来拿起电话。 『我要怎么处理尸体呢?』 『把他们丢到游泳池里去。』 『什么游泳池啊?』 『啊？....嗯..请问这只电话是2621-5656吗 刑满之日 妻子半夜醒来，发现丈夫不在身边。她到处寻找，后来听见地 下室有抽泣的声音。 妻子发现丈夫一个人在地下室抽泣。 “你怎么了？” “你还记得２０年前，我使你怀孕吗？” “记得。” “你父亲要挟我，要么和你结婚，要么就进监狱？” “是的。” “如果我进监狱的话，今天半夜就该刑满释放了。” 女性的地位 在波斯湾战争前，一位女性解放者在科威特，她发现科威特的女性 习惯性的走在男伴的后面五公尺。她发表文章攻击科特的大男人主 义。最近她回到科威特，发现现在是男人走在女人的后面五公尺。 她非常兴奋地问一位女士：“真了不起，你们女性是怎样争取到你 们的地位的？”这位科威特女士说：“地雷” 下水道里的金币 一个小孩去给父亲送饭，路上看到一个工人在清理 下水道，好奇地停住脚步说：“前几天，我哥哥的一块 金币就是从这里掉下去的。” 工人的眼睛顿时一亮，故意漫不经心地说：“孩子， 快去送饭吧，等一会儿饭要凉了。” 父亲吃完饭后，小孩拎着空饭盒回家，看到工人还 在下水道里浑身大汗地翻动着泥水。见到小孩回来。工 人直起腰问道：“金币肯定是从这里掉下去的吗？” “没错，”小孩说，“第二天我爸爸就是从这里掏 出来的。” 有一头驴 有一对夫妻经常吵架。一天，经过一番激烈地争吵 后，丈夫说：“这到底是为什么呢？难道我们就不能像 两匹马一样拉着人生之车往前奔吗？” 妻子回嘴道：“这不可能。” “为什么？” “因为我们当中有一个是头驴。” 女人的天性 上帝用亚当的一条肋骨制造了夏娃，俩人生活 在一起。一段时间后，亚当晚归了几天，夏娃开始 生气了。 “你一定是在追其他的女人。”她指责说。 “请讲一点道理吧，”亚当反驳道“你是地球 上唯一的女人。” 争吵持续到大家都因疲倦而睡着为止。突然， 亚当被胸前的一阵戳动给弄醒了，睁开眼一看，是 夏娃。 “咳，你到底想要干什么？”亚当问。 “检查你的肋骨。”夏娃说。 最佳推销员 一个上门推销商厌倦了天天出去推销圣经，他决 定雇佣三个人替他去推销。招聘告示贴出去后有三个 人来应聘。 第一个人面试时说：“我愿意为你推销圣经。” “好，你被录取了。拿着这些东西，去推销吧。” 第二个人面试时也说：“我愿意为你推销圣经。” 他也被录取了。 第三个人面试时说：“我，我，我非，非，我非 常愿意，愿意，愿意为你，你，你推销圣，圣，圣经。” “不行，”雇主叫道，“这个样子怎么能推销圣经呢？ 我不能雇你。” 面试者请求道：“可，可，可是，我，我，我很， 很，我很希望，望，得，得到，得到这，这个，这个 工，工作。” 因为也没有其他的求职者了，于是雇主说：“好吧， 先试用一下吧，我希望你真能推销出去一些圣经，去吧。” 一天结束后，第一个雇员报告成绩：“我今天推销 出去了８本圣经。” 第二个雇员报告成绩说：“我今天推销出去了１１ 本圣经。” 第三个雇员说：“我，我，我今，我今天，天，天推， 推销了，了，了２，２，２８，８本，本圣，圣经。” “太好了，”雇主说，“你的成绩比那两个懒鬼强多 了。你一定有什么诀窍，为什么不把你的推销技巧告诉大 家呢？” 第三个雇员说道：“我，我，我只，只是，只是，只 是走，走，走上，上前，敲，敲，敲开，敲开别，别人， 别人的家，家门，向，向，向他，他，他们读，读，读一， 一段圣，圣经，圣经中的故，故，故事，然，然后礼，礼 貌，礼貌，礼貌地，地问，他，他们，他们是，是，是想， 想买，买一本，买一本自，自，自己，自己看呢？还，还 是，还是想，想，想听我，我，我继，继续，续，续往， 往，往下，下，往下读？” 煮咖啡 在澳大利亚的一个跳蚤市场里， 一群观光客走到一个吹玻璃的摊位前面停下来观看。 只见摊位里的人手持浅锅在火上烧, 不久更吸引了许多同团的人上前围观， 大家等着看玻璃工匠大显身手。 这时只见他把锅里深褐色的液体小心翼翼的斟入一个塑胶杯中， 导游问他：「你现在做的是什麽？ " 我在煮咖啡。" 那人答道。 走私 有一位老头子每天都会骑着一辆摩托车从加拿大进入美国。 边界警察觉得很奇怪，有一天就将那人拦了下来，问道： 「你背上每天背的那个包包里面放的是什麽？」 老头说是沙！警察不信！？ 检查一看果然是沙，又有一天检查还是沙， 终於有一天，警察实再受不了了，将那老头再拦下来说： 「你老实告诉我，你是不是在走私，我绝对不抓你！」 老头说：「是！」 再问：「那你走私的到底是什麽？」 「摩托车！」 你要打赌吗？ 有一男子走到酒吧¨ 向酒保说：「 你要打赌吗？五十美元，打赌我能咬我的眼睛！」 酒保认为不可能，就接受了打赌。 那男子把假眼球拿出来，放在嘴里咬。酒保只得乖乖赔了五十美元。 不一会，男子又说：「 要不要翻本？五十美元，打赌我能咬我另一个眼睛！」 酒保看那人没用导盲犬，也没拿拐杖，不可能两眼都是假的，於是就接受了。 那男子把假牙拿出来，咬另一个眼睛。酒保只得又乖乖赔了五十美元。 男子喝完啤酒，走出酒吧。 不久又回来了 … 他对酒保说：「 好了，这次让你有机会翻本，一百美元， 打赌我能 尿进廿 外的啤酒杯，一滴也不漏！」 酒保心想：这怎麽可能？於是就接受了。 那男人拉开裤头就 起尿来，但 的满地都是，一滴也没射进酒杯。 酒保高兴极了，拿回一百元，吹起口哨清理残局。 此时，他看见那男子笑咪咪地在一旁抽烟， 很惊讶，於是就问：「老弟，我不明白为什麽你那麽开心， 你不是已经把赢来的一百元输回给我吗？」 那人笑咪咪答道：「老兄，看到那边的叁个人吗？ 我和他们打赌五百美元，说我能在你的酒吧里撤尿， 而你会笑咪咪、吹着口哨清理残局！」 宴会 一日，一位富有的家伙在他家举办宴会，他富可敌国拥有一切。 他有钱、一栋位於比佛利山庄的别墅、美酒、美女、轿车、私人飞机等.... 这家伙有点怪异，他养了一池的鳄鱼。 於是，他与他的朋友们站在池塘旁喝酒，且渐有醉意。 这男子爬上救生员坐的高椅，所有人都看着他； 他要求所有人都安静并说： 『好，第一位游过这池塘的人将拥有我所有的钱。』 没有人动......他看所有的人一下又说： 『好，第一位游过这池塘的人将拥有我所有的钱及别墅。』 还是没人动........富翁开口： 『这麽办，第一位游过这池塘的人将拥有我所有的钱、别墅、轿车及私人飞机。』 还是没人动，甚至连眨眼都没有。这家伙又说： 『好，第一位游过这池塘的人将不但拥有我所有的钱、别墅、轿车及私 人飞机，更拥有我的一切如美酒、股票、债券、投资事业及美女等。』 一声水溅声，有人身羡於池塘内； 他的四周都是鳄鱼，他像泰山一样的在池中翻滚、打斗、躲避； 终於，他游到池塘的对岸，富翁跳下高椅并向他跑去: 『真是不可思议，我从未想过有人会这麽做，你现在是否要我的金钱？』 『我不要钱』 『你现在是否要我的房子？』 『我不要房子』 『你现在是否要我的轿车及私人飞机？』 『我不要轿车及私人飞机』 『你现在是否要我的债券、股票及其他财产？』 『我也不要这些东西』 这富翁看着他并说：『你到底要什麽？』 『我要那位推我下水的混蛋』 说谎 一个已婚的男子和他的秘书正进行着火辣辣的婚外情。 有一天下午他们再也隐藏不了心中燃烧的热情。 两人就一路冲到秘书的住处缠绵了一整个下午。 完了之後，两个都累了，一直睡到八点才醒来。 他们赶快整装，然後这位男子要秘书把他的鞋子拿到外头的草坪去磨一磨。 她觉得莫名其妙，不过还是照他的话办。 男子终於回到了家。 太太在门口迎接他回来，生气的问他上那儿去了。 男子答道：『我说不了谎。我的秘书和我正有一手。我们俩今天早下班， 然後到她住的地方缠绵一整个下午，一直到累了睡着了。 那是为什麽我晚归的原因。』 太太瞧瞧他，注意到了他的鞋子，然後说： 『我看到你鞋子上有草，你又跑出去打高尔夫球了，对不对？』 精打细算 在到欧洲出公差之前，一名男子开着劳斯莱斯到伦敦市中心的银行， 进去要求预借现金$5000元。 贷款部服务人员，相对的，要他留下抵押品。 『嗯，那麽，这是我劳斯莱斯的钥匙，』男子说道。 贷款部的人员马上拿着钥匙把车开到地下室的停车中心去保管， 接着就拿$5000元给他。 两个礼拜以後，男子走进银行的大门，要求偿还贷款并把车领回。 『您预贷的款项为$5000元，加上$15.40元的利息，』贷款部的人员解说道。 这名男子开了张支票後准备离去。 『先生等等，』贷款部人员说道，『在您离开後，我发现您原来是个百万富豪。 您怎麽可能会需要向银行借$5000元?』 男子微笑道，『在曼哈顿有什麽地方可以停两个礼拜的车子却只收$15.40呢?』 我有罪 他对神父说:神父，我有罪． 神父说：孩子，每个人都有罪． 你犯了什麽错？ 那人回答：神父，我偷了别人一条牛，我该怎麽办？ 神父，我把牛送给你好不好？ 神父回答：我不要．你应该把那头牛送还给那位失主才对． 那人说：但是他说他不要． 神父说：那你就自己收下吧． 结果，当天晚上神父回到家後，发觉他的牛不见了． 散步趣话 一位胖太太正沿着街道散步时，一个与她素不相识的男孩紧紧地跟 在她的后面。“你这是干什么？”胖太太回过身问，“你是有什么 事情要问我吗？”“不，夫人。我只是喜欢在阴凉的地方散步。” 问路 “请问，去警察局怎么走？” “到对面的肉店不付钱就拿几块牛排，10分钟后你便到警察局了。” 哭泣的丈夫 三个人死后进入天国。当他们到达时，圣彼得问第一个人，生前是 否忠于他的妻子。此人承认做错了两件事。圣彼得说他只能得到一 辆小型轿车。然后圣彼得又问第二个人是否忠于自己的妻子，第二 个人承认做错了一件事。圣彼得说他可以得到一辆中型轿车。第三 个告诉圣彼得，直到死他都一直忠于妻子。圣彼得夸奖了他并赠给 一辆豪华轿车。一星期后，三个人开着车外出，碰上红灯，他们全 停下来。坐在小型车和中型车的两个人看到豪华车上的人正在哭， 于是就问他：“你有了那么好的车，还哭什么？”那人说：“我刚 看到我妻子，她只踩了一辆小滑轮车。” 酒鬼的狗 “你家的狗怎么走起路来总是七歪八扭的？”“可怜的小东西，我 丈夫从酒店里回家的时候，它总是跟着，跟惯了。” 误会 一名欧洲游客在东京的商店里寻找运动衣的拉链。他用手势向一位女售货员比划好一阵子。终于，女售货员明白了，拿出了一把用于剖腹的剑放到柜台上。 领带的问题 某人在沙漠中行进了大半天，口渴得直冒烟。在他快要走出沙漠时，遇到了一位推销员。后者劝他买一条领带。他说：“你行行好吧，我渴得连衬衣都想撕开了，还买什么领带！”推销员讨了个没趣便走开了。这个可怜人总算在沙漠边上的一个小镇上找到了一家酒吧，他急不可待地要冲进去。于是他对门口的侍者说：“快给我点什么喝的吧！”他的喉咙都快枯哑了。“对不起，先生，不打领带者是不许进入的。”这个侍者很有礼貌地拒绝了他的要求。“什么！......” 加　油　站 非洲某城市郊外的汽车加油站贴出布告：“给油箱和油桶加油，仅此一地。往前所有的加油站都是海市蜃楼。” 意外灾难 有个手臂骨折的家人，向护士叙述发生意外的经过。他说那天他在田里工作，觉得胶鞋里有块石头，于是便在田间的高压塔旁，一手扶着铁塔，一边猛力摇着他的腿。碰巧有个工人经过，见他身体在拌动，以为他触电，便拾起木棍用力打他的手臂，于是他来到了医院。 小小骗局 一个男人牵着一个七、八岁的男孩走进一家理发店 。这人很急，要理发师先给他理，再给小孩理。他 坐在理发椅上，小孩在一旁等着。他理完发后，站 起身来，把孩子抱到椅子上，然后对理发师说，他 有点急事去去就来。理发师给孩子理了发，叫他坐 到旁边的椅子上等着。半个小时过去了，又过了一 个小时，理发师对小孩说：“别着急，你爸爸就会 回来。” “我爸爸？他不是我爸爸。”小孩说，“我在街上 玩，他走过来对我说：‘小孩，过来，跟我理发去。’” 应付自如 “亲爱的朋友，我把钱包忘在家进而，请借我 一百图格里克吧！” “给，拿着，这是车费！乘公共汽车回去取钱 吧！” 男人气概 一位卡车司机走进一家餐馆，要了食物后坐了下来。 正在这时，门外来了三个穿皮夹克的小伙子，他们从急驰的摩拖车上跳下来进了餐馆，一个抢走了卡车司机的汉堡包，一个端起他的咖啡一个吃起了他的苹果饼。卡车司机一句话没说，付了钱就走了。 三个小伙子走到收款小姐面前说，“他不象个好男人”，收款小姐说，“他也不象个 好司机，你们看，他轧烂了三辆摩托车。” 捐款 一个替教会募捐的小姑娘对一个老先生说：“请您为上帝捐些钱吧。”老先生看了一 眼小姑娘，慢悠悠地说：“我想我会比你先见到他老人家的，到时候我亲自交给他吧！”。 一位年轻的女士坐在抛锚的车里等待有人能给与帮助。终于两个男人来到她的面前。 “我的汽油用完了，你们能帮忙把车推到加油站吗？”两名男士立即上前卖力地推车，这样他们推车越过了几个街区。过了一会儿，一个精疲幡尽的男人抬头一看，见他们刚刚路过了一个加油站。“你为什么不把车拐进去？”他大声喊道。“我绝不去那儿。” 女士大声回答，“他们那儿的服务态度不好。” 谁 在 开 车 两个醉汉驾着汽车狂奔。 甲：“小心点！前面是急转弯。” 乙：“什么？不是你在开车吗？ 店里的规矩 经理：记住，这个店里的规矩是－顾客永远是对的。现在告诉我，刚才 那位先生说了些什么？ 店员：他只说了一句－你们的经理是个大笨蛋。 出 诊 帕特先生请了一位医生到家里来给妻子看病，他把医生让近屋里， 自己坐在门外等待。不久，医生探出头来问：“帕特先生，有起子吗？ ”过了一会儿，医生又要钳子。后来，又要锤子。帕特先生终于忍耐 不住了：“大夫，我妻子到底得了什么病？” 医生说：“不知道， 我的药箱还没有打开哪！” 别 数 了 当我和丈夫与六个孩子一起驾车出去旅行时，我相信我们这个大家 庭准能引人注目。然而当一辆有许多小脑袋瓜的旅行车从后面超过我们 时，我吃了一惊。“那辆车上有多少个孩子？”我们中间的一个问道。 我们赶上那辆车时才发现，那车的后车窗上挂着一块小牌子，上面写着 几个粗字：“别数了，一共14个！” 有个男人出差回来，撞见老婆正与邻居的老公斯磨在一起。他怒气冲冲的去敲隔壁的门，向邻居的太太说：『你老公正与我老婆在偷情。』 『太不像话了，我们一定要报复。』邻居太太把他拉进房内，脱下衣服，展开激烈的作爱。 不久，二人躺在床上休息，数分钟后，邻居太太又说：『怎么样？我们再来报复一次吧！』 就这样，连续报复了四次，当邻居太太要求第五次的报复时，男人摇摇晃晃的站起来说：『算了！我己经不恨他们了.......』`,``,`html`,`多态`,`20240307183503-_java 允许不同类的对象对同一消息做出不同的响应 编译时多态,方法重载 运行时多态,程序运行时动态决定调用哪个方法,满足继承关系,父类引用指向子类对象 public class Master { public void feed(Animal animal) { if (animal instanceof Cat) { animal.eat(); ((Cat) animal).playball(); } else if (animal instanceof Dog) { animal.eat(); ((Dog) animal).sleep(); } } public static void main(String[] args) { Master master= new Master(); Cat cat = new Cat(); Dog dog = new Dog(); master.feed(cat); master.feed(dog); } }`,``,`html`,`大力士`,`20240307183503-影摘 20230926205238.webp 《大力士》是1997年迪士尼同名動畫長片電影的衍生劇，兩季全65集，泰特·多諾萬、弗倫奇·斯圖爾特等配音，該劇於1998年8月31日到1999年3月26日在美國ABC首播，並曾經在國內小神龍俱樂部播出過中文版。 S01E01.海格力斯和阿波罗任务 哈迪斯冥府日光浴 不得不遗憾地 S01E07.海格力斯和冥河 哈迪斯惩罚海伦吃油炸薯片让她长痘痘,环境配音异常清晰 S01E09.海格力斯和世界上第一位医生 用希腊世界报运动版买通摆渡人 S01E16.海格力斯和希波莱特的腰带 亚马逊战士台语配音 S01E24.海格力斯和失踪的英雄们 哈迪斯奖杯 S01E25.海格力斯和亚哥号船员 你可以命令一个人往左往右 但是你不能命令他相信你 亚哥号的船员不是对我失去信心 他们是对自己失去信心 你也一样,孩子 S01E28.海格力斯和英雄教练 阿菲推销长矛到蛇发女妖家里,发现屋子里到处都是被石化了的推销员,最后看到蛇发三姐妹照片吓跑 S01E30.海格力斯和睡神 痛苦: 他说一只会说话的公鸡就能叫醒摩菲斯,啊,慌张,就是它,我们得抓到那一只公鸡,听我说,我们知道海格力斯需要一只会说话的公鸡,所以我们只要搜集希腊所有的公鸡,找到会说话的那一只 慌张: 你这么快就想出这个办法了,你一定是他们卧底的 S01E33.海格力斯和喀里多尼亚野猪 如果谎话是孩子,你就是多产婆 S01E37.海格力斯和史诗冒险 喜欢抢东西的鹦鹉,哪儿都比不上自己的家,我的我的我的我的我的 S01E38.海格力斯和坠落星群 不是说七仙女不漂亮,你知道永久是多久吗 S01E44.海格力斯和狮鹫 小喽啰们用水浇铸冰桥 S01E51.海格力斯和学校舞会 嗨,你不能进去,非请莫入 呃..我在受邀名单上 是吗,自作聪明的家伙,我们没有名单 哦,如果没有名单,你们怎么知道我不在名单上啊 嗯,他说得有理 好了,进去吧 S01E53.海格力斯和美杜莎 啊,我说你们张开眼睛行不行,她只能把凡人变成石头,傻瓜 嘿嘿嘿嘿,不是因为那个是因为 因为我们在女生化妆室,嘿嘿嘿嘿 唉哟..`,``,`html`,`大旗英雄传`,`20250112140526-影摘 温柔乡就是英雄冢 这是我自失明之后, 自创的天耳通, 为了避免失传, 我想将它传授于你, 它虽然谈不上是什么盖世神功, 但比起其它武功有所特点, 可备不时之需, 不知弟弟你可愿一学 小弟多谢大哥器重, 我当苦学其功, 绝不会让它失传的 当前世上有几个不看皮相的 都不知道你这一身乳臭干了没有, 屁大就学会品头论足 这儿女情长, 终有些错落的伤, 怨不得, 也急不得 英雄泪只用来怜芳草 一滴泪跌落, 情飞花万朵`,``,`html`,`大醉侠2002`,`20240307183503-影摘 第1集 皇后被砍倒地，咚—— 弹幕：皇后摔得好头疼`,``,`html`,`天蚕变`,`20240307183503-影摘 片头曲中寒潭老怪甩头的姿势和最后被杀时360度倒地的姿势，天智上人拍死吕家小姐时白魔惊呆的表情，呵呵呵呵`,``,`html`,`安卓多用户`,`20250216153941-_工具使用 行为特点 1，当一个用户处于激活状态时,其它用户虽保持后台但无法发出通知,本体闹钟除外 2，电话短信可以留痕相当于公共应用 3，多用户下相同的应用仅安装一次，任何用户将其更新为高版本之后，其余用户使用的也即更新后的版本，不接受低版本覆盖 对比工作资料 同一账户下切换“工作模式”即可访问或隐藏工作应用, 关闭后不会收到工作通知 应用可以共享双开, 而数据是分开的 可一定程度用作沙盒 系统级攻击仍可能影响整个设备（如内核漏洞、Rootkit）。 恶意软件可能通过设备权限或漏洞攻击整个 Android 系统，而不仅仅是工作资料 真正的沙盒（如 Android 的 Work Profile 之外的 App Sandbox）是进程级隔离，而工作资料仍共享同一个 Android 内核。 无法限制应用的系统 API 调用，某些恶意软件仍可能绕过隔离机制。 可以使用“受限用户”（Limited User）或“访客模式”来更好地隔离恶意应用。`,``,`html`,`安卓自动化`,`20241123225336-_工具使用 https://play.google.com/store/apps/details?id=com.arlosoft.macrodroid&hl=en_US&gl=US&pli=1 smtp goddady server: smtpout.secureserver.net port: 465 or 587 yeah.net server: smtp.yeah.net port: 25 短信抄送邮件 //标题 [SMS] {sms_number} //正文 <span style="font-size:24px;font-family:serif">{sms_message}</span><br><br><span style="color:white">[{year}-{month_digit}‐{dayofmonth} {hour}:{minute}] [{sms_number}]</span> 漏话抄送邮件 //标题 [CALL] {call_number} //正文 <span style="font-size:24px;font-family:serif">{call_number}</span><br><br><span style="color:white">[{year}-{month_digit}‐{dayofmonth} {hour}:{minute}] [{call_number}]</span> 桌面编发短信 //Dropbox文件夹 sms def.txt //号码\n短信内容 //离线访问 trigger.url //触发链接 //定义局部变量 str,arr //触发器 Webhook //动作 如果(VPN状态启用) 清除变量str,arr 启动Dropbox(重新启动) //必要 等待10秒 从文件中读取(def.txt -> str) 文本操作, 拆分为数组({lv=str}) -> arr //分割符\n 发短信({lv=arr[0]}:{lv=arr[1]}) 发送提示邮件 已向{lv=arr[0]}发送了消息: {lv=arr[1]} 否则 发送提示邮件 代理未开启 //结束条件 解锁失败存照 //局部变量 cnt //触发器 登陆尝试失败 任何的登录失败 //动作 如果cnt<3 设置变量 cnt:(+1) 结束条件 如果cnt=3 设置变量 cnt:0 拍照 前摄像头 等待直至触发 屏幕已解锁 显示对话框 suspicious unlocking 结束条件 //约束条件`,``,`html`,`宰相刘罗锅`,`20240307183503-影摘 家有鲜花一朵,日子长了,也跟个狗尾巴草似的 百步之内,必有芳草`,``,`html`,`小侠龙旋风`,`20240307183503-影摘 [花弄月] 早上跟你一起看日出，白天到山上去奔马，黄昏的时候，在山顶上一起看日落，到了晚上，我们就在花园，放一张小几，两张椅子，在月光下对饮 ..可是人一旦做了决定，痛苦就会变得很轻很轻，甚至没有了 梦是一种胡说八道的东西，越是没有定见的人，越是想解释他的梦 我有灵珠一颗，久被尘牢关锁， 如今尘尽光生，把情痴一起经过。 生又如何，死又如何， 心是灵光一片，照遍山河万朵`,``,`html`,`小兵人儿`,`20240307183503-转载 有一天，我正在清理我儿时的玩具箱，发现了里面有一堆小兵人的玩具，一个小兵人跑到我的面前来问我，“你知道我们司令去哪儿了吗”，我沉默，他伤心地问，“请问他是牺牲了吗”，我摇摇头说“不是，是他长大了”`,``,`html`,`小说写作教程`,`20240307183503-书摘 第一稿永远是一堆臭狗屎 把自己内心的批评家的嘴巴堵住，你要敢于写出很糟糕的东西来，这是写作路上的一座独木桥，舍此别无他途 冲突的作用就在于迫使人物行动起来,强迫人物利用自身条件,以一种揭示他们自身性格特征的方式采取某种行动。 写作切忌好高鹜远。你只管写作就好,让脑海里自然而然地冒出来的念头都流溢到纸面上来。你写下的只是原始的创作素材,这种素材需要经过反复雕琢之后才能演绎出一段真实可信的故事。最终,你会把这门技艺学到手。目前,你的任务只是练习 。 骨架既定, 情节,细部描写,对白等等就会像肌肉一样附着上去, 直到作品成为一个有机整体 迷幻药物和酒精是灵感的最佳媒介 金先生用词"从不在乎礼仪问题", 其理由是一把锤子落到你的手上时即便你是个敬畏上帝,谈吐拘谨的老处女, 你定会脱口叫出一声shit而不是sweetheart 玛丽卡尔把她的童年用几乎毫不间断的大场景展现出来. 我的却是一片雾色弥漫的风景, 零星的记忆片段就像孤零零的树木掩映其间 我的新老师叫泰勒夫人,是个好人,留着一头艾尔沙 兰切斯特式的花白卷发,就像弗兰肯斯坦的新娘那种卷发,她还长着一对肿眼泡. 我妈说过:"我跟她说话的时候,老想把手捧在泰勒夫人眼睛下头, 怕万一她眼珠子会掉出来" 日子过得紧巴巴 当你年纪还小, 脸上无毛可刮的时候, 乐观面对失败是最合情合理的反应 斯坦:"海狸对橡树说什么?" 珍:"很高兴咬到你" "你写故事的时候, 是在给自己讲故事," 他说, "当你修改的时候,主要工作就拿掉不属于故事本身的内容." 就像只惊恐的小耗子一样在里斯本高中的课堂之间匆匆溜过 午后时分的我就像一条刚吞了只山羊的大蟒蛇一样, 只想歇会儿, 专心消化, 没力气动弹`,``,`html`,`工厂模式`,`20240616183123-_模式算法 20240711151708.webp 通过创建工厂类来隐藏额外的创建细节, 作为使用者来说不关心底层的创建逻辑是什么样的, 只需要了解工厂中有哪些方法, 返回的是什么接口就可以了 多语言 interface I18N { //Internationalization String greeting(); } class Chinese implements I18N { @Override public String greeting() { return "你好"; } } class English implements I18N{ @Override public String greeting() { return "Hello"; } } class I18nFactory{ //静态工厂 public static I18N getI18n(String area) { switch (area) { case "CN": return new Chinese(); case "US": return new English(); default: return null; } } } public class Software { public static void main(String[] args) { I18N i18N = I18nFactory.getI18n("US"); System.out.println(i18N.greeting()); } } 多平台 public interface Device { String getIndex(); } public class DesktopDevice implements Device{ @Override public String getIndex() { return "/desktop/index.html"; } } public class MobileDevice implements Device{ @Override public String getIndex() { return "/mobile/index.html"; } } public class DeviceFactory { public static Device getDevice(HttpServletRequest req) { String ua = req.getHeader("User-Agent"); if(ua.contains("Windows NT")){ return new DesktopDevice(); } else if(ua.contains("Android") || ua.contains("iPhone")){ return new MobileDevice(); } return null; } } @WebServlet("/index.html") public class DeviceIndex extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Device device = DeviceFactory.getDevice(req); req.getRequestDispatcher(device.getIndex()).forward(req,resp); } }`,``,`html`,`左拉传`,`20240307183503-影摘 愿望需要时间来达成`,``,`html`,`常量池`,`20240616183123-_java 包装类常量池 除了Boolean,Character继承自Object,其它6个数值类都继承自Number类 除了Float和Double外,其它包装类都有常量池的概念 除了Integer以外，其他包装类的缓存范围都不能改变。 和其他系统属性一样，在JVM启动时，cache数组的大小是可以通过设置-Djava.lang.Integer.IntegerCache.high=xxx传递进来的 Byte	-128 ~ 127 Short	-128 ~ 127 Integer	-128 ~ 127 Long	-128 ~ 127 Character	0 ~ 127 Boolean	true,false Float	无 Double	无 Integer one = 100;//也即执行了Integer one=Integer.valueOf(100); Integer two = 100;//也即执行了Integer two=Integer.valueOf(100); System.out.println(one == two);//true //当参数值位于[-128,127]时,会将值放入缓存区,下次操作如果值存在于缓存区,则直接用,不存在时则实例化Integer Integer three = 128; Integer four = 128; System.out.println(three == four);//false Integer a = -127; Integer b = -127; System.out.println(a == b);//true 字符串常量池 String str1 = "hello"; //在常量池中创建"hello",将栈引用str1指向它 String str2 = "hello"; //发现常量池中已经存在"hello",直接将栈引用str2指向它 String str3 = new String("hello"); //在堆中开辟地址唯一的堆空间存放"hello"对象,将栈引用str3指向它 String str4 = new String("hello"); //在堆中开辟地址唯一的堆空间存放"hello"对象,将栈引用str4指向它 栈(存放引用) str1 str2 str3 str4 常量池 "hello" 堆(存放对象) new String("hello") new String("hello") String的不可变性 String s1 = "Tom"; //在常量池中创建"Tom",将栈引用s1指向它 s1 = "Hello, " + s1; //在常量池中创建"Hello, Tom",将栈引用s1指向它,而"Tom"废弃不再被引用 String s1 = "abc"; String s2 = "abc"; String s3 = "abc"+"def"; String s4 = "abcdef"; String s5 = s2+"def"; //s2是一个引用对象, 编译期间无法确定其值所以无法对其进行常量优化,所以会对s5分配一个新的内存空间 String s6 = new String("abc"); System.out.println(s1==s2);//t System.out.println(s3==s4);//t System.out.println(s4==s5);//f System.out.println(s4.equals(s5));//t System.out.println(s1==s6);//f`,``,`html`,`序列化`,`20240328174034-_java 序列化是将对象的状态转换为字节流的过程 持久化： 将对象的状态保存到磁盘文件或数据库中，以便在程序退出后仍能保留对象的状态。 网络传输： 在分布式系统中，通过网络传输对象，允许不同进程之间进行通信。 缓存： 将对象存储在内存或磁盘中，以便在需要时快速加载。 反序列化是将字节流重新转换为对象的过程 恢复对象状态： 从磁盘或数据库中读取对象的状态，以恢复程序退出前的状态。 接收网络数据： 从网络中接收到序列化的对象，并在本地重建这些对象 serialVersionUID 用于验证在序列化和反序列化过程中，发送者和接收者的版本是否一致。 它是类版本的唯一标识符，如果类的定义发生任何变更（例如增加或删除字段），则需要更新 serialVersionUID 序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中 IDEA自动生成 serialVersionUID 搜索serializable, 勾选"Serializable class without 'serialVersionUID'提示 反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则InvalidCalssException 在Java中实现序列化主要通过两个接口: Serializable 接口 这是一个标识接口，不包括任何方法 一个对象想要被序列化,要实现此接口或者它的子接口。 这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递。 序列化不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态 不想序列化的字段可以使用transient修饰。(transient 短暂的) 由于Serializable对象完全以它存储的二进制位为基础来构造，因此并不会调用任何构造函数，因此Serializable类无需默认构造函数，但是当Serializable类的父类没有实现Serializable接口时，反序列化过程会调用父类的默认构造函数，因此该父类必需有默认构造函数，否则会抛异常。 使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。 Externalizable 接口 它是Serializable接口的子类，用户要实现的writeExternal()和readExternal() 方法，用来决定如何序列化和反序列化。 因为序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，而transient在这里无效。 对Externalizable对象反序列化时，会先调用类的无参构造方法，这是有别于默认反序列方式的。 如果把类的无参构造方法删除，或者把该构造方法的访问权限设置为private、默认或protected级别，会抛出java.io.InvalidException: no valid constructor异常，因此Externalizable对象必须有默认构造函数，而且必需是public的。 public class Apple implements Serializable { private static final long serialVersionUID = -4251269726946099535L; private int x; private String y; transient private String z; static String staticField = "I am static"; Apple(int x, String y) { this.x = x; this.y = y; this.z = "z"; } @Override public String toString() { return "x = " + x + " " + "y = " + y + " " + "z = " + z + " " + "staticField = " + staticField; } public static void main(String[] args) { String objFile = "Apple.txt"; Apple apple = new Apple(1, "apple"); try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(objFile))){ oos.writeObject(apple); } catch (IOException e) { throw new RuntimeException(e); } Apple.staticField = "Changed static field"; Apple appleRead = null; try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(objFile))){ appleRead = (Apple) ois.readObject(); } catch (IOException | ClassNotFoundException e) { throw new RuntimeException(e); } System.out.println(appleRead);// x = 1 y = apple z = null staticField = Changed static field } }`,``,`html`,`异常`,`20240307183503-_java 当子类重写父类方法(带抛出异常)时,声明的异常必须是父类方法所声明异常其同类或子类 多个catch块时,异常的父类放在最后一个块中防止无匹配而中断 自定义异常,定义一个类继承throwable或它的子类 throw 用于在代码块中手动抛出异常，可以用于自定义异常, 手抛的时候不建议抛出非检查异常,因为编译器不会提醒要求强制处理 throws 是用于在方法中声明可能会抛出异常，用于向上层的调用者传递异常信息 20240730123260.webp 20240730123949.webp 非检查异常（unckecked exception）： Error 和 RuntimeException 以及他们的子类。 javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。 检查异常（checked exception）： 除了Error 和 RuntimeException的其它异常。 javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。 异常链 class CustomException extends Exception { public CustomException() { super("异常本体"); } } public class Demo { public static void main(String[] args) { try { test4(); } catch (Exception e) { System.out.println(5); printExceptionChain(e); } } //1 //2 //临时例.异常_1.CustomException: 异常本体 //3 //java.lang.Exception: test1中的新异常 //4 //java.lang.Exception: test2中的新异常 //5 //Exception: test4中的新异常 //Exception: test3中的新异常 //Exception: test2中的新异常 //Exception: test1中的新异常 //Exception: 异常本体 public static void test1() throws Exception { System.out.println(1); throw new Exception("test1中的新异常", new CustomException()); } public static void test2() throws Exception { try { test1(); } catch (Exception e) { System.out.println(2); System.out.println(e.getCause()); throw new Exception("test2中的新异常", e); } } public static void test3() throws Exception { try { test2(); } catch (Exception e) { System.out.println(3); System.out.println(e.getCause()); throw new Exception("test3中的新异常", e); } } public static void test4() throws Exception { try { test3(); } catch (Exception e) { System.out.println(4); System.out.println(e.getCause()); throw new Exception("test4中的新异常", e); } } // 打印异常链信息的方法 public static void printExceptionChain(Throwable throwable) { while (throwable != null) { System.out.println("Exception: " + throwable.getMessage()); throwable = throwable.getCause(); } } } try-with-resources 处理必须关闭的资源时，优先考虑用try-with-resources，而不是用try-finally，这样得到的代码将更加简洁、清晰，产生的异常也更有价值 try-with-resources是Java 7引入的一种语法结构，用于自动关闭实现了AutoCloseable 接口的资源 它可以代替传统的try-catch-finally结构来处理资源的释放 当使用try-with-resources 时，编译器会生成一个隐式的 finally 块来关闭资源 无论是否发生异常，都会调用资源的 close() 方法进行关闭操作 如果同时存在多个资源，它们的关闭顺序与声明的顺序相反 在 try 后面的括号内声明的资源对象必须是 final 或 effectively final(一个非final的局部变量或方法参数，其值在初始化后就从未更改) 的（Java 9+ 不再有此限制） 如果资源的 close() 方法抛出异常，那么原始异常将被隐藏，只会抛出 close() 方法的异常 try (BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); Scanner scanner = new Scanner(System.in)) { if (scanner.hasNextLine()) writer.write(scanner.nextLine()); } catch (IOException e) { // handle the exception } //在scanner之前关闭writer try-catch-finally中的return finally总是在控制转移语句执行之前执行 return、throw、break 和 continue 都是控制转移语句 其中 return 和 throw 把程序控制权转交给它们的调用者（invoker） 而 break 和 continue 的控制权是在当前方法内转移。 try块中有return语句时,会将要return的值先隔离暂存,执行finally之后,再将隔离暂存值返回去,返回值是在finally执行前确定的,不受finally影响 finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。 finally块和try块中都有return语句，函数会通过finally块中的return返回 public class FinallyReturn3 { public static void main(String[] args) { System.out.println(get1());//finally仍然执行 1 System.out.println(get2());//2 } static int get1(){ int x = 1; try { return x; }finally { ++x; System.out.println("finally仍然执行"); } } static int get2(){ try { return 1; }finally { return 2; } } } finally不会执行 只有与 finally 相对应的 try 语句块得到执行的情况下，finally 语句块才会执行。 在 try 语句块之前返回（return）或者抛出异常，所以 try 对应的 finally 语句块不会执行。 在 try 语句块中执行了 System.exit () 语句，finally 语句块不会执行。 当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行`,``,`html`,`弃儿汤姆·琼斯的历史萧乾译`,`20240307183503-书摘 对于作者的这个观点，我们在议论时切不可脱离当时的具体环境。我认为菲尔丁这种写法是对十八世纪英国社会的伪善⻛气的一种反应；或者说，是一种矫枉过正的作法。他太痛恨人间的虚伪了，以致故意让笔下的人物堕落到那样地步，最终仍把他树立为一个正面人物。好像是表示：浪子终必回头。人只要不假冒为善，不从心里溃烂，他仍可以成为体面人物的。 在第一卷的序章中，他就说：“一个作家不应以宴会的东道主或舍饭的慈善家自居，他毋宁应该把自己看作一个饭铺的老板......”[25]不言而喻，开饭铺的倘若与上门的主顾关系冷漠，这个馆子如何开得下去！ 在序章中，菲尔丁真是海阔天空，无所不谈。时而泛论爱情与肉欲（第六卷序章），时而比较舞台与人生（第七卷序章）。第十及第十一卷的序章都是抨击批评家的。作者也在几卷序章中同读者讨论人物的评价问题。他总是告诫读者：人是复杂的动物。好人有时也会失足，而坏人身上有时也有可取之处。力劝读者不要急于判断人物的道德品质，要耐心地读完全书再去玩味。 在这些序章中，他谈得最多的，还是小说艺术这个问题。他不厌其烦地强调作品的真实性，而为了做到真实，作者必须了解社会，了解人。在“向诗神召唤”（第十三卷序章）里，他向诗神所提出的四项要求，实际上就是菲尔丁心目中从事创作所必须具备的四个条件。它们是：（一）天资：“穿过自然的所有那些曲折迂回的迷宫，看到俗眼凡胎从未⻅到的全部隐秘。”（二）人道，也即是悲天悯人之心：从而产生“高贵无私的友谊，忘我的爱情，开阔的胸襟，深切的谢忱，体贴入微的同情和直率的⻅解......这股力量能使人们那润湿的眼睛里噙满泪水，用热血涨红了人们那神采焕发的双颊，使悲哀、欢乐和仁慈像潮水般在人心中起伏不已”。（三）学识：“历代积累下来的......全部哲学、诗歌和历史的库藏......”（四）经验：“熟悉各色各样的人，从清晨接⻅下属的大臣到拘留债户的衙吏，从午后茶会上的公爵夫人到酒店柜台后面的老板娘。”也即是说，一个写小说的，必须熟悉各阶层的人。在第七卷序章里，他甚至认为一个作家倘若没进入“自然”（也即是人生）这座伟大舞台的幕后，不洞察人生，他只配去编编字典或拼音课本。 关于人道，他补充说：“倘若一个人对一片悲惨景象无动于衷，他就不可能把它描绘得逼真。......滑稽场面也是这样。我深信，除非我自己先捧腹大笑，否则我永远也不能使读者发笑。”`,``,`html`,`恶作剧`,`20240307183503-转载 我以前是个坏女人 从窗户里看到松鼠在鬼鬼祟祟挖洞，好奇跑下楼看看，趁他走了去把他埋起来的松果挖出来，藏到另外一棵树下了……`,``,`html`,`憨豆先生TV`,`20240307183503-影摘 憨豆先生买火鸡估重量 憨豆先生open day投晃硬币`,``,`html`,`成人笑话`,`20240424214437-碎片 冰箱里有五颗鸡蛋第一颗跟第二颗说:你看第五颗鸡蛋有毛耶真恐怖!第二颗又跟第三颗说三又跟四说结果第五颗听到了!它说:干!老子是奇异果啦! 一男人逛街尿急准备尿在角落，老太太看到便说：随地小便罚款伍元。这人说：誰说我小便，我拿出来看看不行吗？ 一个女孩走进一间酒吧，对店主说：”你出两百元，我会为你做任何事情。“ 店主说：”好啊，你把这里的墙壁粉刷一遍。“ 半夜司机载了一位老妇人,妇人缓缓道:你喜欢吃苹果吗?司机:喜欢.妇人:我生前也很喜欢.司机顿时面色惨白.“但生孩子以后就不喜欢了“ 有个漂亮的单身女警因为怕一个人独居太危险，所以养了一只凶恶的狗防身。有一天，当这位美丽的女警正在洗澡时，窄小的公寓突然发生火警，女警匆匆披上浴巾逃出火场，可是没穿内裤又觉得很不好意思，于是女警就把大狗叫过来，让狗闻一闻她的下体，希望狗能依著她的味道，回房里叼一件内裤出来。这只狗的鼻子的确不错，只见它不畏漫天大火，左去右回三十秒，相当迅速地叼来女警挂在衣橱里最粗最长的那根警棍。。。。。 刚上小学的儿子，向父亲提出一个问题。 『爸爸，为什么上帝会先造男人，再造女人呢？』 『也许他是不希望在造男人的时候，有一个女人在他耳边唠唠叨叨个不 停吧！』 法官望著被告说：『我是不是曾经见过你，你好像有些眼熟。』 被告满怀希望地说：『是的！法官，您忘啦？二一年前，是我介绍尊夫人跟您认识的。』 法官咬牙切齿地说：『判你二十年有期徒刑。』 有一天耶稣把他的三十六个门徒带到山下说:"你们大家先拿两颗石头然後跟我一起上山"其中有一个叫撒旦的就拿两颗最小粒的,到了山上耶稣对大家说:"现在拿你们手上的石头来换我的馒头",结果撒旦换到最小的馒头,於是他怀恨在心 第二天耶稣一样把门徒带到山下,叫他们先拿两颗石头上山,於是撒旦就拿两颗大石头上山,到了山上撒旦气喘如牛耶稣开口说:"你们用你手上的石头丢向前去,丢越远馒头越大",结果撒旦丢了二十公分远换到最小的馒头,撒旦气的喷血 第三天耶稣一样叫他们拿石头上山,撒旦想"大的石头可换大馒头,小的石头可以丢很远,我拿一大一小就万无一失了",於是撒旦就很高兴的拿一大一小的石头上山,到了山上耶酥很高兴的说:"你们跟我上三次山一路辛苦为了答谢你们我把你们手上的两颗石头变成你们下面那两粒"撒旦听到马上昏倒从此以後撒旦就背叛耶稣一直想害死耶稣 有一名贵妇养了一只母鹦鹉，但这只鹦鹉只会说：「来ㄚ！要不要爽一下ㄚ......」 贵妇觉的这鹦鹉的行为实在有辱她的身份 有日贵妇看到对面教堂的神父也养了一只公鹦鹉，而且很乖的在笼子里祷告 於是便去请教神父：「为何你的鹦鹉那麽乖？养多久啦？我把我家的鹦鹉给你调教好吗？」 神父：「我养两年啦，它ㄧ直都很乖，你的鹦鹉怎麽啦？」 於是贵妇便把家里那只说话低贱的鹦鹉的情形ㄧ五一十地说给神父听 神父ㄧ口答应：「好ㄚ，你把你的鹦鹉给我养，我保证它会和我的鹦鹉ㄧ样，乖乖地在笼里祷告。」 隔日，贵妇把鹦鹉送给神父，神父便把母鹦鹉关在与神父的公鹦鹉同一个笼子，希望能以近朱者赤的方法把母鹦鹉教化 未料，只见母鹦鹉一看见公鹦鹉便叫著：「来ㄚ！要不要爽一下ㄚ......」 只见正在祷告的公鹦鹉眼睛为之一亮：「神ㄚ，我祷告两年的愿望终於实现啦.......」 一位救生员向游客抗议：我以已经注意你三天了,汪先生,你不能在游泳池小便. 汪先生：每个人都在游泳池小便. 救生员：没错!先生,但只有你站在跳板上...... 有位法国探险家在沙漠里迷了路,濒临死亡之际;忽然看见一位仙女缓缓而来,这位探险家急忙高呼"仙女救救我吧!我已三天没喝水了!" 这位仙女想了一想.皱了皱眉,又　然而退,不久端了一杯小红莓给探险家喝,探险家喝完意犹未尽说"我还要再一杯"这位仙女叹了囗气说:"没了,要到下个月才会有." 一日， 盛暑午后， 阳光刺眼，一美貌女子立于街旁， 手搭凉棚， 似在找人。小王一见， 脱囗而出 “美女怕日手遮阴”。] 美女走进情趣店买按摩棒，挑了半天最后跟老板说：我要那边那只红色的。老板沈默了一会儿道：那是灭火器 甲买了一挂鞭炮后藏起，乙询问为何不放，甲说要等到过年才放， 现在不点，乙说：我非点！我非点！话音刚落即见救护车云集，几个白衣白甲的人从车上跳将下来，一把把乙拉到隔离中心.... 和朋友到泰山顶看日出，一个朋友指着天空说：“我看见了！”“我也看见了！”这时远处有人提着裤子出来骂道：“看见就看见呗！你们嚷什么啊！” 　6.还少一题 　　化学课上，老师布置作业。“练习四，5、7、9、11、16、19，就做这些吧。”忽听几个男生大喊：“老师，还少一道题。”老师大喜，心想终于盼到学生主动学习的一天了。于是笑着说：“好吧，加上22和27题吧。”下课铃声响起，众男生向彩票投注站奔去，边跑边说：“咱老师真好，这下边特别号都有了。” 23.专断 　　一个妇女十分专断，她的丈夫不得不带她看心理医生。丈夫在外面等了快一个小时，妻子终于出来了。丈夫问道：“现在好点了吧？”“没有大变化，”夫人说，“花了我50分钟，才让他相信那张病床搁在靠墙的一边，比放在中间好多了……” 25.磨牙 　　丈夫赶写一篇论文，妻子偏偏在一旁唠叨不停。丈夫无可奈何，长叹口气说：“人家读书有红袖添香，我读书有红袖添乱；人家写文章有佳人磨墨，我写文章有佳人磨牙。”`,``,`html`,`把酒问青天`,`20250202094530-影摘 钟鼎山林, 各有心志 好, 果然是神乎其技啊 折翅之鸟已非鸟 美人如祸水, 只会毁人心志 芬芳可挹 舀取。《詩經．小雅．大東》：「維北有斗，不可以挹酒漿。 北斗挹琼浆 二世祖是一个汉语词汇，是粤语俗语，通指那些有不少家产，只会花钱享乐的人；专指上一代有权有势有钱，下一代只管吃喝玩乐的富家子弟（纨绔子弟）；另指禅宗二祖慧可。 一个男人, 役于情或役于物, 都成不了大业, 女人嘛, 姹紫嫣红, 差别不大, 只看她对你有没有用 据地称王, 裂土封疆 古有禅让之制, 贤能者治天下, 世袭皇帝是人订的规矩, 可不是老天爷, 就有那些不要脸的人, 才自称是天子 不痴不聋, 不作家翁 指作为长辈，对下辈的过失要能装糊涂 也许只有经过时间的沉淀, 才能还原事物的本象 每个人都有自己的选择和坚持, 我不会劝你回头, 你也由我随心吧 回我的地方, 救我的命, 然后杀你 我想, 在情感上, 无论谁对谁错, 谁伤了谁, 其实痛苦都是一样的 你敢偷我的令牌, 敢去劫牢, 敢拎着全家人的脑袋去闯祸 凡事谋定而后动 令天下沸腾, 百姓荼毒`,``,`html`,`排序算法`,`20240618093949-_模式算法 在 Java 中，默认的排序算法 (Collections.sort 和 Arrays.sort 使用的是 TimSort) 通常比手动实现的快速排序算法要快。以下是原因： 优化程度：TimSort 是一种混合排序算法，结合了合并排序和插入排序的优点，针对不同的数据模式进行了大量优化。它在处理已排序或部分排序的数据时表现特别出色。 稳定性：TimSort 是稳定排序，保持相同元素的相对顺序，而标准的快速排序不是稳定的。 内置优化：Java 的内置排序方法在底层进行了多种优化，包括减少对象分配、优化递归调用等，这些优化在手动实现的算法中很难完全实现。 垃圾回收：Java 内置排序方法对垃圾回收有更好的处理，尤其是在处理大型数组或列表时。 TimSort 优点: 结合了归并排序和插入排序的优点。 稳定排序，适合处理部分已排序的数据。 Python的sorted()函数和Java的Arrays.sort()方法都使用TimSort。 缺点: 实现复杂。 最佳应用场景: 适用于大多数一般用途的排序，特别是当数据集已经部分排序时表现出色。 冒泡排序 (Bubble Sort) 优点: 实现简单，易于理解。 缺点: 时间复杂度为O(n²)，性能很差，不适合大数据集。 最佳应用场景: 适用于小数据集和对教学目的的示例。 插入排序 (Insertion Sort) 优点: 实现简单。 对于几乎已经排序的数据集，性能很好。 稳定排序。 缺点: 时间复杂度为O(n²)，对于大数据集性能较差。 最佳应用场景: 适用于小数据集或部分已排序的数据。 快速排序 (Quick Sort) 优点: 平均时间复杂度为O(n log n)，性能优异。 对大多数随机数据集表现良好。 缺点: 最坏情况时间复杂度为O(n²)，例如数据已经排序或接近排序的情况下（可通过随机选择主元或三数取中法改进）。 不稳定排序。 最佳应用场景: 适用于一般用途的排序，特别是随机数据集。 选择排序 (Selection Sort) 优点: 实现简单。 内存需求低，仅需要常数级额外空间。 缺点: 时间复杂度为O(n²)，性能较差。 不稳定排序。 最佳应用场景: 适用于小数据集或内存有限的情况。 总结 TimSort通常是最优选择，特别是对部分已排序的数据集。 快速排序在大多数随机数据集上的性能最佳。 插入排序在小型数据集或部分已排序的数据集上表现良好。 冒泡排序和选择排序一般仅在小数据集或教学中使用。 稳定排序 稳定排序是指在排序过程中，相等的元素在排序后仍保持其相对顺序不变。也就是说，如果在未排序的列表中，两个相等的元素 A 和 B，A 原本在 B 之前，那么在排序后的列表中，A 仍然在 B 之前。 稳定排序在某些情况下非常有用，特别是在需要多关键字排序的时候。例如，你有一个包含多个字段的记录列表，你首先根据一个字段排序，然后根据另一个字段排序。如果第二次排序使用稳定排序算法，那么相等字段的记录的相对顺序将保持不变。 常见的稳定排序算法： 插入排序 冒泡排序 归并排序 TimSort 不稳定排序算法： 快速排序 选择排序 堆排序 假设有一个对象数组，每个对象包含一个名称和一个年龄字段，如下所示： [ {name: "Alice", age: 25}, {name: "Bob", age: 20}, {name: "Charlie", age: 25}, {name: "David", age: 20} ] 如果我们按年龄字段进行稳定排序，结果将是： [ {name: "Bob", age: 20}, {name: "David", age: 20}, {name: "Alice", age: 25}, {name: "Charlie", age: 25} ] 注意到年龄相同的记录（Bob 和 David 以及 Alice 和 Charlie）在排序后仍保持它们原来的相对顺序。 冒泡排序 public static void bubbleSort(int[] arr) { int i, j, tmp; for (i = 0; i < arr.length - 1; i++) { for (j = 0; j < arr.length - 1 - i; j++) { if (arr[j] > arr[j + 1]) { tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } } public static void main(String[] args) { int[] arr = {5, 2, 2, 4, 6, 7, 2, 1, 3}; System.out.println(Arrays.toString(arr)); bubbleSort(arr); System.out.println(Arrays.toString(arr)); } 快速排序 https://blog.csdn.net/zou_albert/article/details/107405455 它的基本思想就是选取一个基准，一趟排序确定两个区间，一个区间全部比基准值小，另一个区间全部比基准值大，接着再选取一个基准值来进行排序，以此类推，最后得到一个有序的数列 假设我们现在对 6 1 2 7 9 3 4 5 10 8 这个 10 个数进行排序 首先在这个序列中随便找一个数作为基准数（就是一个用来参照的数）。为了方便，就让第一个数 6 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 6 的右边，比基准数小的数放在 6 的左边，类似下面这种排列 3 1 2 5 4 6 9 7 10 8 在初始状态下，数字 6 在序列的第 1 位。我们的目标是将 6 挪到序列中间的某个位置，假设这个位置是 k。现在就需要寻找这个 k，并且以第 k 位为分界点，左边的数都小于等于 6，右边的数都大于等于 6 方法其实很简单：分别从初始序列两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。 首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动 20240618130836.webp 哨兵 j 一步一步地向左挪动（即 j–），直到找到一个小于 6 的数停下来。接下来哨兵 i 再一步一步向右挪动（即 i++），直到找到一个数大于 6 的数停下来。最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前。 20240618131154.webp “探测”继续。哨兵 j 继续向左挪动，他发现了 3（比基准数 6 要小，满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。说明此时“探测”结束。我们将基准数 6 和 3 进行交换, 此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j 的使命就是要找小于基准数的数，而哨兵 i 的使命就是要找大于基准数的数，直到 i 和 j 碰头为止。 20240618131554.webp 现在基准数 6 已经归位，它正好处在序列的第 6 位。此时我们已经将原来的序列，以 6 为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“ 9 7 10 8 ”。接下来还需要分别处理这两个序列。因为 6 左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6 左边和右边的序列即可。 20240618141129.webp 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了 public class Demo { //Collator.getInstance(Locale.CHINESE) 是一个相对昂贵的操作,避免重复创建 Collator 实例 private static final Collator collator = Collator.getInstance(Locale.CHINESE); public static void quickSort(int[] arr, int low, int high) { if (low > high) { return; } int l = low; int h = high; int base = arr[low]; //定义左起始为基准点 int tmp; while (l < h) { //直到两者相逢停下 while (base <= arr[h] && l < h) //从右往左直到遇见小于base的数时停下 h--; while (base >= arr[l] && l < h) //从左往右直到遇见大于base的数时停下 l++; if (l < h) { tmp = arr[h]; //两者都停下时交换位置 arr[h] = arr[l]; arr[l] = tmp; } } arr[low] = arr[l]; arr[l] = base; //交换位置,确定出base的确切位置, 分隔出左右两部分 quickSort(arr, low, h - 1); //同样的方法递归左部 quickSort(arr, h + 1, high); //同样的方法递归右部 } public static void quickSort(String[] arr, int low, int high) { if (low > high) { return; } int l = low; int h = high; String base = arr[low]; String tmp; while (l < h) { while (collator.compare(base, arr[h]) <= 0 && l < h) h--; while (collator.compare(base, arr[l]) >= 0 && l < h) l++; if (l < h) { tmp = arr[h]; arr[h] = arr[l]; arr[l] = tmp; } } arr[low] = arr[l]; arr[l] = base; quickSort(arr, low, h - 1); quickSort(arr, h + 1, high); } public static void main(String[] args) { int[] arr = {10, 7, 2, 4, 7, 62, 3, 4, 2, 1, 8, 9, 19}; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); String[] arr2 = {"123", "abc", "*", "中文", "1a2b3", "中国", "a", "12a", "aa", "bb", "b2ba", "b3bc", "cc", "dd", "12", "中1文", "中3c","中3文","中2", "99", "00"}; quickSort(arr2, 0, arr2.length - 1); System.out.println(Arrays.toString(arr2)); } } 插入排序 20240618152109.webp public class Demo { public static void insertionSort(int[] arr) { int target, j; for (int i = 1; i < arr.length; i++) { //将数组第一个元素视为已排序的部分 target = arr[i]; //取出未排部分的第一个元素 j = i - 1; //已排元素中的最个一个元素的位置 while (j >= 0 && arr[j] > target) { //遍历已排部分, 如果有比自己(target)大的则已排右移 arr[j + 1] = arr[j]; j--; } arr[j + 1] = target; //(前面已经j--,此处j+1实际为j), 没有比自己大的则放末尾 } } public static void main(String[] args) { int[] arr = {5, 2, 2, 4, 6, 7, 2, 1, 3}; insertionSort(arr); System.out.println(Arrays.toString(arr)); } } 选择排序 是用逐个选择的方式来进行排序，逐个选择出数组中的最大（或最小）的元素，直到选择至最后一个元素 20240618160201.gif public class Demo { public static void selectSort(int[] arr) { int i, j, min, t; for (i = 0; i < arr.length - 1; i++) { min = i;//最小数位置 for (j = i + 1; j < arr.length; j++) { //已确立顺序的最后一个依次与后面的比较 if (arr[j] < arr[min]) min = j; } if (min != i) { //非同一位置时交换 t = arr[i]; arr[i] = arr[min]; arr[min] = t; } } } public static void main(String[] args) { int[] arr = {52, 14, 63, 14, 59, 8, 68, 35, 8, 67, 45, 99}; selectSort(arr); System.out.println(Arrays.toString(arr)); } }`,``,`html`,`搞笑一家人`,`20240307183503-影摘 第17集湿巾封口晃啤酒起沫 生活一半是误会 啊，阳光真明媚啊，这么暖洋洋的阳光，杀人也未尝不可啊 是啊，那天的我很不寻常，他像阳光那样强烈，我眼里满是泪水`,``,`html`,`新女驸马`,`20250210095943-影摘 20250228005616.webp 只有世界上最无知最愚蠢, 最不知天高地厚的人才会用金钱和权力来发婚姻的誓言 哼, 冒充风雅, 等冯小姐做了我的老婆, 她就会知道权力和金钱, 才是婚姻的补品, 大补 孟子云, 食色性也, 美色当前, 怜香惜玉而不动心, 那是圣人, 怜香惜玉而怦然心跳, 那是普通人, 不怜香惜玉又铁石心肠, 那不是人是畜生, 老道做不了圣人, 又不愿做畜生, 只好做普通人啦 第6集, 一剑飘红给天香盖被子 人为什么没有两颗心, 一颗心里放着一个人, 一颗心里放着另一个人 杏儿, 桃儿 希望有一天, 将这些全部抛开, 你我去一乡间小隅, 三间草房, 四壁泥土, 早上是清水稀饭, 晚上是稀饭清水, 只要在院落里遍种菊花, 满庭芬芳 惜花吟 枝上花，花下人 可怜颜色俱青春 昨日看花花灼灼 今朝看花花欲落 不如尽此花下欢 莫待春风总吹却 莺歌蝶舞韶光长 红炉煮茗松花香 妆成罢吟恣游後 独把芳枝归洞房 错认水是曾经闻名天下的金华名酒之一。“金华酒”是古代金华郡、州、府及辖县生产的各种黄酒的总称，历代名酒有：寿生酒、错认水、瀔溪春、东阳酒、白字酒等 风来疏竹, 风过而竹不留声, 雁渡寒潭, 雁去而潭不留影, 故君子事来而心始观, 事去而心随空是也 碧树森森风浩浩, 白云漠漠水潺潺 度水红蜻蜓, 傍人飞款款, 但知随船轻, 不知船去远 内无大患, 外无大战, 国家安宁富强, 朝中为官数年乃至十数年者, 不在少数, 出将入相, 为官为臣, 不管权势大小, 皆有敛财聚富之心, 只不过是大小程度不等, 各人机会不同 你怕不怕死 我怎么会不怕, 谁也不会不怕死亡, 除非是死得太突然, 来不及害怕, 像我现在这个样子, 站在死亡的悬崖边上, 如果说不害怕, 那绝不是真的, 只是我现在的仇恨要远远大于我对死亡的恐惧 害怕和仇恨无法免除死亡 这算是死亡通知吗, 你痛快地告诉我, 怎么个死法 作为皇亲国戚, 你可以选择自己的死亡方式 我惟一的要求, 是你们对这句话的承诺 北宋苏轼的《洗儿诗》 人皆养子望聪明，我被聪明误一生。 惟愿孩儿愚且鲁，无灾无难到公卿。 20250311184052.webp 看戏掉眼泪, 替古人担忧, 值不值啊`,``,`html`,`方位`,`20250305232053-户外 不论是在林木遮蔽的山林中, 还是在丛草盖地的山坡上, 低头近看, 根本找不出路迹采, 只有远看, 看到几十米以外, 才能隐约地看出一条草枝微斜、草叶微倾、叶背微翻的痕迹 垂直立一根标杆,影子顶点放石子A, 10分钟后影子顶点放石子B, 与AB垂直向太阳的一端即南 在野外迷失方向时, 立即停下来冷静回忆所走过的道路, 重新制定方向, 然后再寻找道路。最可靠的方法是“迷途知返”, 退回于原出发地。 在山地迷失方向后, 应先登高远望, 判断应该向什么方向走。通常应朝地势低的方向走, 这样容易碰到水源、顺河而行最为保险, 这一点在森林中尤中为重要。因为道路、居民点常常是滨水临河而筑的。 如果遇到岔路口, 道路多而令人无所适从时, 首先要明确要去的方向, 然后选择正确的道路。若几条道路的方向大致相同, 无法判定, 则应先走中间那条路, 这样可以左右逢源, 即便走错了路, 也不会偏差太远。 山地行进时力求有道路不穿林翻山, 有大路不走小路, 如没有道路, 可选择在纵向的山梁、山脊、山腰、河流小溪边缘, 以及树高林稀、空隙大、草丛低疏的地形上行进, 走梁不走沟, 走纵不走横。 攀登岩石时应慎重地识别岩石的质量和风化程度, 确定攀登的方向和路线。 遇到河流时不要草率入水, 要仔细地观察之后再确定渡河的地点和方法。 山区河流通常水流湍急, 水温低, 河床坎坷不平。 涉渡时, 为了保持身体平衡, 应当用一根午子支撑在水的上游方向, 或者手执重达15~20公斤石头。 集体涉渡时, 可三人或四人一排, 彼此环抱肩部, 身体最强壮的位于上游方向。 GPS 经纬度直投 经纬度等间隔直投的特点是相同的经纬度间隔在屏幕上的间距相等, 没有复杂的坐标变换。但是只是在低纬度地区长度、角度、面积、形状变化比较小, 越向高纬度, 水平距离变长越大, 很小的纬圈都变得和赤道一样长。同时要素自身会变形, 长方形会变成上宽下窄的倒梯形 墨卡托投影 墨卡托(Mercator)投影, 又名“等角正轴圆柱投影”, 荷兰地图学家墨卡托（Mercator）在1569年拟定, 假设地球被围在一个中空的圆柱里, 其赤道与圆柱相接触, 然后再假想地球中心有一盏灯, 把球面上的图形投影到圆柱体上, 再把圆柱体展开, 这就是一幅标准纬线为零度（即赤道）的“墨卡托投影”绘制出的世界地图 墨卡托投影的“等角”特性, 保证了对象的形状的不变行, 正方形的物体投影后不会变为长方形。“等角”也保证了方向和相互位置的正确性, 因此在航海和航空中常常应用, 而在Google等地图上计算人们查询地物的方向时不会出错。 墨卡托投影的“圆柱”特性, 保证了南北（纬线）和东西（经线）都是平行直线, 并且相互垂直。而且经线间隔是相同的, 纬线间隔从标准纬线（此处是赤道, 也可能是其他纬线）向两级逐渐增大。 但是, “等角”不可避免的带来的面积的巨大变形, 特别是两极地区, 明显的如格陵兰岛比实际面积扩大了很多倍。 20250305235252.webp WGS-84 World Geodetic System世界大地测量系统, 通过遍布世界的卫星观测站观测到的坐标建立, 其精度为1—2m 坐标原点位于地球的质心, Z轴指向BIH1984.0定义的协议地球极方向, X轴指向BIH1984.0的启始子午面和赤道的交点, Y轴与X轴和Z轴构成右手系 WGS的最新版本为WGS 84（也称作WGS 1984、EPSG:4326）, 1984年定义、最后修订于2004年 中国大陆坐标系 WGS-84:全球 GPS:标准坐标系	Google Earth、GPS 设备等 GCJ-02:中国国家测绘局加密坐标（火星坐标）:高德地图、腾讯地图、Google Maps（中国地区） BD-09:百度地图专用坐标, 在 GCJ-02 基础上再次加密:百度地图、百度 API 偏移保护 精确的坐标系统, 对于军事和国家安全具有重要价值。通过将地图坐标进行加密和偏移, 可以防止对地图数据进行不当分析, 不同坐标系之间存在着平移和旋转关系 坐标偏移使得所有在中国境内使用的地图坐标系统（如 百度地图、高德地图 等）都采用了本地坐标系（如 GCJ-02 坐标系、BD-09 坐标系）。这使得外国地图服务商（如 Google Maps）在中国提供地图服务时需要 遵守中国的坐标标准, 而无法直接使用 WGS-84 坐标系 或其他国际标准坐标, 只有政府授权的地图服务商（如高德、百度、腾讯）能够正确处理 GCJ-02 偏移, 但它们不会直接提供 WGS-84 真实坐标。如果私人建立的是一个小规模的地图服务, 没有涉及公开发布或商业使用, 则不受坐标偏移的法律辖管 WGS-84 → GCJ-02（火星坐标系） 由政府算法加密, 使 GPS 设备采集的 WGS-84 坐标 在地图上显示时会出现偏移, 大致偏移量： 经度偏移 约 50~500 米（东偏）。 纬度偏移 约 20~300 米（北偏）。 这个偏移是非线性的, 也就是说, 不同地点的偏移量不一样, 不能简单用一个固定值修正。 GCJ-02 → BD-09（百度坐标系） 百度地图 进一步加密 GCJ-02 数据, 形成 BD-09 坐标系。 采用了 高斯模糊和随机噪声扰动, 让普通方法难以逆向破解偏移规则。 BD-09 → WGS-84（逆偏移） 由于 GCJ-02 和 BD-09 坐标都是通过非线性加密变换得到的, 所以无法简单用数学公式逆推回 WGS-84。 需要使用 API 逆转换 或者 基于大数据拟合模型 才能获得较为准确的 GPS 坐标。 以下地图可能不会应用偏移： Google Earth（离线版） OpenStreetMap（OSM, 开源地图） 部分军事、科研级别的专用地图 未受中国法律约束的私人地图（如海外制作的自建地图） 而 Google Maps（在线版） 在中国大陆地区同样使用 GCJ-02, 所以 GPS 坐标仍然会偏移。 小数度 度+分/60+秒/3600 garmin etrex solar的使用 太阳能 只要设备检测到阳光, 即使设备关机, 也会进行太阳能充电。 避免设备过热, 因为过热会减慢充电速度。注意：高温下, 设备可开启自我保护以防过热, 并自动停止充电。设备连接外部电源或电量满格时, 将不会进行太阳能充电。 探险模式 收集更少的 GPS 追踪点并关闭 Bluetooth 连接, 如果两分钟不活动, 自动选项会自动开启探险模式。可以在手动菜单中使用电源选项开启探险模式。间隔选项确定记录 GPS 追踪点的频率。 卫星系统 演示模式选项将关闭 GPS 投影航点 已知一点坐标和目标方向和距离, 导航至目标 重置行程数据 将所有行程信息数值归零。为了获得准确的信息, 请在开始行程前进行重置。 更多数据：新增更多数据字段至行程信息。 更少数据：从行程数据表中删除数据字段。 插入页面：插入可自定义数据字段的附加页面。 移除页面：移除包含自定义数据字段的多余页面。 恢复原厂设置：将行程信息恢复至出厂设置。 平均位置 进行平均时, 导航仪会在同一个位置取得多个 GPS 读数并使用平均值以提升准确度。 当可信度状态栏达到100％时, 选择保存。为了获得最佳结果, 请为航点收集四到八个样本, 两次样本之间至少要等待90分钟。 重新定位航点至当前位置 将航点位置更改为当前位置。 导航到起点 导航返回活动的起点。在野外迷路或无路可走时, 可使用此功能来脱离困境 目测导航 将设备指向远处的目标点, 锁定方向, 然后导航到目标点`,``,`html`,`方法`,`20240616183123-_java 方法签名 方法名和参数列表(它们合起来被称为"方法签名")唯一地标识出某个方法 可变参数列表 一个方法中只能有一个可变参数,且置于末尾 方法1: add(int i, int... f); //可以add(1, 2, 5),也可以add(1, new int[]{2,5}) 方法2: add(int i, int[] f); //不可以add(1, 2, 5) 一个类中同时存在方法1和方法2时,两者为重复定义而非重载 当add(1, 2)时, 优先调用方法2: add(int i, int[] f); 重载 参数类型,顺序,个数不同 与返回值无关 与访问修饰符无关 重写 存在于有继承关系的子类中 参数类型,顺序,个数相同 父类返回值为void或基本数据类型不允许修改,为引用类型时可以是父类或它的子类 访问修饰符权限不能小于父类 父类static修饰的方法不能被重写 若子类中也有方法签名一致的static方法时,视为子类独有方法,并非重写,而只是对父类的该方法做了隐藏`,``,`html`,`日志`,`20240425192057-_java 日志门面(一系列的日志接口) JCL (Commons Logging) Commons Logging常与Log4j组合使用 SLF4J (Simple Logging Facade for Java) Slf4j常与Logback组合使用 日志实现 log4j是apache实现的一个开源日志组件。Log4j 1当前已经停止维护，不建议使用 Log4j 在一些项目中仍然被广泛使用 Logback 是 log4j 的后继者，由 log4j 的作者设计和开发 Logback 具有较低的延迟和高吞吐量。 Logback 支持异步日志，但是需要使用 AsyncAppender 实现。 在配置简易性、社区支持等方面, Logback 是一个优秀的选择。 Log4j2是Log4j的升级产品,, Log4j 2不兼容Log4j 1（但log4j2提供了桥接包，可以将log4j1桥接到log4j2） log4j2 通过异步日志和可配置的缓冲区来提高性能，可以实现比 Logback 更高的吞吐量。 log4j2 默认就支持异步日志，不需要额外配置。 如果性能是首要考虑因素，可以选择 log4j2 Jul (Java Util Logging),自Java1.4以来的官方日志实现 无需额外的依赖，并且具有较好的集成性 如果是旧项目或需要与其他 Java 库集成，可以考虑使用 SLF4J + JUL，通过 SLF4J 将 JUL 日志转发到其他框架。 日志级别 TRACE:最详细的日志信息，通常用于跟踪程序的内部流程:通常不会在生产环境中启用，用于调试和详细跟踪信息 DEBUG:详细信息，用于调试应用程序，通常会输出较多信息:在开发和测试阶段启用，帮助开发人员调试和诊断问题 INFO:普通信息，表明应用程序正在运行:通常记录应用程序的主要事件和状态信息 WARN:警告信息，表示潜在的问题或不期望的情况，但不会导致应用程序失败:指示可能的问题，不会影响应用程序的正常运行 ERROR:错误信息，指出发生的错误或异常，可能会影响应用程序的正常运行:用于记录错误和异常情况，可能需要进一步的处理和干预 避免在循环中记录日志： 在循环中频繁记录日志会导致性能问题。应该避免在循环中记录大量的调试信息或详细信息。 可以考虑使用条件判断来控制日志记录的频率，以降低对性能的影响 异步日志记录： 如果日志记录对应用程序的性能产生较大影响，可以考虑使用异步日志记录。 异步日志记录允许在后台线程中执行日志记录操作，从而减少对主线程的影响。 定期清理日志文件： 长时间运行的应用程序可能会生成大量的日志文件，占用过多的磁盘空间。 应该定期清理旧的日志文件，避免磁盘空间不足和性能下降的问题。 可以使用定时任务或日志框架自带的日志文件滚动机制来实现日志文件的清理。 logback 依赖 logback-classic 包含了 SLF4J 的 API 依赖项，因此只需要单独引入 logback-classic 就可以了 Logback 1.2.3 是为 Java 8 编译的最后一个版本 如果你的项目运行在 Java 8 环境下，推荐使用 Logback 1.2.3 版本或更低的 1.2.x 版本。 Logback 1.2.6 也可以在 Java 8 环境下使用的原因是，Logback 1.2.x 系列的版本都是为 Java 7 及以上版本设计的。 虽然 Logback 1.2.6 可能包含一些 Java 9 或更高版本的改进和优化，但它仍然保持与 Java 8 的兼容性。 <dependency> <groupId>ch.qos.logback</groupId> <artifactId>logback-classic</artifactId> <version>1.2.3</version> </dependency> 配置 如果没有创建 resources/logback.xml 文件, Logback 默认将向控制台输出 INFO 级别及以上的日志，并且不会将日志输出到文件中 Logback本身不支持直接在同一个文件中定义和引用公共模式。你需要将公共的部分提取到一个单独的文件，然后在主配置文件中通过include标签引入, 如果不希望分成多个文件，使用Groovy配置也是一种选择 <?xml version="1.0" encoding="UTF-8" ?> <configuration> <appender name="root" class="ch.qos.logback.core.FileAppender"> <!-- 如果日志文件的路径没有特别指定，会在项目的根目录下生成 --> <file>logback_root.log</file> <encoder> <!-- %-5level 日志级别按5个字符占位右对齐 %logger{36} 产生信息的类名超出36个字符用缩写形式 %msg%n 信息和换行 --> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> <!-- 如果不指定字符编码，系统默认可能使用操作系统的默认编码 --> <charset>UTF-8</charset> </encoder> </appender> <!-- 注意区别FileAppender和ConsoleAppender, 输出到控制台不需要指定文件 --> <appender name="console" class="ch.qos.logback.core.ConsoleAppender"> <encoder> <!-- 控制台使用 ANSI 转义序列对关键信息着色 --> <pattern>%d{HH:mm:ss.SSS} [%thread] %highlight(%-5level) %logger{36} - %highlight(%msg) %n</pattern> </encoder> </appender> <!-- 使用 RollingFileAppender 类来处理日志文件的滚动和写入 --> <appender name="debug" class="ch.qos.logback.core.rolling.RollingFileAppender"> <!-- 指定了滚动策略为基于时间的滚动策略 --> <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"> <!-- 其中 %d 表示日期格式，生成的文件名类似于 LogX.2024-06-28.log，根据当前日期生成具体的文件名 --> <fileNamePattern>logback_debug.%d.log</fileNamePattern> </rollingPolicy> <encoder> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> <charset>UTF-8</charset> </encoder> <filter class="ch.qos.logback.classic.filter.LevelFilter"> <!-- 过滤器的目标级别为 INFO。不包括高于或低于INFO的级别, 如果要包含级别以上的使用ThresholdFilter--> <level>DEBUG</level> <onMatch>ACCEPT</onMatch> <onMismatch>DENY</onMismatch> </filter> <!-- <filter class="ch.qos.logback.classic.filter.ThresholdFilter"> <level>INFO</level> </filter> --> </appender> <appender name="info" class="ch.qos.logback.core.rolling.RollingFileAppender"> <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"> <fileNamePattern>logback_info.%d.log</fileNamePattern> </rollingPolicy> <encoder> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> <charset>UTF-8</charset> </encoder> <filter class="ch.qos.logback.classic.filter.LevelFilter"> <level>INFO</level> <onMatch>ACCEPT</onMatch> <onMismatch>DENY</onMismatch> </filter> </appender> <appender name="error" class="ch.qos.logback.core.rolling.RollingFileAppender"> <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"> <fileNamePattern>logback_error.%d.log</fileNamePattern> </rollingPolicy> <encoder> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> <charset>UTF-8</charset> </encoder> <filter class="ch.qos.logback.classic.filter.LevelFilter"> <level>ERROR</level> <onMatch>ACCEPT</onMatch> <onMismatch>DENY</onMismatch> </filter> </appender> <!-- 自定义日志记录器 --> <appender name="custom" class="ch.qos.logback.core.rolling.RollingFileAppender"> <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"> <fileNamePattern>logback_custom.%d.log</fileNamePattern> </rollingPolicy> <encoder> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> <charset>UTF-8</charset> </encoder> </appender> <!-- 未显式声明additivity(增加性)属性时等于隐式声明了additivity="true" 设为true时,记录器(logger)会继承其父logger的附加器(appender)配置，并将接收到的日志消息传递给其父logger和根logger 如果一个记录器的名称是另一个记录器名称的前缀（即名称以另一个名称开始），则这两个记录器具有父子关系 例如，com.example 是 com.example.MyClass 的父记录器 通过将 additivity 设置为 false，可以禁用这种继承行为，使得日志消息只会被当前logger处理 日志事件会先被发送到自定义记录器，然后才会传递给根记录器 如果日志事件级别为info,自定义记录器级别为error,根记录器级别为debug 那么自定义记录器不会接受此事件,因为additivity为false,根记录器也无法捕获到此事件 --> <logger name="com.ida.日志测试.LogbackTest" level="DEBUG" additivity="false"> <appender-ref ref="custom"/> </logger> <!-- 当一个日志消息到达根记录器时，意味着该消息未被任何其他具体记录器（即没有与之匹配的 logger）处理 因此根记录器会接收并处理这些未被处理的消息 根记录器可以被视为日志消息的“最后一道防线”，确保所有日志消息都有一个最终的输出位置 --> <root level="DEBUG"> <appender-ref ref="error"/> <appender-ref ref="info"/> <appender-ref ref="console"/> <appender-ref ref="debug"/> <appender-ref ref="root"/> </root> </configuration> 使用 package com.ida.日志测试; //注意包地址 //这些是Sun内部的SLF4J实现，不推荐在生产代码中使用它们，这些内部类可能不会与Logback正确集成，因此无法生成日志文件。 //com.sun.org.slf4j.internal.Logger //com.sun.org.slf4j.internal.LoggerFactory import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class LogbackTest { private static final Logger logger = LoggerFactory.getLogger(LogbackTest.class); public static void main(String[] args) { logger.debug("This is a debug message LogbackTest"); logger.info("This is an info message LogbackTest"); logger.error("This is an error message LogbackTest"); } } public class LogbackTest2 { private static final Logger logger = LoggerFactory.getLogger(LogbackTest2.class); public static void main(String[] args) { logger.debug("This is a debug message LogbackTest2"); logger.info("This is an info message LogbackTest2"); logger.error("This is an error message LogbackTest2"); // 使用自定义记录器 Logger customLogger = LoggerFactory.getLogger("com.ida.日志测试.LogbackTest"); customLogger.debug("This is a debug message from customLogger."); } } log4j2 依赖 <dependency> <groupId>org.apache.logging.log4j</groupId> <artifactId>log4j-api</artifactId> <version>2.14.1</version> </dependency> <dependency> <groupId>org.apache.logging.log4j</groupId> <artifactId>log4j-core</artifactId> <version>2.14.1</version> </dependency> 配置 log4j2.xml <?xml version="1.0" encoding="UTF-8"?> <!-- status属性用于设置 Log4j2 内部日志记录器的级别。 这个日志记录器负责记录 Log4j2 自身的行为和状态信息，例如配置文件加载、日志记录器初始化等 内部日志记录器产生的内容默认输出到控制台,主要用途是帮助开发人员调试 Log4j2 自身的配置和运行问题 开发阶段使用较低的日志级别（例如 debug 或 trace）来获取更多详细的日志信息，有助于调试和诊断问题 生产环境使用较高的日志级别（例如 error 或 fatal(非常严重的错误)）以减少不必要的日志输出，只记录重要的错误和警告信息。 --> <Configuration status="fatal"> <!-- 可复用的部分 --> <Properties> <!-- 如果日志文件的路径没有特别指定，会在项目的根目录下生成 --> <Property name="baseDir" value="D:\Dropbox\workspace\idea\practice"/> <!-- <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>是log4j1.x的格式 %p: 输出日志事件的级别 %l: 输出日志事件的源代码位置，包括类名、方法名、文件名和行号, com.example.MyClass.myMethod(MyClass.java:42) %l 输出源代码位置时，会对性能产生较大影响，获取行号涉及到在运行时解析堆栈跟踪信息，这是一项相对较昂贵的操作, 建议在开发和调试阶段使用，在生产环境中尽量避免使用。 %m: 输出日志事件的消息内容 %n: 输出换行符 --> <!-- %logger{36} 类名超36字符时采用缩写 %C{1} 如果类名是 com.example.MyClass，则只输出 MyClass,调整{1}中的数字来控制输出的类名部分数 %M：方法名 %L：行号 --> <Property name="p_debug" value="[%d{MM:dd HH:mm:ss.SSS}] [%level] [%logger{36}] [%C{1}.%M:%L] - %msg%n"/> <Property name="p_console" value="[%d{MM:dd HH:mm:ss.SSS}] %highlight{[%level]} [%logger{36}] - %highlight{%msg} %n"/> <Property name="p" value="[%d{MM:dd HH:mm:ss.SSS}] [%level] [%logger{36}] - %msg%n"/> </Properties> <Appenders> <!-- 控制台输出debug级以上信息 --> <Console name="console" target="SYSTEM_OUT"> <ThresholdFilter level="DEBUG" onMatch="ACCEPT"/> <!-- Log4j2 可能默认禁用了 ANSI 转义码。可以通过设置 disableAnsi="false" 属性来启用它 --> <PatternLayout pattern="&#36;{p_console}" disableAnsi="false"/> </Console> <!-- debug级别日志文件输出 --> <RollingFile name="debug" fileName="&#36;{baseDir}/log4j2_debug.log" filePattern="&#36;{baseDir}/log4j2_debug_%i.log.%d{yyyy-MM-dd}"> <!-- ThresholdFilter：根据日志级别过滤，比如只接受某个级别及以上的日志事件 <ThresholdFilter level="DEBUG"/> RegexFilter：使用正则表达式匹配日志消息内容来决定是否接受事件 <RegexFilter regex=".*error.*" onMatch="ACCEPT" onMismatch="DENY"/> LevelRangeFilter：指定一个级别范围来过滤日志事件 <LevelRangeFilter minLevel="INFO" maxLevel="WARN" onMatch="ACCEPT" onMismatch="DENY"/> --> <!-- Filters(过滤链)中包含了多个ThresholdFilter(阈值过滤器) 日志事件将按ThresholdFilter的声明顺序依次被处理 level 属性指定了日志消息的最低级别, 如果没有显示声明level, 默认为error 如果未显式指定 onMatch 和 onMismatch，它们的默认行为分别是 ACCEPT 和 NEUTRAL(即使默认值符合预期，显式设置可以减少配置错误的风险) ACCEPT [记录并向下传递], DENY [不记录且不向下传递], NEUTRAL [不记录但向下传递到下一个过滤器（如果有）] 影响范围仅限于当前附加器的过滤链 --> <Filters> <!-- debug、info、warn、error、fatal 级别的日志事件都会被接受 --> <!-- info、warn、error、fatal 级别的日志事件会被拒绝, debug,trace不记录但向下传递到下一个过滤器（如果有） --> <!-- 两个ThresholdFilter组合的效果是只接受级别等于debug的日志信息 --> <ThresholdFilter level="DEBUG"/> <ThresholdFilter level="INFO" onMatch="DENY" onMismatch="NEUTRAL"/> </Filters> <PatternLayout pattern="&#36;{p_debug}"/> <Policies> <!-- <TimeBasedTriggeringPolicy interval="1" modulate="true"/> interval(默认值1): 日志文件每隔1个时间单位进行滚动,具体取决于日志文件名模式中的日期格式 如果文件模式是 log_%d{yyyy-MM-dd-HH}.log，那么 interval="1" 则意味着每小时滚动一次 如果文件模式是 log_%d{yyyy-MM-dd}.log，那么 interval="1" 就意味着日志文件每天会滚动一次 modulate=(默认值true): 确保滚动时间点与自然时间单位（如午夜12点）对齐 即使默认值符合预期，显式设置可以减少配置错误的风险 size="10 MB": 当日志文件大小达到10 MB时进行滚动 当配置了多个触发策略时，日志滚动会在任意一个策略满足条件时触发 两个策略的组合确保了日志文件不会变得太大，同时也会按时间单位定期滚动 --> <TimeBasedTriggeringPolicy interval="1" modulate="true"/> <SizeBasedTriggeringPolicy size="10 MB"/> </Policies> </RollingFile> <!-- info级别日志文件输出 --> <RollingFile name="info" fileName="&#36;{baseDir}/log4j2_info.log" filePattern="&#36;{baseDir}/log4j2_info_%i.log.%d{yyyy-MM-dd}"> <Filters> <ThresholdFilter level="INFO"/> <ThresholdFilter level="ERROR" onMatch="DENY" onMismatch="NEUTRAL"/> </Filters> <PatternLayout pattern="&#36;{p}"/> <Policies> <TimeBasedTriggeringPolicy interval="1" modulate="true"/> <SizeBasedTriggeringPolicy size="10 MB"/> </Policies> </RollingFile> <!-- error级别日志文件输出 --> <RollingFile name="error" fileName="&#36;{baseDir}/log4j2_error.log" filePattern="&#36;{baseDir}/log4j2_error_%i.log.%d{yyyy-MM-dd}"> <Filters> <ThresholdFilter level="ERROR"/> </Filters> <PatternLayout pattern="&#36;{p}"/> <Policies> <TimeBasedTriggeringPolicy interval="1" modulate="true"/> <SizeBasedTriggeringPolicy size="10 MB"/> </Policies> </RollingFile> <!-- 总记录 --> <File name="root" fileName="&#36;{baseDir}/log4j2_root.log"> <Filters> <ThresholdFilter level="DEBUG"/> </Filters> <PatternLayout pattern="&#36;{p}"/> </File> <!-- 自定义记录器 --> <RollingFile name="CustomAppender" fileName="&#36;{baseDir}/log4j2_custom.log" filePattern="&#36;{baseDir}/log4j2_custom_%i-%d{MM-dd-yyyy}.log"> <ThresholdFilter level="DEBUG" onMatch="ACCEPT"/> <PatternLayout pattern="&#36;{p}"/> <Policies> <TimeBasedTriggeringPolicy/> <SizeBasedTriggeringPolicy size="10 MB" /> </Policies> </RollingFile> </Appenders> <Loggers> <!-- additivity="false" 不会向父记录器(没有父包则为Root)传播日志事件 只有配置在当前日志记录器下的附加器（Appender）会处理和记录日志消息，而不会有任何父级记录器的附加器参与记录 --> <Logger name="com.ida.日志测试.Log4j2Test" level="DEBUG" additivity="false"> <AppenderRef ref="CustomAppender"/> </Logger> <!-- 对于一条日志消息, 先查找是否属于某个自定义记录器(Logger)及是否匹配其等级, 没有的话就交给根记录器(Root), 根记录器处理所有没有被其他显式定义的日志记录器处理的日志事件 如果匹配到了某个记录器, 则所有与该记录器关联的附加器（Appender）都会接收这条日志消息,然后根据自身配置处理 --> <Root level="DEBUG"> <appender-ref ref="error"/> <appender-ref ref="info"/> <appender-ref ref="console"/> <appender-ref ref="debug"/> <appender-ref ref="root"/> </Root> </Loggers> </Configuration> 使用 package com.ida.日志测试; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class Log4j2Test { private static final Logger logger = LogManager.getLogger(Log4j2Test.class); public static void main(String[] args) { logger.debug("This is a debug message Log4j2Test"); logger.info("This is an info message Log4j2Test"); logger.error("This is an error message Log4j2Test"); } } public class Log4j2Test2 { private static final Logger logger = LogManager.getLogger(Log4j2Test2.class); public static void main(String[] args) { logger.debug("This is a debug message Log4j2Test2"); logger.info("This is an info message Log4j2Test2"); logger.error("This is an error message Log4j2Test2"); // 使用自定义记录器 Logger customLogger = LogManager.getLogger("com.ida.日志测试.Log4j2Test"); customLogger.debug("This is a debug message from customLogger."); } } JUL Java Util Logging (JUL) 中每个级别的含义 级别:数值:含义 SEVERE:1000:表示非常严重的错误事件，可能导致程序终止。 WARNING:900:表示潜在的问题或即将出现的错误情况，但不影响程序的继续执行。 INFO:800:表示程序正常运行的信息，用于描述程序的进度、状态和一些重要但非关键性的信息。 CONFIG:700:表示程序或系统配置的信息，通常用于在程序启动时输出配置信息。 FINE:500:表示详细的调试信息，用于跟踪程序的执行情况。 FINER:400:表示比 FINE 更详细的调试信息，用于更详细的跟踪和诊断。 FINEST:300:表示最详细的调试信息，用于最细粒度的跟踪和诊断。 ALL:0:启用所有日志消息的输出。 OFF:Integer.MAX_VALUE:关闭所有日志消息的输出。 配置类 package com.ida.日志测试; import java.io.IOException; import java.util.logging.ConsoleHandler; import java.util.logging.FileHandler; import java.util.logging.Filter; import java.util.logging.Level; import java.util.logging.LogRecord; import java.util.logging.Logger; import java.util.logging.SimpleFormatter; public class JULConfig { private static final Object globalLock = new Object(); private static final Object customLock = new Object(); public static void setup() throws IOException { // 获取全局日志记录器 Logger globalLogger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME); globalLogger.setUseParentHandlers(false); // 禁用默认的控制台处理器 // 创建控制台处理器并设置格式化器和日志级别 ConsoleHandler consoleHandler = new ConsoleHandler(); consoleHandler.setFormatter(new SimpleFormatter()); consoleHandler.setLevel(Level.ALL); // 设置控制台处理器的日志级别 globalLogger.addHandler(consoleHandler); // 创建不同级别日志的处理器 FileHandler fineHandler = new FileHandler("jul_fine.log", true); // 追加模式 FileHandler infoHandler = new FileHandler("jul_info.log", true); // 追加模式 FileHandler severeHandler = new FileHandler("jul_severe.log", true); // 追加模式 FileHandler rootHandler = new FileHandler("jul_root.log", true); // 追加模式 // 设置处理器的格式化器 SimpleFormatter formatter = new SimpleFormatter(); fineHandler.setFormatter(formatter); infoHandler.setFormatter(formatter); severeHandler.setFormatter(formatter); rootHandler.setFormatter(formatter); // 设置日志级别过滤器 fineHandler.setFilter(new LevelFilter(Level.FINE)); infoHandler.setFilter(new LevelFilter(Level.INFO)); severeHandler.setFilter(new LevelFilter(Level.SEVERE)); // 将处理器添加到日志记录器中 synchronized (globalLock) { globalLogger.addHandler(fineHandler); globalLogger.addHandler(infoHandler); globalLogger.addHandler(severeHandler); globalLogger.addHandler(rootHandler); // 设置rootHandler的日志级别 rootHandler.setLevel(Level.ALL); // 设置全局日志记录器的日志级别 globalLogger.setLevel(Level.ALL); } // 配置自定义记录器 setupCustomLogger(); } private static void setupCustomLogger() throws IOException { // 创建自定义记录器 Logger customLogger = Logger.getLogger("custom"); // 禁用自定义记录器的父级处理器 customLogger.setUseParentHandlers(false); // 创建处理器 FileHandler customHandler = new FileHandler("jul_custom.log", true); // 追加模式 customHandler.setFormatter(new SimpleFormatter()); // 设置日志级别 customHandler.setLevel(Level.ALL); // 添加处理器到自定义记录器 synchronized (customLock) { customLogger.addHandler(customHandler); customLogger.setLevel(Level.ALL); } } static class LevelFilter implements Filter { private final Level level; LevelFilter(Level level) { this.level = level; } @Override public boolean isLoggable(LogRecord record) { return record.getLevel().equals(level); } } } 使用 package com.ida.日志测试; import java.io.IOException; import java.util.logging.Logger; public class JULTest { private static final Logger logger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME); private static final Logger customLogger = Logger.getLogger("custom"); public static void main(String[] args) { try { JULConfig.setup(); } catch (IOException e) { e.printStackTrace(); return; } logger.fine("这是一条DEBUG信息"); logger.info("这是一条INFO信息"); logger.severe("这是一条ERROR信息"); customLogger.fine("这是一条DEBUG信息 custom"); customLogger.info("这是一条INFO信息 custom"); customLogger.severe("这是一条ERROR信息 custom"); } }`,``,`html`,`明代荆襄流民的治理史_摘`,`20240307183503-书摘 “四川、陕西两界相接之地，自定天下以来，番汉顽民多潜遁山谷间，不供征徭，不惧法度” 项忠杀伐远甚于白圭，“兵刃所加，无分玉石” 草木盛而变为矛戟，猿鹿多而化为豺鼠 不被统治的艺术`,``,`html`,`春光灿烂猪八戒`,`20241002173403-影摘 开心一刻也是地久天长，痛痛快快向前走决不回望。 这花开花落一千年一切形状，我还是自己模样 凡事要去做了才有希望 掌事大姐`,``,`html`,`智慧金块`,`20240307183503-书摘 我曾经看到一只小狗叼着一根肉骨头得意地走着，想找个地方好好地享受。忽然，一条大狗出现了，小狗叼着骨头狠命地跑，大狗气势汹汹地在后面追。当小狗发现自己根本跑不过大狗时，便立刻松开嘴扔下了骨头，大狗于是不再理小狗，叼起骨头扬长而去。小狗只是愣了一小会儿，便又欢快地摇着尾巴去寻找其他的食物了。 有时候我们只有放弃一些东西才会远离伤害、保全自己，虽然那些东西是我们十分需要或喜欢的；但是，我们还是要学会在放弃之后继续快乐地生活！ 篱笆另一边的草看起来总是比较翠绿，而他们看你的草也觉得你的草比较翠绿。它真的看起来比较翠绿、比较浓密、长得比较好，那就是距离所创造出来的幻象。 当你走近一点，你就会开始看出它并非如此。但是人们都跟别人保持距离，即使是朋友，甚至爱人，也都跟对方保持距离，太靠近是危险的，他们或许会看到你的真面目。 将生命献给那些美丽的事物，不要将生命给予那些丑陋的事物，因为你没有太多时间和太多精力可以浪费。我们的生命是那么地短暂，我们能量的泉源是那么地小，将它浪费在悲伤、愤怒、怨恨和嫉妒里简直是愚蠢。 为什么人们在谈论真理，而却仍然停留在谎言的世界里，那个原因是很清楚的，因为他们的内心对真理有一种渴望；他们不能够很真实，因此他们在他们自己面前感到羞耻，所以他们就开始谈论真理，但也仅止于谈谈而已，按照它来生活太危险了，他们不能够冒那个险。 要成为不可预测的，要成为一直在改变的。永远不要停止改变，永远不要停止成为不可预测的，唯有如此，生命才能够成为一件赏心悦事。 当你变成能够预测的，你就变成了一部机器。 机器是能够预测的，它昨天一样，今天一样，明天也将会一样，它是不变的。每一个片刻都在改变，那是人的特权。 你停止改变的那一天，你就以一种很微妙的方式死了。 将每一样东西都赌下去，成为一个赌徒！ 将每一样东西都冒险下去，因为下一个片刻是不确定的，所以，为什么要烦恼？为什么要挂虑？ 危险地去生活，高高兴兴地去生活，没有恐惧地去生活，没有罪恶感地去生活。生活，但是不要对地狱有任何恐惧，或是对天堂有任何贪婪。 只要生活。 服从不需要智力，所有的机器都是服从的，没有人曾经听过一部不服从的机器。 服从也是很简单的，它将任何责任的重担从你身上拿下来，不需要去反应，你只要做任何你被告知的。责任在于那个发出命令的源头。就某方面而言，你非常自由，你不会因为你的行为而遭到谴责。 你不能够在一个单一的行为基础上对他的整个人作描述，你甚至不知道那个行为，你甚至不知道它是什么情况下发生的，或许在那种情况下，你也会去偷；或许在那种情况下，偷窃并不是不好的，因为每一项行为都跟它所处的情况有关。 人生最困难，但也是最基本的事情之一，就是不要将生命划分为很美的事和愚蠢的事，根本不要划分，它们都是同一个整体的一部分。 它只需要一点幽默感。对我而言，如果一个人要成为完整的，幽默感是非常主要的。 一些小事和一些愚蠢的事有什么不对？你为什么不能对它们笑一笑，你为什么不能够享受它们？你一直都在判断说什么是对的，什么是错的。你一直都坐在一个判断的座位上，那使你变得很严肃。 没有人是更优越的，没有人是更低劣的，也没有人是相等的，每一个人都是独一无二的。 相等是心理学上的错误，不可能每一个人都是爱因斯坦，也不可能每一个人都是泰戈尔，但是那并非意味着泰戈尔比较优越，因为你不能够成为他。泰戈尔也不能够成为你。 我的整个要点就是：每一个人都是独一无二的呈现，所以我们必须摧毁整个优越和低劣的概念，相等和不相等的概念，而代之以“独一无二”的新观念。 每一个人都是独一无二的。 只要具有爱心地看，你将能够看出每一个个人都具有某种其他人所没有的东西。 你被太阳所接受，你被月亮所接受，你被树木所接受，你被海洋所接受，你被大地所接受，这样你还要什么呢？ 塑胶花是永恒的，塑胶爱也是永恒的，而真实的花是不永恒的，它每一个片刻都在改变，今天它在那里，在风中欢舞，在阳光下欢舞，在雨中欢舞，但是明天你将找不到它，它的消失跟它的出现一样神秘。 真实的爱就好像一朵真实的花 如果整个存在是一体的，如果整个存在一直都在照顾树木、动物、山岳、海洋――从最小的草叶到最大的星星―― 那么它也将会照顾你。 为什么要占有？占有只是显示出一件事：你不信任存在，你必须为你自己安排另外的保障和安全，你无法信任存在。 不占有基本上是对存在的信任。 不需要去占有，因为整体已经是我们的了。 打从一开始就是两个乞丐在互相乞讨，而他们两个人都只有空的乞丐碗。 当你说：“我爱你。”就有一个微妙的占有的意思在里面。 虽然没有被说出来，但是大家都了解：“现在你是我的占有物，不应该有其他的人再来爱你。” “我爱你”意味着“你也必须爱我”。事实上，我爱你只是因为我想要你爱我。它是一种简单的交易，因此会有害怕说：“你不应该爱其他任何人，也不应该有其他任何人来爱你，因为我不想要其他任何人成为我这个爱里面的合夥人，成为我这爱里面的分享者。” 信任的确具有比爱更高的价值，信任隐含了爱，但是在爱当中，信任是不被包含的。当你说：“我信任你。”那么我们就可以了解说你是具有爱的。 但是当你说你爱，信任与它无关。事实上，你的爱里面包含猜疑，你非常不信任，你非常害怕，你总是在监视着你所爱的那个人。爱人几乎变成了侦探，他们暗中在互相监视对方。 如果爱是信任的一部分，那么它是很美的，因为信任不能够没有爱。`,``,`html`,`月亮和六便士`,`20240307183503-书摘 但他性情超然，从他的谈话判断，这些年来，并没有什么事让他印象深刻。或许，当他来到巴黎，已经老大不小，光怪陆离的生活诱惑不了他。 遗憾的是，我无法描述他如何一步一步，战胜艰难，取得了卓越的成就；因为，如果我能描写他如何屡遭失败，坚持不懈，如何满怀勇气，从不绝望，在面对艺术家的劲敌——自我怀疑时，如何不屈不挠，再接再厉，我可能会激发读者们的同情。 斯特里克兰曾经暗示，布兰奇委身于他，有报复德克·斯特洛夫的意思，因为他是在她陷入绝境时救了她，斯特里克兰这话，为臆想打开了窗户，不免让人浮想联翩。我希望这不是真的。这太可怕了。但是，谁又能洞悉人心的奥秘？那些只希望从人心见出高雅情操和正常感情的人，当然不会理解。 当他重新恢复了自我，看着那个他享受过的女人，他一定不寒而栗。他的思想在九天之上徜徉，他的身体对她万分恐惧，也许宛如花丛中飞舞的彩蝶，见到自己胜利蜕变出来的肮脏蛹壳那样。 作家更关心知悉人性，而非判断人性 男人的灵魂在天际游荡，女人却想将它囚禁在自己的账本儿里。 也许，在我们的潜意识中，我们很看重自己对别人的影响，别人是否重视我们对他的看法很重要，如果我们对他的看法没有影响到他，我们就很讨厌他。我想，这正是人性虚荣最痛的创伤。 我不知道，为什么斯特里克兰突然提出让我看画。有这样一个机会，我还是蛮高兴。作品见真我。在社会交往中，一个人只让你看到他希望别人接受的一面，你只能凭他不经意间的举手投足，一颦一笑，对他有所了解。有时候，人们带着完美的假面，久而久之，真会弄假成真。但是，在他写的书、画的画里，他会毫无保留地表露自己。如果他装腔作势，只能暴露自己的空虚。滥竽充数，最终会被发现。冒充个性，无法掩饰平庸的头脑。对于目光敏锐的观察者来说，哪怕是一个人最漫不经心的创作，也会泄露他灵魂深处的秘密。 对于依然爱她而她已不爱的男人，女人往往比谁都残忍 有时候，一个人的外表和他的灵魂并不相称，这实在糟糕。德克·斯特洛夫，有着罗密欧的激情，托比·培尔契爵士 [39] 的身形。他本性善良大方，但行事荒唐莽撞；他深知美为何物，但创作平庸无奇；他见解独特敏锐，但举止粗俗笨拙。他与人交往老练圆通，可自己的事儿往往一塌糊涂。大自然在创造他时，将这么多自相矛盾的东西放在一起，让他面对令人迷惑不解的冷酷宇宙，这是多么残忍的恶作剧啊！ 但她的脸庞，仿佛一副从不开口的面具。 生活的经验表明，人们总是不断地去做招致灾祸的事情，但总有机会，能让人逃避愚蠢的后果 护士用她那双平静、善良的眼睛望着德克，这双眼睛不知看见过多少恐惧和痛苦，可那里面依然是一个没有罪恶的理想世界，所以依然平静。 我说的伟大，和时来运转的政治家或平步青云的军人无关；这种人的“伟大”源于他们的地位，而非自身的品质；形势一旦改变，这些人就微不足道了。常常，一位离职的首相不过是夸夸其谈的演说家，一个退休的将军不过是胆小软弱的市井之徒。 画家们的意见我不敢苟同，他们傲慢地声称，外行对绘画一窍不通，这种人对艺术作品最好的赞赏，就是沉默或支票簿。这是一种荒唐的误解，以为艺术只是工匠才懂的手艺。艺术是情感的体现，情之所至，人人都能理解。但我承认，批评家如果对技术实践没什么知识，很难说出真正有价值的观点 怀特布莱希特·罗特霍尔兹博士所属的这一历史学派，不只相信人性本恶，而且认为人性的邪恶远远超乎想象；确实，比起那些把浪漫人物写成道貌岸然的君子的作家来，这一流派的学者能够激起读者更大的兴趣。 那些豪言壮语，当他们说时，总以为前无古人，实际上却是陈词滥调，百年不变。钟摆来回摆荡，旅程永远循环。 如果我的写作不是自娱自乐，而是抱有其他想法，那我就是个十足的傻瓜。 “为什么漂亮的女人总是嫁给无趣的男人？” “因为有脑子的男人不娶漂亮的女人。” 我承认这种生活的社会价值，我也看到它井然有序的幸福，但是，我的血液里有一种强烈的冲动，渴望一种桀骜不驯的旅程。这样的安逸总让我惊惧。我的心渴望更加惊险的生活。只要我能有所改变——改变和不可预知的冒险，我将踏上嶙峋怪石，哪怕激流险滩。 2023年05月23日 17:19:30 摘自<<月亮与六便士.mobi>> 第23页 我不愿意看别人痛苦，自己却无力分忧； 我仿佛看见，自己去拜访查尔斯·斯特里克兰，递上我的名片；他走进房间，用大拇指和食指捏着它—— “请问，有何贵干？” “我来和你谈谈，你夫人的事。” “是吧。如果你年纪再大点儿，肯定会懂得，不该多管闲事。如果你把头稍稍向左转，就会看到，那边有一扇门。再见！” 亲爱的艾米： 我想你会发现，家中一切，都安排好了。你吩咐安妮的事，我已转告，等你和孩子回到家，晚饭会为你们准备好。我不能接你们了。我已决定离开你，明早就去巴黎。这封信，我到了之后会寄出。我不会再回来了。去意已决。不容更改。 你永远的， 旅途中，我对自己巴黎之行的使命，疑虑重重。现在，我已看不到斯特里克兰夫人痛苦的模样，可以更从容地考虑这件事。我发觉，她的行为有些矛盾，这让我疑惑不解。她很不幸，但为了引起我的同情，她向我表演她的不幸。显而易见，她准备大哭一场，因此准备了好多条手帕；我很钦佩她的深谋远虑，可现在回想起来，她眼泪的分量变轻。我说不准，她让丈夫回来，是因为爱他，还是怕招人议论；我也怀疑，爱的痛楚是否掺杂着虚荣心受伤的痛苦，这对我年轻的心灵来说，简直龌龊。我那时还不懂得，人性有多矛盾；我不知道，真诚中有多少虚伪，高尚中有多少卑鄙，或者，邪恶中有多少善良。 但是，我的巴黎之行本来就有些冒险，当我离目的地越近，情绪也越高涨。我也反观自己，就像在演戏，我对自己的角色非常满意：一个值得信赖的朋友，要把误入歧途的丈夫，带回给宽宏大量的妻子。 这会儿，正是克里希林荫路人头攒动的时刻，只要想象丰富，就能在来来往往的行人中，发现许多庸俗贪婪的浪漫。小职员、女售货员，仿佛是从巴尔扎克笔下走出的老式人物，凭借人性的弱点赚钱的各色男女。在巴黎的一些贫民区，街道上总是熙熙攘攘，充满勃勃生机，让人血脉偾张，灵魂随时静等着出人意料的事情发生。 当罪人对自己的罪行供认不讳，劝导的人又能如何？ “无论如何，法律会让你抚养你的妻子儿女，”我有些生气地说，“我想法律会为他们提供保护。” “法律能从石头里榨出油来吗？我没钱，就一百英镑。” 只有女人才会反反复复做同一件事，而且热情不减。 如果一个人的离经叛道切合他所在阶层的行事作风，那他在世人面前违反常规倒也不难。这会让他扬扬得意。既标榜了自己的勇敢，又不用担风险。 但是，这里真有一个不在乎别人看法的人，传统对他无可奈何。他就像是一个身上抹油的摔跤手，你根本抓不住他；这就给了他自由，让你火冒三丈。 人们想让别人认可自己的欲望如此强烈，害怕别人指责自己的恐惧如此剧烈，结果适得其反，引狼入室；而它就在那里监视，高度警惕，保卫着主人的利益，一旦这个人有了半点儿脱离集体的想法，马上就会受到它的斥责。它逼迫每一个人，把社会利益置于个人之上。它把每个人，牢牢系于整体之上。而人，总会说服自己，相信某种集体利益大于个人，结果沦为这个主子的奴隶。他将自己放在荣誉的宝座上。正如弄臣奉迎皇帝按在他肩头的御杖一样，最后，他也为自己有着敏锐的良心而倍感骄傲。 斯特里克兰夫人的姐姐，比她大几岁，样子和她差不多，只是更老些；她显得精明强干，仿佛整个大英帝国都揣在她的口袋里；这些高级官员的太太，深知自己身份尊贵，所以总这般神气。她神情活跃，她的教养几乎无法隐藏她的信念：如果不是军人，你连一个站柜台的都不如。 感情自有其理，理性难以知晓 女人总喜欢在爱人临终前表现得大度不凡，这始终让我感到不安。有时候，好像她们不情愿男人寿命太长，就是怕没机会把这一幕好戏尽早上演。 我那时和今天不同，认为人性单纯如一，但是，我沮丧地发现，原来这么迷人的女人也会有如此可怕的报复心。那时我还不明白，人性其实非常复杂。现在，我清楚地意识到：卑鄙与高尚，邪恶与善良，仇恨与热爱，可以并存于同一颗心灵中。 他劈头盖脸，问了一大堆。让我坐在一把椅子上，不停地拍打我，好像我是靠垫似的。 她安然地忙碌在锅碗瓢盆之间，使家务成为一种仪式，从而获得道德的意义； 你还记得第一次把她搂在怀里的喜悦吗？” 过了几天，斯特里克兰可以下床了。他瘦得简直皮包骨头。衣服穿在他身上，就像稻草人披着破布。他胡须凌乱，头发邋遢，他的五官，本来就比常人的要大，一场大病，让它们更加异乎寻常； 但正因奇怪，反而不显其丑。他的怪样，竟有一种威武庄严的气派，我真不知道，怎样才能准确描述他给我的印象。 “我爱她，远远胜过爱我自己。要我说，爱情中如果考虑自尊，只能说明你更爱自己。不管怎样，一个结了婚的男人爱上了别人，这司空见惯，常常等他的热乎劲儿过了，就又回到妻子身边，而她也接纳他，这种事，谁都觉得很自然。为什么男人可以这样，女人就不行？” “我不相信。简直不可思议。她本来那么受不了他啊。太不可思议了，简直让人难以置信。我还以为是我在吃醋呢。你明白，我一向爱吃醋，但我强迫自己不表现出来；她认识的每个男人我都吃醋，连你也是。我清楚，她不像我爱她那么爱我。这很正常，不是吗？但她允许我爱她，这我就够幸福的了。我强迫自己出去，一走就是几小时，好让他们在一起；我想惩罚我自己，这么爱怀疑，简直不配；但是当我回来，我发现他们并不需要我 说到底，这种感情不过是衣食无虞的满足，财产殷实的骄傲，受人爱慕的愉悦，以及家庭圆满的得意；女人赋予这种感情精神层面的价值，只是出于一种无伤大雅的虚荣。但这种感情，在面对激情时往往显得手足无措。我怀疑，布兰奇·斯特洛夫之所以非常讨厌斯特里克兰，一开始便有模糊的性诱惑的因素在内。我是谁啊，怎么可能解开性的复杂神秘？或许，斯特洛夫的激情，激起却未能满足她天性的一面，她讨厌斯特里克兰，是因为她觉得，他身上有自己所需要的那种力量。当她极力反对自己的丈夫把斯特里克兰带回家时，我想是真诚的；她被他吓坏了，虽然不知道为什么；我还记得，她曾预言会有灾祸。我觉得，她对斯特里克兰的恐惧，是对自己恐惧的奇怪移植，因为他让她疑惑，简直不可思议。斯特里克兰，相貌粗野狂放，眼神超然不群，嘴唇肉欲性感，身材高大健壮，这些都给人野性激情的印象；也许她和我一样，在他身上看到了某种邪恶，就像史前时期的野兽 他把日程排得满满的，不愿虚度每一寸光阴。 毛姆不光阅读量惊人，阅读速度也让人叹为观之。他可以短时间内通读莎士比亚、易卜生、巴尔扎克、福楼拜、莫泊桑等许多名家经典作品，并抄写熟记部分内容。 福楼拜曾经对他的学生莫泊桑说：“无论你想说的是什么，真正能表现他的句子只有一句。” 毛姆受福楼拜的影响深远，简单贯穿了他一生写作的脉络。 上帝的磨盘转得很慢，但磨得很细。 魔鬼要行凶，总会引用《圣经》。 一百多年前，奥斯卡·王尔德写下这样的话：“我不想谋生。我想生活。”这简直可以拿来概括《月亮与六便士》这部小说。 一九一五年，毛姆的长篇小说《人性的枷锁》发表，八月十二日，英国《泰晤士报文学增刊》刊发了一篇书评，称这部小说的主人公菲利普·凯里和许多年轻人一样，“为天上的月亮神魂颠倒，对脚下的六便士视而不见”。毛姆喜欢这个说法，所以才有了一九一九年出版的《月亮与六便士》这一书名。 “我”是谁？我们深陷于错综复杂的凡俗之中，对于别人和他们的生活无从知晓，只是凭着臆想，做出可能的判断。一切仿佛都是真实的，一切又都极不可靠。 不局限于传统的经典人物、线性叙述，或者现代派的意识流、荒诞、夸张变形，而是将写作当作一场平常而又奇异的旅行。旅行往往有目的，但也需要懂得享受落花流水、走走停停的意外之美，所以这部小说主题深刻，但外表非常放松，如同与你聊天。 斯特里克兰说：我不需要爱情。我没有时间恋爱。这是人性的弱点。我是个男人，有时候我需要女人。当我的欲望满足了，我就会去忙别的事情。真是讨厌，我无法克制自己的欲望；它囚禁着我的精神；我希望有一天，我可以不受欲望支配，自由自在地去工作。因为女人除了爱情什么也不懂，所以她们把爱情看得非常重要，简直荒谬。她们还想说服我们，让我们相信这就是生活的全部。实际上，这是微不足道的一部分。我只知道欲望。这是正常的、健康的。爱情是一种病。 毛姆曾说：“作为一个小说家，我回到年代悠远的新石器时代，仿效在山洞里围火讲故事的人。”他的小说表面看来确实非常朴素，并不复杂，但这丝毫掩盖不住他那游刃有余的刀锋。毛姆的小说夹叙夹议，人物性格鲜明，对话幽默生动，尤其分析透彻见底。 他们的举止稀奇古怪；但人们知道，一个人往往不是他想成为的那种人，而是他不得不成为的那种人。 这就像一群人高高兴兴，看着小丑的插科打诨哈哈大笑，却突然在他的眼神里瞥见了哀伤 一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死 但是这里却有一个真正不计较别人如何看待他的人，因而传统礼规对他一点也奈何不得。他象是一个身上涂了油的角力者，你根本抓不住他。 当我看到思特里克兰德对他的行为肯定会引起的斥责真的无动于衷的时候，我就象见到一个奇异的怪物一样，吓得毛骨悚然，赶快缩了回去。 思特里克兰德太太的姐姐比思特里克兰德太太年纪大几岁，样子同她差不多，只是更衰老一些。这个女人显出一副精明能干的样子，仿佛整个大英帝国都揣在她口袋里似的 卑鄙与伟大、恶毒与善良、仇恨与热爱是可以互不排斥地并存在同一颗心里的。 但是我知道她答应做这件事并不是出于仁慈的心肠。有人说灾难不幸可以使人性高贵，这句话并不对；叫人做出高尚行动的有时候反而是幸福得意，灾难不幸在大多数情况下只能使人们变得心胸狭小、报复心更强。 他劈头盖脸地问了我一大堆问题。他让我坐在一把椅子上，把我当靠垫似地拍打着，又是叫我吸雪茄，又是让我吃蛋糕，喝酒。他一分钟也不叫我停闲。因为家里没有威士忌，他简直伤心极了。他要给我煮咖啡，绞尽脑汁地想还能招待我些什么。他乐得脸上开了花，每一个汗毛孔都往外冒汗珠。 “如果我置身于一个荒岛上，确切地知道除了我自己的眼睛以外再没有别人能看到我写出来的东西，我很怀疑我还能不能写作下去。 叫我来说吧。我猜想你是这样一种情况。一连几个月你脑子里一直不想这件事，你甚至可以使自己相信，你同这件事已经彻底绝缘了。你为自己获得了自由而高兴，你觉得终于成为自己灵魂的主人了。你好象昂首于星斗中漫步。但是突然间，你忍受不住了。你发觉你的双脚从来就没有从污泥里拔出过。你现在想索性全身躺在烂泥塘里翻滚。于是你就去找一个女人，一个粗野、低贱、俗不可耐的女人，一个性感毕露令人嫌恶的畜类般的女人。你象一个野兽似地扑到她身上。你拼命往肚里灌酒，你憎恨自己，简直快要发疯了。” “我现在要告诉你一件看来一定是很奇怪的事：等到那件事过去以后，你会感到自己出奇地洁净。你有一种灵魂把肉体甩脱掉的感觉，一种脱离形体的感觉。你好象一伸手就能触摸到美，倒仿佛‘美’是一件抚摸得到的实体一样。你好象同飒飒的微风、同绽露嫩叶的树木、同波光变幻的流水息息相通。你觉得自己就是上帝。你能够给我解释这是怎么回事吗？” 作家更关心知悉人性，而非判断人性。 瓦尔特・饶利爵士②之所以永远珍留在人们记忆里是因为他把披风铺在地上，让伊丽莎白女皇踏着走过去，而不是因为他把英国名字带给了许多过去人们从来没有发现的国土 想到有那么多书被辛勤地写出来，作者看著书籍出版，抱着那么殷切的希望，等待着这些书又是什么样的命运，这真是一种有益身心的修养。一本书要能从这汪洋大海中挣扎出来希望是多么渺茫啊！即使获得成功，那成功又是多么瞬息即逝的事啊！天晓得，作者为他一本书花费了多少心血，经受多少磨折，尝尽了多少辛酸，只为了给偶然读到这本书的人几小时的休憩，帮助他驱除一下旅途中的疲劳。如果我能根据书评下断语的话，很多书是作者呕心沥血的结晶，作者为它绞尽了脑汁，有的甚至是孜孜终生的成果。我从这件事取得的教训是，作者应该从写作的乐趣中，从郁积在他心头的思想的发泄中取得写书的酬报；对于其他一切都不应该介意，作品成功或失败，受到称誉或是诋毁，他都应该淡然处之。 这些人同那些最活跃的年轻人比赛喉咙，但是他们发出的呐喊听起来却那么空洞，他们有如一些可怜的浪荡女人，虽然年华已过，却仍然希望靠涂脂抹粉，靠轻狂浮荡来恢复青春的幻影。 说这些豪言壮语的人可能还觉得他们在说一些前人未曾道过的真理，但是实际上连他们说话的腔调前人也已经用过一百次，而且丝毫也没有变化。钟摆摆过来又荡过去，这一旅程永远反复循环。 我记得我遇见不少身材壮硕、腰板挺得笔直的女人。这些女人生着大鼻头，目光炯炯，衣服穿在她们身上好象披着一挂甲胄 实际上他生得魁梧壮实，大手大脚，晚礼服穿在身上有些笨拙，给人的印象多少同一个装扮起来参加宴会的马车夫差不多 只要在我的生活中能有变迁――变迁和无法预见的刺激，我是准备踏上怪石嶙峋的山崖，奔赴暗礁满布的海滩的。 我没有说什么。我想到我去拜访查理斯・思特里克兰德，递上我的名片，我想到他走进屋子里来，用两个指头捏着我的名片。 “您有什么贵干？” “我来同您谈谈您太太的事。” “是吗？当您年纪再长几岁的时候，肯定就会懂得不该管别人的闲事了。如果您把头稍微向左转一转，您会看到那里有一扇门。再见。” 我看不透她要自己丈夫回来是因为爱他呢，还是因为怕别人议论是非；我还怀疑使她肠断心伤的失恋之痛是否也搀杂着虚荣心受到损害的悲伤（这对我年轻的心灵是一件龌龊的事）；这种疑心也使我很惶惑。我那时还不了解人性多么矛盾，我不知道真挚中含有多少做作，高尚中蕴藏着多少卑鄙，或者，即使在邪恶里也找得着美德。`,``,`html`,`枚举`,`20240616183123-_java 枚举类最终会被编译为被 final 修饰的普通类，它的所有属性也都会被 static 和 final 关键字修饰，所以枚举类在项目启动时就会被 JVM 加载并初始化，而这个执行过程是线程安全的，所以枚举类也是线程安全的类,可以避免反射和序列化问题 compareTo() 比较两个枚举成员在定义时的顺序,返回的是索引值的差值 values()：返回 enum 实例的数组，数组中的元素严格保持在 enum 中声明时的顺序。 name()：返回实例名。 ordinal()：返回实例声明时的次序，从0开始。 getDeclaringClass()：返回实例所属的 enum 类型。 equals()：判断是否为同一个对象。 可以使用 ==来比较enum实例 如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加 JDK7后switch支持enum类型 interface INumberEnum { int getCode(); String getDescription(); } //错误码 public enum ErrorCode implements INumberEnum{ OK(0, "成功"), ERROR_A(100, "错误A"), ERROR_B(200, "错误B"); ErrorCode(int number, String description) { this.code = number; this.description = description; } private int code; private String description; @Override public int getCode() { return code; } @Override public String getDescription() { return description; } public static void main(String args[]) { for (ErrorCode s : ErrorCode.values()) { System.out.println("code: " + s.getCode() + ", description: " + s.getDescription()); } } } 策略枚举,通过枚举嵌套枚举的方式,将枚举常量分类处理 public enum PayrollDay { MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND); //常量 private final PayType payType; //构造 PayrollDay(PayType payType) { this.payType = payType; } //普通方法 double pay(double hoursWorked, double payRate) { return payType.pay(hoursWorked, payRate); } //嵌套枚举 private enum PayType { WEEKDAY { double overtimePay(double hours, double payRate) { return hours <= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT) * payRate / 2; } }, WEEKEND { double overtimePay(double hours, double payRate) { return hours * payRate / 2; } }; //常量 private static final int HOURS_PER_SHIFT = 8; //抽象方法 abstract double overtimePay(double hrs, double payRate); //普通方法 double pay(double hoursWorked, double payRate) { double basePay = hoursWorked * payRate; return basePay + overtimePay(hoursWorked, payRate); } } //测试 public static void main(String[] args) { System.out.println("时薪100的人在周五工作8小时的收入：" + PayrollDay.FRIDAY.pay(8.0, 100)); System.out.println("时薪100的人在周六工作8小时的收入：" + PayrollDay.SATURDAY.pay(8.0, 100)); } } ------------------------ 时薪100的人在周五工作8小时的收入：800.0 时薪100的人在周六工作8小时的收入：1200.0 在接口中组织枚举类 interface ColorInterface { enum ColorEnum implements ColorInterface { GREEN, YELLOW, RED } enum NewColorEnum implements ColorInterface { NEW_GREEN, NEW_YELLOW, NEW_RED } } public class EnumTest { public static void main(String[] args) { // 赋值第一个枚举类 ColorInterface colorEnum = ColorInterface.ColorEnum.RED; System.out.println(colorEnum); // 赋值第二个枚举类 colorEnum = ColorInterface.NewColorEnum.NEW_RED; System.out.println(colorEnum); } } ----------------- RED NEW_RED EnumSet  public class EnumTest { public static void main(String[] args) { List<Colorenum> list = new ArrayList<Colorenum>(); list.add(ColorEnum.RED); list.add(ColorEnum.RED); // 重复元素 list.add(ColorEnum.YELLOW); list.add(ColorEnum.GREEN); // 去掉重复数据 EnumSet<Colorenum> enumSet = EnumSet.copyOf(list); System.out.println("去重：" + enumSet); // 获取指定范围的枚举（获取所有的失败状态） EnumSet<ErrorCodeEnum> errorCodeEnums = EnumSet.range(ErrorCodeEnum.ERROR, ErrorCodeEnum.UNKNOWN_ERROR); System.out.println("所有失败状态：" + errorCodeEnums); } } enum ColorEnum { RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLOW("黄色", 4); private String name; private int index; private ColorEnum(String name, int index) { this.name = name; this.index = index; } } enum ErrorCodeEnum { SUCCESS(1000, "success"), ERROR(2001, "parameter error"), SYS_ERROR(2002, "system error"), NAMESPACE_NOT_FOUND(2003, "namespace not found"), NODE_NOT_EXIST(3002, "node not exist"), NODE_ALREADY_EXIST(3003, "node already exist"), UNKNOWN_ERROR(9999, "unknown error"); private int code; private String msg; ErrorCodeEnum(int code, String msg) { this.code = code; this.msg = msg; } } ----------------- 去重：[RED, GREEN, YELLOW] 所有失败状态：[ERROR, SYS_ERROR, NAMESPACE_NOT_FOUND, NODE_NOT_EXIST, NODE_ALREADY_EXIST, UNKNOWN_ERROR] 枚举单例 //枚举类型在类加载时就会被初始化，这意味着在第一次使用枚举类型的任何成员时，所有枚举实例都会被创建 //类似于饿汉式没有懒加载, 如果在不需要懒加载的情况下，推荐使用枚举单例模式。 //当一个序列化的对象被反序列化时，会创建一个新的对象，这就破坏了单例模式的初衷 //Java 语言规范不允许通过反射来创建枚举类型的新实例 //防止反序列化攻击：枚举类不会被反序列化破坏单例。即使在面对复杂的序列化或者反射攻击的情况下，枚举单例也能保证单例的实现。 //序列化问题：枚举类型默认提供了序列化机制，保证在序列化和反序列化过程中枚举实例的唯一性。 //简洁明了：枚举单例的实现非常简单明了，而饿汉式单例需要编写更多的代码来实现单例的特性，例如需要在构造函数中处理实例已存在的情况等。 public enum SingletonEnum { INSTANCE("Initial value"); private String value; // 构造方法 SingletonEnum(String value) { this.value = value; } //getter,setter // 实现单例的具体逻辑 public void doSomething() { System.out.println("SingletonEnum is doing something with value: " + value); } } public class Main { public static void main(String[] args) { public static void main(String[] args) { SingletonEnum singleton = SingletonEnum.INSTANCE; System.out.println(singleton.getValue()); // 输出 "Initial value" singleton.setValue("Hello, World!"); singleton.doSomething(); // 输出 "SingletonEnum is doing something with value: Hello, World!" SingletonEnum anotherSingleton = SingletonEnum.INSTANCE; System.out.println(anotherSingleton.getValue()); // 输出 "Hello, World!" } } } 假设我们有一个游戏，游戏中有三个角色：战士、法师和牧师。每个角色都有自己的属性：血量、攻击力和防御力。 我们可以使用枚举类型来表示这三个角色，代码如下： enum Role { WARRIOR("战士", 100, 50, 30), MAGE("法师", 80, 70, 20), PRIEST("牧师", 60, 30, 50); private String name; // 角色名称 private int hp; // 角色血量 private int attack; // 角色攻击力 private int defense; // 角色防御力 // 构造方法 Role(String name, int hp, int attack, int defense) { this.name = name; this.hp = hp; this.attack = attack; this.defense = defense; } public void setHp(int hp) { this.hp = hp; } public String getName() { return name; } public int getHp() { return hp; } public int getAttack() { return attack; } public int getDefense() { return defense; } } class Player { private Role role; // 玩家角色 public Role getRole() { return role; } public Player(Role role) { this.role = role; } public void attack(Player target) { int damage = this.role.getAttack() - target.getRole().getDefense(); if (damage > 0) { int newHp = target.getRole().getHp() - damage; // 防止血量出现负值 target.getRole().setHp(Math.max(newHp, 0)); } } } public class GameTest { public static void main(String[] args) { Player player1 = new Player(Role.WARRIOR); Player player2 = new Player(Role.MAGE); System.out.println("玩家1选择了" + player1.getRole().getName()); System.out.println("玩家2选择了" + player2.getRole().getName()); player1.attack(player2); System.out.println("玩家2的血量为：" + player2.getRole().getHp()); } } ----------------- 玩家1选择了战士 玩家2选择了法师 玩家2的血量为：50`,``,`html`,`桃色公寓`,`20240307183503-影摘 不论在什么时代，不论在哪个国家，我们面对的问题都是相似的，你要做的就是对摆在面前的各种选项权衡利弊，做出选择，同时坚定地走下去。这就是看完这部“公寓”之后给我最深的感受。 Baxter是一家大公司里的小职员，就和50年后的今天一样，想在拥有几万员工的大公司里被人瞩目，崭露头角，要不就任劳任怨的埋头苦干，一步一步往上爬，要不就得抓住机会引起领导们的注意。当然最开始是无意为之，到后来变成骑虎难下，可这是Baxter对自己在公司里的生存方式做出的选择——出租自己的公寓作为老板们与情人相会的“爱巢”。当然也许最糟糕的选择：他不得不经常在公司加班，以打发等待客人离开的时间，或者在雨夜中受冻挨饿，等待回到温暖的家中；但这也是让他“拥有经理盥洗室钥匙”的最快的选择，我们的主人公因为出租公寓，很快认识了4个高层主管，并被他们保鉴到人事部长那里，眼看升官在即。Baxter对于爱情也一直采取主动出击的态度，明知道电梯小姐fran不好追，却仍然不放弃尝试。很快他发现一手掌握自己事业发展的人事主管居然和自己心仪已久的女人有着千丝万缕的联系，该选择事业，还是为了爱情牺牲自己为之努力的一切？ 当然片子中的每个人都要为自己做出选择，人事经理是和妻子离婚还是继续欺骗fran，而fran又应该在两个男人之中选择谁？ 人事经理是三人中拥有最多的人，可他却最难放弃，既想维持和太太的婚姻，又想享受fran的温柔。离婚不是他自己的选择，而是被自己的贵妇太太扫地出门的，和fran在一起是他当时唯一的归宿，不难想象当有新的选择摆在他面前时，他还会继续贪婪地都想占为己有。 相对的，穷困的小职员和不识字的电梯员却能决绝地做出决定，抛弃辛苦拥有的一切：电影的结尾Baxter和fran选择了重新开始，Baxter交出盥洗室的钥匙，而fran在圣诞夜抛弃了已经离婚的人事经理。在公寓里，fran一句“shut up & deal”把前面的过往抹得烟消云散，两个人都重新站在了新的起点。 有朋友觉得这部电影的整个基调都很消极或者悲伤，但我却觉得，电影中，两位主人公不管采取什么样的手段，从头到尾都是在坚持自己的选择，都是在努力生活并全心享受生活的人，也许一度也很被动，但很快他们都能把生活的主动权掌握在自己的手里，所以不论那盘牌过后他们会怎样，两人都已经是人生的赢家。`,``,`html`,`正则`,`20240328174034-_工具使用 https://regex101.com/ Java 和 JavaScript 的正则表达式在语法和功能的区别 在贪婪量词,捕获组和正向预查的使用方式上基本一样,但在反向预查上存在差异，JavaScript 不支持反向预查 语法差异： Java 使用双反斜杠 \\ 来转义特殊字符，例如 \d 表示数字字符，在 Java 中应写作 \\d。 JavaScript 使用单反斜杠 \ 来转义特殊字符，例如 \d 表示数字字符，在 JavaScript 中写作 \d。 匹配方式： Java 的正则表达式是基于 Perl 5 的正则表达式，支持多种匹配模式（如贪婪匹配、非贪婪匹配等）。 JavaScript 的正则表达式也支持贪婪匹配和非贪婪匹配，但默认情况下是贪婪匹配。 标志符： 在 Java 中，标志符（如忽略大小写、多行模式等）是通过在正则表达式开头使用 (?...) 语法来设置的。 在 JavaScript 中，标志符是作为第二个参数传递给正则表达式的构造函数或者 RegExp 对象的方法来设置的。 特殊字符差异： Java 中的正则表达式中，字符类（Character Class）中的特殊字符（如 [, ], -, ^ 等）在某些情况下需要转义，以防止其被解释为特殊含义。 JavaScript 中的正则表达式中，字符类中的特殊字符不需要转义。 常规 ^ 英文称为caret/ˈkærət/,别名插入符号、帽子、控制符、上箭头 \d \D大写为非 . 任意单字符 * 不限数量 .* 任意长度的字符，包括零个字符 \d* 等价\d{0,} 任意次 \d? 等价\d{0,1} 至多1次 \d+ 等价\d{1,} 至少1次 [\u4e00-\u9fa5] 单个中文字符 (^[\u4e00-\u9fa5]{2,8}$)|(^[A-Z][a-z]+\s[A-Z][a-z]*$) 中英姓名 贪婪 正则默认为贪婪模式(在满足条件的情况下尽可能多地匹配) 12345 贪婪 \d{3,4} 1234 非贪婪 \d{3,4}? 123 "属性1","属性2" 贪婪 ".*" "属性1","属性2" 非贪婪 ".*?" 问号跟在长度后面 "属性1" "属性2" 常见的贪婪量词包括： *：零次或多次匹配，贪婪匹配。使用 *? 表示非贪婪匹配。 +：一次或多次匹配，贪婪匹配。使用 +? 表示非贪婪匹配。 对于字符串aaa a+ 会直接匹配"aaa" a+? 则会匹配"a","a","a" ?：零次或一次匹配，贪婪匹配。使用 ?? 表示非贪婪匹配。 {n}：匹配 n 次，贪婪匹配。使用 {n}? 表示非贪婪匹配。 {n,}：至少匹配 n 次，贪婪匹配。使用 {n,}? 表示非贪婪匹配。 {n,m}：匹配 n 到 m 次，贪婪匹配。使用 {n,m}? 表示非贪婪匹配。 分组 abababcdcdcd (ab){2}(cd){2} 加上小括号后就可以像对待单个字符一样约束其作为整体出现的次数 ababcdcd var regex = /(?:https?|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/; var url = "https://www.example.com/path/to/resource"; var matches = url.match(regex); //数组的第一个元素为匹配到的整个字符串 console.log(matches[0]); // https://www.example.com/path/to/resource console.log(matches[1]); // www.example.com console.log(matches[2]); // /path/to/resource url中有主机名和路径 String s = "https://www.example.com/path/to/resource\nftp://www.example2.com/path/to/resource2"; //标志符和非捕获组 // ([^/\\r\\n]+) 第一组: 不包含 /、\r 或 \n 的,{1,}次 // (/[^\\r\\n]*) 第二组: 以 / 开头的，不包含 \r 或 \n的,{0,}次, 第二组整体出现{0,1}次 Pattern p = Pattern.compile("(?m)(?:https?|ftp)://([^/\\r\\n]+)(/[^\\r\\n]*)?"); Matcher m = p.matcher(s); while (m.find()){ System.out.println(m.group(0));//group(0)为整个字符串, group()方法在不带参数的情况下，相当于调用group(0) System.out.println(m.group(1));//主机名 System.out.println(m.group(2));//路径 } /* https://www.example.com/path/to/resource www.example.com /path/to/resource ftp://www.example2.com/path/to/resource2 www.example2.com /path/to/resource2 */ 宽度断言,环视,预查,前瞻后顾 "Swift1 Swift2 Swift3Swift4Swift4Swift4" (Swift4)\ 1 匹配Swift4Swift4，其中\ 1即表示使用了存储的匹配(存储的第一个匹配)，相当于匹配两次Swift4； (Swift3)(Swift4)\ 2 匹配Swift3Swift4Swift4，其中\ 2即表示使用了存储的第二个匹配，即Swift4(当然第一个匹配为：Swift3)； (?:Swift3)(Swift4)\ 1 匹配Swift3Swift4Swift4，与(Swift3)(Swift4)\ 2相同； 由于在小括号中使用了?:，作用是匹配Swift3字符串，但不会存储该匹配,所以第一个匹配(Swift3)没有被存储，只存储了后面的第二个匹配(Swift4)； 若写成(?:Swift3)(Swift4)\ 2，则正则表达式错误，因为没有存储第二个匹配； 捕获非捕获型分组通常在需要使用分组但不需要捕获结果的情况下使用 例如以下,协议头需要小括号包起来实现二选一,但是又不需要把它作为结果存储 Swift(?=4) 匹配右边紧跟着4的Swift； 其中(?=)称为：正向预查匹配,也称前瞻断言,Positive Lookahead (?=4)表示先看看有没有4 如果有，则把4左边的Swift匹配出来 如果没有，则继续向右查看，这个过程就是正向预查匹配。 不消耗字符：正向预查在匹配过程中不消耗字符，即预查的内容在匹配结束后仍然可用于后续匹配。 匹配条件：正向预查用于匹配一个位置，而不是具体的字符。它只是检查当前位置之后的字符是否符合预查条件，而不会将这些字符作为匹配结果的一部分。 不包含在匹配结果中：正向预查匹配的内容不会包含在最终的匹配结果中。只有正向预查条件匹配成功，才会继续进行后续的匹配。 提高灵活性：正向预查可以提高匹配的灵活性，允许在匹配某个子表达式之前或之后添加额外的条件 Swift(?=.*[0-9]) 后面必须要带任意长度任意字符并有一位数字。 Swift(?!4) 匹配右边不跟着4的Swift； 其中(?!)称为：正向预查不匹配，也称否定前瞻断言（Negative Lookahead）,(?!4)表示先看看有没有4 如果没有，也即不等于4的情况，则把左边的Swift匹配出来 如果有，则继续向右查看，这个过程就是正向预查不匹配。 (?<=4)Swift 匹配左边紧跟着4的Swift，即第五个Swift单词，索引为26到30的字符； 其中(?<=)称为：反向预查匹配，也称后顾断言（Positive Lookbehind）,(?<=4)表示先看看有没有4 如果有，则把4右边的Swift匹配出来 如果没有，则继续向右查看，这个过程就是反向预查匹配。 (?< !4)Swift 匹配左边不跟着4的Swift，即第1、2、3、4个Swift单词； 其中(?< !)称为：反向预查不匹配，也称否定后顾断言（Negative Lookbehind）,(?< !4)表示先看看有没有4 如果没有，也即不等于4的情况，则把右边的Swift匹配出来 如果有，则继续向右查看，这个过程就是反向预查不匹配。 public class 正则测试 { public static void main(String[] args) { args = new String[]{ "Swift1 Swift2 Swift3Swift4Swift4Swift4", "(Swift4)\\ 1", // 注意这里的双反斜杠，Java字符串中的反斜杠需要转义 "(Swift3)(Swift4)\\ 2", "(?:Swift3)(Swift4)\\ 1", "Swift(?=4)", "Swift(?=.*[0-9])", "Swift(?!4)", "(?<=4)Swift", "(?<!4)Swift" }; for (int i = 1; i < args.length; i++) { System.out.println("expression: \"" + args[i] + "\" "+"target: \""+args[0]+"\""); int count = 1; Pattern p = Pattern.compile(args[i]); Matcher m = p.matcher(args[0]); while (m.find()) { System.out.println("Match "+(count++)+" \"" + m.group() + "\" at positions " + m.start() + "-" + (m.end() - 1)); } System.out.println("------------------------------"); } } } /* expression: "(Swift4)\ 1" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift4Swift4" at positions 20-31 ------------------------------ expression: "(Swift3)(Swift4)\ 2" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift3Swift4Swift4" at positions 14-31 ------------------------------ expression: "(?:Swift3)(Swift4)\ 1" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift3Swift4Swift4" at positions 14-31 ------------------------------ expression: "Swift(?=4)" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift" at positions 20-24 Match 2 "Swift" at positions 26-30 Match 3 "Swift" at positions 32-36 ------------------------------ expression: "Swift(?=.*[0-9])" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift" at positions 0-4 Match 2 "Swift" at positions 7-11 Match 3 "Swift" at positions 14-18 Match 4 "Swift" at positions 20-24 Match 5 "Swift" at positions 26-30 Match 6 "Swift" at positions 32-36 ------------------------------ expression: "Swift(?!4)" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift" at positions 0-4 Match 2 "Swift" at positions 7-11 Match 3 "Swift" at positions 14-18 ------------------------------ expression: "(?<=4)Swift" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift" at positions 26-30 Match 2 "Swift" at positions 32-36 ------------------------------ expression: "(?<!4)Swift" target: "Swift1 Swift2 Swift3Swift4Swift4Swift4" Match 1 "Swift" at positions 0-4 Match 2 "Swift" at positions 7-11 Match 3 "Swift" at positions 14-18 Match 4 "Swift" at positions 20-24 ------------------------------ */ public void matches_lookingAt() { final String REGEX = "foo"; final String INPUT = "fooooooooooooooooo"; final String INPUT2 = "ooooofoooooooooooo"; Pattern pattern; Matcher matcher; Matcher matcher2; pattern = Pattern.compile(REGEX); matcher = pattern.matcher(INPUT); matcher2 = pattern.matcher(INPUT2); //lookingAt()尝试将整个输入字符串与正则表达式进行匹配。如果整个字符串与模式完全匹配，则返回 true。 System.out.println(matcher.lookingAt());//true System.out.println(matcher2.lookingAt());//false //尝试从输入字符串的开始位置进行匹配。如果输入字符串的开头部分与模式匹配，则返回 true，即使整个字符串不匹配 System.out.println(matcher.matches());//false System.out.println(matcher2.matches());//false } public void appendReplacement_appendTail() { final String REGEX = "a*b"; final String INPUT = "aabfooaabfooabfoobfoo"; final String REPLACE = "-"; Pattern p = Pattern.compile(REGEX); Matcher m = p.matcher(INPUT); StringBuffer sb = new StringBuffer(); while(m.find()){ //把匹配到的内容替换为REPLACE //把从上次替换的位置到这次替换位置之间的字符串也拿到，然后加上这次替换后的结果一起追加到 StringBuffer //假如这次替换是第一次替换，那就是只追加替换后REPLACE m.appendReplacement(sb,REPLACE); } System.out.println(sb);//-foo-foo-foo- m.appendTail(sb);//把最后一次匹配到内容之后的字符串追加到 StringBuffer 中 System.out.println(sb);//-foo-foo-foo-foo // 两个方法一起使用就可以达到所有替换或者替换第一个 // // 所有替换 // while(m.find()){ // m.appendReplacement(sb,REPLACE); // } // m.appendTail(sb); // //替换第一个 // if (matcher.find()){ // matcher.appendReplacement(sb, REPLACE); // } // matcher.appendTail(sb); } 正则表达式的标志 这些标志可以单独使用，也可以组合在一起使用，以改变正则表达式的匹配行为 i 忽略大小写，即在匹配时不区分大小写。 g 全局匹配，即匹配所有符合条件的结果，而不是第一个匹配项。 m 多行匹配只有当使用^和$模式时才会起作用 多行匹配模式 m 主要影响 ^ 和 $ 这两个锚点的匹配行为。在默认情况下，^ 和 $ 只匹配整个字符串的开头和结尾，而不考虑换行符。 而使用多行匹配模式 m 时，正则表达式会考虑换行符, ^ 和 $ 的行为会发生变化： ^ 匹配行的开头，而不仅仅是整个字符串的开头。 $ 匹配行的结尾，而不仅仅是整个字符串的结尾。（行尾是 \n 或 \r 或 \r\n） s 通常情况下，. （点号）只能匹配除了换行符之外的任意字符 而在单行模式下，点号可以匹配任意单个字符，包括换行符 y 全局匹配会尝试在整个字符串中找到所有匹配项，而粘性匹配则会从上一次匹配的位置开始，只匹配剩余的字符串 let regex = /\d+/y; // 使用粘性匹配标志 'y' let text = "123 456"; let match; // 第一次匹配 match = regex.exec(text); console.log(match); // ["123"] // 再次匹配，从上一次匹配的位置开始 match = regex.exec(text); console.log(match); // ["456"] // 再次匹配，已经匹配完所有数字，返回 null match = regex.exec(text); console.log(match); // null u 处理 Unicode 编码超过 \uFFFF 的字符 // 使用 Unicode 匹配模式 let regex = /\u{1F601}/u; let text = "Hello! 😁"; // 检查文本中是否包含笑脸符号 console.log(regex.test(text)); // true //笑脸符号 "😁" 的 Unicode 编码是 U+1F601，它被表示为一个代理对，因此字符串长度为 2。 const emoji = "😁"; // U+1F601 console.log(emoji.length); // 2，代理对长度为 2 在 JavaScript 中，字符串是以 UTF-16 编码存储的。当你声明一个字符串时，JavaScript 将根据字符串中的字符自动选择使用 1 个或 2 个 16 位编码来表示每个字符。如果字符的 Unicode 编码超出了 16 位范围，则会使用 2 个 16 位编码。 UTF-16 (Unicode Transformation Format, 16-bit) 是一种可变长度字符编码，用于表示 Unicode 字符集中的字符。在 UTF-16 编码中，基本的 Unicode 字符（U+0000 到 U+FFFF）使用一个 16 位编码表示，而其他字符（U+10000 到 U+10FFFF）使用一对 16 位编码表示，这对编码称为代理对（surrogate pair）。 例 //233 656-5521 //(266)448-6662 //(266) 446-6662 //(266) 446-6663 //233 656 5521 public class 从文本中提取电话 { public static void main(String[] args) throws IOException { ClassLoader classLoader = 从文本中提取电话.class.getClassLoader(); BufferedReader in; //使用 ClassLoader.getResourceAsStream() 和 Class.getResource() 是两种常见的读取资源文件的方法, 参见反射应用例1 in = new BufferedReader(new InputStreamReader(classLoader.getResourceAsStream("phone.txt"))); Pattern pattern = Pattern.compile("\\(\\d{3}\\)\\s\\d{3}-\\d{4}"); String s; while ((s = in.readLine()) != null) { Matcher matcher = pattern.matcher(s); if (matcher.find()) System.out.println(matcher.group()); } in.close(); //(266) 446-6662 //(266) 446-6663 } }`,``,`html`,`正德演义`,`20250209212136-影摘 茶来, 酒来 造膝宴 江山是主, 人是客 神器永固 觊觎非分，窥窃神器 棋风老辣 黄白之物 来将通名 早就忘了自己叫什么了 本帅不斩无名之将 气煞我了 小将军可是来偷营劫寨的 非也, 我是来安营扎寨的 安营扎寨? 岂能是无声无息的勾当 正待要放炮安营, 却遇偷袭 身上可有何宝物 可惜没有带在身边 那宝物为何物何名 五子登科大保国 大侄子, 今夜你来是想做什么来了 洗脚来了 洗脚? 你终于想开窍了 再不开窍, 怕人骂 《露水珠》 露水珠儿在荷叶转，颗颗滚圆；姐儿一见忙用线穿，喜上眉尖；恨不能，一颗一颗穿成串，排成连环；要成串，谁知水珠也会变，不似从前；这边散了，那边去团圆，改变心田；闪杀奴，偏偏又被风吹散，落在河中间；後悔迟，当初错把宝贝看，叫人心寒。 提铃 鞭炮惊马脱逃 这女子就跟熟透的水果子一样, 熟透了呢, 就要离树外嫁, 如果成熟了掉在地上, 就成了一团泥, 无人要, 那到是小事, 那将来要是变成了一股臭味, 那就难闻喽 你倒还真是个方家 大方之家的简称, 本义是道术修养深厚精湛的人, 后多指饱学之士或精通某种学问技艺的人 你怎么笑得怪怪的, 就跟狐狸见了一窝鸡似的 明日复明日, 明日有几何 不破不立 朝廷名器 入山见得藤缠树, 出山见得树缠藤, 藤生树死缠到死, 树死藤生死也缠 太原府啊, 本巡抚的这碗面呐, 你就把它给吃下去吧 是, 卑职照办, 太原县, 本府的这碗面你就吃了吧 是, 卑职照办, 典史, 本县这碗面你吃了吧 是 ..(倒桶喂猪) 谁干的缺德事啊, 把我家的猪全给撑死了呀, 这年头人都没吃过这么细的面啊, 你们拿来喂猪, 那猪哪知道饱啊, 我的猪啊, 我娶儿媳妇的猪啊 退隐林泉 取妻取德, 取妾娶色 一个人如果说起假话来, 连他自己都相信是真的, 那此人心里的算计就大了 我只是手指大的菩萨, 怎受得王爷碗口粗的香啊 响马 明代马政危害甚远。当时政府推动马匹“民牧”，即在河北、河南、山东、江苏、安徽等地实行，订有应纳马驹数，若不够，养马户须赔偿，养马户多因此破家，转为“响马”，以此谋生。河北地区，尤其严重，时称“江南之患粮为最，河北之患马为最。”（顾炎武《天下郡国利病书》）正德五年（1510），直隶霸州（今河北霸县）文安县人刘六、刘七、杨虎等人起义，一呼百应，聚流民、响马、屯军数千人，屡败官军，被政府呼作“响马盗”，三年后才被弭平。 古指拦路抢劫的强盗，又称“响马子”指盗贼，马贼等作恶多端，为非作歹之人。指拦路抢劫商旅的强盗，因抢劫时放响箭得名。响箭一响，马匪就会杀出，抢劫货物辎重。 浑家 你过去, 阅人多矣, 而且用了太多麝香 投刺 古代礼节，通报姓名以求相见或表示祝贺。刺，指名刺或名帖，也就是现代的名片 投刺在门 战国时官场拜会，会先送上以竹片或木片制成的「谒」、「刺」。 「谒」即为汉朝的名片，用于较庄重的场合，需针对双方的辈分「量身订做」，通常是临行拜访前才写，而后来出现的「刺」（札），则可以一次写个十几片，广发于亲朋同僚间。 「名刺」的「刺」字有探求、刺探虚实之意，或指拜访扑空，只好将名片「插」在对方家门上，表示自己来过。 过去向权贵投递名刺是种自我推荐的方法，诗人元稹有「自投名刺」之语，《后汉书》也记录祢衡为求进用，随身携带自荐书，却因心高气傲而从来没有拿出来过，导致上面的字已经磨损。而随着造纸术发展，名刺的材质由木、竹改为纸张，名称也逐渐改为「帖」、「门状」、「名纸」，「名帖」，至民国才出现「名片」一词。 [刨木板] 不错, 像官家姨太太小姐的大腿了 桃花庵歌 唐寅 桃花坞里桃花庵，桃花庵下桃花仙。 桃花仙人种桃树，又摘桃花换酒钱。 酒醒只在花前坐，酒醉还来花下眠。 半醉半醒日复日，花落花开年复年。 但愿老死花酒间，不愿鞠躬车马前。 车尘马足显者事，酒盏花枝隐士缘。 若将显者比隐士，一在平地一在天。 若将花酒比车马，彼何碌碌我何闲。 世人笑我太疯癫，我笑他人看不穿。不见五陵豪杰墓，无花无酒锄作田。 郁孤台下清江水，中间多少行人泪。 西北望长安，可怜无数山 赣江 文学在身, 能为国所用则用, 不能为国所用, 则为己润身, 不要把文学当成谋生的惟一手段, 也不要把文学当成君政的附属品, 人无所求品自高啊 某不才, 也浸淫诗书数十年, 一些浅显的道理还是懂得的 中原鹿正肥 一念之差, 霄壤之别 “大耳朵老百姓”系四川方言，即平民百姓 大耳朵，指听话。大耳朵百姓指百依百顺的毫不反抗的良民 马彬, 你一生所有的功劳, 都在于杀良冒功, 动起真刀真枪来, 王某三回合不将你斩于马下, 当自刎而谢天下 他是一头养不亲的狼 那万贯家财本不该属于你, 只是暂时寄存在你那, 仅此而已 心宽体胖`,``,`html`,`武林外传`,`20240307183503-影摘 掌柜的：还有这地 小郭：这地咋了吗 掌柜的：这地……它不平，坑坑洼洼滴 小郭：这是砖地哎大姐，又不是大理石的，它倒是想平 	 关门，放小郭 滥情剑客无情剑 银钱使 以后不要写这种乱七八糟的东西，什么情什么爱，男男女女的，不健康 小郭 小郭郭 你才小蝈蝈 你还小蛐蛐小蚂蚱呢！ 额的秀才啊！额那聪明能干物美价廉的秀才啊 咋回事嘛，生个娃都该娶媳妇咧 生个娃也该老死咧，咋还不回来捏? 掌柜：那个镜子照一照，看这个脸都拧成啥样子了？（小六拿刀敲桌子）哎呀，我的水曲柳老榆木桌面啊！ 小六：到底嘛桌面？ 掌柜：你管？我愿意说啥就说啥。 耳光随便打，银子一定要给 秀才：说到这个知识啊，我这么有知识，为什么，当然，是因为我脑子好使，那我为什么脑子好使呢，从小被打的呀 小六：那不对呀，我妈从小也打我，我为嘛脑子不好使 秀才：她一般打你哪儿啊 小六：打我后脑勺，有时用棍子抡，有时候拿板儿砖拍，狠极了 秀才：哎，我知道你为啥脑子不好使了，手来 他是热face贴上了冷臀部，活了（liao）大该呀 这井是不是正德年间的 再累再苦，只当自己是二百五 再难再险，就当自己是二皮脸 与君共勉 这位官爷，我姓佟，佟湘玉的玉 往上一靠，那叫一个阿斗啊 危乎高哉，蜀道之难，难于上青天 节目之烂，烂过臭鸡蛋 卧倒 （后排扔果蔬） 我的这位小兄弟啊，体健貌端无婚房，有各种不良嗜好 上一任关中大侠 我杀杀杀杀你干嘛呀，这是你的钱钱钱钱包 第一他是不是来寻仇的，这有可能，第二，他是不是伤害我了，那肯定是伤害我了啊 菩提树下全是宝,大伙学习要趁早 不就是谈谈人生，聊聊理想嘛 狂犬病患，生人勿近 唯女子与小人难养也 女为君子儒无为小人儒 看郭靖杨过不通文采，乔峰段誉，略显老套，一代宗师东方不败，只知深闺绣花鸟啊 扫的不是地，而是那颗蒙尘的心 未来的人生有无数种可能，难道非要在一开始就想好一切，然后按照图纸去施工吗 白展堂：由种东西叫巡犬，你知道吧。 佟湘玉：我只知道巡抚。`,``,`html`,`武林外史`,`20241105185513-影摘 等你到了我这个年纪, 你就会发现, 许多事情老天爷就只给你一次机会, 失去了就再也找不回来了 蝶儿闯入我梦, 我在蝶梦之中, 是梦是醒有什么不同`,``,`html`,`母女情深`,`20240307183503-影摘 女儿睡着，妈妈总认为她或许死了，掐出哭声才放心`,``,`html`,`民谚`,`20240307183503-碎片 喂的鸡多，下的蛋多 软藤缠死硬树 无忧即是佛 世上英雄本无主 冷铁难打，老竹难弯 乌龟爬门槛，就看此一番 乌龟的屁股---规定 乌龟倒立---上面有规定 乌龟翻筋斗--- 一个又一个规定 大乌龟背上背个小乌龟---上面又有新规定 一羽示风向，一草示水流 阎王爷喜欢伶俐的小鬼 善弈者谋势，不善者谋子 拼着一身剐，皇帝老子拉下马 阎王也怕拼命鬼 自丑不觉，人丑笑煞 套着脖子的猎犬不能打猎 光阴有脚当珍惜，书田无税应勤耕 饱时省一口，饿时得一斗 力能胜贫，谨能胜祸 针无双头利，蔗无两头甜 一人计短，百人计长 好汉一言，快马一鞭 药对如锁开 公买公卖，童叟无欺 一朝无粮兵马散 拿衣捉领，张网提纲 姑爷进门，小鸡断魂 习惯之始如蛛丝，习惯之后如绳索 日食三餐，夜眠一榻 脖子再粗，硬不过刀 店有雅号，客人自到 不要看海洋的颜色，要看到海洋的暗礁 秀才造反，三年不成 蜂多出王，人多出将 情深恭敬少，知己笑谈多 看惯了骆驼，看不出牛大 人会十样，不怕百样；一窍通，百窍通 大丈夫处其厚，不居其薄；处其实，不居其华 听千曲者辨其音，观千剑者识其器 谁对时间越吝啬，时间对谁就越慷慨 无丑不显俊 洪水再大也淹不过鸭背 有钱王八坐上席 车行半坡停不得 薄技在身，胜握千金 只敬衣衫不敬人 宁做泥里藕，不做水上萍 馋言败坏君子，冷箭射死英雄 猎家小狗不怕虎 懦弱会造成卑鄙`,``,`html`,`水源`,`20240307183503-户外 如果一次喝个够，身体会将吸收后多余的水分排泄掉，这样就会白白的浪费很多的水。 一次只喝一两口，然后合在口中慢慢咽下，过一会儿感觉到口渴时再喝一口，慢慢地咽下，这样重复饮水，既可使身体将喝下的水充分吸收，又可解决口舌咽喉的干燥。 20221112133859.webp 20221112134243.webp 沙漠里的无活水源头的死湖，形成盐湖，盐湖里的水只有经过蒸馏才能饮用。 生长着香蒲、沙柳、马莲、金针（也称黄花）、木芥的地方，水位比较高，旦水质也好； 生长着灰菜、蓬篙、沙里旺的地方，也有地下水，但水质不好，有苦味或涩味，或带铁锈； 初春时。其它例枝还设发芽时，独有一处树枝已发芽，此处有地下水； 入秋时，同一地方其它树时己经枯黄，而独有一处树叶不黄，此处有地下水； 三角叶杨、梧桐、柳树、盐香柏，这些植物只长在有水的地方，在它们下面能挖出地下水来。 sawyer mini迷你净水器的使用 过滤材质为0.1µm的中空纤维过滤膜, 设计压力最高为 20 psi(约0.14mpa), 超压会过滤膜破裂 微滤（MF）（孔径约 0.1~10 µm）：可去除细菌、部分原生动物、微塑料，但无法去除病毒和溶解性物质。 超滤（UF）（孔径约 0.01~0.1 µm）：可去除细菌、原生动物、大部分病毒，但仍无法去除溶解性物质和小分子化学污染物。 细菌（通常 0.2~2 µm） 原生动物（通常 2~50 µm） 微塑料（通常 >1 µm） 化学物质、农药（分子级别，小于 1 nm） 病毒（通常 20~300 nm，部分超滤膜能过滤大病毒，但不能完全去除） 重金属（通常以离子或小分子形式存在，小于1 nm） 溶解性物质（盐、糖、染料）（分子级别，无法被滤膜截留） 病毒比细菌小，无法独立生存，必须依赖宿主细胞才能复制 细菌是独立的单细胞生物，可以在适宜的环境中自行繁殖。 病毒是由核酸（DNA或RNA）和蛋白质外壳组成的生物因子 化学物质（如毒素、污染物）是非生物物质，不会像病毒那样自我复制。化学物质可能会引发疾病，但它们的作用方式与病毒不同。 水中的重金属比细菌体积小得多 可以过滤原水(河水, 湖水), 不能过滤溶解性的水(包括染色水, 盐水, 糖水) 可以过滤细菌, 原生动物, 微塑料, 不能过滤化学物质, 农药, 病毒, 重金属 结束户外活动时用干净水进行反冲洗, 第一次反冲洗要用力，这样才能清除所有纤维 纤维中积聚了钙时(阻力变大), 在醋中浸泡半小时，然后用热水（不高于60度）进行严格的反冲洗 纤维湿润后，没有明确的方法来判断过滤器是否因冻结而损坏 如果怀疑过滤器已冻结，Sawyer 建议更换过滤器。 如果处于冻结温度，建议将过滤器放在口袋中或靠近身体的地方，体温可以防止冻结`,``,`html`,`汤姆·琼斯`,`20240307183503-影摘 20230922230203.webp 1964年奥斯卡最佳影片、导演、改编剧本与配乐+威尼斯影帝。1.典型后现代式无厘头喜剧片，叙事上：脸谱化的人物+夸张的情节+猝然强行反转大团圆的结局，形式上：角色各种打破第四堵墙的言行&旁白剧透、自指（如“以下照例省略激情戏”）与自嘲&出片名前的数分钟仿默片式开场+圈入圈出转场+高速剪辑+降格镜头（追逃戏）+定格镜头蒙太奇（男女两人门外偷听场景）等拼贴式的电影语言。2.最有名的段落当属两人边吃海鲜与水果边调情的正反打蒙太奇了，极具性暗示。3.一处妙到毫巅的压缩银幕时间技法：在单个镜头中，汤姆·琼斯由左至右连续数次入画与出画，每次都骑在马上，但骨折的胳膊都愈加趋近于康复，摆出不同的姿态与动作。4.不得不说，当年奥斯卡的确勇气可嘉，竟然会给一部如此戏谑的闹剧式电影颁发多项最有分量的大奖。 本片的搞笑方式是英国式的，在我来看就是比较夸张的扩大了矛盾冲突。比如，乡绅的外甥以及老师三人组的邪恶，农家女的淫荡，邻家女的清纯，以及伦敦贵族们的虚伪，等等等。通过这些人物以及故事，可以看到本片将它们完全脸谱化了，一一对应着如童话故事般的人物。如外甥象征邪恶的亲戚，邻居家则是青梅竹马的恋人，乡绅是那种容易被蒙骗的好人。当然，本片人物最突出的还是男主角，他善良、大方、勇猛，除了经不起诱惑外，是典型的白马王子形象。正是这种光明的白马王子式人物，让我们在哈哈大笑的同时，也明白光明永远会胜利的，只不过路途坎坷一些。总之，本片通过人物脸谱化的方式，极大的扩大了剧情矛盾，不仅使电影搞笑风趣，更深化了影片主题。`,``,`html`,`泛型`,`20240307183503-_java 所有的集合接口和实现都大量地使用它 泛型允许我们为集合提供一个可以容纳的对象类型 避免了在运行时出现 ClassCastException 不需要使用显式转换和 instanceOf 操作符 运行时不会产生类型检查的字节码指令 //A及A的子类 <? extends A> //A及A的超类 <? super A> //作为泛型方法时 public static <T> void printValue(T t) {} //作为泛型类时 public class NumGeneric<T> {} public class NumGeneric1<T> { private T num; public void setNum(T num) { this.num = num; } public static void main(String[] args) { NumGeneric1<Integer> intNum = new NumGeneric1<>(); intNum.setNum(10); System.out.println(intNum.num); NumGeneric1<Float> floatNum = new NumGeneric1<>(); floatNum.setNum(5.5f); System.out.println(floatNum.num); } } public class NumGeneric2<x,y>{ private x num1; private y num2; public void genNum(x num1, y num2) { this.num1=num1; this.num2=num2; } public void setNum1(x num1) { this.num1 = num1; } public void setNum2(y num2) { this.num2 = num2; } public static void main(String[] args) { NumGeneric2<Integer, Float> numObj = new NumGeneric2<>(); numObj.genNum(10,5.5f); System.out.println(numObj.num1); System.out.println(numObj.num2); numObj.setNum1(11); numObj.setNum2(5.6f); System.out.println(numObj.num1); System.out.println(numObj.num2); } }`,``,`html`,`注解`,`20240307183503-_java 注解原理 注解本质上是接口 每个注解在编译时都会生成一个对应的接口类型 这也就解释了为什么在注解中其成员要么是抽象方法要么是常量 当RUNTIME注解被JVM加载进来，那么Java就可以用反射获取到注解内容 java会为注解产生一个代理类，这个代理类包括一个AnnotationInvocationHandler成员变量 AnnotationInvocationHandler有一个Map的成员变量，用来存储所有的注解的属性赋值； 传统接口中的变量都是public final static无法修改，而我们要的是注解里的成员变量能够赋值，所以选用了方法表示变量 在程序中，调用注解接口的方法，也就是调用注解里的成员变量，将会被代理类拦截接管，然后根据方法名字，到Map里面拿相应的Value并返回。 注解的分类 按保留策略（Retention Policy）分类 SOURCE: 只在源码中保留，编译时被丢弃 CLASS: 编译时保留在class文件中，但不会被jvm加载（默认） RUNTIME: 编译后保留在class文件中,而且会被jvm运行时访问到，可以结合反射读取 按用途分类 标记注解: 不包含成员变量，仅用于标记。：示例@Deprecated 单值注解: 只有一个成员变量。：示例@SuppressWarnings 完整注解: 包含多个成员变量。：示例@Retention 元注解: 用于注解其他注解的注解。：示例@Retention, @Target 按目标（Target）分类 ElementType.ANNOTATION_TYPE: 可以应用于注解类型的注解（元注解）。 ElementType.CONSTRUCTOR: 可以应用于构造函数。 ElementType.FIELD: 可以应用于字段或属性。 ElementType.LOCAL_VARIABLE: 可以应用于局部变量。 ElementType.METHOD: 可以应用于方法。 ElementType.PACKAGE: 可以应用于包。 ElementType.PARAMETER: 可以应用于方法参数。 ElementType.TYPE: 可以应用于类、接口（包括注解类型）或枚举声明。 ElementType.TYPE_PARAMETER: 可以应用于类型参数。 ElementType.TYPE_USE: 可以应用于任意使用类型的地方。 预设元注解 @Target 指定多个目标 @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) 如果在定义一个注解时没有显式指定 @Target 注解，则编译器会为该注解自动添加一个默认的 @Target 注解。可以应用于任何地方 @Retention @Inherited 如果注解A受元注解@Iherited的注解,那么当父类使用了注解A时,子类不写注解A也会自动具有注解A @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Inherited //可继承的 @interface A { String name() default "A"; } @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface B { String name() default "B"; } @A class Animal {} @B class Dog extends Animal {} public class Demo { public static void main(String[] args) { //getAnnotations获取所有可继承的注解，包括从父类继承的注解 System.out.println(Arrays.toString(Dog.class.getAnnotations())); //[@A(name=A), @B(name=B)] } } @Documented 表明这个注解应该被javadoc工具记录 @Repeatable 允许在同一个元素上多次声明相同的注解 必须指定容器注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Repeatable(A.class) //可以在一个元素上多次声明 B 注解，或者使用容器注解 A 一次性声明多个 B 注解 @interface B { String value() default "b"; } @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface A { //容器注解 B[] value(); } class One { //方式1: 使用可重复注解 //@B("b1") //@B("b2") //方式2: 使用容器注解 @A({@B("b1"),@B("b2")}) private void m() {} } public class Main { public static void main(String[] args) { Method[] methods = One.class.getDeclaredMethods(); for (Method method : methods){ if (method.getName().equals("m")) { //getDeclaredAnnotations获取当前元素上声明的所有注解，不包括继承的注解 Annotation[] annotations = method.getDeclaredAnnotations(); System.out.println(annotations.length);//1 System.out.println(Arrays.toString(annotations)); //[@A(value=[@B(value=b1), @B(value=b2)])] } } } } @Retention(RetentionPolicy.RUNTIME) @Repeatable(Annos.class) @interface Anno { int a() default 1; int b() default 0; int c() default 0; } @Retention(RetentionPolicy.RUNTIME) @interface Annos { Anno[] value(); } class Op { @Anno(b = 2, c = 3) @Anno(a = 0, b = 2, c = 4) private static void add(int a, int b, int c) { if (c != a + b) throw new ArithmeticException("error"); } } public class Demo { public static void main(String[] args) { for (Method m : Op.class.getDeclaredMethods()) { if (m.isAnnotationPresent(Annos.class)) { System.out.println(m.getName()); Anno[] annos = m.getAnnotationsByType(Anno.class); for (Anno anno : annos) { System.out.println(anno.a() + " " + anno.b() + " " + anno.c()); try { boolean accessible = m.isAccessible(); m.setAccessible(true); m.invoke(null, anno.a(), anno.b(), anno.c()); m.setAccessible(accessible); } catch (InvocationTargetException e) { //捕获被反射调用的方法内部抛出的异常 //要特别处理 InvocationTargetException，因为该异常会包装被调用方法抛出的任何异常。 //可以使用 InvocationTargetException.getCause() 来获取被调用方法内部抛出的异常,getCause() 方法返回的类型是 Throwable //如果明确知道被调用方法可能抛出的异常类型，并且想要进行特定的处理，可以先用 Throwable 接收，然后进行类型检查 Throwable cause = e.getCause(); if (cause instanceof ArithmeticException) { System.out.printf("Test [%s] failed: %s %n", m, cause.getMessage()); } else { System.out.printf("Test [%s] failed: %s %n", m, e); } } catch (Exception e) { System.out.printf("Test [%s] failed: %s %n", m, e); } } } } } } /* add 1 2 3 0 2 4 Test [private static void com.ida.temp.Op.add(int,int,int)] failed: error */ @Native 用于标记那些在本地代码中使用的常量，表明这些常量在本地方法实现中是可用的。它没有任何语义上的影响，主要是作为一种文档化工具 例如可以在本地代码（如 C 或 C++ 实现的 JNI 方法）中使用 预设标准注解 @Override @Deprecated 可以带有描述信息 @Deprecated(since = "1.5", forRemoval = true) 自1.5版本开始被标记为过时,计划在未来版本中移除 @SuppressWarnings 用于标记那些你明确知道并决定忽略的警告，以保持代码的整洁和易读性 @SuppressWarnings({"unchecked", "deprecation"}) 忽略使用了未检查的转换,过时的方法的警告 @SafeVarargs 仅用于抑制与泛型类型的可变参数方法相关的编译器警告，它并不能防止实际的类型不安全操作 不能在可具体化的类型上使用, 只能应用于静态方法、final 实例方法或私有实例方法 @SafeVarargs //@SuppressWarnings("unchecked") public static <T> void safeVarargsMethod(T... args) { for (T arg : args) { System.out.println(arg); } } @FunctionalInterface 与注解相关的方法 Class.getAnnotations() //返回该类上所有直接显式声明的注解，包括继承的隐式具有的注解 Class.getDeclaredAnnotations() //返回该类上所有直接显式声明的注解，但不包括继承的 Class.getAnnotation(Class<T> annotationClass) //返回指定类型的注解，包括继承的 Class.getDeclaredAnnotation(Class<T> annotationClass) //返回该类上直接声明的指定类型的注解，不包括继承的注解 Method.getAnnotationsByType(Class<T> annotationClass) //返回方法上指定类型的所有注解，包括继承的, 但是它只能访问到公共方法上的注解 Method.getDeclaredAnnotationsByType(Class<T> annotationClass) //返回方法上指定类型的所有注解，不包括继承的, 不受访问权限的限制 boolean isAnnotationPresent(Class<?> extends Annotation> annotationClass) //检查当前元素是否有指定类型的注解。 Annotation[][] getParameterAnnotations() //获取方法参数上的注解数组(按照参数顺序),[[anno1,anno2],[anno3],[anno4,anno5]] Annotation.annotationType() //返回注解的Class对象 Annotation[] annotations = Demo.class.getDeclaredMethod("m").getAnnotations(); for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); System.out.println("Annotation type: " + annotationType.getName());//运行时动态获取注解的类型信息 } 自定义注解 如果自定义注解内只有一个抽象方法需要赋值，且方法名为value，可以省略value= 所以如果注解只有一个抽象方法成员，建议使用方法名value 自定义注解内的抽象方法以无参数有返回值的形式来声明，又称为配置参数 返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组 enum Day { SATURDAY, SUNDAY } @Retention(RetentionPolicy.RUNTIME) @interface A { B[] bs(); String s() default ""; int num(); Day day(); } @Retention(RetentionPolicy.RUNTIME) @interface B { int n() default 0; String name() default ""; } @A(s = "注解", num = 22, day = Day.SATURDAY, bs = { @B(n = 1, name = "SpongeBob"), @B(n = 2, name = "Patrick") } ) public class Demo { public static void main(String[] args) { A a = Demo.class.getAnnotation(A.class); System.out.println(a.day()); System.out.println(a.bs()[0].name()); System.out.println(a.bs()[1].n()); } } 自定义注解的读取 读取方法参数上的注解 @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) @interface Anno { String value() default "1"; } @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) @interface Anno2 { String value() default "2"; } public class Demo { public void test(@Anno("5") String s, @Anno2 @Anno("6") String s1, String s3, @Anno("9") String s4) {} public static void main(String[] args) { Method[] methods = Demo.class.getMethods(); for (Method method : methods) { if ("test".equals(method.getName())) { System.out.println(method); Annotation[][] annotations = method.getParameterAnnotations(); int n = 0; for (Annotation[] annos : annotations) { n++; if (annos.length > 0) { System.out.println("第" + n + "个参数的注解数量:" + annos.length + ",含有以下注解:"); for (Annotation anno : annos) { if (anno instanceof Anno) { Anno a = (Anno) anno; System.out.println(anno.annotationType().getSimpleName() + ": " + a.value()); } else if (anno instanceof Anno2) { Anno2 a = (Anno2) anno; System.out.println(anno.annotationType().getSimpleName() + ": " + a.value()); } else { System.out.println(anno.annotationType().getSimpleName()); } } } else { System.out.println("第" + n + "个参数的注解数量为0"); } System.out.println("-----------------"); } } } } } /* public void com.ida.temp.Demo.test(java.lang.String,java.lang.String,java.lang.String,java.lang.String) 第1个参数的注解数量:1,含有以下注解: Anno: 5 ----------------- 第2个参数的注解数量:2,含有以下注解: Anno2: 2 Anno: 6 ----------------- 第3个参数的注解数量为0 ----------------- 第4个参数的注解数量:1,含有以下注解: Anno: 9 ----------------- */ 读取类上的注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface Anno { int id() default -1; String msg() default "Hi"; } @Anno(id = 222,msg = "awdawd") public class Demo { public static void main(String[] args) { Method[] methods = Anno.class.getDeclaredMethods(); //获取注解的变量名 for (Method method : methods) { System.out.println("注解的变量名为：" + method.getName()); } boolean hasAnnotation = Demo.class.isAnnotationPresent(Anno.class); if (hasAnnotation) { Anno anno = Demo.class.getAnnotation(Anno.class); //获取变量值 System.out.println("id:" + anno.id()); System.out.println("msg:" + anno.msg()); } } } /* 注解的变量名为：id 注解的变量名为：msg id:222 msg:awdawd */ 读取方法上的注解 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface Anno { String value() default ""; } @Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface Anno2 { String value2() default ""; } class User { private String name; private String age; public String getName() { return name; } @Anno("Sandy") @Anno2(value2 = "Park") public User setName(String name) { this.name = name; return this; } public String getAge() { return age; } @Anno("20") public User setAge(String age) { this.age = age; return this; } } public class Demo { public static void main(String[] args) { Method[] methods = User.class.getDeclaredMethods();//包括private，不包括父类的 for (Method method : methods) { System.out.println("方法名为：" + method.getName()); Annotation[] annotations = method.getDeclaredAnnotations();//不包括继承的 for (Annotation annotation : annotations) { System.out.println("方法包含注解：" + annotation.annotationType().getSimpleName()); Method[] annotationMethods = annotation.annotationType().getDeclaredMethods();//包括private，不包括父类的 for (Method annotationMethod : annotationMethods) { try { //对注解实例调用其属性方法，从而获取属性的值 System.out.println("注解的属性为：" + annotationMethod.getName() + "=" + annotationMethod.invoke(annotation)); } catch (IllegalAccessException | InvocationTargetException e) { throw new RuntimeException(e); } } } System.out.println("------------------------"); } } } /* 方法名为：getName ------------------------ 方法名为：setName 方法包含注解：Anno 注解的属性为：value=Sandy 方法包含注解：Anno2 注解的属性为：value2=Park ------------------------ 方法名为：getAge ------------------------ 方法名为：setAge 方法包含注解：Anno 注解的属性为：value=20 ------------------------ */ 读取字段上的注解 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface A { String value() default ""; } @Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface B { String value() default ""; String value2() default ""; } class User { @A("张三") private String name; @A("33") @B(value = "22", value2 = "11") private String age; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } } public class Demo { public static void main(String[] args) { User user = new User(); user.setName("李四"); user.setAge("44"); Field[] fields = User.class.getDeclaredFields(); for (Field field : fields) { boolean accessible = field.isAccessible(); field.setAccessible(true); Object o;//获取对象的字段实际值 try { o = field.get(user); field.setAccessible(accessible); } catch (IllegalAccessException e) { throw new RuntimeException(e); } System.out.println("user对象的字段信息: " + field.getName() + "=" + o); Annotation[] annotations = field.getDeclaredAnnotations(); System.out.println(Arrays.toString(annotations)); for (Annotation annotation : annotations) { //错误的: annotation.getClass() //Method[] methods = annotation.getClass().getDeclaredMethods(); Method[] methods = annotation.annotationType().getDeclaredMethods(); System.out.println("包含注解: " + annotation.annotationType().getSimpleName()); for (Method method : methods) { try { System.out.println(method.getName() + "=" + method.invoke(annotation)); } catch (IllegalAccessException | InvocationTargetException e) { throw new RuntimeException(e); } } } System.out.println("----------------"); } } } /* user对象的字段信息: name=李四 [@com.ida.temp.A(value=张三)] 包含注解: A value=张三 ---------------- user对象的字段信息: age=44 [@com.ida.temp.A(value=33), @com.ida.temp.B(value2=11, value=22)] 包含注解: A value=33 包含注解: B value=22 value2=11 ---------------- */ 注解处理器 APT（Annotation Processing Tool） 注解处理器（Annotation Processor）是一个用于在编译时处理注解的工具。通过注解处理器，可以在编译时生成代码、验证代码或执行其他类型的代码分析 创建注解处理器项目 pom <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.1</version> <configuration> <source>1.8</source> <target>1.8</target> <encoding>UTF-8</encoding> <!-- 禁用了注解处理器的自动发现机制。 其目的是在构建注解处理器本身时，防止其在自己项目内触发注解处理流程。 这是因为在编译注解处理器项目时，注解处理器不应对自身进行处理 --> <compilerArgument>-proc:none</compilerArgument> </configuration> </plugin> </plugins> </build> 注解类 @Retention(RetentionPolicy.SOURCE) @Target(ElementType.TYPE) public @interface MyAnnotation { String value(); } 注解处理器类 @SupportedAnnotationTypes("com.ida.my_anno_processor.annotation.MyAnnotation") @SupportedSourceVersion(SourceVersion.RELEASE_8) public class MyAnnotationProcessor extends AbstractProcessor { @Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) { for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) { MyAnnotation myAnnotation = element.getAnnotation(MyAnnotation.class); String className = element.getSimpleName() + "_Generated"; String packageName = processingEnv.getElementUtils().getPackageOf(element).getQualifiedName().toString(); try { JavaFileObject file = processingEnv.getFiler().createSourceFile(packageName + "." + className); try (Writer writer = file.openWriter()) { writer.write("package " + packageName + ";\n"); writer.write("public class " + className + " {\n"); writer.write(" public String getValue() {\n"); writer.write(" return \"" + myAnnotation.value() + "\";\n"); writer.write(" }\n"); writer.write("}\n"); } } catch (IOException e) { processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.toString()); } } return true; } } 注册注解处理器 在resources/META-INF/services目录下创建名为 javax.annotation.processing.Processor的文件，写入注解处理器的全限定名 META-INF/services 目录对于注册注解处理器是必要的, 用于告知 Java 编译器哪些类是注解处理器 它是 Java 服务提供者接口（Service Provider Interface, SPI）的一部分，允许框架和工具在运行时动态发现和加载实现特定接口的类 当编译器或工具（如 IDE）在编译时需要查找注解处理器时，它会扫描该目录并读取 javax.annotation.processing.Processor 文件来找到可用的注解处理器 javax.annotation.processing.Processor 是固定的文件名，用于标识注解处理器的服务提供者配置文件 在这个文件中(文件中不应该有空行)，每行包含一个注解处理器的完全限定类名，这样编译器就可以发现和加载这些处理器 发布为依赖 mvn clean install 在另一个项目中使用注解 添加加注解处理器编译时依赖 <dependencies> <dependency> <groupId>com.ida</groupId> <artifactId>my-anno-processor</artifactId> <version>1.0-SNAPSHOT</version> <scope>provided</scope> </dependency> </dependencies> 应用注解 import com.ida.my_anno_processor.annotation.MyAnnotation; @MyAnnotation("我将无我") public class TestMyAnnotationProcessor { public static void main(String[] args) { String info = new TestMyAnnotationProcessor_Generated().getValue(); System.out.println(info); } } 例 工厂预设 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface Init { String value() default ""; } class User { private String name; private String age; public String getName() { return name; } @Init("louis") public User setName(String name) { this.name = name; return this; } public String getAge() { return age; } @Init("22") public User setAge(String age) { this.age = age; return this; } } class UserFactory { public static User create() { User user = new User(); Method[] methods = User.class.getMethods(); try { for (Method method : methods) { if (method.isAnnotationPresent(Init.class)) { Init init = method.getAnnotation(Init.class); method.invoke(user, init.value()); } } } catch (Exception e) { e.printStackTrace(); return null; } return user; } } public class Demo { public static void main(String[] args) { User user = UserFactory.create(); user.setAge("26"); System.out.println(user.getName()); System.out.println(user.getAge()); } } 方法检查 @Retention(RetentionPolicy.RUNTIME) @interface Jiecha { } class NoBug { @Jiecha public void suanShu() { System.out.println("1234567890"); } @Jiecha public void jiafa() { System.out.println("1+1=" + 1 + 1); } @Jiecha public void jiefa() { System.out.println("1-1=" + (1 - 1)); } @Jiecha public void chengfa() { System.out.println("3 x 5=" + 3 * 5); } @Jiecha public void chufa() { System.out.println("6 / 0=" + 6 / 0); } public void ziwojieshao() { System.out.println("我写的程序没有 bug!"); } } public class Demo { public static void main(String[] args) { NoBug testobj = new NoBug(); StringBuilder log = new StringBuilder(); int errornum = 0; Method[] method = testobj.getClass().getDeclaredMethods(); for (Method m : method) { if (m.isAnnotationPresent(Jiecha.class)) { try { boolean accessible = m.isAccessible(); m.setAccessible(true); m.invoke(testobj); m.setAccessible(accessible); } catch (Exception e) { errornum++; log.append(m.getName()); log.append(" "); log.append("has error:"); log.append("\n\r caused by "); log.append(e.getCause().getClass().getSimpleName()); log.append("\n\r"); log.append(e.getCause().getMessage()); log.append("\n\r"); } } } log.append(testobj.getClass().getSimpleName()); log.append(" has "); log.append(errornum); log.append(" error."); System.out.println(log); } } /* 1234567890 3 x 5=15 1-1=0 1+1=11 chufa has error: caused by ArithmeticException / by zero NoBug has 1 error. */ 方法检查2 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Check { } class Foo { @Check public static void m1() { } public static void m2() { } @Check public static void m3() { throw new RuntimeException("Boom"); } public static void m4() { } @Check public static void m5() { } public static void m6() { } @Check public static void m7() { throw new RuntimeException("Crash"); } public static void m8() { } } public class Demo { public static void main(String[] args) { int passed = 0; int failed = 0; for (Method m : Foo.class.getDeclaredMethods()) { if (m.isAnnotationPresent(Check.class)) { try { m.invoke(null); passed++; }catch (Throwable ex) { System.out.printf("Test [%s] failed: [%s] %n", m, ex.getClass()); System.out.printf("Test [%s] failed: [%s] %n", m, ex.getCause()); System.out.println(); failed++; } } } System.out.printf("Passed: %d, Failed %d%n", passed, failed); } } /* Test [public static void com.ida.temp.Foo.m3()] failed: [class java.lang.reflect.InvocationTargetException] Test [public static void com.ida.temp.Foo.m3()] failed: [java.lang.RuntimeException: Boom] Test [public static void com.ida.temp.Foo.m7()] failed: [class java.lang.reflect.InvocationTargetException] Test [public static void com.ida.temp.Foo.m7()] failed: [java.lang.RuntimeException: Crash] Passed: 2, Failed 2 */`,``,`html`,`测试`,`20240902152921-_java JUnit 4: 是一个单一的库（junit-4.x.x.jar），所有功能都在同一个包里。 @Test, @Before, @After, @BeforeClass, @AfterClass, @Ignore 不支持动态测试 JUnit 5: 是一个模块化的框架，分为多个模块，包括： JUnit Platform: 提供启动测试框架的基础设施。 JUnit Jupiter: 提供JUnit 5的API和功能。 JUnit Vintage: 用于运行JUnit 4的测试。 增加了一些新的注解，如 @BeforeEach, @AfterEach, @BeforeAll, @AfterAll, @Disabled 新增了对动态测试的支持，可以在运行时生成测试用例。 Assert（或 Assertions）在单元测试中的主要目的是验证代码的行为是否符合预期，并且带来了以下几个关键好处 1. 自动化测试 无需手动检查代码的输出，这大幅提高了测试效率，特别是在项目规模较大时。 2. 即时反馈 可以在代码的行为不符合预期时立即提供反馈。如果一个断言失败，测试将中断，并报告错误。这种即时反馈可以帮助开发者迅速定位问题。 3. 代码质量保证 通过在代码中使用 Assert 进行严格的验证，可以保证代码的质量。 开发人员可以通过编写测试用例来确保代码在不同情况下都能正常工作，从而减少bug的数量。 4. 回归测试 当项目迭代时，旧代码可能会因为新代码的加入而产生问题。 通过保留和运行使用 Assert 的单元测试，可以快速发现回归问题，确保新改动没有破坏已有功能。 5. 文档作用 测试用例中的断言不仅仅是验证工具，还起到了一定的文档作用。 它们明确地表达了代码在特定情况下应该具有什么样的行为。 其他开发者可以通过阅读测试用例，快速理解代码的设计意图和预期行为。 6. 减少手动测试的依赖 通过编写自动化测试，尤其是使用断言，可以减少对手动测试的依赖。 手动测试不仅耗时，还容易出错。自动化测试则可以反复执行，并且每次都能确保一致的结果。`,``,`html`,`海绵宝宝`,`20250426182108-影摘 20220926035016.webp 20220926035027.webp 20240531230749.webp 第十季第九集失物招领处 这是失物招领处的诅咒 没人能被找到 他们只会遗失 it is the curse of the Lost and Found no one ever gets found they just stay lost 蟹堡王的失物招领处，只是一个水晶球就能撼动整个比奇堡 dimwit二愣子 you bozo you greedy crook i'd like to withdraw all my money, please oh blow me down beat it you deadbeats 海绵宝宝第十一季第03集 嬉皮士 海绵宝宝第十一季第06集 恐高影子章鱼哥 20250124165745.webp 20250124165746.webp 20250124165747.webp 20250124165750.webp 好了小姐, 我很少这么没有礼貌, 但是闪一边凉快去 20250426182010.webp 20250426182011.webp 20250426182012.webp 20250426182013.webp 20250426182014.webp 20250426182015.webp 20250426182016.webp 20250426182017.webp 20250426182018.webp`,``,`html`,`火种`,`20240307183503-户外 点燃篝火最好的材料是桦树皮，桦树皮的含油量极高．在雨中仍可燃烧。 避孕套水球聚光取火 干柴要选择干燥、未腐朽的树干或枝条。要尽可能选择松树、栎树、柞树、桦树、槐树、山樱桃、山杏之类的硬木，燃烧时间长，火势大，木炭多。不要捡拾贴近地面的木柴，贴近地面的木柴湿度大，不易燃烧，烟多熏人。 	 生火工具如火柴，可先在蜡烛油中沾过后，放入火柴盒中，再装进密封袋内，以保持干燥。 生火的柴薪须就地取材，如遇天雨潮湿难找到干柴时，须较费心在石缝、崖洞中寻找；或在枯树的洞穴里常有松鼠等动物窝巢中的柔软干草；此外，松树树瘤中含有松油，涂在柴薪上也能引火助燃。 在离开小木屋时，屋里的摆设要和你发现小木屋时所希望的一样，将下一个拜访者所需要的东西都准备好，最好是要准备一小堆“羽毛棒”，一些劈开的引火物和柴火。如果木屋结实干燥，就留下一盒火柴。将火柴棒的末端伸出来，这种小小的好意曾挽救过一些旅行者的生命，他们历经艰辛找到小木屋时，手指已被严重冻伤，以至于无法打开火柴盒。 20221112132737.webp 锯沉重树枝的方法；劈木头省力的方法；锯齿的形状 20221112132740.webp 羽毛棒的制作；印第安火堆；长原木火堆；火堆的维持 20221112132742.webp 森林泥炭土；潮湿的石头`,``,`html`,`炎热的夜晚`,`20240307183503-影摘 “天气太热了，我整天都光着身子……他说墓地的大理石上躺着会非常凉爽，我于是坐着他的警车去了墓地……” 【剧情简介】 美国南部密西西比州的小镇斯巴达。夜半时分，一列火车到站。一个西服革履的黑人青年下车走进候车室等候换乘下趟火车。 天气酷热，驾着警车在镇上夜间巡逻的警察山姆看见孤零零立在路旁的快餐店尚未打烊，便进去喝杯冷饮，顺便要块蛋糕。但那举止猥琐的侍者嘲弄地指了指剩下的那块蛋糕，上面爬着几只苍蝇。山姆悻然离去。警车慢驶着穿过镇上每条街道，走到某个十字路口时，车子拐进一条街。漆黑的夜里，只有一栋房子亮着灯，透过落地玻璃窗可以看见一个白人女子全身赤露在屋里行走。警车慢慢驶过继续巡逻。突然，山姆发现地上有个人，下车一看，那人满脸是血已经死亡。他急忙向警长报告。 死者是到镇上投资设厂的工业家柯尔伯。他头骨破裂，身上没有钱包。警长和验尸官赶到，初步断定死者死去已有一小时了。斯巴达镇急需外来投资，柯尔伯之死对这个平静的小镇来说是个不小的打击。新上任的警长对此很重视，吩咐手下四出侦察看看有无可疑的人。 山姆看见火车站候车室有个陌生的黑人，立刻令他把手放在墙上对他搜身。黑人的钱包里有许多百元大钞，山姆二话不说就把他带回警署。警长一看疑犯的钱包里掉出一叠大钞，张口便问：用什么凶器打的。黑人忿然出示证件，上面赫然写着：费城警察局警官威吉尔·提布斯。他到南方来探亲，现在正等午夜四时的火车回费城。他让警长打电话去费城警察局核实他的身份。费城警察局告诉警长，提布斯是凶杀案专家，可以请他帮助破案。提布斯不愿留下，警长也不愿求他，但为了破案，警长还是用激将法使提布斯留了下来。 第二天，抓到一个叫威利的青年，他身上揣着柯尔伯的钱包。威利说钱包是他从死者身边捡的，警长不信，认为已经破案，叫人送提布斯去火车站。提布斯捏了捏威利的手腕，说这人不是凶手，因为他刚看过验尸报告，柯尔伯的致命伤在后脑右上方17度的地方，说明凶手是使用右手的人，而威利是左撇子。警长不满，叫提布斯交出验尸报告赶快离开。提布斯要把报告上交，于是警长以 “私藏证物” 为理由把提布斯扣押起来。 提布斯与威利关在一起，他向威利出示证件，表示可以帮他洗刷罪名，同时问他，为什么警察会怀疑他，是不是以前有案底。威利答道，以前他被山姆抓过，因为他和镇上一个叫桃丽的女子在坟场幽会。桃丽总是喜欢裸体炫耀自己的身材。山姆把他关起来，警告以后不许和桃丽鬼混。 提布斯发现柯尔伯的汽车座位有血迹，脚闸有一根羊齿植物。提布斯请警长陪他去农场主安迪高的家。安迪高以喜爱植物著称，而且他和柯尔伯关系不好。路上经过安迪高农场的大片棉田，采棉工人都是黑人。提布斯很有感触。仆人把二人领到花房。警长介绍了提布斯的身份。提布斯把话题拉到羊齿植物上。安迪高说，羊齿植物的根是寄生兰必不可少的养料，寄生兰就像黑人，要靠别人养，柯尔伯也一样。提布斯压着怒火问他对柯尔伯的死有什么看法，昨晚柯尔伯是不是来过这里。安迪高一听黑人竟敢盘问自己，大怒，给了提布斯一记耳光。不想提布斯当即回他一记耳光。安迪高气得发抖。含泪问警长管不管。二人出门后，警长责备提布斯不该打安迪高。提布斯恨恨地说，再有两天时间就能把他抓起来。警长凝视他说：原来你也和我们一样有偏见。 黑人警官打了白人一事迅速传遍全镇，提布斯成了众矢之的。镇长责备警长对提布斯采取姑息态度，说如果前任警长在，就会为此杀掉那黑人。镇上的白人种族主义者更是磨刀霍霍要杀提布斯。警长感到事态严重，令手下赶快把提布斯送走。这时提布斯果然陷在一群白人的包围中，他们手拿凶器打算致他于死命。幸好警长及时赶到，为提布斯解了围。警长要求提布斯赶快离开斯巴达镇，否则再发生黑人警官被杀的事，这个小镇就更乱了。但提布斯执意要破案才离开。 提布斯让山姆按事发当晚的巡逻路线重演一遍。山姆载着警长和提布斯在镇上穿行，照那晚一样进快餐店喝冷饮，但警车开到十字路口时，山姆却不拐弯一直走。提布斯问他为什么改变路线。山姆不答。提布斯下车自行往前走。后来提布斯告诉警长，山姆改变路线是因为不想让黑人看见白人女子裸体。 警长到银行去查看山姆的账户，发现山姆昨天突然存入600多元。柯尔伯被杀前刚从银行取出900元，可威利捡到的钱包里只剩下300元。警长怀疑山姆谋财害命，把他扣起来。这时，桃丽的哥哥拉着她到警署，告山姆使他妹妹怀了孕。他向警长叙述的时候，要求提布斯退场，但警长让提布斯留下。据桃丽说，她和山姆常去坟场幽会，那里最凉快。提布斯若有所思，去问威利，镇上如果有男人使女人怀了孕，一般会怎么做。威利说，有个黑女人给人打胎。提布斯请他介绍去见这个黑女人。 验尸发现死者伤口有松木刺。提布斯到柯尔伯工厂的工地去查看，看见地上好多松木棍，可能这里是作案第一现场，凶手是用汽车把尸体搬到发现尸体的地方去的。这便排除了山姆的嫌疑，因为他一人不可能同时驾两部车。警长佩服提布斯的侦察方法，更担心他的安全，便邀请他到自己家过夜。单身的警长在简朴的家里对提布斯谈了自己的苦恼。 威利的朋友前来带提布斯去找黑女人。警长问提布斯去哪里，提布斯说，去白人不能去的地方。提布斯独自进入黑女人的杂货铺，向她打听是谁付钱为桃丽打胎。黑女人开始不肯说，提布斯诚恳地告诉她，他在找一个杀了柯尔伯的白人，这人也就是为桃丽付钱打胎的人。他劝黑女人不要牵连进去，说白人黑人都会坐牢，但黑人受罪更大。黑女人终于告诉提布斯，这人今晚要带桃丽来。正说着桃丽就进来了。她一见提布斯转身就走。提布斯追出去。黑暗中一个男子用枪指着提布斯——原来是快餐店的侍者。正在剑拔弩张之际，以桃丽哥哥为首的一群白人青年追杀提布斯到来。提布斯沉着地对他们说，是这人使桃丽怀孕并诬陷山姆，不信可看桃丽的皮包，有一百元的钞票。哥哥翻桃丽的钱包，果然如此。他大怒扑向侍者，侍者向桃丽的哥哥开了一枪。提布斯抓住侍者带回警署。罪犯招供说，那晚柯尔伯驾车经过，他搭顺风车，假装想到工厂工作，问工厂在哪里，柯尔伯把他带到工地，他用木棍从后面猛击柯尔伯的头，取走钱后伪装成抢劫现场。警长想不到，破案的关键竟是那个爱在炎热的夜晚脱光衣服的桃丽。 第二天，警长亲自帮提布斯提箱子送他去车站。火车开动时，警长亲切地对提布斯说： “威吉尔，保重!”`,``,`html`,`煤气灯下`,`20240307183503-影摘 嗜血贝西`,``,`html`,`环游世界八十天`,`20240307183503-影摘 20220926035355.webp 风雨无阻`,``,`html`,`现代汉语词典`,`20240307183503-书摘 凛若冰霜 不识之无 才识卓异 财源茂盛 草甸子 天寒地坼 沉冤莫白 陈陈相因 瞠乎其后 cheng1 在后面干瞪眼，赶不上 吃瓦片 收租过日子 不可一日驰懈 为老不尊 令人齿冷 笑得合不拢嘴时间长了牙齿感到冷 褫夺 chi3 斥候 侦察兵 情思百结 穿云裂石 乐器歌声 春风化雨 适宜于草木生长的风雨，比喻良好的教育 存亡绝续 撮火 打尖 大鳄 当世无双 倒毙街头 登对 民生凋敝 度牒 咄咄称奇 是非变于俄顷 额手称庆 恶谥 shi4 千人之诺诺，不如一士之谔谔 脸红耳热 帆樯林立 樊笼 发轫 新事物新局面出现 反水 饭囊衣架 贩夫走卒 妃色 淡红 烟雨霏微 风刀霜剑 风中之烛 锋镝 父执 父亲的朋友 高歌猛进 高视阔步 膏腴之地 诰命 受过封号的妇人 绠短汲深 谦辞难以胜任 公子王孙 功成名遂 勾乙 标记采用 入我彀中 箭能射及的范围 古道热肠 待人真挚热情 金瓜击顶 瓜代 任期已满换人接替 鬼神莫测 过河卒子 过屠门而大嚼 瓠子 hu4 寒星闪烁 汗颜无地 呼朋引类 狐死首丘 不忘本或念故 少失怙恃 化外之邦 政治教化不及 化外之民 回禄之灾 火神 积羽沉舟 葭莩之亲 jia1 疏远 披坚执锐 间不容发 jian1 fa4 见猎心喜 金乌西坠 囝 jian3 囡 nan1 荆棘载途 zai4 南风不竞 强烈 径情直遂 平步青云 旧雨新知 旧雨重逢 老朋友 客家 西晋末唐末南宋末自黄河南迁的汉人 空谷足音 难得 口血未干 不久毁约 匡谬正俗 狼奔豕突 坏人乱窜 细作 冷语冰人 李代桃僵 代过 力透纸背 连中三元 敛衽而拜 练家子 金樽潋滟 凛于夜行 害怕 柳眉倒竖 龙生九子 兄弟志趣各异 漏壶 漏刻 倚闾而望 lv2 旅进旅退 盲随 乱臣贼子 掠视左右 略识之无 荦荦大端 luo4 明显 马齿徒增 蟒袍 清大臣 金蟒 毛举细故 蟊贼 危害国家人民 媚悦 有意 孟夏 夏季第一月，农历四月 灭此朝食 钱三百缗 min2 鸣鼓而攻之 宣布罪状加以声讨 螟蛉 义子 妺喜 mo4 末非未 目光如豆 目无余子 眼无旁人 难兄难弟 nan2 古：兄弟俩都非常好难分高下；今：讥讽俩人同样坏。 nan4共患难处同样境地的人 赧颜汗下 内详 信封下面写“代替发信人的姓名地址” 泥足巨人 实际非常虚弱的庞然大物 盘马弯弓 先做出将要射击的姿势，不立刻行动 貔貅 pi2 否极泰来 卦名 片瓦无存 朴刀 po1 刀身狭长，刀柄略长，双手砍杀 破颜一笑 剖腹藏珠 衣冠齐楚 齐东野语 道听途说 群轻折轴 群情鼎沸 人存政举 人亡政息 人微言轻 人莫予毒 目空一切，认为无人能伤害自己 人世间的事物千奇百怪 仁人君子 家业不及三稔而衰 ren3 年 日甚一日 如汤沃雪 入境问俗 色魔 贪色并以凶残的手段 霎时间 山高水低 指意外发生的不幸事情，多指死亡 深文周纳 牵强附会妄加罪名 狮子搏兔 对待小事也不遗余力 蜀犬吠日 少见多怪 死磕 拼命作对 獭祭 罗列典故 踏石留印，抓铁有㾗 太阿倒持 逃之夭夭 兔死狐悲，物伤其类 团脐 雌蟹 顽石点头 忘年交 葳蕤 枝叶繁盛 微言大义 韦编三绝 委绝不下 问道于盲 呜呼哀哉 无尽无休 吴牛喘月 疑心遭遇不测而害怕 五日京兆 意思是因以比喻任职时间不会长，或凡事不作久长打算 如坠五里雾中 勿谓言之不预 徙木立信 细大不捐 抛弃 细针密缕 仙山琼阁 寻隙 压舱石 一孔之见 一曝十寒 一丘之貉 瘐死 监狱病死 珠圆玉润 言多语失`,``,`html`,`白头神探`,`20240307183503-影摘 20231213215857.webp 20231213215900.webp 20231213215903.webp 白头神探2床戏`,``,`html`,`碎片1`,`20240401103934-碎片 蒲柳之姿,望秋而落;松柏之质,经霜弥茂 身体虚弱 晚清小说家刘鹗对这一问题有直接的阐述。他在《老残游记》中说：“清廉人原是最令人佩服的，只有一个脾气不好，他总觉得天下都是小人，只他一个人是君子。这个念头最害事的，把天下大事不知害了多少……赃官可恨，人人知之；清官尤可恨，人多不知。盖赃官自知有病，不敢公然为非；清官则自以为我不要钱，何所不可，刚愎自用，小则杀人，大则误国。” 康熙皇帝对清官问题有其自身的认识，他在一道诏书中说：“清官多刻，刻则下属难堪，清而宽方为尽善。朱子云：居官人，清而不自以为清，乃为真清。”康熙的意思很明确，清官要把道德优越感丢掉，对人不可苛责太严，施政不能一味地依靠近乎偏执的强硬。身为一国之君，他当然不是鼓励贪污，而是不希望出现“水至清则无鱼，人至察则无徒”的局面，使国家机器无法正常运转。 有问题先把提出问题的人解决掉 黄色是互联网的底色 舍夫佐娃大将携巨款叛逃法国, 根据《互不取笑条约》，国内互联网媒体低调报道了此事。 钱是给女人看的，不是给女人花的 家里老鼠见了都摇头 不要把时间用在意念所改变不了的事情上 扶？不扶？这是个问题 有时候冷漠可以避免80%的麻烦 never cry over spilt milk 罗汉局”和“观音局 黄钟毁弃，瓦釜雷鸣 都说KFC是中国食品安全的天花板，麦当劳不服。 杀一人为罪, 屠万人为雄 黄台瓜辞 种瓜黄台下，瓜熟子离离。 一摘使瓜好，再摘使瓜稀。 三摘犹自可，摘绝抱蔓归。 煎豆摘瓜 买房成为“结婚入场券” 有许多家庭或许是基于经济因素，将嫁女儿视为一种“红利”，甚至还有父母是用女儿出嫁时收的彩礼，拿来为将来自己的儿子要娶媳妇时，势必要付的彩礼做准备 scary equals funny 铁西三扎三不扎。三扎：男的扎、女的扎、不男不女往死了扎。三不扎：死的不扎、扎完不扎、没在眼前的不扎 带着它出门看风景，在雨中沐浴，逛超市；带着一块上课；给宠物石过生日；甚至还有给宠物石找对象征婚的 中国的媒体致力于搭建一个平行宇宙 社会边角料 视角越多, 离真相就越近 政治八股文 身怀利器杀心自起 兴奋得像苍蝇一样不停搓手, 欢喜得不知搔处 未来可能不再关注怎样解决问题,而是如何将问题向AI描述清楚 非创造性的工作,60%和99%区别不大 恨你有,笑你无的卑劣思想 微软这个软件巨头还说，中国国家支持的黑客也用这些大型语言模式做测试，试图就敌对情报机构、网络安全问题以及“知名个人”进行询问。 洼地 中国的醫保 = 智商稅 = 劳斯莱斯五元代金劵 欲戴皇冠必承其重 王爱花 李有财 国际金融中心遗址 无事小神仙 变星星了 女人对男人, 最大的爱意是赤祼身体 结庐在人境 而无车马喧 问君何能尔 心远地自偏 采菊东篱下 悠然见南山 山气日夕佳 飞鸟相与还 此中有真意 欲辨已忘言 一个程序，如果没有响应，当然是选择关闭 芭比Q 甜甜,刀疤 贱花 灵犀 零元购 由于盗跖诸匪喜爱“取人妇女”，华北地区信奉盗跖为娼妓的守护神 虚构的故事如果有用，那也是用来表达观点，而不是指代着过去。 谁控制了过去就控制了未来，谁控制了现在就控制了过去 知人者智，自知者明；胜人者有力，自胜者强；知足者富，强行者有志；不失其所者久，死而不亡者寿。 邹忌修八尺有余，而形貌丽。朝服衣冠，窥镜，谓其妻曰：“我孰与城北徐公美?”其妻曰：“君美甚，徐公何能及君也!”城北徐公，齐国之美丽者也。忌不自信，而复问其妾曰：“吾孰与徐公美?”妾曰：“徐公何能及君也!”旦日，客从外来，与坐谈，问之客曰：“吾与徐公孰美?”客曰：“徐公不若君之美也。”明日徐公来，孰视之，自以为不如;窥镜而自视，又弗如远甚。暮寝而思之，曰：“吾妻之美我者，私我也;妾之美我者，畏我也;客之美我者，欲有求于我也。” 于是入朝见威王，曰：“臣诚知不如徐公美。臣之妻私臣，臣之妾畏臣，臣之客欲有求于臣，皆以美于徐公。今齐地方千里，百二十城，宫妇左右莫不私王，朝廷之臣莫不畏王，四境之内莫不有求于王：由此观之，王之蔽甚矣。” 王曰：“善。”乃下令：“群臣吏民能面刺寡人之过者，受上赏;上书谏寡人者，受中赏;能谤讥于市朝，闻寡人之耳者，受下赏。”令初下，群臣进谏，门庭若市;数月之后，时时而间进;期年之后，虽欲言，无可进者。燕、赵、韩、魏闻之，皆朝于齐.此所谓战胜于朝廷。 天道不一定酬所有勤, 但是天道只酬勤 阔阔气气 标致 藏冰取冰 迷人的反社会的 如果你只要安全，就不要起床、不要上车、不要做任何事。有时你就得冒风险，这是风险与回报的问题。 所谓财富自由,指某个人再也不用为了满足生活必须,而出售自己的时间了 生活中99%的烦恼都能用钱解决,赚到的钱多了,生活中的琐事自然迎刃而解 如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界。 有一次，阿波罗看到小爱神丘比特正 拿着弓箭玩。他不客气的警告丘比特说：「喂！弓箭是很危险的东西，小孩子不要随便拿来玩。」原来小爱神丘比特有两枝十分特别的箭。凡是被他用那枝用黄金作成的利箭射到的人，之后，遇见的第一个人，不管是谁，他都会疯狂的爱上他，要是那枝铅做的钝箭射到的人，之后见到的第一个人，就会十分厌恶，反感。 丘比特被阿波罗这么一说，心里很不服气。他趁着阿波罗不注意的时候，「飕」的一声把金色之箭射向阿波罗。正巧这时候，来了一个名叫达芙妮的美丽少女。调皮的丘比特把那枝铅做的钝箭射向达芙妮。阿波罗就对达芙妮产生了疯狂的爱慕，而达芙妮却对阿波罗有一种莫名其妙的厌恶。 也许，在我们的潜意识中，我们很看重自己对别人的影响，别人是否重视我们对他的看法很重要，如果我们对他的看法没有影响到他，我们就很讨厌他。我想，这正是人性虚荣最痛的创伤 我们每个人都孤独地生活在世界上。谁都被囚禁在一座铁塔里，只能凭一些符号与人交流，但这些符号并没有共同的价值，所以它们的意义模糊不定。我们可怜地想把心灵的珍宝传递给别人，但他们却无力接受，因此我们只能踽踽独行，虽然紧挨着，却并不真正在一起，既无法了解别人，也不被别人所了解。我们就像身在异国他乡的陌生人，对他们的语言知之甚少，想表达那些美妙而深刻的事物，只能局限于会话指南上一点平庸的词句。我们的大脑充满了奇想，却只会说“花匠的姑姑有把雨伞在屋里”。 也许，她的理智告诉她，她打造的这些链条只能激起他破坏的天性，就像窗户上的厚玻璃，看着让你手痒痒，想捡起半块烂砖头。 月朦胧鸟朦胧萤火照夜空, 山朦胧鸟朦胧秋虫在呢哝, 花朦胧夜朦胧晚风叩帘拢, 灯朦胧人朦胧但愿同入梦. “她那时候还年轻，不知道命运馈赠背后，早已标好了相应的砝码。”《断头王后》 清静独处是非常难得的事情 意志将近崩溃时，本能会被无限放大 幸运的人一生都被童年治愈，不幸的人一生都在治愈童年 饥饿、艰难、失望的现实，是生活不可改变的规律。 《契丹国志》记载：“五国（即黑龙江流域的五个部落）之东接大海出名鹰……”，名鹰海东青，多单独生活，但幼鸟常伴亲鸟飞翔。栖息时，停落在岩石或地面上，有时长时间地站在乔木枝上。主食野兔、鼠类等中小型兽类，夏秋时节，常飞行在水面上空，向水内俯冲以搜索鱼虾；冬天捕食村里的小猫和小狗，并食腐尸肉。海东青捕食犹如闪电，扑扑凌凌人，煞是威严。它的食量很大，耐饱饿力较强，吃饱一次可20天不进食。 多看看大海，多爬爬高山，人不过蝼蚁，专注自己就好 天下攘攘，皆为利往。 良田千倾不过一日三餐, 广厦万间只睡卧榻三尺 我年轻，又年老，连灵魂都无聊至极。我失去了表情，整个人消失不见。I'm young，And I'm old and I am bored up to my soul. l am out of faces and l am gone.——《超脱》· 托尼·凯耶 美好的东西从来不会寻求关注。Beautiful things don't ask for attention.《白日梦想家》· 本·斯蒂勒： 作者不居，居者不作 飞向青天斩明月 人都有失去耐心的时候 “活蹦乱跳的无症状感染者现场抢救筋疲力竭晕倒的护士” 笑到我了 冒傻气 这些女人几乎只关心“占有”和“被占有”，只关心自己的“归属感”。 嫖资比彩礼容易 为了掩盖谎言，就必须制造更多的谎言 师旷之聪，离娄之目 ”将其头按在水池里，直到水池中不再冒泡…” 用时间换来的优惠得不偿失 .. 分割这个世界有很多种方法，我小的时候通常用好人和坏人来区分，长大以后知道更通俗的方法是穷人和富人。 据说民间有一种捕猴子的方法：在一块木板上挖两个洞，刚好够猴子的手伸进去。木板后面放一些花生。猴子看见花生，就伸手去抓。结果，抓了花生的手紧握成拳头，无法从洞里再缩回来。猴子就这样紧紧地抓着他的花生，被人轻而易举捉去。 杰克•伦敦在小说《热爱生命》里，写了一个迷途者的故事。这个不幸的人独自在荒野挣扎，饥饿，疲劳，孤独，绝望，还有一匹和他同样饥饿、同样疲惫的老狼，一直跟着他，等着他倒下，好把他吃掉。然而最终不是狼吃掉了他，而是他吃掉了狼。小说的结尾是，这个人终于回到船上，吃了很多，胖了很多。他不住地吃，吃过之后就到处收集面包。他收集的面包如此之多，塞满了船舱的各个角落，虽然都已干了、碎了，他还是每天收集不止。 对资源的认识还仅仅局限在食物和异性上 美洲有一种蚂蚁叫蓄奴蚁，它们自己不劳动，而是靠掠夺为生。他们袭击邻近的蚂蚁巢穴，不仅掠走别人的食物，还要带走一大群活口，充当他们的奴隶。这些奴隶命运十分悲惨，然而为了活命，他们什么活都干，直到习惯了奴役，变得像在原来部落里一样勤奋。 更让人难以置信的是，蓄奴蚁每次抢掠，并不把对方的巢穴彻底摧毁，而是故意留下相当数量的男女，以便它们能继续繁殖，从而保证奴隶的来源取之不尽，用之不竭。 就算立法本身已经做到了相对公平，这个公平的法律也不是人人可以享受的。为了保证法律的公平，就必须有相应的程序，而很多繁琐的程序看起来是为了公平，实际上是把弱者拒之门外。 穷人的钱永远只是生活消费资金，和资本的性质完全不同。没有资本，报刊上那些发财的故事，无论多么精彩，对穷人来说，就像一部武侠小说，闲来读读，不过是茶余饭后的精神体操而已。 从历史的角度看，一个社会的游戏规则既然是由富人制定的，那就必然对穷人不利，穷人要想胜出，可能性就微乎其微。于是穷人就想自己来制定规则，冲突就产生了，革命就爆发了，有的人真的就掌了权。但很快他也变成了富人，他的规则又对新的穷人构成威胁，新的冲突又再产生。社会历史就是如此循环下去的。 杨绛在回忆钱钟书的文章里说，钱先生从来不借钱给人，凡有人借钱，一律打对折奉送。借一万，就给你五千，再加上一句“不用还了”。钱先生的睿智通达，真是惊人。 对白手起家的人来说，如果第一个一百万花费了十年时间，那么从一百万到一千万，也许只需要五年，再从一千万到一亿，只要三年就够了，说不定更短。这是因为你已经有了丰富的经验和启动的资金，就像汽车已经跑起来，速度已经加上去，只需轻轻点住油门，车就会前进如飞。 我国西北有个俚词“凤翔改改”，意思是很笨很傻的人。词的历史并不悠久，来源也很清楚。 解放初期凤翔县有位张姓妇女名叫改改。她没念过书，脑子有些迟钝，在常人眼里是个又傻又笨的女人。长大嫁人后，男人不幸早逝，改改孤苦无依，只好在路边摆了一个卖水摊。 改改不仅不识字，连钱都不识，为了不收错钱，她找来一枚2分钱的硬币作为样板，一杯水收2分，每卖一杯，她就把别人给的钱和这枚样板对照一下，小了不收，大了也不收，纸币当然更不收。 旁人都嘲笑她傻，可她依然如故。于是当地人将她视为愚蠢呆傻的代名词，如果有人要骂你笨蛋，干脆就说你“笨得和改改一样”。久而久之，这句话竟成了当地人的口头禅。 但奇怪的是，像改改这样笨的人，虽然做的是小生意，但生意却越来越好，很多人在她的水摊前驻足观看，有人为了喝上一杯改改“2分钱”的水，专门从大老远赶来，甚至于有一天，省上一位很有名望的领导也慕名来到了她的水摊前，改改一下子在西北五省都出了名。 在聪明人眼里，改改是个傻瓜，但聪明人可能没有想过，一个连钱都不认识的弱女子，能够在几十年时间里，靠做生意，哪怕是小生意，不仅养活自己，还养活了家人，这是为什么。几十年了，多少政治风波，多少人沉沉浮浮，多少聪明人走投无路。可是改改，无论是连农民卖几个鸡蛋都会被“割资本主义尾巴”的年代，还是在摸着石头过河的改革时期，无论世界怎么风起云涌，改改始终安然地做着她的生意，衣食无忧。 抱朴守拙，向来是中国哲学中的最高智慧……这是民间的经验总结。聪明过头的人，往往不能长久，算尽机关太聪明，反算了卿卿性命。那种一眼看上去聪明劲一股一股往外冒的人，最终是很难做成大事的。 旧时的田篱翁多打了几斗米，也还要琢磨着讨个小。 I like cats. They never ask question. 拿破仑向阿尔卑斯山，向莫斯科进发；我向着女人的臂弯，女人的腹地。 电影或许能被看懂，现实永远不能。 “如果尖锐的批评完全消失，温和的批评将会变得刺耳。 如果温和的批评也不被允许，沉默将被视为居心叵测。 如果沉默也不再允许，赞扬不够卖力将是一 种罪行。 如果只允许一种声音存在，那么，唯一存在的声音就是谎言。” 游戏行业有这么一句行话：1.我们这没有免费玩家。2.免费玩家是我们提供给付费玩家的一种服务。 “常常因为不够变态而与他人格格不入” “为了直达最深层的本质，我研究了黑格尔；我看的了什么？毫无思想的含糊不清的文字游戏！…… 井蛙不可语海，夏虫不可语冰 拨刀能留住她吗 栀子花粗粗大大，又香得掸都掸不开 ，于是为文人雅士不取，以为品格不高。栀子花说：“去你妈的，我就是要这样香，香得痛痛快快，你们他妈的管得着吗?” 释迦牟尼说过一句话：“无论你遇见谁，他都是你生命该出现的人，绝非偶然，他一定会教会你一些什么” 原谅他是上帝的事，我的任务就是送他去见上帝 不要把圣物给狗，也不要把你们的珍珠丢在猪前。 就好像庄子说的浑沌。浑沌北边有个帝，南边有个帝，他们到中间来看浑沌，浑沌没有鼻子，没有眼睛，但对他们非常好，这个南边的帝和北边的帝就要报答浑沌，就给他开鼻子眼睛，凿七窍，要让他看看世界一日凿一窍，庄子说：七日，浑沌死。他睁开眼睛的时候，就死了 对待生命你不妨大胆一点，因为我们始终要失去它。 MV末尾脑洞大开，让牛郎织女穿上飞行服登上宇宙飞船，跨越银河，幸福地在一起。 玲珑骰子安红豆，入骨相思知不知。 身体死，你必死 免费的也是最贵的 你是砍柴的，他是放羊的，你和他聊了一整天，他的羊吃饱了，你的柴呢？ 放好心态，马上就开大了 你为什么总是把事情想得如此不堪呢 一滴甘露落入口,千粒珍珠滚下喉 别人的攻击和诋毁是对方自己内心不美好的投射，与自己无关 一杯清水因滴入一滴污水而变污浊，一杯污水却不会因一滴清水的存在而变清澈。 最快的脚步不是跨越，而是继续；最慢的步伐不是小步，而是徘徊`,``,`html`,`碎片2`,`20250201104649-碎片 学成文武艺，货与帝王家；帝王不用，卖与识家；识家不用，仗义行侠。——元朝杂剧 过劳者死，过慧者天收 蝴蝶多愉快 飞进秋风中双双对对 蝴蝶多愉快 刀光剑影中来来回回 一人吃饱全家不饿 ost Original Sound Track 只有伟大的作品，没有伟大的作家 作为观众，不需要关注幕后 担雪填井 你能在浪费时间中获得乐趣, 就不是浪费时间 有价无市 黄昏门外六花飞，困倚胡床醉不知 人名 茶壶 泡泡茶壶 super泡泡茶壶 猴儿 地球生物无一例外最本质的追求只有两个：生存和繁衍后代。其实这两个目标可以看成是一个，就是因为无法实现永生，才能退而求其次让自己基因遗传下去。 中国是一个“实行公民监控的威权国家”。 孔鲤，字伯鱼，孔子的儿子，因其诞时别人赠孔子一尾鲤鱼而得名。孔鲤先孔子而亡。目前所有正统孔家后代都是孔鲤的儿子孔伋的后裔。 孔鲤虽无建树，但是后世传言其有一言很是出名： 孔鲤对孔子说：“你的儿子不如我的儿子”，又对儿子孔伋说：“你的父亲不如我的父亲”。 待诸异日或待诸他人 后人看待历史，切忌犯“以己度人”、“以今度古”的思维惯性错误，这当然是个很难意识到的问题，因为关键在于，时空不同，最重要的社会环境已然发生很多变化，特别是某些变化，可能是完全“对立、背反”级别的改变，这就导致，我们不仅很难理解，甚至压根就想不到——原来当时的社会环境，是完全相反的啊！ 这个时候，用现代的观点去解读历史，用今人去猜度古人，显然只会得到完全相反的结论。就如李广报复霸陵尉这个事，我们现在自然都鄙视李广的做法，但当时人却都推崇他。 晨兴理荒秽，荷月带锄归 宵禁制度则是以坊为单位，当宵禁的鼓声响起，所有街上的行人必须回到坊内不得外出，以保障城市的安全和秩序。 宵禁制度并不是要求每个人必须在家里呆着不许出门，而是要求人们在规定的时间内回到自己的居住坊内。 虽然有宵禁制度，但是并不是完全禁止人们在坊内活动，一旦进入坊内，也就是城市的各个居住区，人们就可以随意出行，不受任何限制。 每个坊内都具备一些能够满足日常生活的基础设施，如商店、餐馆、娱乐设施等。 元宵弛禁 半闲老人 俗话说慈不掌兵，义不掌财 蒋雪柔说自己热爱武侠里的情与义，因为那里有符合她梦想的唯美因子。她想让观众们从中寻觅到世俗生活里失落已久的情怀，从某种意义上说，电视剧也可以成为一件艺术作品。 因为年轻人往往不会选择老一辈人追捧的品牌, 他们希望用割席的方式来确立自己的位置, 定义自己的存在 隐己之长，补己之短。“韬”本指剑衣或弓袋，引申为内藏；“光”即光芒、光彩，比喻实力、才华等优长；“韬光”即收敛自己的光芒，指不以自身优长而炫耀、张扬；“养”即修养、培养；“晦”即昏暗不明，与“光”相对，比喻自身的劣势、短处；“养晦”指加强修养，弥补自身不足。此语体现了中国人低调、内敛，注重自我完善和发展的精神气质 收养，又称抱养，系指养子，将他人子女收为自己子女，中国古代又称为螟蛉子，这是由于古人误以为蜾蠃把螟蛉的幼虫收养作己子，实际上它们是用作给自己幼虫的食物。 六神和会自安然, 一日清闲一日仙 观今鉴古，无古不今 兰风梅骨，剑胆琴心 美妇悦目，贤妇愉心 慢藏诲盗，冶容诲淫 语出《易传·系辞传上·第八章》。意为：财货收藏不善，易诱人起盗心；容貌打扮妖冶，易诱人起淫心。“淫”一作“婬”。 道高龙虎伏，德高鬼神钦 久在江边站，必有望海心 独行不愧影，独寝不愧衾 行不愧影，寝不愧衾 何必丝和竹，山水有清音 砣小压千斤，椒小辣人心 力微休负重，言轻莫劝人 是亲不是亲，非亲却是亲 同欲者相憎，同忧者相亲 救烦无若静，补拙莫如勤 读书须用意，一字值千金 人皆因禄富，我独以官贫 海枯终见底，人死不知心 世事短如春梦，人情薄似秋云 人情似纸张张薄，世事如棋局局新 易涨易退山溪水，易反易覆小人心 稻粱谋 随时莫起趋时念，脱俗休存矫俗心 宁恋本乡一捻土，莫爱他乡万两金 垂头自惜千金骨，伏枥仍存万里心 种花须知百花异，育人要懂百人心 红粉佳人休使老，风流浪子莫教贫 蛇行无声，奸计无影 传言失指，图影失形 时间无私，历史无情 蝼蚁尚且贪生，为人岂不惜命 曾参岂是杀人者，谗言三报慈母惊 精神到处文章老，学问深时意气平 不能正己，安能化人 《元和十年自朗州召至京戏赠看花诸君子》（又名《玄都观桃花》）： 紫陌红尘拂面来，无人不道看花回。 玄都观里桃千树，尽是刘郎去后栽。 《再游玄都观》： 百亩庭中半是苔，桃花净尽菜花开。 种桃道士归何处？前度刘郎今又来。 尺蠖之曲，将以求伸 huo4 劳于读书，逸于作文 读书上多花工夫，那么写文章时就轻松容易了 先到为君，后到为臣 译文抢先一步就能当上君王，后到一步只能称作臣子。 指走在对手前面，才能占得先机，最终才能取得胜利。 莫信直中直，须防仁不仁 人生一世，草木一春，来如风雨，去似微尘 遍身绮罗者，不是养蚕人 剑诛无义汉，金赠有恩人 客来主不顾，应恐是痴人 若要断酒法，醒眼看醉人 莫道君行早，更有早行人 茶为花博士，酒是色媒人 意思是男女同桌品茶饮酒，往往容易撮合成色情的勾当。出自《二刻拍案惊奇·卷七》 救寒莫如重裘，止谤莫如修身 怀既往而不咎，指将来而骏奔 相逢不饮空归去，洞口桃花也笑人 人生结交在终始，莫为升沉中路分 谁人背后无人说，哪个人前不说人 即人们往往难以避免参与对他人的评价和讨论 相逢尽道休官好，林下何曾见一人 吾观自古贤达人，功成不退皆殒身 莺花犹怕春光老，岂可教人枉度春 寒天不冻勤织女，饥年不饿苦耕人 古人不见今时月，今月曾经照古人 东方风来满眼春，花城柳暗愁杀人 不信但看筵中酒，杯杯先敬有钱人 青山背后有翠谷，噩梦醒来是早晨 竹本无心，外生许多枝节；藕虽有空，内中不染污尘 天下奇观看尽，无过书本；世间滋味尝来，无过菜根 何必读尽圣贤书，能识世态，便为实学；纵然周遍天下事，不知进退，终是愚人 难字压顶，寸步难行；闯字当头，随意纵横 君子交绝，不出恶声 贱力得人敬，贱口讨人憎 一个人很愿意出力帮助别人，他会受人尊敬，这叫“力贱得人敬”；而“口贱得人憎”，一个人言语过多，说得又不是很妥当，就会遭人厌恶 野花不种年年有，烦恼无根日日生 须知叶落根未死，待看春来芽又生 昨是儿童今是翁，人间日月急如风 颜仁郁《农家》 夜半呼儿趁晓耕， 赢牛无力渐艰行。 时人不识农家苦， 将谓田中谷自生。 行高于众，人必非之 门内有君子，门外君子至；门内有小人，门外小人至 病来如山倒，病去如抽丝 磨刀恨不利，刀利伤人指 人忧日落慢，心急马行迟 水深流去慢，贵人语话迟 记得旧文章，便是新举子 人见白头嗔，我见白头喜，多少少年亡，不到白头死 骄傲源自浅薄，狂妄出于无知 抛砖不怕众人笑，引玉难得一字师 十载寒窗无人问，一举成名天下知 荷尽已无擎雨盖，菊残犹有傲霜枝 天上金童配玉女，地上瘸骡配破车 百年之计种松，十年之计种柳，一年之计种谷，一月之计种韭。 手提三尺龙泉剑，不斩奸邪誓不休 近来学得乌龟法，得缩头时且缩头 莫向人前夸大口，强中更有强中手 吴宫花草埋幽径，晋代衣冠成古丘 人心似铁，官法如炉 法有明文，情无可恕 认真还自在，做假费工夫 以色事人者，色衰而爱驰 老夫不言当年勇，好汉不吃眼前亏 力排南山三壮士，齐相杀之费二桃 赤日炎炎似火烧，野田禾稻半枯焦，农夫心内如汤煮，公子王孙把扇摇 花因色娇遭蝶采，雀因声巧被笼牢 侠心交友，素心做人 骑着驴骡思骏马，官居宰相望王侯 庙小妖风大，池浅王八多 竹密不妨流水过，山高岂碍白云飞 他有关门计，我有攀墙梯 笋因落箨方成竹，鱼为奔波始化龙 瓦罐不离井上破，将军难免阵前亡`,``,`html`,`碎片3`,`20250419104243-碎片 山木自寇, 膏火自煎 山木自寇，源泉自盗 人生行乐尔, 安用声名藉 木人石心 飞行的死亡盐罐, 周期蝉 宇宙大将军, 候景 积弩将军 官名，四品官，领积弩营，辖二千五百人，担当宿卫之任 其山深邃, 当暑有雪 兔园标物序，惊时最是梅。 在花园里是容易看出时节的变化的，最能标志时节变化的就是梅花 味道贺雪，仲冕吟雷。 染髭天泽，剃眉渊材。 文德啮被，景让擎杯。 孙山答友，苗振绷孩。 风雷昨夜破枯株，借问天公有意无？莫是卧龙踪迹困，放教头角入亨衢 黄裳，北宋词人，字冕仲 苏味道贺雪 王求礼, 凡物反常皆为妖 《正月十五夜》苏味道 火树银花合，星桥铁锁开。 暗尘随马去，明月逐人来。 游伎皆秾李，行歌尽落梅。 金吾不禁夜，玉漏莫相催 秾（nóng）李：《诗经·召南》“何彼秾矣，华如桃李”。此处指观灯歌伎打扮得艳若桃李。 元朝, 中书丞相史忠武王（天泽），髭髯已白。一朝，忽尽黑。世皇见之，惊问曰：“史拔都，汝之髯何乃更黑邪？”对曰：“臣用药染之故也。”上曰：“染之欲何如？”曰：“臣览镜见髭髯白，窃伤年且暮，尽忠于陛下之日短矣。因染之使玄，而报效之心不异畴昔耳！”上大喜。人皆以王捷于奏对，推此一事，则余可知矣。汉人赐名拔都者，惟王与太师张献武王（弘范）及真定新军张万户（兴福）耳。 彭几, 北宋协律郞 乐颐，字文德，南阳涅阳人。世居南郡。少而言行和谨，仕为京府参军。父在郢州病亡，颐忽思父涕泣，因请假还，中路果得父凶问。颐便徒跣号啕，出陶家后渚，遇商人附载西上，水浆不入口数日。尝遇病，与母隔壁，忍痛不言，啮被至碎，恐母之哀己也。湘州刺史王僧虔引为主簿，以同僚非人，弃官去。吏部郎庾杲之尝往候，颐为设食，枯鱼菜菹而已。杲之曰：“我不能食此。”母闻之，自出常膳鱼羹数种。杲之曰：“卿过于茅季伟，我非郭林宗。”仕至郢州治中，卒 《后汉书》有一则故事：汉朝时，有个叫茅季伟的人，一天，家里来了最亲近的朋友郭林宗。茅季伟天色微明就起床了，从鸡窝里逮一只鸡，烧水、杀鸡，煮汤。郭林宗一看，甚为高兴，看来茅季伟对我真不错。孰料，吃饭时，茅季伟把整只鸡都端到母亲房里，与郭林宗吃的是鸡汤炖蘑菇。郭林宗瞬间明白了，原来杀鸡不是为了招待我，而是为了孝敬母亲。知晓真相后，郭林宗比真吃了鸡还要开心，对茅季伟说，你真是贤良至孝的人，日后读书求上进，定可大展宏图 李景让是唐宣宗时的御史大夫，以“孝”著称并流传于世，他自己也当仁不让。有一次宰相蒋伸在酒宴上举杯对客人说：“有孝于家、忠于国者饮此。”李景让在“客肃然”中脱颖而出，拿起酒杯就一饮而尽。 在一次乡试中，孙山虽然上榜，但名次却排在最后一名，也就是榜尾。按照当时的科举制度，上榜者都有资格参加更高一级的考试，而未上榜者则只能等待下一次机会。孙山的好友同时参加了这次乡试，但却未能上榜。孙山回家后，好友便来询问考试结果。孙山不便直说好友落榜，便幽默地答道：“解名尽处是孙山，贤郎更在孙山外。” 宋朝时候有个叫苗振的人，写文章是一把好手。他曾取得了第四名进士及第的好成绩，因此获准参加崇文院馆职（史馆、昭文馆、集贤院的官职）选录考试。 临考之前，苗振去拜访当朝宰相晏殊。晏殊很恳切地对他说：“你担任行政官僚太久了，恐怕笔墨功夫都已经生疏，还是要略略温习一下文章才好。”苗振志得意满地说：“嗐！相爷多虑了。哪有当了三十年接生婆却把孩子倒着包进襁褓的？（岂有三十年为老娘而倒绷孩儿者乎？）”意思是说，我做文章轻车熟路，那是绝不会出错的。 有的时候，话不能说得太满太高调。苗振万没想到这次考试偏偏出了差错。原来，考试题目是《泽宫选士赋》，叫谈谈选拔人才的问题。苗振在行文中把“普天之下莫非王土”写成了“普天之下莫非王”，说轻点儿是粗心大意，说严重点儿是大逆不道。最后考试结果出来，苗振当然没选上。 偏巧考试结果公布那天苗振又碰上了晏殊。晏殊打趣地问：“苗先生果然倒绷孩儿了吗？”把苗振羞得脸蛋通红。 后来，人们用“倒绷孩儿”比喻多年的老手一时大意而犯了错。 其博文强记，阁中每得异书，多向他咨询。他凡所检阅，告诉书吏：某事、某书在某卷某行，检之，无一差误，人颂其为“杜万卷”。 柳开年少的时候喜欢意气用事，说话也比较盛气凌人。应举的时候，他将自己的文章主动献给了主考官，总共有一千卷，并用独轮车装着，到了考试那天，他穿着襕衫，自己押着车进入考场，想要用这样的方式来轰动众人并取得功名。当时张景善于写文，很有名气，只拿着一篇文章，献给了主考官。主考官对其大加赞赏，并将张景提拔为优等及第。因此当时的人说：“柳开千轴，不如张景一书。” 曼陀罗花又名彼岸花，传说上天规定彼和岸二人，永生不能相见，但他们偷偷见面，并坠入爱河，受到上天的惩罚，变他们为一株花的花和叶子，花开不见叶，叶生不见花。后经佛主和地藏王菩萨点化，为后人所道。 花定有情堪索笑，自怜无术唤真真 太宗怀鹞，桓典乘骢 冉闵（320年代—352年6月1日），有文献记为“染闵”，字永曾，小字棘奴，魏郡内黄人（今河南安阳市内黄县西北），出生于兰陵郡（今山东枣庄和山东临沂交界的地方），中国五胡十六国时期后赵君主石虎的养孙[1]，冉魏君主。 电影《九品芝麻官》雷豹有句经典台词：“我玩完了她，不给钱，就不算啰！” 趴体 北宋苏轼的《寄吴德仁兼简陈季常》 　　东坡先生无一钱，十年家火烧凡铅。 　　黄金可成河可塞，只有霜鬓无由玄。 　　龙丘居士亦可怜，谈空说有夜不眠。 　　忽闻河东狮子吼，拄杖落手心茫然。 　　谁似濮阳公子贤，饮酒食肉自得仙。 　　平生寓物不留物，在家学得忘家禅。 　　门前罢亚十顷田，清溪绕屋花连天。 　　溪堂醉卧呼不醒，落花如雪春风颠。 　　我游兰溪访清泉，已办布袜青行缠。 　　稽山不是无贺老，我自兴尽回酒船。 　　恨君不识颜平原，恨我不识元鲁山。 　　铜驼陌上会相见，握手一笑三千年。 赏析 　　苏轼的好友陈 慥，字季常，自称龙丘先生。陈季常好宾客，喜蓄歌伎，其妻柳氏却以凶悍嫉妒闻名。每当陈季常宴客，如有歌伎在场，柳氏则以杖击壁，客皆散去，陈季常对柳氏多有畏惧。苏轼曾作一诗戏曰：本文来 自龙丘居士亦可怜，谈空 说友夜不眠。忽闻河东狮子吼,拄杖落 手心茫然。“河东”是柳姓的郡 望，陈妻姓柳，故以“河东”指代。陈季常好佛，而佛家以“狮子吼则百兽惊”比喻佛教神威，故苏轼以佛家语与陈季常开玩笑。苏轼此诗通俗风趣，嘲 讽了柳氏的凶妒与季常的惧内。后因以“河东狮吼”称悍妇。 　　河东这两句是戏笑他的朋友龙邱居士（陈季常）的可怜，一天到晚只知谈“空”说“有”的论说玄学，谈的直忘了睡眠，他的太太又凶悍又善妒，龙邱居士曾经忽然听到太太如河东狮子般地吼叫声，人一呆，不觉拄杖落手，整个心为之茫茫然。 吕蒙正（946年—1011年），字圣功。宋代河南洛阳人，知名大臣，曾三度拜相，赠中书令。 关于吕蒙正的内容：以知人著称，吕夷简、富弼等人皆受其赏识，此说词有疑问，因为吕蒙正逝于公元1011年，但富弼生于1004年，当时才8岁。 祖父后唐户部侍郎吕梦奇，山东莱州人。 父吕龟图，起居郎。 有七子出仕：吕从简、吕惟简、吕承简、吕行简、吕务简、吕居简、吕知简。 六女，长女嫁光禄寺丞直集贤院孙暨，次女嫁刑部侍郎参知政事赵安仁，三女嫁太常博士周渐，四女嫁观文殿学士尚书右丞丁度，五女早夭，六女嫁永州推官杨巽。 侄吕夷简，同中书门下平章事。 太子洗马 银牌天使 这个官职是从唐代开始设置的，其职责是被皇帝派遣出使他国或者巡查各地，因为需要手拿银牌而得名，见到银牌就是相当于皇帝驾临一般。 不良人 不良人和“失足妇女”可是两个意思，它是唐朝一个官职，是衙门里的官吏，负责调查案件、捉拿凶犯，慢慢地这些人都被改称捕快。 之所以有这个称呼，是因为当时这些人，都或多或少有犯罪前科，官府用这些人去“抓坏人”，有些以恶治恶的意思了。 小儿垂钓 胡令能〔唐代〕 蓬头稚子学垂纶，侧坐莓苔草映身。 路人借问遥招手，怕得鱼惊不应人。 事后平原君欲封赏鲁仲连，鲁仲连始终不肯接受，并留下千古名言，掷地有声：“所贵于天下之士者，为人排患、释难、解纷乱而无所取也。即有所取者，是商贾之人也，仲连不忍为也”。 河中之水歌, 萧洐 河中之水向东流，洛阳女儿名莫愁①。 莫愁十三能织绮，十四采桑南陌头②。 十五嫁于卢家妇，十六生儿字阿侯③。 卢家兰室桂为梁，中有郁金苏合香④。 头上金钗十二行，足下丝履五文章⑤。 珊瑚挂镜烂生光，平头奴子擎履箱⑥。 人生富贵何所望，恨不嫁与东家王⑦。 惠帝也记得司马威曾强行掰开他的手指抢夺玺绶，复位后坚持将其处死。 司马威（3世纪—301年），字景曜，小名阿皮，西晋宗室成员，河间平王司马洪之子，章武王司马混的兄长。司马威阿附于赵王司马伦，在其称帝期间当上中书令，司马伦败后因其逼夺国玺之事被晋惠帝诛杀。 司马威为人残暴，不重道德，亲附于赵王司马伦，对其谄媚奉承。元康末年，司马威迁任散骑常侍。永康二年（301年）司马伦谋朝篡位，派遣司马威及黄门郎骆休逼宫，在晋惠帝手上强夺玉玺。随后司马伦即位为帝后，以司马威为中书令。同年司马伦遭齐王司马冏等推翻并被赐死，晋惠帝复位后对司马威逼宫一事怀恨在心，说：“阿皮强行掰开我的手指，抢夺我的玺绶，不可不杀。”于是下令诛杀司马威。[3] 蟋蟀堂堂主阿皮 暗牖悬蛛网，空梁落燕泥 伏波将军 蜻蜓的幼虫水虿chai4 木棉也叫攀枝花 难怪苏轼感慨说：“将军百战竟不侯，伯良一斛得凉州。”当时的“一斛”大约相当于现在的二十升，也就是四十瓶葡萄酒吧。 凉州词【唐·王翰】 葡萄美酒夜光杯， 欲饮琵琶马上催。 醉卧沙场君莫笑， 古来征战几人回？ 西塞山怀古 刘禹锡 王浚楼船下益州，金陵王气黯然收。 千寻铁锁沉江底，一片降幡出石头。 人世几回伤往事，山形依旧枕寒流。 从今四海为家日，故垒萧萧芦荻秋。 忠武小校 若非是掌上留裙, 几掠仙子而去 风横暴异常，有时几乎把人吹入空中。妃子，指汉成帝妃赵飞燕。伶玄《飞燕外传》载，汉成帝“于太液池作千人舟，号合宫之舟。后歌舞《归风送远之曲》，侍郎冯元方吹笙以倚后歌。中流歌酣，风大起。后扬袖曰：‘仙乎仙乎，去故而就新，宁忘怀乎？’帝令无方持后袖，风止，裙为之绉。他日，宫姝或襞裙为绉，号留仙裙。” 《赵飞燕别传》中有这样的描述：“赵后腰骨尤纤细，善踽步行，若人手执花枝颤颤然，他人莫可学也。”“踽步”是赵飞燕独创的技巧，可见其舞蹈功底深厚，并能控制呼吸。明朝艳艳生的小说《昭阳趣事》有幅木刻《赵飞燕掌上舞图》，是赵飞燕站在一个宫人的手上，做出各种舞蹈动作，扬袖飘舞，宛若飞燕。汉成帝专为她造了一个水晶盘，叫宫人将盘上托。赵飞燕在盘上起伏进退，下腰轻提，旋转飘飞，就像仙女在万里长空中迎风而舞一样优美自如。汉宫中有个太液池，成帝造了一艘沙棠木做的大船，用紫色的文桂木做舵与桨。一次，赵飞燕穿着云芙紫裙，碧琼轻绡，在船之上表演歌舞《归风送远之曲》，飞燕越舞越飘飘，欲乘风归去之态，舟至中流，大风忽至，飞燕随风扬袖旋舞，像要乘风飞去，成帝急忙令宫人拉住赵飞燕，怕叫大风吹走了！宫人两手握住飞燕双履。赵飞燕索性在宫人手上随风飞舞。因此后世传说她“身轻若燕，能做掌上舞”。后来，汉成帝怕大风把赵飞燕吹跑，特地为她大兴土木之工，花巨资为她筑起一座华丽的“七宝避风台”居住。 歌舞正酣，忽然起了大风，飞燕随风扬袖飘舞，看着好像就要乘风飞去。此时，汉成帝急忙叫冯无方拉住赵飞燕，生怕她被大风吹跑了。过了一会儿，风停了，赵飞燕的裙子也被抓皱了。从此宫中就流行一种折叠有皱的裙子叫“留仙裙”。因为汉成帝怕大风把赵飞燕吹跑，于是特地为赵飞燕筑起了“七宝避风台”。 公元前7年汉成帝绥和二年三月丙戌，惊蛰已过春色渐浓，而身处长安汉宫的赵飞燕、赵合德姐妹却觉出一阵特别的秋凉肃杀之气。 一帮男人手持太后符节，口称大司马王莽和御史、丞相、廷尉的命令冲进了赵昭仪所住的少嫔馆，将赵昭仪团团围住，气焰逼人，高声诘问皇帝前日暴死时的一切起居细节。 赵合德招来同胞姐姐赵飞燕皇后，殷殷话别，“我等本系弃儿，惟天佑得活。得幸荐于天子，宠所被耀于四海之内，已矣。今何堪复对宵小，争辩男女榻第之事哉?”于是自杀身死。 永始元年，为了长保富贵，赵飞燕曾“多通侍郎、宫奴多子者”希望能生下一男半子，冒为刘姓血肉。不料，被皇帝得知消息，始欲杀赵飞燕，多亏妹妹合德在刘骜面前转關，“妾姊性刚，有如为人构陷，则赵氏无种矣！” 当夜，合德移步远条馆，屏开众人，说道: “姊曾忆家贫寒饥无聊，姊使我共邻家女为草履，入市货履市米。一日得米，归遇风雨，无火可炊，饥寒甚，不能成寐，使我拥姊背同泣。此事岂不忆也?今日幸福贵，无他人伐我而自毁败，或再有过，帝复怒，事不可救，身首异地，为天下笑。今日妾能拯救也，存殁无定，或尔妾死，尚可攀乎?” 赵合德灭绝成帝皇嗣一事也成为燕啄皇孙典故的来源。 耕田放牧, 打豺狼 石斑木 波斯菊, 格桑花 桉树 蔓九节, 上树龙, 拎壁龙 佥，汉语二级字，读作佥（qiān）， 本义指皆，咸。 箭毒木, 挨刀木 为什么辣不是味觉？ 人类的五种基本味觉是甜、酸、苦、咸、鲜，由味蕾上的味觉受体感知。 辣的感觉并不是由味蕾感知的，而是由三叉神经（主要负责痛觉、温度感知）中的TRPV1受体检测到的。 辣的本质：一种“痛觉+温觉”刺激 辣椒素（Capsaicin）会刺激TRPV1受体，这个受体通常用于感知高温（42°C以上）和疼痛，因此大脑误以为“舌头着火”了。 这种“灼热感”其实是神经的反应，而不是普通的味觉感知。 芥末、辣根的“呛辣” → 主要刺激鼻腔粘膜的TRPA1受体，让人流泪、呛鼻。 薄荷的清凉感 → 薄荷醇刺激TRPM8受体，大脑误以为“遇冷”。 入吾室者, 但有清风, 对吾饮者, 唯当明月 吐穗扬花, 灌浆结果 许登科 聂隐娘, 磨镜少年, 精精儿, 空空儿 负局 磨镜, 断袖 磨镜客做的是手艺活，打交道的却还是人。妇人喜好妆容，更是离不开一面光亮常新的铜镜。于是磨镜客便成了一个总令闺中女子期待的人物。《梦粱录》即载有：“修磨刀剪、磨镜，时时有盘街者，便可唤之。”他们手里拿着几块铁片，好像拍板的模样，沿街敲打着，妇女们听见后，即可出来磨镜，这叫做“惊闺”。在明代就流行着这样的诗句：“云想衣裳花想容，宝镜绰约映春风。难见庐山真面目，拨雾还赖老磨工。” 最为著名的磨镜客形象当属唐传奇《聂隐娘》中的“磨镜少年”。他在文本中的出现非常突兀：“忽值磨镜少年及门，女曰‘此人可与我为夫’。白父，父不敢不从，遂嫁之。其夫但能淬镜，余无他能。” “余无他能”的磨镜少年竟能被聂隐娘点招为夫，这一情节在如今看来不可思议，在当时的读者看来却合情合理，磨镜本就是项稀缺的技艺，足够令人心仪。还有一种可能性就是“磨镜少年”隐藏了某种身份。唐朝诗人刘得仁在《赠道人》中写道：“长安城中无定业，卖丹磨镜两途贫。”可见磨镜客也顺便兜售丹药，考虑到磨镜药的制得颇费工夫，原材料只有道士方便获取，而且磨镜祖师负局先生也是得道之人，这位“磨镜少年”很可能就是修真之人。聂隐娘师徒杀人之后，常用一种神奇的药水将尸体溶解，能做到“毛发不存”，全凭某种厉害道具相助。由此而言，聂隐娘与“磨镜少年”结合，更像是为了修炼一些高深的道术。 璞玉浑金, 莫名其器 莫谈公事, 止谈岁月 “水底笙歌蛙两部，山中奴婢橘千头。” 王子直秀才的田园宅舍甚有雅趣，只听得门前的水池里蛙声阵阵，如同两个乐队在轮番演奏着动听的二部声乐。山坡上，橘树千行万株，郁郁葱葱，仿佛是众多的奴婢站在那里。诗句写出了王子直田园的特色。句中以“笙歌”喻蛙鸣，“两部”写蛙声此起彼落的情景，更觉有趣。 注： 奴婢，汉丹阳太守李衡种橘千树，称己有“千头木奴” ，后世遂呼橘树为“橘奴”。 “水底笙歌蛙两部，山中奴婢橘千头。”古诗句出处：宋·苏轼《赠王子直秀才》 狼奔豕突, shi3 豖chu4 燔fan2,焚烧 睢sui1 种豆南山下, 草盛豆苗稀 一顷南山豆, 五色东陵瓜 《口占绝句》宋·道潜 寄语东山窈窕娘，好将幽梦恼襄王 禅心已作沾泥絮，不逐春风上下狂 收心不兴狂想 面如凝脂, 眼如点漆 南朝齐梁时文人殷芸在《小说》中记载一段与桓温有关的事。内容描述东晋权臣桓温伐成汉时遇到一位百岁老翁，年轻时曾在诸葛亮在世时与之共事过。桓温召见他说：“当今之世谁可以跟诸葛亮相比呢?”，桓温的话语相当自衿。没想到老翁回答：“诸葛亮在世时我不认为他有什么特别的，但诸葛亮死后我发现没人比得上他。” 当初郗超与桓温结党，因为父亲忠于晋室，所以不敢让父亲知道。临终前，将一箱密谋书信交给门生保管，嘱咐道：“公年尊，我死以后，若以哀惋害寝食者，可呈此箱；不尔，即焚之。”后来郗愔果然悲痛欲绝，门生呈上书信，郗愔见儿子为桓温出谋划策，图谋东晋江山，大怒道：“小子死已晚矣！”从此不再悲伤。 赵禹为人廉洁孤傲，自从任官以来，舍第中从未有食客。公卿相继邀请赵禹，赵禹却从不回报，其用心在于杜绝知交、亲友及宾客的邀请，以便坚持自己的主张。 雉带箭 唐 韩愈 原头火烧静兀兀⑵，野雉畏鹰出复没⑶。 将军欲以巧伏人⑷，盘马弯弓惜不发⑸。 地形渐窄观者多⑹，雉惊弓满劲箭加⑺。 冲人决起百余尺⑻，红翎白镞随倾斜⑼。 将军仰笑军吏贺⑽，五色离披马前堕⑾。 《逢蒙杀羿，羿也有过》出自《孟子》的《离娄章句下》。逢蒙艺成害师，历来为人所不齿，这本已是大家的共识，孟 子却提出了自己独特的见解，认为共有自取其祸的责任在内。 吉凶倚伏 《诗经》乱匪降自天、生自妇人 资貌殊绝 吴起和商鞅都是卫国人, 商鞅的徙木立信效仿了吴起, 吴起担任西河郡守期间，向子夏学习儒家思想，[26]并改革魏国兵制，创立武卒制。吴起规定凡是能够身着全副甲胄，执12石[注 6]之弩，背负箭矢50个，荷戈带剑，携三日口粮，在半日内跑完百里者，可入选为武卒，免除其全家的徭役和田宅租税。武卒经过吴起的严格训练，成为魏国的精锐之师。 吴起主张兵不在多，要建立一支平时守礼法，战时有威势，前进时锐不可挡，后退时速不可追的军队。[63]建立这样的军队，要选募良材，重用勇士和志在杀敌立功的人，为他们加官进爵，厚待他们的家人，让他们作为军队的骨干。[64]对士卒的使用要因人而异，使其发挥各自的特长。要按照同乡同里编组，同什同伍相互联保，对部众严格管理。[65]采取一人教十人，十人教百人…万人教三军的教战方法，严格训练。让士兵适应方阵、圆阵的变化以及掌握队列的前、后、左、右、坐、起、进、止等动作，[66]熟悉金、鼓、旗、铃等指挥号令。[67][68]前进有重赏，后退有重罚，赏罚必信。[69]奖励有功者，勉励无功者，抚恤和慰问牺牲将士的家属。[70]要选拔文武兼备、刚柔并用、安抚士众、威慑敌军、决断疑难的武将作为军队的主将 吴起担任西河郡守期间，秦国有个岗亭靠近魏国境内。这个岗亭会对魏国的种田人造成很大危害，但是又不值得征调部队攻打它。于是吴起就在北门外放了一根车辕，然后下令说：“谁能把车辕搬到南门外，就赏赐他上等田地、上等住宅。”起初没有人去搬它，最终有个人把车辕搬到南门，吴起立即按照命令行赏。不久吴起又在东门外放了一石红豆，下令说：“谁能把红豆搬到西门，赏赐如前。”百姓们都争抢去搬。最后吴起下令道：“明天要攻打岗亭，能冲锋陷阵的，就任命他做大夫，赏赐上等田地和住宅。”百姓们争先恐后参战，一个早上就把岗亭攻占了。 合抱之木, 生于毫末, 九层之台, 起于累土, 千里之行, 始于足下 强中更有强中手, 莫向人间夸大口 黄口孺子 《井底引银瓶》白居易 中长篇叙事诗 井底引银瓶，银瓶欲上丝绳 .. 忆昔在家为女时，人言举动有殊姿。 婵娟两鬓秋蝉翼，宛转双蛾远山色。 笑随戏伴后园中，此时与君未相识。 妾弄青梅凭短墙，君骑白马傍垂杨。 墙头马上遥相顾，一见知君即断肠。 知君断肠共君语，君指南山松柏树。 感君松柏化为心，暗合双鬟逐君去。 合双鬟：古少女发式为双鬟，结婚后即合二为一。`,``,`html`,`碎片4`,`20250501094747-碎片 不仅生无知己, 即使死后也只有青蝇吊慰, 毕生落落寡合, 孤独无友 蒲葵细织团圆扇，薤叶平铺合遝花。却用水荷苞绿李，兼将寒井浸甘瓜 《题悬溜岩隐者居》方干 颛顼（zhuān xū），姬姓，高阳氏，黄帝之孙，昌意之子。出生于若水（现四川省雅安市荥经县地区六合乡附近）。上古部落联盟首领，“五帝”之一 愿为西南风, 长逝入君怀 黎巴嫩诗人纪伯伦：「你的孩子不是你的，他们经你而生，但非出自于你，他们虽然和你在一起，却不属于你。你可以给他们爱，但别把你的思想也给他们，因为他们有自己的思想。」 穷寇莫追, 以防垂死反扑, 给己方造成不必要的损失 穷乃工诗 自放于山巅水涯 明．冯惟敏《中吕粉蝶儿．五岳游囊杂咏》 归来饭饱黄昏后，曲肱而枕，鼓腹而游。 直木先伐, 甘井先竭 受国之垢，是谓社稷主；受国不祥，是为天下王 勇于担当责任，敢于承担屈辱和祸难，这样的人，才配做天下的君主。 李广李敢李陵, 三代, 陵降善终, 司马迁宫 卫青霍去病, 舅甥, 甥杀李敢 李广利, 李夫人哥, 昌邑王舅, 贰师将军, 降死 东风欲明心烂烂, 汝南晨鸡登坛唤 抖擞胸中三斗尘, 强欲哦吟无好语`,``,`html`,`神医喜来乐`,`20241229091513-影摘 溜须的功夫 老小子 甭管多没面子的事, 只要您自己不觉得害臊就没人笑你, 退一步说, 就是笑也没用啊, 咱不在乎呀 输一千次也不可怕, 可怕的是认输 杏林老前辈 杏林指医界，典故出自三国时期医生董奉行医不取一文钱，只要求病患者栽种杏树。 人都说京城是花花世界, 我这临走了, 连那花柳巷的门朝哪开我都不知道呢 德: 要不, 我怎么每天都睡床呢 瑞: 睡床怎么了, 瞧把你给美的 德: 别的伙计都睡柜台里的地铺呢, 你以为床是随便就能睡的呀, 谁的德行好才能睡床 瑞: 行行行, 我知道你最有德行 你小子不愧是吃剩饭长大的, 一肚子馊主意 再说了, 大老爷们的, 宁可让人给打死, 咱不能让人给吓死 赛老板, 我们夫人我最了解了, 她小事厉害, 大事扛不住, 您看她那架式, 估摸着去不成了 光脚不怕穿鞋的 指穷百姓和有钱有势的人斗，不怕丢掉什么，没有什么顾虑。 不求有功, 但求无过 你上坟不带烧纸, 你惹你祖宗生气呢 有道是响鼓不用重锤 是草它就进不了花盆, 这是花呢, 它就落不到野地里头 有事说事, 没事滚蛋, 今儿来什么意思吧 重操旧业收拾旧河山 这小子屎壳郎打喷嚏, 满嘴喷粪 不胜攻伐 鱼归大海, 鸟入山林`,``,`html`,`福星高照猪八戒`,`20241015103703-影摘 以后下雨的时候, 多护着点脑袋 我为什么要护着脑袋啊 当心再进水啊 人外有人, 逞强不好 你的鞋带儿呢 我的鞋没有鞋带儿 曾经有过的已经足够了, 不需要再多了`,``,`html`,`穿越时空的爱恋`,`20241209122851-影摘 我老人家不爱过生日, 岁数越大越不爱过, 过生日就像花钱, 谁也不知道, 自己从娘胎里带来的只会出不会进的钱究竟有多少, 老伙计, 你知道吗, 年长一岁, 就等于是花出去一个, 花一个就少一个, 今年的花了, 明年的还不知道有没有得花 一两星星二两云, 晒干的雪花要一斤 就算是如来佛也逃不出我小猴子的手掌心 郡主, 为什么你就不肯给我一个重获新生的机会呢, 为什么一个犯过错的人就不能得到别人的原谅呢, 如果我的家庭幸福, 生活美满, 那我怎么会去做一个小偷呢 依你的意思, 那就是社会的错啰 郡主果然是老天爷派来拯救小人的, 这个意思在小人心头转了好几年了, 今天被郡主一句话就说明白了 想不到明代的小偷就懂得把过错推给社会了 自古英雄多磨难, 从来纨绔少伟男 烤鸭店门口, 也搞得莺莺燕燕的 彩衣娱亲 浪子回头金不换, 浪女回头大家看 早晚一祷告, 晨昏三柱香 逢山开道, 遇水架桥 脚不沾地 意思是形容走得非常快，好像脚尖都未着地，同“脚不点地。出自《红楼梦》 儿臣若是被冤死, 那一定会, 六月飘雪, 大旱三年, 血溅三尺白绫 急水灌不了满杯 敬她如她在 焦不离孟，又名“孟不离焦”，出自《杨家将》，焦、孟指的是杨延昭（杨六郎）部下的两员大将焦赞和孟良，二人是结义弟兄，常形影不离。后用于比喻两人关系非常铁，感情深厚。 圣经上说的, 你们当中, 若谁没有犯过罪, 都可以用石头来丢他 圣经中记载了这样一个故事，文士和法利赛人带着一个淫乱时被抓的妇人，带到耶稣面前，请耶稣作出判决——是否要用石头打死，陷耶稣于两难之中。 耶稣回应说“你们中间谁是没有罪的，谁就可以先拿石头打她”，结果犹太人从老到少全都离开了，没人向妇人砸石头，耶稣也没有定女人的罪，放她走了。 人说一登九五, 六亲情绝, 手足相残, 父子反目, 斗争倾轧, 天伦难再, 果真如此吗 呜乎哀哉 你这叫绣花啊, 远看, 嗯, 不是花, 近看, 豆腐渣`,``,`html`,`笑林广记`,`20240307183503-书摘 升官 一官升职，谓其妻曰：“我的官职比前更大了。”妻曰：“官大，不知此物亦大不？”官曰：“自然。”及行事，妻怪其藐小如故，官曰：“大了许多，汝自不觉着。”妻曰：“如何不觉？”官曰：“难道老爷升了官职，奶奶还照旧不成？少不得我的大，你的也大了。” 有理 一官最贪。一日，拘两造对鞫，原告馈以五十金，被告闻知，加倍贿托。及审时，不问情由，抽签竟打原告。原告将手作五数势曰：“小的是有理的。”官亦以手覆曰：“奴才，你讲有理。”又以手一仰曰：“他比你更有理哩。” 胡涂 一青盲人涉讼，自诉眼瞎。官曰：“你明明一双清白眼，如何诈瞎？”答曰：“老爷看小人是清白的，小人看老爷却是糊堡得紧。” 避暑 官值暑月，欲觅避凉之地。同僚纷议，或曰某山幽雅，或曰某寺清闲。一老人进曰：“山寺虽好，总不如此座公厅，最是凉快。”官曰：“何以见得？”答曰：“别处多有日头，独此处有天无日。” 不往京 一监生娶妾，号曰京姐，妻妒甚。夫诣妾，必告曰：“京里去。”一日，欲往京去，妻曰：“且在此关上纳了纱着。”既行事讫，妻曰：“汝今何不往京！”生曰：“绒也没有一些在肚里，京里去做甚么！” 咬飞边 贫子途遇监生，忽然抱住兜耳一口。生惊问其故，答曰：“我穷苦极矣，见了大锭银子，如何不咬些飞边用用。” 书低 一生赁僧房读书，每日游玩，午后归房，呼童取书来。童持《文选》，视之，曰：“低。”持《汉书》，视之，曰：“低。”又持《史记》，视之，曰：“低。”僧大诧曰：“此三书，熟其一，足称饱学，俱云低，何也？”生曰：“我要睡，取书作枕头耳。” 打丁 一人往妓馆打丁毕，妓牵之索谢，答曰：“我生员也，奉祖制免丁。”俄焉又一人至，亦如之。妓曰：“为何？”答曰：“我监生也。”妓曰：“监生便怎么？”其人曰：“岂不知监生从来是白丁。” 自不识 有监生，穿大衣，带圆帽，于着衣镜中自照，得意甚。指谓妻曰：“你看镜中是何人？”妻曰：“臭乌龟！亏你做了监生，连自（字）多不识。” 仿制字 一生见有投制生帖者，深叹“制”字新奇。偶致一远札，遂效之。仆致书回，生问：“见书有何话说？”仆曰，“当面启看，便问：‘老相公无恙？’又问：‘老安人好否？’予曰：‘俱安。’乃沉吟半响，带笑而入，纔发回书。”生大喜曰：“人不可不学，只一字用得着当，便一家俱问，到添下许多殷勤。” 借牛 有走柬借牛于富翁者，翁方对客，讳不识字，伪启缄视之。对来使曰：“知道了，少刻我自来也。” 不愿富 一鬼托生时，冥王判作富人。鬼曰：“不愿富也。但求一生衣食不缺，无是无非，烧清香，吃苦茶，安闲过日足矣。”冥王曰：“要银子便再与你几万，这样安闲清福，却不许你享。” 田主见鸡 一富人有余田数亩、租与张三者种，每亩索鸡一只。张三将鸡藏于背后，田主遂作吟哦之声曰：“此田不与张三种。”张三忙将鸡献出，田主又吟曰：“不与张三却与谁？”张三曰：“初间不与我，后又与我，何也？”田主曰：“初乃无稽（鸡）之谈，后乃见机（鸡）而作也。” 黉门 三秀才往妓家设东叙饮，内一秀才曰：“兄治何经？”曰：“通《诗经》。”复问其次，曰：“通《书经》。”因戏问妓曰：“汝通何经？”曰：“妾通月经。”众皆大笑。妓曰：“列位相公休笑我，你们做秀才，都从这红门中出来的。” 行房 一秀士新娶，夜分就寝，问于新妇曰：“吾欲云雨，不知娘子尊意允否？”新人曰：“官人从心所欲。”士曰：“既蒙俯允，请娘子展股开肱，学生无礼又无礼矣。”及举事，新妇曰：“痛哉，痛哉！”秀才曰：“徐徐而进之，浑身通泰矣。” 七等割屪 一士考末等，自觉惭愧，且虑其妻之姗己也。乃架一说诳妻曰：“从前宗师止于六等，今番遇着这个瘟官，好不利害，又增出一等，你道可恶不可恶？”妻曰：“七等如何？”对曰：“六等不过去前程，考七等者，竟要阉割。”妻大惊曰：“这等，你考在何处？”夫曰：“还亏我争气，考在六等，幸而免割。”此义通“讪” 姗,诽也。从女,删省声。与讪略同 腹内全无 一秀才将试，日夜懮郁不已。妻乃慰之曰：“看你作文，如此之难，好似奴生产一般。”夫曰：“还是你每生子容易。”妻曰：“怎见得？”夫曰：“你是有在肚里的，我是没在肚里的。” 　 　 不完卷 一生不完卷，考置四等，受朴。对友曰：“我只缺得半篇。”友云：“还好。若做完，看了定要打杀。”　 猫逐鼠 一猫捕鼠，鼠甚迫，无处躲避，急匿在竹轿杠中。猫顾之叹云：“看你管（馆）便进得好，这几个节如何过得去！” 蜈蚣咬 上江人出外坐馆，每兴举，辄以手铳代之，以竹筒盛接。其精日久气腥，为蜈蚣潜啖。一日，其兴复发，正作事，忽被蜈蚣箝住阳物，师恐甚。岁暮归家，摸着其妻阴户多毛，乃大声惊诧曰：“光光竹筒，尚有蜈蚣，蓬蓬松松，岂无蛇虫！” 咏钟诗 有四人自负能诗。一日，同游寺中，见殿角悬钟一口，各人诗兴勃然，遂联句一首。其一曰：“寺里一口钟。”次韵云：“本质原是铜。”三曰：“覆转像只碗。”四曰：“敲来嗡嗡嗡。”吟毕，互相赞美不置口，以为诗才敏捷，无出其右。“但天地造化之气，已泄尽无遗，定夺我辈寿算矣。”四人懮疑，相聚环泣。忽有老人自外至，询问何事，众告以故。老者曰：“寿数固无碍，但各要患病四十九日。”众问何病，答曰：“了膀骨痛！” 老童生 老虎出山而回，呼肚饥。群虎曰：“今日固不遇一人乎？”对曰：“遇而不食。”问其故，曰：“始遇一和尚，因臊气不食。次遇一秀才，因酸气不食。最后一童生来，亦不曾食。”问：“童生何以不食？”曰：“怕咬伤了牙齿。” 冥王访名医 冥王遣鬼卒访阳间名医，命之曰：“门前无冤鬼者即是。”鬼卒领旨，来到阳世，每过医门，冤鬼毕集。最后至一家，见门首独鬼彷徨，曰：“此可以当名医矣。”问之，乃昨日新竖药牌者。 拾柩 一医生医死人，主家愤甚，呼群仆毒打。医跪求至再，主曰：“私打可免，官法难饶。”即命送官惩治。医畏罪，哀告曰：“愿雇人抬往殡殓。”主人许之。医苦家贫，无力雇募，家有二子，夫妻四人共来抬柩。至中途，医生叹曰：“为人切莫学行医。”妻咎夫曰：“为你行医害老妻。”幼子云：“头重脚轻抬不起。”长子曰：“爹爹，以后医人拣瘦的。” 医女接客 医生、妓女、偷儿三人，死见冥王，王问生前技术。医士曰：“小人行医，人有疾病，能起死回生。”王怒曰：“我每常差鬼卒勾提罪人，你反与我把持抗衡，可发往油锅受罪。”次问妓女，妓曰：“接客。人没妻室者，与他解渴应急。”王曰：“方便孤身，延寿一纪。”再问偷儿，答曰：“做贼。人家晒浪衣服，散放银钱，我去替他收拾些。”王曰：“与人分劳代力，也加寿十年，发转阳世。”医士急忙哀告曰：“大王若如此判断，只求放我还阳。家中尚有一子一女，子叫他去做贼，女就叫他接客便了。” 赔 一医医死人儿，主家欲举讼，愿以己子赔之。一日，医死人仆，家止一仆，又以赔之。夜间又有叩门者云：“娘娘产里病，烦看。”医私谓其妻曰：“淘气！那家想必又看中意你了。” 胡须像 一画士写真既就，谓主人曰：“请执途人而问之，试看肖否？”主人从之，初见一人问曰：“那一处最像？”其人曰：“方巾最像。”次见一人，又问曰：“那一处最像？”其人曰：“衣服最像。”及见第三人，画士嘱之曰：“方巾、衣服都有人说过，不劳再讲，只问形体何如？”其人踌躇半晌，曰：“胡须最像。” 有进益 一翁有三婿，长裁缝，次银匠，惟第三者不学手艺，终日闲游。翁责之曰：“做裁缝的，要落几尺就是几尺。做银匠的，要落几钱就是几钱。独汝游手好闲，有何结局？”三婿曰：“不妨。待我打一把铁窍，窍开人家库门，要取论千论百，也是易事，稀罕他几尺几钱！”翁曰：“这等说，竟是贼了。”婿曰：“他们两个，整日落人家东西，难道不是贼？” 试试看 新妇与新郎无缘，临睡即踢打，不容近身。郎诉之父，父曰：“毕竟你有不是处，所以如此。”子云：“若不信，今晚你去睡一夜试试看。” 白鼻猫 一人素性最懒，终日偃卧不起。每日三餐，亦懒于动口，恹恹绝粒，竟至饿毙。冥王以其生前性懒，罚去轮回变猫。懒者曰：“身上毛片，愿求大王赏一全体黑身，单单留一白鼻，感恩实多。”王问何故，答曰：“我做猫躲在黑地里，鼠见我白鼻，认作是块米糕，贪想愉吃，潜到嘴边，一口咬住，岂不省了无数气力。” 买海蛳 一人见卖海蛳者，唤住要买，问：“几多钱一斤？”卖者笑曰：“从来海蛳是量的。”其人喝曰：“这难道不晓得！问你几多钱一尺？” 浼匠迁居 一人极好静，而所居介于铜，铁两匠之间，朝夕聒耳，甚苦之，常曰：“此两家若有迁居之日，我宁可作东款谢。”一日，二匠并至曰：“我等欲迁矣，足下素许东道，特来叩领。”其人大喜，遂盛款之。席间问之曰：“汝两家迁往何处？”答曰：“他搬在我屋里，我即搬在他屋里。” 混堂嗽口 有人在混堂洗浴，掬水人口而嗽之。众各攒眉相向，恶其不洁。此人贮水于手曰：“诸公不要愁，待我嗽完之后，吐出外面去。”　 丑汉看 一妇人在门首，被人注目而看，妇人大骂不已。邻妪劝曰：“你又不在内室，凭他看看何妨？”妇曰：“我若把好面孔看看也罢，被这样呆脸看了，岂不苦毒。” 洞房佳偶 一佳人新嫁，合欢之夜，佳人以对挑之曰：“君乃读书之辈，奴出一对，请君对之。如答得来，方许云雨，不然则不从也。”新郎曰：“愿闻。”女曰：“柳色黄金嫩，梨花白雪香，你爱不爱？”新郎对曰：“洞里乾坤大，壶中日月长，你怕不怕？” 抢婚 有婚家女富男贫，男家虑其新婚，率领众人抢亲，误背小姨以出。女家人急呼曰：“抢差了！”小姨在背上曰：“不差，不差！快走上些，莫信他哄你哩。” 两尽 夫劝新妇解衣。妇曰：“母戒我勿解，母命不可违﹔夫劝我解，夫命又不可违﹔奈何？”正沉吟间，夫迫之，妇曰：“我知之矣！只脱去下截，做个两尽其情罢。” 问嫂 一女未嫁者，私问其嫂曰：“此事颇乐否？”嫂曰：“有甚乐处，只为周公之礼，制定夫妇耳。”及女出嫁后归宁，一见其嫂，即笑骂曰：“好个说谎精。” 没良心 一妓倚门而立，见有客过，拉人打钉，适对门楼上，姑嫂二人推窗见之，姑问嫂：“扯他何事？”嫂曰：“要他行房。”须臾事毕，妓取厘戥夹剪付之，姑曰：“彼欲何为？”嫂曰：“行过了房，要他出银子。”姑叹曰：“好没良心，如何反要他出。” 死结 新人初夜上床，使性不止。喜娘隔壁劝曰：“此乃人伦大事，个个如此，不要害羞。”新人曰：“你不晓得，裤子衣带，偏生今夜打了死结。” 出气 一女未嫁，父母索重聘。既嫁初夜，婿怪岳家争论财礼，因恨曰：“汝父母直恁无情，我只拿你出气。”乃大干一次。少倾又曰：“汝兄嫂亦甚可恶，也把你来发泄。”又狠弄一番。两度之后，精力疲倦，不觉睡去。女复摇醒曰：“我那兄弟虽小，日常多嘴多舌，倒是极蛮惫的。” 纳茄 一妇昼寝不醒，一人戏将茄子纳入牝中而去。妇觉，见茄在内，知为人所欺，乃大骂不止。邻妪谓曰：“其事甚丑，娘子省口些罢。”妇曰：“不是这等说，此番塞了茄儿不骂，日后冬瓜、葫芦便一起来了。” 罚真咒 一人欲往妾处，诈称：“我要出恭，去去就来。”妻不许，夫即赌咒云：“若他往做狗。”妻将索系其足放去。夫解索，转缚狗脚上，竟往妾房。妻见去久不至，收索到床边，起摸着狗背，乃大骇云：“这死乌龟，我还道是骗我，却原来倒罚了真咒。” 嫌口阔 一少年嫖妓，嫌妓口阔，因述俗语云：“口阔屄儿大。”妓即撮口骂曰：“小猢狲。” 缠住 一螃蟹与田鸡结为兄弟，各要赌跳过涧，先过者居长。田鸡溜便早跳过来。螃蟹方行，忽被一女子撞见，用草捆住。田鸡见他不来，回转唤云：“缘何还不过来？”蟹曰：“不然几时来了，只因被这歪刺骨缠住在此，所以耽迟来不得。” 龟渡 有一士欲过河，苦无渡船。忽见有一大龟，士曰：“乌龟哥，烦你渡我过去，我吟诗谢你。”龟曰：“先吟后渡。”士曰：“莫被你哄，先吟两句，渡后再吟两句，何如？”龟曰：“使得。”士吟曰：“身穿九宫八卦，四游龙王也怕。”龟喜甚，即渡士过河。士续曰：“我是衣冠中人，不与乌龟答话。” 叫城门 一人最好唱曲。探亲回迟，城门已闭，因叫：“开门！”管门者曰：“你唱一曲我听，便放你进来。”此人曰：“唱便唱，只是我唱，你要答应。”管门曰：“依你。”其人先说白云：“叫周仓！”城上应曰：“嗄。”“关爷爷在城外了，还不快迎！”复应曰：“嗄。”其人曰：“你既晓得关出你爷在城外，就该开门，如何还敢要我唱曲？” 抵偿 老虎欲吃猢狲，狲诳曰：“我身小，不足以供大嚼。前山有一巨兽，堪可饱餐，当引导前去。”同至山前，一角鹿见之，疑欲啖己，乃大喝云：“你这小猢狲，许我拿十二张虎皮送我，今只拿一张来，还有十一张呢？”虎惊遁，骂曰：“不信这小猢狲如此可恶，倒要拐我抵销旧帐！” 开当 有慕开典铺者，谋之人曰：“需本几何？”曰：“大典万金，小者亦须千计。”其人大骇而去。更请一人问之，曰：“百金开一钱当亦可。”又辞去。最后一人曰：“开典如何要本钱，只须店柜一张，当票数纸足矣。”此人乃欣然。择期开典，至日，有持物来当者，验收讫，填空票计之。当者索银，答曰：“省得称来称去，费坏许多手脚，待你取赎时，只将利银来交便了。” 恋席 客人恋席，不肯起身。主人偶见树上一大鸟，对客曰：“此席坐久，盘中肴尽，待我砍倒此树，捉下鸟来，烹与执事侑酒，何如？”客曰：“只恐树倒鸟飞矣。”主云：“此是呆鸟，他死也不肯动身的。” 四脏 一人贪饮过度，妻子私相谋议曰：“屡劝不听，宜以险事动之。”一日，大饮而哕，子密袖猪膈置哕中，指以谓曰：“凡人具五脏，今出一脏矣，何以生耶？”父熟视曰：“唐三藏尚活世，况我有四脏乎！” 借水 一家请客，失分一箸。上菜之后，众客朝拱举箸，其人独抻手而观。徐向主人曰：“求赐清水一碗。”主问曰：“何处用之？”答曰：“洗干净了指头，好拈菜吃。” 不奉富 千金子骄语人曰：“我富甚，汝何得不奉承？”贫者曰：“汝自多金子，我何与而奉汝耶？”富者曰：“倘分一半与汝何如？”答曰：“汝五百，我五百，我汝等耳，何奉焉？”又曰：“悉以相送，难道犹不奉我？”答曰：“汝失千金，而我得之，汝又当趋奉我矣。” 留茶 有留客吃茶者，苦无茶叶，往邻家借之。久而不至，汤滚则溢，以冷水加之。既久，釜且满矣，而茶叶终不得。妻谓夫曰：“茶是吃不成了，不如留他洗个浴罢。” 剩石沙 一穷人留客吃饭，其妻因饭少，以鹅卵石衬于添饭之下。及添饭既尽，而石出焉。主人见之愧甚，乃责仆曰：“瞎眼奴才，淘米的时节，眼睛生在那里？这样大石沙，都不拿来拣出。” 说出来 一人为讨债者所逼，乃发急曰：“你定要我说出来么！”讨债者疑其发己心病，嘿然而去。如此数次。一日发狠曰：“由你说出来也罢，我不怕你。”其人又曰：“真个要说出来？”曰：“真要你说。”曰：“不还了！” 坐椅子 一家索债人多，椅凳俱坐满，更有坐槛上者。主人私谓坐槛者云：“足下明日来早些。”那人意其先完己事，乃大喜，遂扬言以散众人。次早黎明即往，叩其相约之意。答曰：“昨日有亵坐槛，甚是不安，今日早来，可占把交椅。” 不停当 有开当者，本钱甚少。初开之月，招牌写一“当”字。未几，本钱发尽，赎者不来，乃于“当”字之上，写一“停”字，言停当也。及后赎者再来，本钱复至，又于“停”字之上，加一“不”字。人见之曰：“我看你这典铺中，实实有些不停当了。” 朝奉 徽人狎妓，卖弄才学，临行事，待要说一成语切题。乃舒妓两股，以其阴对己之阳曰：“此丹凤朝阳也。”妓亦以徽人之阳对己之阴，徽人问曰：“此何故事？”妓曰：“这叫做卵袋朝奉。” 风流不成 有嫖客钱尽，鸨儿置酒饯之。忽雨下，嫖客叹曰：“雨落天留客，天留人不留。”鸨念其撒钱，勉留一宿。次日下雪复留。至第三日风起，嫖客复冀其留，仍前唱叹。鸨儿曰：“今番官人没钱，风留（流）不成。” 通谱 有人欲狎一处女，先举其物询之曰：“此是何物，汝知之否？”女曰：“那是一张。”因“卵”字不便出口，故作歇后语也。又问曰：“这等，你腰下的何物？”女曰：“也是一张。”男曰：“你也一张，我也一张，可见这两件东西都是姓张的了，五百年前共一家，何不使他通一通谱？”女许之，遂解裤相狎。事毕后，女叹曰：“谱便通了，只是这个门户渐渐的大起来，收敛不得，却怎么好？” 定亲 一人登厕，隔厕先有一女在焉，偶失净纸，因言：“若有知趣的给我，愿为之妇。”其人闻之，即以自所用者，从壁隙中递与。女净讫径去。其人叹曰：“亲事虽定了一头，这一屁股债，如何干净？” 骂无礼 有数小厮同下池塘浴水，被一小蛇将屪子咬了一口。小厮忿怒，将池塘戽干，果见小蛇，乃大骂曰：“这小畜生太无礼，咬我屪子就是你！” 瓦窑 一人连生数女，招友人饮宴。友作诗一首，戏赠之云：“去岁相招因弄瓦，今年弄瓦又相招。弄去弄来都弄瓦，令正原来是瓦窑。” 嘲滑稽客 一人留客午饭，其客已啖尽一碗，不见添饭。客欲主人知之，乃佯言曰：“某家有住房一所要卖。”故将碗口向主人曰：“椽子也有这样大。”主人见碗内无饭，急呼童使添之。因问客曰：“他要价值几何？”客曰：“如今有了饭吃，不卖了。” 僭称呼 一家父子僮仆，专说大话，每每以朝廷名色自呼。一日，友人来望，其父出外，遇其长子，曰：“父王驾出了。”问及令堂，次子又云：“娘娘在后花园饮宴。”友见说话僭分，含怒而去。途遇其父，乃述其子之言告之。父曰：“是谁说的？”仆在后云：“这是太子与庶子说的。”其友愈恼，扭仆便打。其父忙劝曰：“卿家弗恼，看寡人面上。” 床榻 有卖床榻者，一日夫出，命妇守店。一人来买床，价少，银水又低，争值良久，勉强售之。次日，复宋买榻，妇曰：“这人不知好歹，昨日床上讨尽我便宜，今日榻上又想要讨我的便宜了。” 闹一闹 一杭人妇，催轿往西湖游玩，贪恋湖上风景，不觉归迟。时已将暮，怕关城门，心中着急，乃对轿夫言曰：“轿夫阿哥，天色晚了，我多把银钱打发，你与我尽力闹一闹。早行进到里头去，不但是我好，连你们也落得自在快活些。” 摸一把 妇人门首买菜，问：“几个钱一把？”卖者说：“实价三个钱两把。”妇还两个钱三把，卖者云：“不指望我来摸娘娘一把，娘娘倒想要摸我一把，讨我这样便宜。” 苏空头 一人初往苏州，或教之曰：“吴人惯扯空头，若去买货，他讨二两，只好还一两。就是与人讲话，他说两句，也只好听一句。”其人至苏，先以买货之法，行之果验。后遇一人，问其姓，答曰：“姓陆。”其人曰：“定是三老官了。”又问：“住房几间？”曰：“五间。”其人曰：“原来是两间一披。”又问：“宅上还有何人？”曰：“只房下一个。”其人背曰：“原还是与人合的。” 连偷骂 吴人有灌园者，被邻居窃去蔬果，乃大骂曰：“入娘贼，春天偷了我婶（笋），夏天又来偷我妹（梅）子，到冬来还要偷我个老婆（萝卜）。” 晾杩桶 苏州人家晒晾两杩桶在外，瞽者不知，误撒小解。其姑喝骂，嫂忙问曰：“这肏娘贼个脓血，滴来你个里面，还是撒来我个里头。”姑回云：“我搭你两边都有点个。” 不知令 饮酒行令，座客有茫然者。一友戏曰：“不知令，无以为君子也。”其人诘曰：“不知命，为何改作令字？”答曰：“《中庸》注云：‘命犹令也。’” 卖糖 一糖担歇在人家门首敲锣，妇喝曰：“快请出去，只管在此甚么？出个小的儿来，又要害我淘气。” 蚬子 两人相遇，各问所生子女几何。一曰：“五女。”一曰：“一子。”生女者曰：“一子是险子。”生子者怒曰：“我是蚬子，强如你养了许多肉蚌。” 底下硬 一人夜膳后，先在板凳上去睡，翻身说：“底下硬得紧。”妻在灶前听见，回言曰：“不要忙，收拾过碗盏就来了。” 手氏 一人年逾四旬始议婚，自惭太晚，饰言续弦。及娶后，妻察其动静，似为未曾婚者。乃问其前妻何氏，夫骤然不及思，遽答曰：“手氏。” 两夫 丈夫欲娶妾，妻曰：“一夫配一妇耳，娶妾见于何典？”夫曰：“孟子云：‘齐人有一妻一妾。’又曰：‘妾妇之道。’妾自古有之矣。”妻曰：“若这等说，我亦当再招一夫。”夫曰：“何故？”妻曰：“岂不闻《大学》上云：‘河南程氏两夫’。《孟子》中亦有‘大丈夫’、‘小丈夫’。” 两企慕 山东人慕南方大桥，不辞远道来看。中途遇一苏州人，亦闻山东萝卜最大，前往观之。两人各诉企慕之意。苏人曰：“既如此，弟只消备述与兄听，何必远道跋涉？”因言：“去年六月初三，一人自桥上失足堕河，至今年六月初三，还未曾到水，你说高也不高？”山东人曰：“多承指教。足下要看敝处萝卜，也不消去得，明年此时，自然长过你们苏州来了。”`,``,`html`,`红楼梦`,`20240307183503-书摘 其晨夕风露，阶柳庭花 今之人，贫者日为衣食所累，富者又开不足之心，纵一时稍闲，又有贪淫恋色、好货寻愁之事，那里有工夫去看那理治之书？ 今风尘碌碌，一事无成 或情或痴，或小才微善 满纸潘安，子建，西子，文君 满纸才人淑女，子建文君红娘小玉 时逢三五便团圆，满把晴光护玉栏． 天上一轮才捧出，人间万姓仰头看 世人都晓神仙好，惟有功名忘不了！ 古今将相在何方？荒冢一堆草没了． 世人都晓神仙好，只有金银忘不了！ 终朝只恨聚无多，及到多时眼闭了． 世人都晓神仙好，只有姣妻忘不了！ 君生日日说恩情，君死又随人去了． 世人都晓神仙好，只有儿孙忘不了！ 痴心父母古来多，孝顺儿孙谁见了？ 一局输赢料不真，香销茶尽尚逡巡．欲知目下兴衰兆，须问旁观冷眼人． 原来，雨村因那年士隐赠银之后，他于十六日便起身入都，至大比之期，不料他十分得意，已会了进士，选入外班，今已升了本府知府．虽才干优长，未免有些贪酷之弊，且又恃才侮上，那些官员皆侧目而视．不上一年，便被上司寻了个空隙，作成一本，参他生情狡猾，擅纂礼仪，大怒，即批革职．该部文书一到，本府官员无不喜悦．那雨村心中虽十分惭恨，却面上全无一点怨色，仍是嘻笑自若，交代过公事，将历年做官积的些资本并家小人属送至原籍，安排妥协，却是自己担风袖月，游览天下胜迹． 今只有嫡妻贾氏，生得一女，乳名黛玉，年方五岁．夫妻无子，故爱如珍宝，且又见他聪明清秀，便也欲使他读书识得几个字，不过假充养子之意，聊解膝下荒凉之叹． 这日，偶至郭外，意欲赏鉴那村野风光．忽信步至一山环水旋，茂林深竹之处，隐隐的有座庙宇，门巷倾颓，墙垣朽败，门前有额，题着"智通寺"三字，门旁又有一副旧破的对联，曰 　　身后有余忘缩手，眼前无路想回头．雨村看了，因想到：“这两句话，文虽浅近，其意则深．我也曾游过些名山大刹，倒不曾见过这话头，其中想必有个翻过筋斗来的亦未可知，何不进去试试。”想着走入，只有一个龙钟老僧在那里煮粥．雨村见了，便不在意．及至问他两句话，那老僧既聋且昏，齿落舌钝，所答非所问． 转过牌坊，便是一座宫门，也横书四个大字，道是“孽海情天”。又有一 副对联，大书云： 厚地高天，堪叹古今情不尽； 痴男怨女，可怜风月债难偿。 又听警幻笑道：“你们快出来迎接贵 客！”一语未了，只见房中又走出几个仙子来，皆是荷袂蹁跹，羽衣飘 舞，姣若春花，媚如秋月。 少刻，有小嬛来调桌安椅，设摆酒馔。真是：琼浆满泛玻璃盏，玉液浓斟琥珀杯 却不知太高人愈妒，过洁世同嫌 问古来将相可还存？也只是虚名儿与后人钦 敬。 歌毕，还又歌副曲。警幻见宝玉甚无趣味，因叹：“痴儿竟尚未 悟！”那宝玉忙止歌姬不必再唱，自觉朦胧恍惚，告醉求卧。警幻便命撤 去残席，送宝玉至一香闺绣阁之中，其间铺陈之盛，乃素所未见之物。更 可骇者，早有一位女子在内，其鲜艳妩媚，有似乎宝钗；风流袅娜，则又 如黛玉。正不知何意。忽警幻道：“尘世中多少富贵之家，那些绿窗风 月、绣阁烟霞，皆被淫污纨袴与那些流荡女子悉皆玷辱。更可恨者，自古 来多少轻薄浪子，皆以‘好色不淫’为饰，又以‘情而不淫’作案，此皆 饰非掩丑之语也。好色即淫，知情更淫。是以巫山之会、云雨之欢，皆由 既悦其色、复恋其情所致也。吾所爱汝者，乃天下古今第一淫人也。” 只见门前歇着些生意担子，也有卖吃的，也有卖顽耍物件的，闹烘烘 三二十个孩子在那里厮闹。刘姥姥便拉住了一个道：“我问哥儿一声，有 个周大娘可在家么？”孩子道：“那个周大娘？我们这里周大娘有三个 呢，还有两个周奶奶，不知是那一行当上的？”刘姥姥道：“是太太的陪 房周瑞。”孩子道：“这个容易，你跟我来。”说着，跳跳蹿蹿引着刘姥 姥进了后门，至一院墙边，指与刘姥姥道：“这就是他家。”又叫 道：“周大妈，有个老奶奶来找你呢。” 秦钟笑道：“家父前日在家提起延师一事，也曾提起这里 的义学到好，原要来和这里的亲翁商议引荐。因这里事忙，不便为这点小 事来聒絮的。宝叔果然度小侄或可磨墨涤砚，何不速速的作成，又彼此不 致荒废，又可以常相谈聚，又可以慰父母之心，又可以得朋友之乐，岂不 是美事？”宝玉笑道：“放心，放心。咱们回来先告诉你姐夫、姐姐和琏 二嫂子。你今日回家就禀明令尊，我回去再回明家祖母，再无不速成之理 的。”二人计议已定。那天气已是掌灯时候，出来又看他们顽了一回牌。 算账时，却又是秦氏、尤氏二人输了戏酒的东道，言定后日吃这东道，一 面又说了回话。 宝玉听说，忙下了炕来至里间门前，只见吊着半旧的红紬软帘。宝玉 掀帘一迈步进去，先就看见薛宝钗坐在炕上做针线，头上挽着漆黑油光的 䰖儿，蜜合色绵袄，玫瑰紫二色金银鼠比肩褂，葱黄绫绵裙，一色半新不 旧，看来不觉奢华。唇不点而红，眉不画而翠，脸若银盆，眼如水杏。罕 言寡语，人谓藏愚，安分随时，自云守拙。 现今咱们家走的这群大夫，那里要得一 个？都是听着人的口气儿，人怎么说，他也添几句文话儿说一遍。可到殷 勤的狠，三四个人一日轮流着到有四五遍来看脉。他们大家商量着立个方 子，吃了也不见效，到弄得一日换四五遍衣裳，坐起来见大夫，其实于病 人无益。 秦氏又道：“婶 子，恕我不能跟过去了。闲了时候还求婶子常过来瞧瞧我，咱们娘儿们坐 坐，多说几遭话儿。”凤姐儿听了，不觉得又眼圈儿一红，遂说道：“我 得了闲儿必常来看你。” 从小儿大妹妹顽笑着就有杀伐决断，如今出了阁， 又在那府里办事，越发历练老成了。 赶乱完了，天已四更将尽，纵睡下，又走 了困，不觉又是天明鸡唱，忙梳洗过宁府中来`,``,`html`,`线程`,`20240307183503-_java 线程调度 线程调度是指系统为线程分配处理器使用权的过程。 协同式线程调度 线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。 抢占式线程调度 每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。 各个线程通过竞争cpu时间而获得运行机会 什么时候得到cpu时间,占用多久,是不可预测的 一个正在运行着的线程在什么地方被暂停是不确定的 Java是抢占式线程调度，支持10个级别优先级，通过Thread.setPriority(Thread.MAX_PRIORITY)设置 MAX_PRIORITY = 10 MIN_PRIORITY = 1 NORM_PRIORITY = 5 线程的默认优先级为5 并不能代表,通过设置优先级来确保高优先级的线程一定会先执行，只是会提高一定的优先级​ cpu比较忙时，优先级高的线程获取更多的时间片 cpu比较闲时，优先级设置基本没用 定义和创建线程 继承Thread类 （可以说是 将任务和线程合并在一起） 任务逻辑写在Thread类的run方法中，有单继承的局限性 创建多线程时，每个任务有成员变量时不共享，必须加static才能做到共享 继承Thread类的类本身就代表了一个线程，每个这样的实例对应一个独立的线程,在执行完run()方法后就会结束，线程对象也会被销毁,每次创建一个线程都会创建一个新的Thread对象，这会增加对象的创建和销毁开销，影响性能 实现Runnable接口 （可以说是 将任务和线程分开了） 当我们使用Runnable接口实现一个任务时，只是创建了一个对象来表示这个任务，而不是直接创建一个线程。 这个任务对象可以被重复使用，可以被提交给线程池中的不同线程来执行,Runnable任务本身也是一个类，但它并不是线程。 当继承了Thread类又实现了Runnable接口时, 实际执行的是继承自Thread类的run方法 Runbale相比Callable有以下的局限性 任务没有返回值 任务无法抛异常给调用方 获取线程结束之后的结果 定义一个类MyCallable实现Callable接口重写call()方法 创建Future的实现类FutureTask对象，MyCallable作为构造方法的参数 启动线程后使用FutureTask对象调用get方法，就可以获取线程的执行结果。 class MyTask implements Callable<Integer> { private int n; public MyTask(int n) { this.n = n; } @Override public Integer call() {// 描述这个线程的任务和这个线程返回的结果 int sum = 0; for (int i = 0; i <= n; i++) { sum += i; } return sum; } } public class Demo { public static void main(String[] args) { MyTask myTask = new MyTask(100); FutureTask<Integer> futureTask = new FutureTask<>(myTask); Thread t1 = new Thread(futureTask,"t1"); t1.start(); try { System.out.println(futureTask.get()); } catch (InterruptedException | ExecutionException e) { throw new RuntimeException(e); } } } 线程的状态 new:新建状态，新创建的线程，此时尚未调用start()方法； Runnable:可运行状态(ready或run)，运行中的线程，已经调用了start()方法，线程正在或即将被执行； Blocked：阻塞状态，运行中的线程，在等待竞争锁时被阻塞(进入到sychronized修饰的代码块同时锁被其它线程拿走了)，暂不执行； 一般习惯而言,把Blocked, Waiting, Timed_waiting都称为阻塞状态, 不仅仅是Blocked Waiting:等待状态，运行中的线程，因为sleep()方法、join()方法等方法的调用，进入等待； Timed Waiting:计时等待状态，运行中的线程，因为执行sleep(等待毫秒值)join(等待毫秒值)等方法,进入计时等待; Terminated:终止状态，线程已经终止，因为run()方法已经执行完毕； 当线程启动后,它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换,直到最后变成Terminated状态,线程终止。 20240615192107.webp Thread thread = new Thread(); System.out.println(thread.getState());//NEW thread.start(); System.out.println(thread.getState());//RUNNABLE Thread.sleep(100); System.out.println(thread.getState());//TERMINATED public class Demo implements Runnable { public static void main(String[] args) throws InterruptedException { Runnable runnable = new Demo(); Thread t1 = new Thread(runnable); Thread t2 = new Thread(runnable); t1.start(); t2.start(); Thread.sleep(10); System.out.println(t1.getState());//Timed_Waiting，t1正在sleep(1000); System.out.println(t2.getState());//BLOCKED, t2排队等t1释放锁 Thread.sleep(1300); System.out.println(t1.getState());//WAITING，t1执行了wait() } @Override public void run() { syn(); } private synchronized void syn() { try { Thread.sleep(1000); wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } 线程方法 sleep() Sleep 不会释放锁，因此其他线程无法访问被当前线程锁住的资源 当线程在睡眠期间被中断时，应确保线程能够正确处理该中断并作出适当的响应。通常的做法是重新设置线程的中断状态 try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 重新设置中断状态 } Sleep(1000) 意思是在未来的1000毫秒内本线程不参与CPU竞争 Sleep(0)的作用是触发操作系统立刻重新进行一次CPU竞争，和yield()作用相同 竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。 wait() wait() 需要在同步代码块或同步方法中调用 会使当前线程让出持有的锁 设置了超时时间的wait方法一旦过了超时时间，并不需要其他线程执行notify也能自动解除阻塞， 没有设置超时时间的wait方法必须等待其他线程调用相同对象的 notify() 或 notifyAll() 方法来唤醒。 通知丢失（Lost Wakeup） 指一个线程发送通知（通过调用 notify() 或 notifyAll() 方法）后，等待通知的线程由于某种原因没有接收到该通知，从而导致程序进入无限等待状态 通知先于等待：如果通知在线程开始等待之前发送，等待的线程将错过这个通知，导致其进入无限等待状态。 没有使用循环检查条件：如果等待线程没有在循环中检查条件，而是直接调用 wait()，则在收到通知时，可能条件并未满足，导致线程错误地继续执行或进入无限等待。 为了避免丢失通知，wait() 通常在循环中使用。确保线程在被唤醒时重新检查条件，而不是盲目继续执行 使用 notifyAll()：在多个线程等待同一条件时，使用 notifyAll() 确保唤醒所有等待线程 class Calculator extends Thread { int total; @Override public void run() { synchronized (this){ for(int i = 0; i < 101; i++){ total += i; } this.notify(); } } } public class ReaderResult extends Thread { Calculator c; public ReaderResult(Calculator c) { this.c = c; } @Override public void run() { synchronized (c) { try { System.out.println(Thread.currentThread() + "等待计算结果..."); c.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + "计算结果为:" + c.total); } } public static void main(String[] args) { Calculator calculator = new Calculator(); //丢失通知的情况 calculator.start(); new ReaderResult(calculator).start();//线程嵌套, Thread[Thread-1,5,main]等待计算结... //不会丢失通知的情况, 交换顺序 //new ReaderResult(calculator).start(); //calculator.start(); //Thread[Thread-1,5,main]计算结果为:5050 } } public class Demo { //使用一个 Object 作为锁对象，condition 作为控制条件 private static final Object lock = new Object(); private static boolean condition = true; public static void main(String[] args) { Thread waitingThread = new Thread(new WaitingTask(), "WaitingThread"); Thread notifyingThread = new Thread(new NotifyingTask(), "NotifyingThread"); waitingThread.start(); notifyingThread.start(); } static class WaitingTask implements Runnable { @Override public void run() { synchronized (lock) { while (condition) {//在 while 循环中调用 wait() 方法，检查条件是否满足 try { System.out.println(Thread.currentThread().getName() + " is waiting."); lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + " is resumed."); } } } static class NotifyingTask implements Runnable { @Override public void run() { synchronized (lock) { condition = false; lock.notify(); System.out.println(Thread.currentThread().getName() + " has notified."); } } } } notifyAll() 在同步块内调用 notify（）方法：随机唤醒等待的某个线程； notifyAll（）方法：唤醒全部等待线程； join() 一般用于等待异步线程执行完结果之后才能继续运行的场景 A线程中执行了B.join()后, A会被阻塞直到B线程执行结束后, A再继续向下执行 阻塞行为只发生在线程 B 实际执行并且还在运行时 使用 join(long millis) 或 join(long millis, int nanos) 方法来设置超时参数, 避免无限循环或长期阻塞 public class joinTest { public static void main(String[] args) { Thread t1 = new Thread(new MyRunnable2(),"刀疤"); Thread t2 = new Thread(new MyRunnable2(),"甜甜"); Thread t3 = new Thread(new MyRunnable2(),"王爱花"); t1.start(); t2.start(); t3.start(); new Thread(new Hotel(t3),"希尔顿大酒店").start(); } } class MyRunnable2 implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+"开始出发了"); try { sleep(2000); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(Thread.currentThread().getName()+"到酒店了"); } } class Hotel implements Runnable{ Thread thread; public Hotel(Thread thread) { this.thread=thread; } @Override public void run() { System.out.println(Thread.currentThread().getName()+"正在等待大家的到来..."); try { thread.join(); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println("人齐了, "+Thread.currentThread().getName()+"的服务员开始上菜"); } } 死锁 Thread thread1 = new Thread(() -> { try { Thread.currentThread().join(); // 这将导致死锁 } catch (InterruptedException e) { e.printStackTrace(); } }); thread1.start(); public class Demo { public static void main(String[] args) { Thread thread1 = new Thread(new Task(), "Thread-1"); Thread thread2 = new Thread(new Task(), "Thread-2"); thread1.start(); thread2.start(); try { thread1.join(); // main 线程等待 thread1 结束 thread2.join(); // main 线程等待 thread2 结束 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("main 线程继续执行"); } static class Task implements Runnable { @Override public void run() { for (int i = 0; i < 5; i++) { System.out.println(Thread.currentThread().getName() + " - " + i); try { Thread.sleep(500); // 模拟一些工作 } catch (InterruptedException e) { e.printStackTrace(); } } } } } yield() yield() 方法不会释放线程持有的锁 yield() 方法用于建议线程调度器让出该线程对CPU的使用权，将执行机会交给其他具有相同优先级的线程 调度器可以选择忽略这个建议,不能依赖 yield() 方法来实现线程之间的精确调度或协作 如果没有其他线程或所有其他线程的优先级都比当前线程低，那么 yield() 方法将不会有任何效果 public class EveryTaskOnThread { public static void main(String[] args) { Thread t1 = new Thread(() -> { for(int i = 0;i<10000;i++) { System.out.println(Thread.currentThread().getName()); } },"-------t1"); Thread t2 = new Thread("t2") { @Override public void run() { for(int i = 1;i<10000;i++) { System.out.println(Thread.currentThread().getName()); Thread.yield(); } } }; t2.start(); t1.start(); } } stop() 已经被jdk废弃，原因是因为stop()方法太过于暴力，会释放对象锁，强行把执行到一半的线程终止，可能会造成数据不一致。 为了避免stop方法终断线程，我们可以采用Java线程的中断机制。 interrupt() 中断是一种协作机制, 并不能直接终止另一个线程，而需要被中断的线程自己处理。 中断标志位 isInterrupted() 判断当前线程的中断标志位是否为true，不会清除中断标志位 interrupt() 将线程的中断状态标志位设置为true，不会停止线程 如果线程处于阻塞状态（如调用了 sleep()、wait()、join(), BlockingQueue.take(),BlockingQueue.put()），会抛出 InterruptedException，并清除中断状态(重置为 false)。 如果在捕获 InterruptedException 后不重新设置中断状态标志位为 true，那么其他检查线程中断状态的代码可能无法检测到中断信号，从而导致线程在实际被中断后继续运行下去 如果你的目的是让线程在捕获到 InterruptedException 后退出循环并结束线程，使用 break 是比较直观和清晰的做法。 但如果你希望线程退出循环后还能继续执行一些其他操作，可能需要重新设置中断标志位以便后续代码能够检测到中断状态 如果线程处于非阻塞状态，会设置线程的中断状态，但不会立即中断线程，可以通过检查中断标志位得到中断信号 interrupted() 判断当前线程的中断标志位是否为true，并清除中断标志位，重置为fasle 在长时间运行的任务中，定期使用 interrupted() 检查中断状态，确保线程可以及时响应中断请求，同时清除中断状态避免重复处理 public class Demo { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { int count = 0; while (!Thread.currentThread().isInterrupted() && count < 1000) { System.out.println("count = " + count++); try { Thread.sleep(1); } catch (InterruptedException e) { Thread.currentThread().interrupt();// 重新设置中断状态 或break } } System.out.println("Stop thread"); },"t1"); t1.start(); Thread.sleep(5); t1.interrupt(); } } class SharedResource { //lock 是一个 Object 实例, 被用作同步的对象，即锁的持有者 private final Object lock = new Object(); public void waitForSignal() { //synchronized (lock) 是同步代码块的形式，表明它锁定的是 lock 对象。代码块内的所有操作都在这个锁的保护下执行 synchronized (lock) { //只有持有 lock 锁的线程才能进入这段同步代码块，其他线程在尝试进入时会被阻塞，直到锁被释放 while (true) { try { System.out.println(Thread.currentThread().getName() + " is waiting..."); lock.wait(); } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() + " was interrupted."); // 判断是否需要继续等待 if (!shouldContinueWaiting()) { System.out.println(Thread.currentThread().getName() + " decided to stop waiting."); break; } System.out.println(Thread.currentThread().getName() + " will continue waiting."); } } } } public void sendSignal() { synchronized (lock) { System.out.println(Thread.currentThread().getName() + " is sending signal..."); lock.notifyAll(); } } private boolean shouldContinueWaiting() { // 在这里可以根据条件决定是否继续等待 return true; // 返回true表示继续等待，返回false表示不再等待 } } public class Demo { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); Thread waitingThread = new Thread(() -> { sharedResource.waitForSignal(); }, "A"); Thread interruptingThread = new Thread(() -> { try { Thread.sleep(1000); // 确保A线程先进入等待状态 waitingThread.interrupt(); } catch (InterruptedException e) { e.printStackTrace(); } }, "B"); Thread signalingThread = new Thread(() -> { try { Thread.sleep(1000); // 确保中断后再发送信号 sharedResource.sendSignal(); } catch (InterruptedException e) { e.printStackTrace(); } }, "C"); waitingThread.start(); interruptingThread.start(); signalingThread.start(); } } public class IsInterruptedDemo { public static void main(String[] args) { Thread workerThread = new Thread(() -> { boolean isWorking = true; while (!Thread.currentThread().isInterrupted()) { if (isWorking) { // 模拟长时间运行的任务 for (int i = 0; i < 1000000; i++) { // 模拟工作 if (i % 100000 == 0) { System.out.println(Thread.currentThread().getName() + " is working... " + i); } // 定期检查中断状态 if (Thread.currentThread().isInterrupted()) { System.out.println(Thread.currentThread().getName() + " was interrupted during work, stopping work..."); break; } } isWorking = false; // 模拟完成工作后进入阻塞状态 } else { // 模拟阻塞操作 try { Thread.sleep(5000); // 可能抛出InterruptedException } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() + " was interrupted during sleep."); Thread.currentThread().interrupt(); // 重新设置中断状态 或 break } } } System.out.println(Thread.currentThread().getName() + " has stopped."); }, "WorkerThread"); workerThread.start(); // 主线程等待一段时间后中断工作线程 try { Thread.sleep(2000); // 主线程等待2秒 workerThread.interrupt(); // 中断工作线程 } catch (InterruptedException e) { e.printStackTrace(); } } } 线程的关闭 定义一个标志位，在线程的run方法中，不断的循环检测标志位，从而确定是否退出 使用interrupt方法 非阻塞过程中通过判断中断标志来退出 阻塞过程通过捕获中断异常后重新设置标志位或break退出循环 守护线程 用户线程 必须执行完毕，JVM 才会退出。 守护线程 当所有用户线程结束时，即使守护线程未完成也会退出, 不能用于执行一些需要完整性保证的任务，如文件写入或数据库事务 通常用于后台任务，如垃圾回收、日志记录等 Java 的垃圾回收器就是一个典型的守护线程 在调用start()方法前,调用setDaemon(true)把该线程标记为守护线程。 public class AsyncLogger { private static final BlockingQueue<String> logQueue = new LinkedBlockingQueue<>();//共享阻塞队列 private static final String logFilePath = "logs.txt"; public static void main(String[] args) { // 使用守护线程异步地将日志写入文件, 不会影响主线程的执行 Thread loggerThread = new Thread(() -> { try (BufferedWriter writer = new BufferedWriter(new FileWriter(logFilePath, true))) { while (true) { try { // 不断从一个共享队列中读取日志消息并写入文件 String log = logQueue.take(); writer.write(log); writer.newLine(); writer.flush(); } catch (InterruptedException e) { // 线程被中断，退出循环 break; } } } catch (IOException e) { e.printStackTrace(); } }); loggerThread.setDaemon(true); loggerThread.start(); // 主线程模拟主业务逻辑 for (int i = 0; i < 10; i++) { String logMessage = "Log message " + i; try { //add 方法在插入元素时，如果队列已满会抛出 IllegalStateException //put 方法在插入元素时，如果队列已满会阻塞直到空间变得可用 logQueue.put(logMessage); } catch (InterruptedException e) { throw new RuntimeException(e); } try { Thread.sleep(1000); // 模拟主线程的工作 } catch (InterruptedException e) { e.printStackTrace(); } } // 主线程结束 System.out.println("Main thread is ending..."); } } 锁的分类 排它锁(独占锁,独享锁) 共享锁,又称读锁,获得共享锁之后,可以查看但无法修改和删除数, 其它线程此时也可以获取到共享锁 共享锁和排它锁的典型是读写锁 ReentrantReadWritLock,其中读锁是共享锁,写锁是独享锁 读写锁 写锁需要等待别人释放读锁和写锁 读锁需要等别人释放写锁 要么是一个或多个线程同时有读锁,要么是一个线程有写锁,两者不会同时出现(要么多读,要么一写) 公平和非公平锁 公平锁指按照线程请求的顺序来分配锁,非公平锁指不完全按照请求的顺序在一定情况下可以插队 非公平锁利用下一个请求线程被唤醒时带来的空档期,为已经处于唤醒状态的其它线程服务, 从而提高服务吞吐量 缺点是可能产生线程饥饿(总有人来插队)而在长时间内始终得不到执行 乐观锁和悲观锁 悲观锁 如果我不锁住这个资源,别人就会来争抢,造成数据结果错误,所以在每次获取并修改数据时,把数据锁住,让别人无法访问,确保数据内容万无一失 java中的悲观锁的实现就是synchronized和Lock相关类 乐观锁 认为自己在处理操作的时候不会有其它线程来干扰,所以并不会锁住被操作对象 在更新的时候,先计算完最终数据,然后去对比在我计算的期间数据有没有被其它人改变过,如果没被改变过,就说明真的是只有我自己在操作,那我就开始去写数据,如果期间被人改变过,那我就不能写数据,选择放弃,报错,重试等策略 乐观锁的实现一般都是利用CAS算法来实现的 数据库例子 用version控制数据库就是乐观锁 添加一个字段version 更新前先查询出version值(假设查出为1) 然后update set num=100,version=version+1 where version=1 and id=10; 如果更新失败通常做法是重新读取数据并再次尝试更新，直到成功或达到最大重试次数 用select for update就是悲观锁 先读取并锁定数据，使用"SELECT id, name, email FROM user WHERE id = ? FOR UPDATE";语句锁定数据行 然后执行更新操作, "UPDATE user SET name = ?, email = ? WHERE id = ?" 自旋锁和阻塞锁 阻塞或唤醒一个java线程需要操作系统切换cpu状态来完成,这种切换需要耗费处理器时间 如果同步代码块中的内容过于简单,切换所耗费的时间可能比用户代码执行的时间还要长 在许多场景中,同步资源的锁定时间很短,为此切换线程带来的线程挂起和恢复所造成的损耗可能让系统得不偿失 如果物理机器有多个处理器,能够让两个或以上的线程同时并行执行,我们就可以让后面那个请求锁的线程不放弃cpu的执行时间,等等看持有锁的线程是否很快就会释放锁 为了让后面那个请求锁的线程稍等一下, 就需要它进行自旋,如果在自旋完成后前面锁定资源的线程已经释放了锁,那么就可以不必阻塞而是直接获取同步资源,从而避免切换线程产生的开销,这就是自旋锁 如果锁被占用的时间很长,那么自旋的线程只会白白浪费处理器资源 可重入锁和非可重入锁 可重入可以避免死锁 允许同一个线程多次获得同一个锁而不会造成死锁 如果一个线程已经持有一个锁，它可以再次获得这个锁，而不会被阻塞,由于一个线程可以多次获得锁，所以它可以避免在复杂的同步场景中出现死锁 可中断锁和不可中断锁 Lock和synchronized Lock接口最常见的实现类是ReentrantLock Lock主要方法 lock() 如果锁已被其他线程获取,则进行等待 不会像synchronized一样在异常时自动释放锁 需要在finally中释放锁,以保证发生异常时锁一定被释放 lock()方法不能被中断,这会带来死锁永久等待 tryLock() 尝试获取锁,如果当前锁没有被其他线程占用,则获取成功返回true, 否则代表获取锁失败返回false 相比于lock(), 它可以根据是否能获取到锁来决定后续程序的行为 该方法会立即返回,即便在拿不到锁时不会一直在那里等待 tryLock(long time,TimeUnit unit) 超时就放弃 lockInterruptibly() 超时时间无限.在等待过程中可以随时被中断 unlock() 解锁 Lock必须使用lock(),unlock来显式加解锁 可以判断当前锁是否被占用,如果不想等待可以退出 异常时不会自动释放锁 synchronized可以用在方法和同步代码块上隐式自动加解锁 如果没有拿到锁只能等待 异常时自动释放锁 早期两者间synchronized性能较低,java6之后差异较小 两者都是可重入的 如果一个线程已经持有一个锁，它可以再次获得这个锁，而不会被阻塞 // f1() 和 f2() 方法都被 synchronized 修饰。这意味着这两个方法都使用了同一个对象作为锁 // 当 new LockTest().f1(); 被调用时，主线程将会获得 LockTest 实例的锁，并进入 f1() 方法。 // f1() 方法内部调用 f2()，因为 f2() 也是 synchronized 的，主线程必须再次获得 LockTest 实例的锁才能执行 f2() 方法。 public class LockTest { public synchronized void f1(){ System.out.println("f1()"); f2(); } public synchronized void f2(){ System.out.println("f2()"); } public static void main(String[] args) { new LockTest().f1(); } } synchronized 使用以下两种类型的锁 对象实例锁 当 synchronized 修饰一个实例方法时，它会使用当前对象实例作为锁。每个对象都有一个关联的监视器，只有获取了该监视器的线程才能执行 synchronized 修饰的代码 类对象锁 当 synchronized 修饰一个静态方法或代码块时，它会使用该类的 Class 对象作为锁。每个类只有一个 Class 对象，静态方法的同步是基于该类的 Class 对象的监视器 synchronized 窗口卖票 class MyRunnable implements Runnable { private static int ticketCount = 100; private static int one; private static int two; @Override public void run() { while (true) { if("窗口一".equals(Thread.currentThread().getName())){ //同步代码块 synchronized (MyRunnable.class){ if(ticketCount == 0){ break; }else{ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } ticketCount--; one++; System.out.println(Thread.currentThread().getName() + "卖了"+one+"张票,还剩下" + ticketCount + "张票"); } } } if("窗口二".equals(Thread.currentThread().getName())){ //同步代码块 synchronized (MyRunnable.class){ if(ticketCount == 0){ break; }else{ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } ticketCount--; two++; System.out.println(Thread.currentThread().getName() + "卖了"+two+"张票,还剩下" + ticketCount + "张票"); } } } } } } public class Demo { public static void main(String[] args) { MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr,"窗口一"); Thread t2 = new Thread(mr,"窗口二"); t1.start(); t2.start(); } } synchronized 一个生产者一个消费者 class Desk { public static boolean flag = false; public static int count = 5; public static final Desk lock = new Desk(); } class Cooker implements Runnable { @Override public void run() { while(true){ synchronized (Desk.lock){ if(Desk.count == 0){ break; }else{ if(!Desk.flag){ System.out.println("厨师煎好了一份牛排"); Desk.count--; Desk.flag = true; //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. Desk.lock.notifyAll(); }else{ try { Desk.lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } System.out.println("没有食材了"); } } class Foodie implements Runnable { @Override public void run() { while(true){ synchronized (Desk.lock){ if(Desk.count == 0){ break; }else{ if(Desk.flag){ System.out.println("顾客吃掉一份牛排"); Desk.flag = false; Desk.lock.notifyAll(); }else{ try { Desk.lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } } } public class Demo { public static void main(String[] args) { Thread f = new Thread(new Foodie()); Thread c = new Thread(new Cooker()); f.start(); c.start(); } } synchronized 一个生产者多个消费者 class Queue { private int n; boolean flag = false; public synchronized int getN() { //当线程A在getN方法中执行wait时，它会释放锁并等待。 //线程B获得锁，进入getN方法，并调用notifyAll，唤醒线程A和其他所有等待的线程。 //线程被唤醒并不意味着它立即可以继续执行。唤醒的线程必须重新竞争获得该对象的锁，才能从wait方法返回并继续执行 //如果使用的是if而不是while，被唤醒的线程不会再次检查条件，因此会出现多个消费者同时消费同一个产品。 while (!flag) {//使用while而不是if try { wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } System.out.println(Thread.currentThread().getName()+"消费: "+n); flag = false;//消费完毕,容器中已经没有数据 notifyAll(); return n; } public synchronized void setN(int n) { while (flag) {//使用while而不是if try { wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } System.out.println(Thread.currentThread().getName()+"生产: "+n); this.n = n; flag = true;//生产完毕,容器中已经有数据 notifyAll(); } } class Producer implements Runnable{ Queue queue; Producer(Queue queue) { this.queue=queue; } @Override public void run() { int n = 0; while (true) { queue.setN(n++); try { Thread.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } class Consumer implements Runnable{ Queue queue; Consumer(Queue queue) { this.queue= queue; } @Override public void run() { while (true) { queue.getN(); try { Thread.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Test { public static void main(String[] args) { Queue queue = new Queue(); Thread a = new Thread(new Producer(queue),"a"); Thread b = new Thread(new Consumer(queue),"b"); Thread b2 = new Thread(new Consumer(queue),"b2"); Thread b3 = new Thread(new Consumer(queue),"b3"); a.start(); b.start(); b2.start(); b3.start(); } } 死锁 两个或更多线程或进程相互持有对方所需要的资源,又不主动释放,导致所有人都无法继续前进 public class Demo { public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -> { synchronized (o1) { System.out.println("Thread 1: Locked o1"); try { Thread.sleep(50); } catch (InterruptedException e) { } synchronized (o2) { System.out.println("Thread 1: Locked o2"); } } }); Thread t2 = new Thread(() -> { synchronized (o2) { System.out.println("Thread 2: Locked o2"); try { Thread.sleep(50); } catch (InterruptedException e) { } synchronized (o1) { System.out.println("Thread 2: Locked o1"); } } }); t1.start(); t2.start(); } } 避免死锁 设置超时时间 Lock的tryLock(long timeout,TimeUnit unit) synchronized不具备尝试锁的能力,如果拿不到会一直等待 获取锁失败时可以打日志,发报警邮件,重启等,将可能发生的大事故缩小为一个小事故(获取不到锁) 多使用并发类而不是自己设计锁 尽量降低锁的范围,例如使用同步代码块而不是同步方法 给线程起个有意义的名字利于排查 public class TryLockDeadlock implements Runnable { int flag = 1; static Lock lock1 = new ReentrantLock(); static Lock lock2 = new ReentrantLock(); static int sharedResource = 0; // 全局变量 public static void main(String[] args) { TryLockDeadlock r1 = new TryLockDeadlock(); TryLockDeadlock r2 = new TryLockDeadlock(); r1.flag = 1; r2.flag = 0; new Thread(r1, "t1").start(); new Thread(r2, "t2").start(); } @Override public void run() { for (int i = 0; i < 100; i++) { if (flag == 1) { try { if (lock1.tryLock(800, TimeUnit.MILLISECONDS)) { System.out.println(Thread.currentThread().getName() + " 获取到了锁1"); Thread.sleep(new Random().nextInt(1000)); // 模拟一些操作 if (lock2.tryLock(800, TimeUnit.MILLISECONDS)) { try { System.out.println(Thread.currentThread().getName() + " 获取到了锁2"); sharedResource++; System.out.println(Thread.currentThread().getName() + " 成功获取到了两把锁, 并修改了共享资源，当前值: " + sharedResource); break; } finally { lock2.unlock(); lock1.unlock(); } } else { System.out.println(Thread.currentThread().getName() + " 尝试获取锁2失败，正在重试"); lock1.unlock(); Thread.sleep(new Random().nextInt(1000)); // 模拟一些操作 } } else { System.out.println(Thread.currentThread().getName() + " 获取锁1失败，正在重试"); } } catch (InterruptedException e) { e.printStackTrace(); } } else if (flag == 0) { try { if (lock2.tryLock(3000, TimeUnit.MILLISECONDS)) { System.out.println(Thread.currentThread().getName() + " 获取到了锁2"); Thread.sleep(new Random().nextInt(1000)); // 模拟一些操作 if (lock1.tryLock(3000, TimeUnit.MILLISECONDS)) { try { System.out.println(Thread.currentThread().getName() + " 获取到了锁1"); sharedResource++; System.out.println(Thread.currentThread().getName() + " 成功获取到了两把锁, 并修改了共享资源，当前值: " + sharedResource); break; } finally { lock1.unlock(); lock2.unlock(); } } else { System.out.println(Thread.currentThread().getName() + " 尝试获取锁1失败，正在重试"); lock2.unlock(); Thread.sleep(new Random().nextInt(1000)); // 模拟一些操作 } } else { System.out.println(Thread.currentThread().getName() + " 获取锁2失败，正在重试"); } } catch (InterruptedException e) { e.printStackTrace(); } } } } } AtomicInteger AtomicInteger 是 Java 提供的一个线程安全的整数类，位于 java.util.concurrent.atomic 包中。它提供了一些原子操作，这些操作都是线程安全的，不需要使用同步块或锁。 get()：获取当前的值。 set(int newValue)：设置新的值。 getAndSet(int newValue)：获取当前的值，并设置新的值。 incrementAndGet()：以原子方式将当前值加 1，并返回加 1 后的值。 getAndIncrement()：以原子方式将当前值加 1，并返回加 1 前的值。 decrementAndGet()：以原子方式将当前值减 1，并返回减 1 后的值。 getAndDecrement()：以原子方式将当前值减 1，并返回减 1 前的值。 addAndGet(int delta)：以原子方式将当前值增加指定的值，并返回更新后的值。 getAndAdd(int delta)：以原子方式将当前值增加指定的值，并返回更新前的值。 compareAndSet(int expect, int update)：如果当前值等于预期值，则以原子方式将该值设置为更新值。 public class AtomicIntegerExample { public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(0); // 创建多个线程进行操作 Thread t1 = new Thread(() -> { for (int i = 0; i < 1000; i++) { atomicInteger.incrementAndGet(); } }); Thread t2 = new Thread(() -> { for (int i = 0; i < 1000; i++) { atomicInteger.incrementAndGet(); } }); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("Final value: " + atomicInteger.get());//2000 } } Semaphore Semaphore(信号) 用于控制同时访问特定资源的线程数量，确保资源不被过度使用 该类通过指定许可证的数量来控制同时访问共享资源的线程数，超过许可证数量的线程必须等待其他线程释放许可证后才能继续执行 Semaphore(int permits)：创建具有给定许可数的信号量。 Semaphore(int permits, boolean fair)：创建具有给定许可数和给定公平性设置的信号量。 公平模式确保线程按照请求资源的顺序获取资源，即先请求资源的线程会先获取到资源 非公平模式则不保证线程按照请求顺序获取资源，这种模式通常会有更高的吞吐量，因为它减少了线程切换的开销,可能会导致某些线程长时间等待（线程饥饿） acquire()：获取一个许可，如果没有可用的许可，则会一直等待。 acquire(int permits)：获取指定数量的许可。 控制并发数量。例如，你有一个池（连接池、线程池等），希望一次只能有固定数量的线程可以访问该池 tryAcquire()：尝试获取一个许可，立即返回 true 或 false。 tryAcquire(int permits)：尝试获取指定数量的许可，立即返回 true 或 false。 release()：释放一个许可。 release(int permits)：释放指定数量的许可。 availablePermits()：返回当前可用的许可数。 public class SemaphoreExample { public static void main(String[] args) { Semaphore semaphore = new Semaphore(3); for (int i = 0; i < 10; i++) { new Thread(new Worker(semaphore, "Worker-" + i)).start(); } } } class Worker implements Runnable { private final Semaphore semaphore; private final String name; public Worker(Semaphore semaphore, String name) { this.semaphore = semaphore; this.name = name; } @Override public void run() { try { System.out.println(name + " trying to acquire permit."); semaphore.acquire();//获取一个许可，如果没有可用的许可，则会一直等待 System.out.println(name + " acquired permit."); Thread.sleep(2000);// 模拟工作 System.out.println(name + " releasing permit."); semaphore.release();//释放一个许可 } catch (InterruptedException e) { e.printStackTrace(); } } } BlockingQueue 用于实现线程安全的阻塞队列 ArrayBlockingQueue: 底层是数组,有界 LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值 put(anObject): 将参数放入队列,如果放不进去会阻塞 take(): 取出第一个数据,取不到会阻塞 BlockingQueue 一个生产者一个消费者 class Producer implements Runnable { private BlockingQueue<String> queue; public Producer(BlockingQueue<String> queue){ this.queue=queue; } @Override public void run() { for(int i=0; i<=100; i++){ String msg = String.valueOf(i); try { queue.put(msg); System.out.println("Produced "+msg); } catch (InterruptedException e) { e.printStackTrace(); } } try { queue.put("exit");//一直到100个数据消费完后 } catch (InterruptedException e) { e.printStackTrace(); } } } class Consumer implements Runnable{ private BlockingQueue<String> queue; public Consumer(BlockingQueue<String> queue){ this.queue=queue; } @Override public void run() { try{ String msg; while(!(msg = queue.take()).equals("exit")){ System.out.println("Consumed "+msg); } }catch(InterruptedException e) { e.printStackTrace(); } } } public class ProduceConsumeDemo { public static void main(String[] args) { BlockingQueue<String> queue = new ArrayBlockingQueue<>(1); Producer producer = new Producer(queue); Consumer consumer = new Consumer(queue); new Thread(producer).start(); new Thread(consumer).start(); System.out.println("Producer and Consumer has been started"); } } BlockingQueue 多个生产者多个消费者 class Queue { private BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10); public void put(int n) throws InterruptedException { queue.put(n); System.out.println(Thread.currentThread().getName() + " 生产: " + n); } public int take() throws InterruptedException { int n = queue.take(); System.out.println(Thread.currentThread().getName() + " 消费: " + n); return n; } } class Producer implements Runnable { private static AtomicInteger idGenerator = new AtomicInteger(0); // 原子整型,产品ID生成器 private Queue queue; Producer(Queue queue) { this.queue = queue; } @Override public void run() { while (true) { try { int id = idGenerator.incrementAndGet(); // 获取唯一产品ID queue.put(id); Thread.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } class Consumer implements Runnable { private Queue queue; Consumer(Queue queue) { this.queue = queue; } @Override public void run() { while (true) { try { queue.take(); Thread.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Test { public static void main(String[] args) { Queue queue = new Queue(); Thread p1 = new Thread(new Producer(queue), "生产者1"); Thread p2 = new Thread(new Producer(queue), "生产者2"); Thread c1 = new Thread(new Consumer(queue), "消费者1"); Thread c2 = new Thread(new Consumer(queue), "消费者2"); Thread c3 = new Thread(new Consumer(queue), "消费者3"); p1.start(); p2.start(); c1.start(); c2.start(); c3.start(); } } 线程池 假如创建线程用的时间为T1，执行任务用的时间为T2,销毁线程用的时间为T3，那么使用线程池就免去了T1和T3的时间； 服务器接收到大量请求时使用线程池技术是非常合适的,它可以大大减少线程的创建和销毁次数,提高服务器的工作效率 实际开发中如果需要创建5个以上的线程,那么就可以使用线程池来管理 线程复用 核心线程是线程池中最基本的线程数量。这些线程在没有任务执行时，默认情况下会一直存活，不会被终止。 核心线程在处理完一个任务后，会继续从任务队列中取新的任务来执行 当线程池中的任务数量超过核心线程数时，线程池会创建非核心线程来处理多余的任务 这些非核心线程只要没有超出其空闲存活时间同样会被复用来处理新提交的任务。 过程 初始化 创建一个固定数量的核心线程并将它们设置为等待任务状态。 任务分发 当有新任务提交时，线程池会从工作队列中取出任务分发给空闲线程。 任务执行 空闲线程接收到任务后开始执行任务的run方法。 复用线程 任务执行完毕后，线程不会退出，而是回到等待任务状态，准备处理下一个任务。 构造方法 public class ThreadPoolExample { public static void main(String[] args) { // 示例1：使用基本的构造方法 ThreadPoolExecutor executor1 = new ThreadPoolExecutor( 2, // 核心线程数 4, // 最大线程数 10L, // 线程空闲时间 TimeUnit.SECONDS, // 时间单位 new LinkedBlockingQueue<>() // 工作队列 ); // 示例2：使用包含线程工厂的构造方法 ThreadFactory threadFactory = Executors.defaultThreadFactory(); ThreadPoolExecutor executor2 = new ThreadPoolExecutor( 2, 4, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), threadFactory // 线程工厂 ); // 示例3：使用包含拒绝策略的构造方法 RejectedExecutionHandler rejectionHandler = new ThreadPoolExecutor.AbortPolicy(); ThreadPoolExecutor executor3 = new ThreadPoolExecutor( 2, 4, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), rejectionHandler // 拒绝策略 ); // 示例4：使用包含线程工厂和拒绝策略的构造方法 ThreadPoolExecutor executor4 = new ThreadPoolExecutor( 2, 4, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), threadFactory, // 线程工厂 rejectionHandler // 拒绝策略 ); // 提交任务给线程池 for (int i = 0; i < 10; i++) { final int taskNumber = i; executor1.submit(() -> { System.out.println("Executing task " + taskNumber + " with thread " + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }); } // 关闭线程池 executor1.shutdown(); executor2.shutdown(); executor3.shutdown(); executor4.shutdown(); } } 拒绝策略 AbortPolicy（默认策略）： 抛出 RejectedExecutionException，通知调用者任务被拒绝。 CallerRunsPolicy： 当线程池已经关闭或者线程池中的任务数量达到最大限制，且任务队列已满时，CallerRunsPolicy 会将任务交给提交任务的线程来执行。 这样可以有效地限制任务的提交速度，避免线程池过载，同时确保任务不会被丢弃。 DiscardPolicy： 简单地丢弃无法处理的新任务，不做任何处理。 DiscardOldestPolicy： 丢弃任务队列中最旧的未处理任务，然后尝试重新提交新任务。 线程工厂 可以使用 ThreadFactory 来创建具有特定名称、优先级、守护状态等属性的线程 public class CustomThreadFactory implements ThreadFactory { private final String namePrefix; private final AtomicInteger threadNumber = new AtomicInteger(1); //线程组: 允许将线程组织在一起集中管理, 如集体中断 private final ThreadGroup group; public CustomThreadFactory(String namePrefix) { this.namePrefix = namePrefix; this.group = Thread.currentThread().getThreadGroup(); } @Override public Thread newThread(Runnable r) { //new Thread(ThreadGroup group, Runnable target, String name, long stackSize) //stackSize线程的栈大小,值为 0 表示使用默认栈大小 Thread t = new Thread(group, r, namePrefix + "-Thread-" + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) { //确保线程在执行完任务之前不会被 JVM 强制结束 t.setDaemon(false); } if (t.getPriority() != Thread.NORM_PRIORITY) { //确保线程使用一致的优先级，避免优先级不一致带来的潜在问题 t.setPriority(Thread.NORM_PRIORITY); } return t; } } ThreadPoolExecutor executor2 = new ThreadPoolExecutor( 2, 4, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), new CustomThreadFactory("MyPool") ); 线程组 ThreadGroup group = new ThreadGroup("MyThreadGroup"); // String groupName = group.getName(); Thread t1 = new Thread(group, () -> { while (!Thread.currentThread().isInterrupted()) { // 线程工作 } }, "Thread-1"); Thread t2 = new Thread(group, () -> { while (!Thread.currentThread().isInterrupted()) { // 线程工作 } }, "Thread-2"); t1.start(); t2.start(); // 中断线程组中的所有线程 group.interrupt(); 核心线程数和最大线程数 corePoolSize 线程池完成初始化后,默认情况下池中没有任何线程,会等待有任务到来时,再创建新线程执行任务, 之后核心线程数会一直存活不会减少数量,即使没有任何新任务 maxPoolSize 核心线程数+非核心线程 线程池的行为 corePoolSize = 2 maximumPoolSize = 5 new ArrayBlockingQueue<>(3) 假设提交了 10 个任务到这个线程池，以下是线程池的行为： 第1,2个任务交给核心线程执行 第3,4,5个任务加入任务队列 第6,7,8个任务因为队列已满，因此会创建额外3个非核心线程来处理它们。此时，线程池中的总线程数增加到 5（2 个核心线程 + 3 个非核心线程） 假设第9,10个任务到来时，所有线程（包括核心线程和非核心线程）仍在忙碌，队列中任务仍为3 因为总线程数已经达到 maximumPoolSize（5）,任务队列已满，在这种情况下第9,10个任务如何处理取决于线程池的拒绝策略 在某些情况下，如果队列中的任务还在等待，而新的任务导致创建了新的非核心线程，新任务可能会比队列中的任务更早完成 一种解决方法是使用较大的任务队列，这样即使有更多的任务提交，所有的任务都可以先进入队列，然后按顺序执行。 另一种解决方法是使用自定义的拒绝策略来控制任务的提交顺序。 任务队列 ArrayBlockingQueue 有界队列，固定容量先进先出, 使用一个锁来控制插入和删除操作（单锁） maximumPoolSize参数在使用有界队列时才具有实际意义 因为在无界队列的情况下，任务可以无限制地被添加到队列中，不会触发创建额外的非核心线程 LinkedBlockingQueue 可以指定容量，也可以使用默认的无界容量(int的最大值) 使用两个独立的锁来控制插入和删除操作（分段锁）,插入和删除操作可以并行执行 SynchronousQueue 一种特殊的同步阻塞队列, 因为没有内部容量所以提供了高效的线程间数据交换(没有任务缓冲区，任务提交后必须立即由工作线程执行), 典型应用包括高性能线程池和实时数据传输 每一个 put 操作必须阻塞等待一个 take 操作，反之亦然。换句话说，生产者线程和消费者线程必须直接进行数据交换 当使用 SynchronousQueue 时，通常需要设置较大的核心线程数, 确保提交的任务能够及时被线程执行，不会因为缺少线程而导致任务被阻塞 虽然 SynchronousQueue 没有容量，但 maximumPoolSize 仍然控制线程池中可以同时存在的最大线程数量。 每个新任务的提交都可能导致创建一个新的线程，直到达到 maximumPoolSize, 这样能够更好地处理突发的高并发任务 public class ThreadPoolWithSynchronousQueue { public static void main(String[] args) { ExecutorService executor = new ThreadPoolExecutor( 2, 4, 60, TimeUnit.SECONDS, new SynchronousQueue<>(), new ThreadPoolExecutor.CallerRunsPolicy() //如果所有工作线程都忙，将任务交给提交任务的线程来执行 ); for (int i = 0; i < 10; i++) { final int index = i; executor.submit(() -> { System.out.println("Task " + index + " is running by " + Thread.currentThread().getName()); try { Thread.sleep(1000); // 模拟任务执行时间 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } executor.shutdown(); } } /* Task 0 is running by pool-1-thread-1 Task 2 is running by pool-1-thread-3 Task 4 is running by main Task 1 is running by pool-1-thread-2 Task 3 is running by pool-1-thread-4 Task 5 is running by main Task 6 is running by pool-1-thread-3 Task 7 is running by pool-1-thread-1 Task 8 is running by pool-1-thread-4 Task 9 is running by pool-1-thread-2 */ submit 和 execute 两者区别在于如何处理它们的返回值和异常 execute 没有返回值，只能提交 Runnable 任务 提交的任务在执行过程中抛出的异常不会被返回给调用者 submit 方法是 ExecutorService 接口中定义的 有返回值，可以提交 Runnable 和 Callable 任务，并返回一个 Future 对象 提交的任务在执行过程中抛出的异常可以通过返回的 Future 对象获取 JDK封装好的线程池 :corePoolSize:maxPoolSize:队列类型:空闲时间:拒绝策略 Fixed Thread Pool:nThreads:同左:LinkedBlockingQueue (无限):0:AbortPolicy Single Thread Executor:1:1:LinkedBlockingQueue (无限):0:AbortPolicy Cached Thread Pool:0:Integer.MAX_VALUE:SynchronousQueue:60 秒:AbortPolicy Scheduled Thread Pool:corePoolSize:Integer.MAX_VALUE:DelayedWorkQueue:0:AbortPolicy Single Thread Scheduled Executor:1:Integer.MAX_VALUE:DelayedWorkQueue:0:AbortPolicy //适合处理执行时间较长的任务，可以充分利用多线程并发执行的优势 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(1); //等效于newFixedThreadPool(1) //适用于需要顺序执行任务且避免多线程竞争条件的场景,例如日志记录、文件写入等 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); //核心线程数为0, 线程最大数量Integer.MAX_VALUE,空闲60秒回收 //可能会创建数量非常多的线程,导致OOM //适合并发执行许多短期任务和动态负载的场景 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); //适用于需要多个并发定时任务的场景 ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10); //延时5秒执行 //threadPool.schedule(new Task(), 5, TimeUnit.SECONDS); //scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);延时1秒后执行, 之后每间隔3秒执行一次 threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS); //schedule(Runnable command, long initialDelay, TimeUnit unit)延后执行,仅执行一次 //等效于Executors.newScheduledThreadPool(1) //适用于需要串行顺序执行定时任务的场景 ScheduledExecutorService threadPool2 = Executors.newSingleThreadScheduledExecutor(); ThreadPoolExecutor实例化方式 ExecutorService executor = new ThreadPoolExecutor(...) ThreadPoolExecutor executor = new ThreadPoolExecutor(...) ThreadPoolExecutor是ExecutorService接口的实现类 ExecutorService executor = new ThreadPoolExecutor( 5, 10, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>() ); // 只能使用ExecutorService接口中定义的方法 executor.submit(new RunnableTask()); executor.shutdown(); // 如果需要使用ThreadPoolExecutor特有的方法，需要进行类型转换 if (executor instanceof ThreadPoolExecutor) { ((ThreadPoolExecutor) executor).setCorePoolSize(7); } 自定义线程池 CPU密集型任务 如果任务主要消耗 CPU 资源，如数学计算、数据处理等，线程池的大小应接近于可用的 CPU 核心数 推荐线程池大小：线程池大小 = CPU核心数 + 1 I/O密集型任务 如果任务主要进行 I/O 操作，如文件读写、网络通信等，线程池可以设置为更大的数量，因为 I/O 操作会导致线程等待。 推荐线程池大小：线程池大小 = CPU核心数 * 2 或更多，具体数量应根据 I/O 等待时间和 CPU 使用率进行调整。 混合型任务 如果任务既有 CPU 密集型操作又有 I/O 密集型操作，可以根据两种任务的比例来调整线程池大小。 public class ThreadPoolExample { public static void main(String[] args) { // 获取可用的CPU核心数 int cpuCores = Runtime.getRuntime().availableProcessors(); // 根据任务类型设置线程池大小 int poolSize = cpuCores * 2; // 假设是I/O密集型任务 // 创建线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor( poolSize, // corePoolSize poolSize, // maximumPoolSize 60, // keepAliveTime TimeUnit.SECONDS, // unit new LinkedBlockingQueue<>() // workQueue ); // 提交任务 for (int i = 0; i < 10; i++) { executor.submit(new Task()); } // 关闭线程池 executor.shutdown(); } static class Task implements Runnable { @Override public void run() { try { // 模拟I/O操作 Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + " is working..."); } catch (InterruptedException e) { e.printStackTrace(); } } } } 20240531140712.webp 暂停和恢复线程池 使用场景 后台任务调度 在许多应用中，后台任务需要定期运行，但在某些情况下（例如系统维护或高峰负载时期）可能需要暂停这些任务。 数据处理 在数据处理流水线中，例如数据清洗、转换、和加载（ETL）流程中，某些任务可能需要暂停以等待上游数据源的更新或下游系统的准备 资源管理 当系统资源（如数据库连接、文件句柄）紧张时，可以暂停部分任务以等待资源变得可用。这样可以避免资源过度消耗和系统崩溃。 系统维护 在进行系统维护时，通常需要暂停某些非关键任务。使用可暂停的线程池可以方便地暂停和恢复这些任务，而不需要完全停止线程池。 任务优先级处理 在一些情况下，某些任务的优先级可能较低，系统需要在处理高优先级任务时暂停低优先级任务。 ThreadPoolExecutor 并不自带此功能，需要自行扩展, 例如通过 ReentrantLock 和 Condition 来控制线程池任务的暂停和恢复 public class PausableThreadPoolExecutor extends ThreadPoolExecutor { private boolean isPaused; //ReentrantLock 提供了更细粒度的锁机制，并且可以通过 newCondition() 方法创建条件对象。 //Condition 对象允许线程等待特定条件（await和signalAll类似于对象监视器的 wait 和 notify 方法） private final ReentrantLock lock = new ReentrantLock(); private final Condition condition = lock.newCondition(); public PausableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); // 获取 lock 对象的锁后，可以向下进入try块, 如果其他线程已经持有这个锁，当前线程将会被阻塞在try块之前，直到锁被释放 lock.lock(); try { while (isPaused) condition.await(); } catch (InterruptedException ie) { t.interrupt(); } finally { lock.unlock(); } } public void pause() { lock.lock(); try { isPaused = true; } finally { lock.unlock(); } } public void resume() { lock.lock(); try { isPaused = false; condition.signalAll(); } finally { lock.unlock(); } } public static void main(String[] args) throws InterruptedException { PausableThreadPoolExecutor executor = new PausableThreadPoolExecutor(2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>()); for (int i = 0; i < 10; i++) { final int index = i; executor.execute(() -> { System.out.println("Task " + index + " is running"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println("Task " + index + " is completed"); }); } Thread.sleep(3000); System.out.println("Pausing thread pool"); executor.pause(); Thread.sleep(6000); System.out.println("Resuming thread pool"); executor.resume(); executor.shutdown(); } } 线程池的关闭 shutdown() 不是立即关闭所有线程, 而是自此不再接收新任务, 继续处理完当前的任务和原队列中存在的任务 shutdownNow() 尝试停止(触发中断)所有正在执行的任务，并不再处理等待队列中的任务 返回值是一个未执行的任务列表 List<Runnable> runnablerlist = executorService.shutdownNow(); isShutdown() 判断shutdown()是否被调用了 isTerminated() 判断所有任务是否都已经执行完毕且所有线程都已经关闭 awaitTerminate(3L,TimeUnit.SECONDS); 如果所有任务在这个时间段内完成，那么方法会立即返回 true 该方法会阻塞调用它的线程，直到以下三个条件中的任何一个满足： 所有提交的任务都已完成执行（无论是正常完成还是异常终止）。 超时时间过去。 当前线程被中断。 通常在调用 shutdown 或 shutdownNow 方法之后使用，以确保线程池中的任务都已经执行完毕。 如果没有调用 shutdown 或 shutdownNow，awaitTermination 将永远等待，因为线程池还在接受新任务。 线程池状态监视 public class ThreadPoolMonitor { private final ThreadPoolExecutor threadPool; private final ScheduledExecutorService scheduler; //创建一个单线程调度线程池 public ThreadPoolMonitor(ThreadPoolExecutor threadPool, int monitoringInterval) { this.threadPool = threadPool; this.scheduler = Executors.newSingleThreadScheduledExecutor(); this.scheduler.scheduleAtFixedRate(this::printThreadPoolStatus, 0, monitoringInterval, TimeUnit.SECONDS); } private void printThreadPoolStatus() { System.out.println("========== ThreadPool Status =========="); System.out.println("Core Pool Size: " + threadPool.getCorePoolSize()); System.out.println("Maximum Pool Size: " + threadPool.getMaximumPoolSize()); System.out.println("Current Pool Size: " + threadPool.getPoolSize()); System.out.println("Active Threads: " + threadPool.getActiveCount()); System.out.println("Completed Tasks: " + threadPool.getCompletedTaskCount()); System.out.println("Total Tasks: " + threadPool.getTaskCount()); System.out.println("Queue Size: " + threadPool.getQueue().size()); System.out.println("========================================"); } public void shutdown() { scheduler.shutdown(); try { if (!scheduler.awaitTermination(1, TimeUnit.SECONDS)) { scheduler.shutdownNow(); } } catch (InterruptedException e) { scheduler.shutdownNow(); Thread.currentThread().interrupt(); } } public static void main(String[] args) throws InterruptedException { ThreadPoolExecutor threadPool = new ThreadPoolExecutor( 2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>()); // 开始3秒一次的调度任务 // 实例化 ThreadPoolMonitor 对象后，调度任务会自动开始运行。这是因为调度任务的设置是在构造函数中完成的，scheduleAtFixedRate 方法会在创建 ThreadPoolMonitor 对象时立即启动任务调度 ThreadPoolMonitor monitor = new ThreadPoolMonitor(threadPool, 3); for (int i = 0; i < 10; i++) { threadPool.submit(() -> { try { Thread.sleep(2000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } Thread.sleep(30000);// 给时间让所有任务完成 threadPool.shutdown(); monitor.shutdown();// 关闭调度线程池 } } 使用注意 避免任务堆积(队列过大) 避免线程数过度增加(CacheThreadPool) 排查线程泄漏(统计线程数量,无法回收,无法结束) ThreadLocal 20240601095501.webp 用于解决多线程环境中的共享变量问题, 可以存储独立于其他线程的数据, 主要是在需要线程隔离的场景，如线程池中的线程共享用户上下文 在多个线程中各自保存一份独立的变量副本, 每个线程对该变量的访问和修改互不影响 在高并发环境下，ThreadLocal 提供线程安全的变量访问和操作，性能优于通过锁机制实现的共享变量 方法 get(): 返回当前线程的变量副本。 set(T value): 设置当前线程的变量副本的值。 remove(): 删除当前线程的变量副本，减少内存泄漏的风险。 withInitial(Supplier): 静态工厂方法，接受一个 Supplier 函数来初始化 ThreadLocal 变量（Java 8 引入）。 initialValue(): 可重写的方法，用于提供变量的初始值（Java 8 之前常用） 未被重写时默认返回 nul作为初始值 每个线程访问 ThreadLocal 变量时, 都只会调用一次 initialValue() 方法, 以确保每个线程都有自己的初始值。之后，该线程对该 ThreadLocal 变量的访问将使用它自己的副本，而不是重新调用 initialValue() 方法。 当一个线程结束后，使用 remove() 方法显式地清除 ThreadLocal 变量, 防止内存泄漏 每次在调用 ThreadLocal.remove() 方法之后，如果再次调用 ThreadLocal.get() 方法，会重新调用 initialValue() 方法为当前线程提供一个新的初始值。 value的泄漏 20240601103733.webp 在 Java 中，所有普通的对象引用都是强引用。 一个对象只要有强引用存在，垃圾回收器就不会回收这个对象 弱引用不会阻止垃圾回收器回收被引用的对象。如果一个对象只被弱引用引用，那么当垃圾回收器运行时，这个对象会被回收 ThreadLocalMap的每个Entry包含一个对key的弱引用,和一个对value的强引用 Entry类继承自WeakReference[ThreadLocal[?]]，表示 Entry 的键是一个 ThreadLocal 对象的弱引用 Entry的值Object v是一个强引用 正常情况下,当线程终止,ThreadLocal里的value会被垃圾回收,因为没有强引用了 但是如果线程不终止或需要保持很久(如使用线程池时的核心线程), 那么作为弱引用的key被回收后对应的value却不能被回收(因为 value 仍然被 ThreadLocalMap.Entry 强引用), 如果没有显式地清除这些 ThreadLocal 变量，随着时间的推移，会导致内存泄漏(某个不对象不再有用,但是占用的内存却不能被回收)，最终可能导致 OutOfMemoryError（OOM）。 显式清除 ThreadLocal 变量： 在不再需要使用 ThreadLocal 变量时，显式调用 remove() 方法清除。 使用 try-finally 块确保清除： 使用 try-finally 块确保在任务完成后清除 ThreadLocal 变量。 使用拦截器（Interceptor）来管理 ThreadLocal 变量是一个非常有效的方法，特别是在使用 Web 框架（如 Spring MVC）或其他支持拦截器的框架时。 通过拦截器，可以确保在每次请求处理完成后清除 ThreadLocal 变量，从而防止内存泄漏。 用户身份验证和会话信息 在 Web 应用程序中，可以使用 ThreadLocal 来存储当前用户的身份验证信息或会话信息。这样可以确保每个线程处理的请求都能安全地访问到正确的用户信息，而不需要在方法之间传递这些信息。 public class UserContext { private static final ThreadLocal<User> userThreadLocal = ThreadLocal.withInitial(() -> null); public static void setUser(User user) { userThreadLocal.set(user); } public static User getUser() { return userThreadLocal.get(); } public static void clear() { userThreadLocal.remove(); } } 简化线程安全的格式化器 例如，日期格式化器 (SimpleDateFormat) 不是线程安全的，可以使用 ThreadLocal 为每个线程提供一个独立的实例。 public class DateFormatter { private static final ThreadLocal<SimpleDateFormat> dateFormatHolder = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd")); public static String formatDate(Date date) { return dateFormatHolder.get().format(date); } public static Date parseDate(String dateStr) throws ParseException { return dateFormatHolder.get().parse(dateStr); } } 线程局部变量的上下文信息 在某些场景下，需要在整个线程的生命周期内保存一些上下文信息，比如日志跟踪 ID、事务 ID 等。 public class LogContext { private static final ThreadLocal<String> logIdHolder = ThreadLocal.withInitial(() -> UUID.randomUUID().toString()); public static String getLogId() { return logIdHolder.get(); } public static void setLogId(String logId) { logIdHolder.set(logId); } public static void clear() { logIdHolder.remove(); } } 数据库连接和事务管理 在某些框架中，可以使用 ThreadLocal 来存储数据库连接或事务对象。这确保了同一个线程在同一个事务中使用相同的数据库连接，从而避免了并发问题。 public class ConnectionManager { private static final ThreadLocal<Connection> connectionHolder = ThreadLocal.withInitial(() -> { // Initialize the connection (e.g., get from a connection pool) return DriverManager.getConnection("jdbc:your_database_url"); }); public static Connection getConnection() { return connectionHolder.get(); } public static void closeConnection() { Connection connection = connectionHolder.get(); if (connection != null) { connection.close(); connectionHolder.remove(); } } } 使用 Spring MVC 拦截器来管理 ThreadLocal 变量 创建 ThreadLocal 变量 public class UserContext { private static ThreadLocal<String> userThreadLocal = new ThreadLocal<>(); public static void setUser(String user) { userThreadLocal.set(user); } public static String getUser() { return userThreadLocal.get(); } public static void clear() { userThreadLocal.remove(); } } 创建拦截器, 在 preHandle 方法中设置 ThreadLocal 变量，在 afterCompletion 方法中清除 ThreadLocal 变量 public class UserContextInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 从请求中获取用户信息并设置到ThreadLocal中 String user = request.getHeader("X-User"); UserContext.setUser(user); return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // 清除ThreadLocal变量 UserContext.clear(); } } 注册拦截器 //Java 配置方式 @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new UserContextInterceptor()); } } XML 配置方式 <mvc:interceptors> <bean class="com.example.UserContextInterceptor"/> </mvc:interceptors>`,``,`html`,`细说中国历史`,`20240307183503-书摘 九年以后，由于天地会的支流“小刀会”曾经占领上海县城。把清朝官吏吓走，有极多的中国老百姓涌入租界居住，上述的禁止华人租买房地的规定，事实上不能生效。 押解冯云山的衙役，在途中与冯云山谈话，听到冯云山的一番大道理，例如上帝创造宇宙，蛇魔骗亚当偷吃苹果，耶稣为亚当子孙赎罪，洪教主是耶稣的兄弟......等等，衙役闻所未闻，十分佩服，就不但放了冯云山，而且跟随冯云山去紫荆山入会。 秣陵关 琦善的唯一资格，也就是当过钦差大臣而已。论军事知识与胆量，他不仅比不了向荣，也比不了赛尚阿。他在河南，坐视武汉被太平军占领而不去救；到了江苏，扎一个“江北大营”于扬州郊外的宝塔山及司徒庙，静候太平军放弃扬州而奏报克服扬州，静候太平军放弃仪征而奏报克服仪征。静候到咸丰四年秋天，寿终。 他改字涤生，另有一段经过。传说他年轻之时，遭遇了一件甚不愉快的事，愤而自杀未死。罗泽南(罗山)劝他不必过于自疚，不妨取“涤生”二字为号，时加警惕。君子不患无过，患不能改 “寂寞河中府，临流结草庐。开樽倾美酒，掷网得影鱼。有客同联句，无人独看书。天涯获此乐，终老又何如? 以上这许多位尚书，在当时都是显宦，然而过不了几时，姓名 都被人们遗忘了。太史公所谓“当时则荣，没则已焉。” 成吉思及其以后的几位可汗，为了扩张领土，招降纳叛，作风 很大方，一点儿也不吝啬名器。逆我者死，顺我者生；顺我者不仅 能生，而且生得极其舒服。刘邦说过：“从吾游者，大者王、小者侯 耳。”这句话，道破了历代帝王的“成功秘诀”。 忽必烈可汗对日本的战争，《游记》也有所记载：说有三万中 国兵在1279年(事实上为l281年)，袭据了一个日本城市，死守了七 个月，最后由于无法与可汗取得联络而投降，留居日本。这一件掌 故，不见于中国的史籍，值得今后的学者加以考订 (正旦云) 我又不曾药死你老子，情愿和你见官去来。 在曲词方 面，例如，窦娥在被押赴刑场之时所唱的调子： (正宫端正好) 没来 由，犯王法。不提防，遭刑宪。叫声屈，动地惊天。顷刻间，游先赴森罗殿。怎不将天地也生埋怨? (滚绣球) 有日月，朝暮悬。有鬼神，掌着生死权。天地也，只 合把清浊分辨。可怎生糊突了盗跖颜渊?为善的，受贫穷，更命短。 造恶的，享富贵，又寿延。天地也做得个怕硬欺软，却元来也这般 顺水推船。地也，你不分好歹，何为地?天也，你错勘贤愚，枉做 天!哎，只落得两泪涟涟。 硕德八剌是爱的亲生儿子，于延祐三年十二月被爱立为太子。 爱作这一件事，铸成大错。当年，武宗海山与爱育黎拔力八达有过 成约：武宗不传位给自己的儿子和世琼，而以爱育黎拔力八达为“皇 太子”(皇太弟)，传位给他，将来他也必须传位给和世琼，让和世琼 再传位给爱育黎拔力八达的一个儿子(例如，硕德八剌) 事机不密 自从英宗硕德八剌的时候以来，西南边省差不多每年均有苗族 与瑶族的民变。这，虽则似乎是“癣疥之疾"，然而日子长了，确是 财政上的一失漏洞 自从英宗硕德八剌的时候以来，西南边省差不多每年均有苗族 与瑶族的民变。这，虽则似乎是“癣疥之疾"，然而日子长了，确是 财政上的一失漏洞 “明教”的本身，最初叫做“摩尼教”，是公元三世纪一个波斯人 摩尼(Mani)，为了想综合波斯拜火教、印度佛教与犹太罗马的基督 教，而创立的新宗教。摩尼主张：点灯点到天亮，帮光明战胜黑 暗；吃素，不吃荤，而所谓荤并非牛肉羊肉，而是大葱；做礼拜， 在每一个“密日”(礼拜天)的夜间，秘密聚会一次。这“摩尼教”在唐 朝时候 他不赞成继续奉韩林儿为帝；主张打陈友谅，而且在鄱阳湖决 战之时建议移军湖口，扼陈军的归路，“以金木相犯日决胜”；反对 朱元璋用他来代替李善长作丞相，说更换丞相好比更换房屋的柱 子，要用大木头来换，不可用小木头扎起来作为代替，他自谦为小 木头的原因，是自知疾恶太甚，又耐不了繁杂，因此他其后反对朱 元璋用他自己的朋友杨宪，说杨宪不能“持心如水，以义理为权 衡”，反对用汪广洋，说在广洋气量偏浅，更甚于杨宪，反对用胡惟 庸，说胡惟庸好比是一匹劣马，必定把车子拉垮。 朱元璋不完全 他的话。杨宪、汪广洋、胡惟庸，这三人朱元璋都重用了 自从胡惟庸的案子一而再、再而三地扩大了以后，明朝不仅是 当臣当民的人人自危．当皇帝的也是感觉到“人人皆敌”，惴惴然不 知道自己能活几天，死在谁的手中。洪武十三年以前上下一心，共 创新局面的风气，消失得无影无踪。当大臣的是“伴君如伴虎”。当 小臣与老百姓的是“虎口余生”，朱元璋自己是虎了，却也未尝不是 厕身于极多的其他老虎之中，“骑虎难下”，以虎骑虎。他竟然保住 了自己的性命与江山，还算是他能干，至于因此而博得了“雄 猜”、“滥杀”、“刻薄寡恩”、“可与共患难而不可与共富贵”等等，千 古的恶名，他也只好认了 他喜欢读书，好贤礼士，注意于为事择 人，而自己“疏节阔目”，只不过是总其大纲，确是中枢宰相之才， 可惜朱元璋为了需要一个像他这样的人放在云南，便让他长期留在 云南了 到了明世宗的时候，常复的孙子常 元振被封为怀远侯，又传了下去，传到儿子、孙子、曾孙。曾孙常 延龄，在崇祯年间请缨，不曾能够如愿；国亡以后，“身自灌园，萧 然布衣终老 三杨性格不同，学养不同，各有所长，亦各有所短。好在他们 均不负行政责任，因此皆能显其所长，而不致因有所短而误国 己。杨士奇之学，杨荣之才，杨溥之量，凑合起来，使得仁宣二宗 在位的十一年左右，成为明朝少有的一个“天下清平，朝无失政”的 插曲。 这时候，瓦刺业已归顺，“鞑靼”毋庸再打，二杨决定停止下西 洋的宝船，停止对安南的征战。他们把贪污的“大官”略惩一二(如都 御史刘观)转转风气，却也并不以察察为明，叫天下当“小官”的人人 自危 也先在撤退以后，攻了几次大同，均被郭登打了回去。这位郭 登颇能打仗，发明了好几种新武器，例如“搅地龙”、“飞天网”，也 仿造了古时候的四轮“偏箱车”，行军时供输运，作战时有钩环连结 成阵。他把兵士每五人成为一伍，叫他们宣誓结盟，他对每伍的 人，有功同赏，有罪同罚。十个伍成为一队，十个队成为一个作战 单位(可能是称为营)。军官临阵退却，杀军官；前队退却，则后队 杀前队。于是，他虽则麾下官兵不多，而始终守住了大同 韩雍在成化四年丁忧回籍 成化六年，荆襄一带的流民，在李原的鼓动之下，也大造其 反。李原自称“平王”，绰号李胡子，本是流民首领刘通的部下。刘 通是河南西华人，绰号刘千斤，到了这荆襄一带，于成化元年造 反，自称“汉王”，被白圭活捉。所谓荆襄一带，是陕鄂交界的森林 区，明朝政府划为禁地，不许人民居住，但是“窜”进来的一年一年 增加，自成团体，没有官吏管束。这地方在平时可称为世外桃源， 在乱时便成了反抗分子的根据地 宪宗在成化十一年，命令刘吉、刘珝二人入阁。这两人，加上 万安，是其后内阁之中仅有的三人。在这三人之中，刘吉完全是一 个依违取容的官僚。刘珝稍好，但也无甚作为。万安呢，是道地的 小人。当时京内京外，称他们三人为“纸糊三阁老”，与所谓“泥塑六 尚书”凑成一对很流行的口语 “臣奉使 遄行，适遇亢旱。天津一路，夏麦已枯，秋禾未种。挽舟者无完 衣，荷锄者有菜色。盗贼纵横，青州尤甚 “夫闾阎之情，郡县不得而知也。郡县之情，庙堂不得而知也。 庙堂之情，九重亦不得而知也。始于容隐，终于蒙蔽。容隐之端甚 小，蒙蔽之祸甚深。臣在山东，伏闻陛下以灾异屡见，敕群臣尽言 无讳。然诏旨频降，章疏毕陈，而事关内廷贵戚者动为掣肘，累岁 经时，俱见遏罢。诚恐今日所言，又为虚文。乞取从前内外条奏， 详加采择，断在必行! 工部的尚书是贾俊、刘璋、徐贯、曾鉴。贾俊很知道节用，也 敢于反对当时动辄调用京军作工的陋例。他认为政府的大工程，应 以修造仓库与城池为限。诸王的府第与坟墓，应由诸王就自己的收 人担负费用的一半。过去，全部是由政府担负。刘璋继任，对贾俊 颇能萧规曹随 宫内的针工局，要招收“幼 匠”一千名，他竭力反对，向孝宗说：尚衣监、军器局、司设监，都 已经收了一千名匠人，兵仗局而且收了二千名，现在针工局又来援 例，这样下去，“其流无已!”孝宗因此而只准针工局招收五百名 明朝由于太祖与马后注重教育，普设学校，读书的风气维持了 二三百年，直至清兵入关为止。虽则留下的特别好的著作不多，却 不足为病。大抵明朝的学者，努力于实践的多，致意于撰述的少。 所撰述的也常常是发挥程朱的陈说，甚鲜新义，然而为学的要点本 在于行。能够行，也就值得我们钦佩了 他的作风，与李东阳相彷佛，混在小人之群，虚与委蛇，随时就能力所及，对 国事稍加补救。武宗去世之时，他认为机会难得，便说服了当时的 司礼太监魏彬，联络皇太后张氏，把江彬等人解决 这最后一点，确是阳明先生的错。于是，虽则他走得不多远， 便病故在南安，桂萼却不饶他，振振有辞地参他一本，说他“擅离职 守”。世宗很受桂萼的影响，叫廷臣公议对阳明先生死后的处分。桂 萼却又作了好人，说阳明先生“功有足录，宜免追夺伯爵，以章大 信。”但是，他又说：“守仁事不师古，言不称师。欲立异以为高， 则非朱熹格物致知之论。知众论之不予，则为朱熹晚年定论之书。 号召门徒，互相倡和，才美者乐其任意，庸鄙者借其虚声。传习转 讹，背谬弥甚。”桂萼的结论是：“宜禁邪说以正人心。”看样子，他 是希望世宗把阳明先生的著作一概焚烧，毁板。 世宗根本不懂得桂萼所痛斥的，是怎么一回事，因此也就未加 理会，仅仅不让阳明先生的儿子袭继伯爵之位 阳明先生是“诗礼家庭的宠儿”，幼年没有衣食之虞，加以天性 豪迈，很想做世间“第一等事”，作世间第一等人。成年以后，接触 到当时士夫夫的以程朱为道统的气氛，努力于“格物致知”。曾经用 了七天功夫，“格”庭院前的竹子，格不出一个所以然的道理来，于 是，在回到家乡以后，便住到阳明洞里去，出入于释老二氏(研究佛 家与道家的书，并且打坐，导引)。那时候，他的年龄是三十一岁 (弘治十五年)。他学仙学佛不到一年，由于割舍不了对祖母与父亲 的孝心便毅然决然放弃了作仙作佛的想头，重行研究儒家的道理。 此后，他颇劝人“立志”。从弘治十八年起，便有人愿意执贽受 教，使得他开始了二十三个年头的授徒讲学的生活。古语说，“教学 相长”。他一面教人，一面也教了自己 武宗正德元年，他以兵部主事的资格上疏请求释放被刘瑾滥捕 的南京给事中戴铣等二十余人。疏中说：“铣等以言为责，其言如 善，自宜嘉纳，如其未善，亦宜包容。......伏愿追收前旨，使铣等 仍旧供职。扩大公无我之仁，明改过不吝之勇。”末了一句之中 的“改过”二字，稍许重了一些，使得武宗与刘瑾有藉口把阳明先生 也关下了诏狱，打四十下棍子，贬到贵州龙场驿当驿丞。龙场是今 灭修文县的县治，在当时还是个充满了“蛇魅魍魉，蛊毒瘴疠”，很 不卫生的所在，居民也什九以上是苗胞，言语不通。全场连一座房 子也没有。阳明先生到了那里，真是苦不堪言，却能慢慢地从苦获得磨练，找到出路。他教导苗民识字读书，也教了他们架木盖 屋。更重要的是，他悟出了“知行合一”的大道理。 这知行合一的大道理，发前人所未发，帮助了他自己后来为人 为学，立功立德，也影响了几百年来中国与日本的政治家及学人。 所谓知行合一，便是“知即是行，行即是知”，“知是行的主意， 行是知的功夫”，“知是行之始，行是知之成。”“知而不行，只是未 知 阳明先生不仅是要人行善，也要人“不行不善”：“今人学问，只 因知行分作两件，故有一念发动，虽是不善，然[自己]却[以为是]未 尝行，便不去禁止。我今说个知行合一，正要人晓得一念发动处， 便即是行了。发动处有不善，就将这不善的念克倒了，须要澈根澈 底，不使那一念不善潜伏在胸中。此是我立言宗旨。 阳明先生在江西平了宸濠之乱，几乎反而招祸，忧谗畏讥，在 思想上多了一番磨练，才把“知行合一”的观念，发展为“致良知”的 教训。“致良知”，是除去“不善的念”，也就是“去人欲’。去了人 欲，天理自现。这天理，便是“良知”，也就是我们通常所谓“良 心”。“知是心之本体，心自然会知。见父自然知孝，见兄自然知 弟，见孺子入井自然知恻隐，此便是良知，不假外求。 然在常人不能胜私意障碍，所以须用致知格物之功，胜私复 理，即心之良知更无障碍，得以充塞流行，便是致其知，知致则意 诚。 话说回来，世宗一朝只有在杨廷和主政的头二年又九个月，有 过几件好事。武宗刚死，杨廷和便以武宗的名义，颁布了一个遗 诏：罢“威武营团练”，遣散边军回镇，在“威武大将军”的所谓“军 门”办事的一切军官都伤令各归本卫，不许留在京城。武宗所经营 的，不成体统的“皇店”一概关门，成千成百的番僧，少林寺僧，教 坊的戏子婊子，以及专供游乐的南京“快马船”的船夫，与全国各女，也一概遣散。而且停止了京城的若干不急之务的营 造，送走了滞留在京城的哈密、土鲁番、佛郎机(葡萄牙)等国的贡 使。宣府行宫的所有金宝，也统统运回京城，存入内库。 除掉江彬的，是杨廷和。主持迎世宗入继大统的，也是杨廷 和。 在世宗即位的前夕，杨廷和起草登极诏书，乘此机会，用世宗 的名义大行改革：裁去了宫内与锦衣等卫的冗员十四万八千七百 人，减免了各地方运往京师的漕粮一百五十三万二千多石 但是，嘉靖帝始终执谜不悟，尤其是在嘉靖二十一年十月受了 宫婢杨金英的刺激以后。杨金英乘他睡得很熟之时，用绳子套在他 的颈子上打了一个结，使得他昏了很久才被救活。从此，他便搬 到“西苑”里去住，不和任何妃子或宫女见面，也不和严嵩以外的任 何文武大臣见面，只和几个道士与宦官打交道，更谈不上视朝听政 了 虎墩兔 张居正是江陵人，生于嘉靖四年，卒于万历十年。他在十二岁 时“进学”(当了秀才)，十六岁中举(当了举人)，二十三岁成为进士， 选庶吉士，受教于徐阶。(那时候，徐阶是吏部侍郎“兼翰林院学 士、教习庶吉士。”)两年以后，散馆(毕业)，张居正被任命为翰林 院编修。 他当了编修七年，感觉到“京师十里之外，大盗十百为群，贪风 不止，民怨日深”，“非得磊落奇伟之人，大破常格，扫除廓清，不 足以弭天下之患”。然而“世虽有此，人未必知，即知之未必用”。因 此之故，他毅然决然，称病辞职，回到家乡，种了半亩竹子，闭户 读书。 读书又读了整整六年。他的父亲(张文明)“郁郁不乐，日见憔 悴”，父亲向朋友说，“吾生平志愿未遂，望斯儿树立，用显吾祖。 今顾若此，吾复何望!” 张居正只得又进京城，作官 张居正生平自称别无他长，只是耐得了烦。 张居正办事严格，但对人并不苛酷。人有小过，他写一封私函 加以规劝或申斥。有了大过，他才依法办理。他把赏罚看得很重 要。没有赏罚，的确也办不了事。然而他一向是赏得重，罚得薄。 不讲道理的人，也未尝没有他们的所谓赏罚。张居正的赏罚， 除了极少数的例外，一秉至公。他尊重明朝已有的考绩制度。而加 以认真执行。京内之官六年一考，京外之官三年一考。过去，常常 只是例行公事。他呢，毫不客气：特别好的升，好的留，不好的 降，太不好的去。可是，他不像某些大官之以给人痛苦为乐。他在 原则上，是让胜任的人久于其任。 胜任的人，却不易找。风气好，好人多；风气坏，好人少。在 少数的好人之中，能办事的人更少。张居正懂得“不求全”。用人只是用其所长。此人的短处，倘与所任之事无关，不必计较。他勇于自任，而律己未尝不严。反对他的人，说他接受贿赂， 说辽王朱宪火(节)被废之时，王府的金宝都被他吞了。神宗因此而 在他去世以后的第二年，抄他的家，却只抄得了十万两左右的银子 而已(他家里原本是盐商，有钱) 崔呈秀是苏州人，万历四十一年的进士，其自甘下流，与顾谦如出一辙。魏忠贤在他未来投奔以前，还不敢太放肆。有了他作 干儿于，就为所欲为了。他作了两本名册，献给魏忠贤作参考。一 本是所谓东林党人，称为“同志诸录”，一本称为“天鉴录”，是反对 东林党的人，魏忠贤有了这两布名册，便逐渐地使得朝廷中“善类为 之一空”。凡是无耻的小人，想升官发财的，都来向崔呈秀“暮夜乞 怜”，于是“蝇集蚁附，其门如市”，纷纷送来“奇异珍宝” 李自成根据“男女财物十三家均分”的原 则，向张献忠要分守陵的小宦官，因为这些小宦官会吹打，吹吹打 打，挺有意思。张献忠不肯给，李自成即刻鼓动高迎样“散伙”，各 奔前程。高李去了归德(商邱)与曹操(罗汝才)合伙，共回陕西；张献 忠南下庐州(台肥)，攻破潜山、罗田、太湖(县)、新蔡 三月十七日，到达京师城下，京营不战而溃；十八 日，进入京师外城；十九日，进入京师宫城。思宗上吊自杀于宫后 的煤山。 事前，于祟祯十七年正月受任“督师”的东阁大学士李建泰，曾 经劝思宗离开京师，迁都南京。思宗不肯，说：“国君死社稷，朕将 焉往？”这是思宗的一大失策。天子有责任保卫国家，却并无死在京 城的义务，尽可以迁都别处，继续奋斗。况且，成祖把南京定为“留 都”，设了具体而微的中央政府机构以备非常，已是为了像崇祯十七 年三月的情况而准备好了的一个退步。无知的思宗，却偏要滞留在 孤城，一死了事，为匹夫匹妇自经于沟壑之烈，对不起他自已，更 对不起他的列祖列宗。 此人十六岁即位，三十三岁自杀，不曾享福一天，而天天在内 忧外患之中过苦日子；有心做好事而无一事做得好，有心去坏人， 用好人，而认不出谁是坏人，谁是好人；他没有治国救国的真本 领，以致局面一年不如一年，一天不如一天，终至于身死国亡，值 得后世同情，而不值得后世效法 在这十六个儿子之中，年纪最长的叫做褚英，其次是代善，这 两人均颇能打仗。他们是一母所乍，母亲是佟佳氏的姑娘。 努尔哈 赤在未称汗以前，就已有意立褚英为继承人，以继承自己的产业与 封号(建州卫都督佥事、龙虎将军)。努尔哈赤先后称褚英为“洪巴图 鲁”与“阿尔哈图.土门”。翻译出来，这两个称呼，一是“大勇士”， 一是“广略之人”。努尔哈赤而且把日常的庶政交给他料理。也许是 因为太负责任，他结怨不少，被弟弟们告了一状。努尔哈赤将他疏 远，他焚表告天，自诉冤屈。弟弟们又告他一状，说他咒诅。努尔 哈赤大怒，把他关起来，关了两年，他死在牢中 这就牵涉到：他有没有在皇太极死后，与皇太极的寡妇、顺治 皇帝的母亲孝庄文皇后正式结婚?有关的官方材料，早已被乾隆一代 的君臣销毁干净。今天我们所能依据的蛛丝马迹，仅有张煌言的四 句宫词：“上寿称为合卺樽，慈宁宫里烂盈门，春官昨进新仪注，大 礼恭逢太后婚。”张煌言虽是清朝的敌人，但为人正派，非一般捕风 捉影、恶意中伤的造谣专家可比。 值得指出的是，皇太后当时并非鸡皮鹤发的老妪，而是三十一 岁的少妇，比多尔衮还小一岁 这时候，驻扎在金门的是郑鸿逵，驻扎在厦门的是郑彩、郑 联。他们与郑成功一样，不愿意随郑芝龙去福州向博洛投降。 清军 不久便开到泉州，占领安平，劫掠了一顿。田川氏夫人自杀。郑成 功得到消息，带了一些兵来打，清军狼狈而退。他把母亲葬了，走 到泉州城外的孔子庙，把平日以秀才身份所戴的儒冠、所穿的儒服 统统烧了，向孔子哭着祷告：“昔为孺子，今为孤臣，向背去留，各 行其是。谨谢儒服，惟先师昭鉴!”他的意思是说：“以前我是儒生． 我是人子；现在我是一个丧了皇帝的孤臣，有国无家，立志投笔戎，作战到底，和父亲分道扬镳，请夫子原谅。” 他离开孔于庙，回到安平堡，约集了志同道合的好友甘辉、施 琅、陈炜、张进等九十几个人结盟，宣誓忠明抗清。盟罢，一齐乘 了两艘大船，到广东、福建交界的地方南澳岛招兵。一招，就招到 九千多人，开回安平堡，占领鼓浪屿，与金门的郑鸿逵，厦门的郑 彩、郑联，互为犄角。这时候，他的年龄是二十四岁 顺治热恋过一位董鄂妃，董鄂妃在顺治十七年八月十七日先他 而亡。顺治为她亲撰行状，说她对皇太后“奉养甚至，左右趋走，皇 太后安之”；说她“事朕，候兴居，视饮食服御，曲体，罔不悉”；又 说她“至节俭，不用金玉，诵四书及易，已卒业；习书未久，即 精”。 顺治在自罪的遗诏中，承认在董鄂妃死后“丧祭典礼，过从优 厚，不能以礼止情”。(他追封她为“端敬皇后”。) 关于董鄂妃的美，顺治下了“婗静”二字的按语。这婗字，根 据“集韵”，意思是妩媚。塞外的满洲女千，刚健婀娜的很多，妩媚 的极少 她在未为博穆博果尔的妃子以前，是不是被清兵从江南掳了来 的?她是不是冒辟疆的爱妾董小宛？ 冒辟疆在《影梅庵忆语》中说，在辛卯年(顺治八年，1651年) 三月底，梦见董小宛被人抢去，又说在同一天夜里，董小宛自己也 梦见被人抢走。 吴伟业(梅村)写了八首诗，题“冒辟疆名姬董白小像”，其中有 这么几句话：“乱梳云髻下妆楼，尽室仓黄过渡头，钿合金钗浑弃 却,‘高家’兵马在扬州”；又有：“欲吊薛涛怜梦断，墓门深更阻侯 门”。 他在“古意”的第六首,写了：“珍珠十斛买琵琶，金谷堂深护绛 纱，掌上珊瑚怜不得,却教移作上阳花。”“上阳”两字，很引起人们 猜测。 此外，他的四首“清凉山赞佛诗”，也常被附会为顺治出家的证 据。清凉山是五台的最高峰。诗中点出了一个“董”字：“可怜千里 草，萎落无颜色”。草头下面一个“千”字，“千”字下面一个“里”字： 合起来，便是董小宛的董字了。但是这也可以解释成董鄂妃的董 字 他住在昆明永历所遗留下的五华山宫殿，又占了沐国公(沐恩 波)所遗留下的七万亩庄园。钱用不完，美女也买了不少，传说其中 有一位“四面观音”与一位“八面观音”。(陈圆圆很消极，当了尼姑， 法名“寂静”。 康熙十二年(1673年)二月，镇守广东的平南王尚可喜，感觉到 自己年已七十(比吴三桂大八岁)，上疏给康熙，请求回辽东故乡去 养老，让儿子尚之信袭封为平南王，留在广州。 康熙借此机会，命令尚可喜把所有兵丁与家眷带回北方，搬到 (辽宁省的)海城去驻扎，撤消他在广东的“藩领”。 康熙的此一命令，惊动了吴三桂与开府福州的靖南王耿精忠(耿 仲明的孙子)。当时，平南王与靖南王、定南王合称三藩，三藩在事 实上是三个“独立王国”。 吴、耿二人于是为了试探康熙有没有早晚也夺取他们地盘的意 思，便忙着上疏，说他们也想退休，情愿“撤藩”。康熙回答 说“好!”而且派钦差去昆明，督促吴三桂早日启程。 吴三桂想了又想，决定在这一年十一月的二十一日，杀掉云南 巡抚朱国治，扣留钦差折尔肯与傅达礼，正式对康熙翻脸。 吴三桂 生平喜欢歌舞，懂得做戏。他在发难的一天，穿了大明衣冠，率领 若干将士到永历的坟前祭了一祭，祭毕大哭。这一哭，引起很多的忠愤。随即，吴三桂杀掉朱国治，拘禁折尔肯与傅达礼，发布“兴明讨 虏”檄文。这一篇檄文在中国已经无法找到，日本人替我们保存了一 份 在檄文里面，他自称“原镇守山海关总兵官，今奉旨总理天下水 陆大元帅，兴明讨虏大将军”。他奉的是谁的旨？是崇祯皇帝的三太 子的旨。他说，深悔在李自成占据北京之时，借了“夷兵十万”，没 想到“狡虏逆天背盟，乘我内虚，雄据燕都，窃我先朝神器，变我中 国冠裳。”他深悔“拒虎进狼之非”，说当他正在准备“反戈北指”之 时，遇到了“先皇之三太子，太子年甫三岁”。于是只好“避居僻壤， 养晦待时，选将练兵，密图恢复”。现在，时机已经成熟，定于甲寅 年(康熙十三年，l674年)正月元旦，恭奉太子祭告天地，敬登大 宝，建元周咨。 他奉了“三太子”(朱慈炯？)为皇帝，建元“周咨”，国号仍是大 明。清朝的官方历史家糟踏他，说他国号“大周”，称甲寅年为“周元 年”。他们故意把“周咨”的“咨”字删了。 关于崇祯的第三个儿子(朱三太子)的传说极多。依照明史，他 是周皇后的儿子，名叫朱慈炯，在崇祯十四年的时候年纪十岁，两 年以后受封为定王。那末，崇祯十七年北京陷清之时，他的年纪是 十三岁，不是“三岁”。如吴三桂的檄文所说。可能是檄文或檄文的 抄本漏了一个“十字”，或吴三桂所奉的为另一人。 吴三桂起事之 时，声势的确浩大。最得力的一员大将马宝，是永历的旧臣。吴三 桂曾经把永历的精锐选了十“营”，任命马宝等十人作为总兵。十人 之中，夏国相与胡国柱二人被他招为女婿。均是健将 次年，康熙四十七年(1708年)，康熙在八月间出去行围(打 猎)，中途皇十八子胤祄【xie】生病，滞留在拜昂阿，康熙回銮去 看这八岁小儿的病，太子胤礽也去看。康熙说，胤礽毫不关心弟弟 的病，而且“每夜逼近布城(皇帝帐篷)，裂缝窃视”。康熙又说：“朕 不卜今日被鸩，明日遇害，昼夜戒慎不宁”。(其实，胤礽窃视，未 尝不是关心父亲康熙是否忧戚过度；至于胤祄的生死，康熙自己也 说过：“区区稚子，有何关系？”) 康熙四十七年九月，康熙在布尔哈苏台继续“行围”，太子胤礽 与皇长子胤禔【zhi】均在身边。这月十六日，康熙召集王、大臣， 宣布太子的罪状，边哭边说，说完自己倒在地上，当场把胤礽废 了，交给胤禔看管 雍正对于曾静之如此不客气，却不甚介意，说“曾讥诽止朕一 人”，吕留良“上诬皇考(康熙)之盛德”，“于本朝祥瑞事迹概隐匿不 书，而专造作妖诬，布其私愤”，“谓我朝曰‘清’，曰‘北’，曰‘燕’， 曰‘彼中’”，“称满、汉之兵，齐跪永历马前”，“此吕之罪，所以为 至大也”。 雍正发明了一套神权理论，说皇帝是天所指派的，天只问某人 的“德”，够不够当皇帝，并不问此人出生在什么地方。“舜为东夷之 人，文王为西夷之人，曾何损圣德?”“我朝既仰承天命，为中外生民 之主，凡所以蒙受此抚绥爱育者，何得以华夷殊视？” 雍正说，写 文章的人“著劝戒于简编，当平心执正而论，对于外国人受大统之 君，其善恶尤宜公平书录，细大不遗。......外国之君，信其是非不 爽，直道常存，亦必愈勇于为善。”“若故贬抑淹没．略其善而不 传，妄载以诬其恶，以为中国之君既生中国，自应享有令名，不必 修德行仁，自臻郅治之隆；而自外国人承大统之君，以为纵能夙夜 励精，勤求治理，究竟无载籍之褒扬，为善之心因以自怠，则内地 之苍生其苦岂有底止耶？”这些话，是雍正的真心话，颇能动人。 关于清兵入关，窃占北京与华北的经过，雍正抄袭多尔衮的理 论，说清朝得天下于李自成之手，不是得之于明朝之手。而且明朝 自“嘉靖(世宗)以后，君臣失德，盗贼起于四方，疆圉无宁，其时可 谓之天地闭塞。本朝定鼎以来，扫除穷寇，文物日盛，黄章白叟， 一生不见兵革......尚可谓之昏暗乎？”“我朝之有造于中国，大且至 矣! 陆的文章更加露骨：“封建之制，古圣人万世无弊之良规，废之为 害，不循其制亦为害。......”“(君)愈尊，权愈重，则身愈危，祸愈 烈。...…(圣人)虽有国事，第存乎纲领，不人人而察；但察铨选之 任，不事事而理。 雍正精力过人，喜欢办事，而不怕繁琐，可说是天生的一位大 行政家。他自奉甚薄，较康熙有过之而无不及，虽致力于清查逋 赋、欠赋、增收关税、盐税，却只是为了充裕国库，不是为了一己 的耳目之娱(宫室)，口腹之欲(饮食)，或穷兵黩武，好大喜功。他把 整理财政的所得，用在免赋、赈灾、浚河、筑堤等项目上。 如果他不是皇帝，而是一位宰相或“大学士”，以他那一种综核 名实的作风与政绩，其值得后人的歌颂，也许要超过张居正。 我们 不可忘记，他是十八世纪上半期的人(即位于公元1722年，逝世于 1735年)。那时候，全世界没有一个国家具有所谓责任内阁制的政 府，除了英国以外。甚至在英国，责任内阁制也不过是刚刚萌芽罢 了 传说，她死后被埋在北京南下洼的陶然亭之旁。坟前立了块 碑，碑面仅有两个字：“香冢”。碑后却有一首词：“浩浩愁，茫茫 劫。短歌终，明月缺。郁郁佳城，中有碧血；碧亦有时尽，血亦有 时灭。一缕香魂无断绝。是耶？非耶？化为蝴蝶。 几天以后，林爽文失掉斗六，退守大里杙。再过七天，大里杙 也失守，林爽文撤到集集(令天南投县的东南)；他在集集支持到十 二月初，逃到埔裹(埔里)山区。清军搜山，林爽文走到一个好朋友 高振家里，把自己的生命送给高振说“我给你一个富贵的机会。”高 振果然捆了他，押解给清军 毕沅于嘉庆二年七月病故，继任的勒保干了半年，被调往四 川，改由一个伯爵景安充当总督。这景安抱定了“贼来我去，贼去我 来”的主意，老百姓也送他一个外号：“迎送伯” 天理教是否如稻叶君山所说为白莲教的化身，尚有待于考证。 传说天理教的另一名称，是“八卦教”。天理会首领林清与李文成的 作风有点像东汉末年的黄巾。黄巾在起事以前的口号是：“苍天已 死，黄天当立，岁逢甲子，天下大吉”。天理教的口号是：“二八中 秋，黄花落地”。“二八”指嘉庆十八年的第二个八月：闰八月。“二 八中秋”，是闰八月十五日。“黄花落地”，是暗示清朝将在这一天 天理教徒把这两句口号到处传播，造成一种预言性的民谣。嘉 庆皇帝本人也听到了，不晓得这是有人故意造出来的，还以为真是 一种天意呢。中国民间从来就有关于闰八月的迷信，以为凡是有闰 八月的一年，总免不了天灾人祸 道光皇帝生于 乾隆四十七年，即位的时候已有三十九岁。 他接下了一个灾祸频仍的帝国，颇知物力艰难，生平最不舍得 用钱。传说他套裤穿破，在膝盖上补了两块，而不肯缝制新的。 中的大臣们，因此也纷纷穿了破旧衣裳上朝 先说南北面官制。太祖时以契丹官制为主，但已采用汉制，任命汉官，中央置三省，地方设州县，又有汉儿司，是统管汉官系统的，以韩知古总知其事。太宗得燕云十六州，当地汉制政权组织纳入了辽朝的地方官系统。不久，太宗进军中原，颠覆后晋，也把中原王朝的官制带回了辽朝，全面确立了南北面官制。南北面的叫法与契丹习俗有关：契丹有拜日之俗，故皇帝宫帐必坐西面东，而且辽俗尚左，故契丹官衙都在皇帝宫帐之左，即在北面，汉人官衙则在其右，即在南面，此即南北面官制的由来。但北面官制中也有分称南北的，例如南枢密院和北枢密院，这里的南 天显五年十一月，他携带亲从，乘船载书数千卷，浮海至登州（今山东蓬莱）。后唐以欢迎天子的仪仗来接待他，明宗还赐他改姓李，改名慕华。其后，耶律倍虽在异国，与契丹亲属却问安之使不绝于路，述律太后也遣使通问。耶律倍南奔，后唐不以其为“非我族类，其心必异”，契丹也不以其为叛国而大张挞伐，双方宽容的心态难能可贵。 天显九年，后唐李从珂杀唐闵帝自立，耶律倍密函辽太宗：“从珂弑君，可来征讨。”两年后，李从珂灭亡在即，欲找耶律倍一起自焚，他因拒绝而被害。契丹大军到达，辽太宗诛杀了凶手，算是为兄长报了仇。太宗对耶律倍的长子耶律阮（小字兀欲）视同己出，封其为永康王 天显元年（926年）七月，辽太祖去世，皇太子继位按说是顺理成章的事。但述律后却自个儿临朝称制，摄军国事。她决心尽可能的为继位的儿子铲除些异己力量。当月，他召集一些从征渤海的大将的妻子，说：“我现在寡居，你们怎么可以有丈夫！”接着把这些大将找来，问他们想念先帝否，回答说：“岂能不想？”她就说：“真想的话，就应去见他！”于是，杀大将百余人。见左右有骜不驯者，说一声“你与我传话给先帝”，就杀之于太祖的墓所。 据说，在安葬太祖时，他问汉军将领赵思温：“你追随先帝最亲近，何不同去？”答道：“亲近不如皇后。你去，我就跟上。”述律后说了一句心里话：“嗣子幼弱，国家无主，我不能去！”最后，他没杀思温，但为堵人之口，便忍痛自断右腕，随葬墓中 四月，在回师的路上，辽太宗勤俭所过城邑多为废墟，感慨地说：“导致中原如此，都是赵延寿的罪过啊！”这当然是推脱责任之言，但他也终于说出之所以不能在中原立足的原因：“我有三失，难怪天下要背叛我。一失是诸州括钱；二失是令契丹人打草谷；三失是没有及早派各节度使回镇守之地。”行至沙胡林，辽太宗病死。为防止尸体腐化，他被开膛剖腹，放盐数斗，汉人称之为“帝羓”（即皇帝肉干） 其一，北征前夕，点检作天子的谣传令京师人心惶惶，富室或举家逃匿外州，赵匡胤密告家人，说：“外间汹汹，将若之何？”他的姐姐拿起擀面杖要揍他，说：“大丈夫临大事，可否应自作主张，到家来吓唬妇女干吗？ 建隆二年七月，一天晚朝结束，太祖与石守信、王审琦等故人饮宴，待酒酣耳热之后，他屏去侍从，对这些禁军宿将说：“我没有你们，就没有今天。但做天子也太艰难了，倒不如当节度使来的快活。我现在是长年累月不敢睡上一个安稳觉啊！” 守信等人忙问何故，太祖说：“这不难明白。天子这个位置，谁不想坐坐呢？”守信等都叩头道：“陛下何出此言！如今天命已定，谁敢再怀异心！” 太祖说：“你们没有异心，你们麾下的人要贪图富贵怎么办？一旦把黄袍加在你身上，你要不干，也办不到啊！”宿将们知道受到猜忌，弄不好就有杀身之祸，便一边叩首，一边流泪，请求太祖指示生路。 太祖开导道：“人生在世，就如白驹过隙。所以企求富贵的人，不过多积攒点金银，自个好好享乐，让子孙也不再贫乏。你们何不放弃兵权，出守大藩，选择好的田宅买下来，为子孙置下永久的基业；再多收些歌儿舞女，每天饮酒作乐，以终天年。我与你们互结婚姻，君臣之间，两无猜疑，上下相安，岂不很好？ 太祖为人豁达自信，往往以此高人一头。既得天下以后，赵普好几次在太祖面前说起发迹以前不善待自己的人，意欲加害。太祖却说：“倘若在凡俗尘世都能认出天子宰相，那人人都去寻找了。”其后，赵普再也不敢在太祖面前说起类似的话 宿将曹翰曾在太宗面前赋诗道：“曾因国难披金甲，耻为家贫卖宝刀”，家贫卖刀只是说说而已，却表达了武将对权力地位日渐下降的满腹牢骚 次年二月，继迁决定夺回银州故地。他亲率少数亲从到银州城下，对曹光实说：“我大败了好几次，走投无路不能立足，允许我投降吗？”并约期在葭芦川（在今陕西佳县）纳节献降。曹光实居然信以为真，擅功心切，也不与人通气，就由继迁为前导，率百来骑前往受降。继迁忽然挥鞭为号，伏兵骤至，尽歼光实及其从骑。然扮为宋军，打起宋帜，袭破了银州城 太平兴国八年，赵普罢相，李昉与宋琪并居相位。宋琪虽是首相，但李昉更受太宗青睐。原来，卢多逊为相时常在太宗面前说李昉的坏话，而李昉尽管不附和卢多逊倒赵普，却与卢关系不坏。有人告以多逊攻击他的事，他总不相信，仍待之不疑。为相以后，他也并不因为卢多逊倒台而落井下石，反而为他辩解。太祖告诉他说，卢多逊平时诋毁你不值一钱，李昉才知道真相。而太宗越加认为他是忠厚长者，因而在宋琪“素好诙谐，无大臣体”罢相后，就让他独相二年有余，这在太宗朝只有后来的吕蒙正和吕端才可与其相比 澶州，因古有称为澶渊的湖泊而得名，州治南北跨黄河为城，南城大而北城小，南城比北城安全，但宋军主力都布防在北城。多数随臣见契丹军声势浩大，都建议驻跸南城。寇准则力主真宗亲赴北城，鼓舞前线士气。高琼甚至说：“陛下如不过河，河北百姓如丧考妣！”一旁的签署枢密院事冯拯呵斥高琼说话不知分寸，高琼激愤地说：“你以文章升为二府，今天敌骑当前，还指责我无礼，你何不赋诗一首咏退敌骑呢！”说完就命令卫士们护卫真宗前往北城，真宗这才渡河登上北城城楼，接见慰劳将士。当宋军将士远远望见御伞黄盖时，立即欢声雷动，高呼“万岁” 然而，当一国君臣都炫耀“皇帝的新衣”时，还是有人大声说出真相。早在天书首降之际，龙图阁待制孙奭就引用孔子的话说：“天何言哉！岂有天书？”西祀汾阴时，他上书指出，所谓祥瑞是欺天愚民惑后世，还警告真宗：“不念民疲，不恤边患，安知今日戍卒无陈胜，饥民无黄巢？”当真宗要去祭祀老子时，他提醒真宗应当牢记唐明皇后期遭受安史之乱的教训。名臣张咏多次指名抨击王钦若和丁谓，他临终上表还要求真宗先斩丁谓之头置国门以谢天下，再斩自己之头置丁氏之门以谢丁谓。真宗对这些激烈的反对意见，采取了既不采纳也不追究的方针，他还没有彻底昏头 入朝之际，有门生向寇准建议：途中称病，坚求外补，是为上策；入朝以后，揭发真相，是为中策；下策就是再入中书，那将大坏平生声明。寇准还是决定入朝为相。也许在他看来，只有为相，才能有所作为，至于入相的手段是可以不必计较的，这也是绝大多数政治家的思路 二是澄清吏治。天圣、明道间，她曾六次下令严惩贪官污吏。京西转运使刘绰为讨好邀功，声称要把多余的千余斛粮食发运京师，她冷笑道：“你认识王曾、张知白、吕夷简和鲁宗道吗？他们谁是因为进献多搜刮的粮食而升官的！”在她的倡导下，当时涌现了范仲淹、王随、张伦、薛奎等一批廉吏。她还颁布了《约束文武臣僚子弟诏》，防止官员子弟违法乱纪。她要求大臣们把子孙和亲族姓名悉数写上来，诈称推恩授官之用，实际上却把个大臣的关系网和裙带图张贴在自己的寝殿中，大臣每有进拟差遣，就对照图表，不是两府亲戚才同意除授 王曾这时还是宰相，范仲淹曾当面批评他：“誉扬人才，是宰相的责任。您的盛德，唯独这一方面还有欠缺。”王曾回答说：“倘若当政者，恩欲归己，怨将归谁？”范仲淹深为叹服。王曾与吕夷简并相以后，见他独断专行，许多问题上政见分歧，搞不到一块儿，矛盾再也无法掩盖 唃厮啰见元昊兵势正盛，便屯兵鄯州（在今青海西宁境内），坚壁不出，同时派兵十万，迂回阻断元昊退路。元昊渡宗哥河（即湟水，今黄河支流西川河）主动出击，并在水浅处插上标志作为回师向导，却被唃厮啰派人暗将标识移至深处。双方连续鏖战二百余天，元昊军队粮草不继，被唃厮啰击溃，士兵寻找标志争相渡河逃命，漂没溺死者大半，损失辎重无数 次年是宋明道二年（1033年），元昊一改使用宋朝年号纪元的旧例，借口明道年号冲犯其父名讳，改元“显道”，颁行国中，向宋朝发出了不奉正朔的明确信号。同时，下秃法令，严禁用汉人风俗结发，推行党项传统发式，境内三日不秃发者，众皆可杀。这年五月，升兴州为兴庆府，仿照唐都长安、宋都东京，扩建宫城，营造殿宇，为立国称帝做准备。元昊还颁行了官制和仪服制度 嘉祐元年（1056年），狄青终于被罢政出知陈州。做这一决定时，仁宗说了句“狄青是忠臣”，宰相文彦博反问道：“太祖不是周世宗的忠臣吗？”狄青听到任命后，到中书去问为什么无罪出知州郡，文彦博两眼直瞪瞪逼视好久，才吐出一句：“无他，朝廷疑你！”狄青惊怖的倒退数步。到任后，朝廷每月两次派内侍前来“抚问”，实际上是不放心狄青，而每来就让他惊疑终日。不到半年，一代名将就在陈州忧愤而死。狄青之死，让人深切感受到宋代猜防武将的祖宗家法有多么森严可怕 过了一段时间，张贵妃又吹枕边风，仁宗见舆论平息，便重新任命尧佐为宣徽使。包拯得知，不管仁宗先前警告，不依不饶，领衔与其他谏官上奏再论。为了说服仁宗，包拯多次上殿争辩。一天，张贵妃还想为大伯说情，仁宗抢白道：“今天包拯上殿，唾沫都溅到我的脸上。你只管要宣徽使、宣徽使，不知道包拯是谏官吗？”由于包拯等抗争，仁宗只得收回成命，并保证今后张尧佐再有升迁，必须听取台谏章奏 仅隔十五天，治平四年正月，英宗去世，韩琦急召皇太子前来，其间英宗的手忽动了一下，另一宰相曾公亮担心英宗活过来都要背上大逆罪，提醒韩琦。韩琦不为所动，说：“先帝复生，就是上皇。”继续安排赵顼即位，他就是宋神宗。 韩琦曾自称“某平生仗孤忠以进，每遇大事，则以死自处”，他历仕三帝，顾命两朝，临变处疑，不动声色，当得起这个自我评价，是宋代有数的社稷大臣之一 在熙宁变法中，与锐意改革的王安石有所不同，神宗好几次表现出犹豫动摇，以至安石说他：“天下事如煮羹，烧一把火，却再放一勺水，何时煮的熟！ 司马光同一阵营内对免役法行废的争论也十分激烈。同知枢密院事范纯仁认为，“此法熟议缓行则不扰，急行则疏略而扰，委非其人，其扰滋甚”。苏轼说得更在理：“差役免役，各有利害。免役之害，聚敛于上，而下有钱荒之患；差役之害，民常在官，不得专利于农，而吏胥缘以为奸。”对免役法如何存利去害与司马光争得面红耳赤，但司马光固执己见，令苏轼私下里感慨大呼“司马牛，司马牛”。南宋吕中也以为：因其利而去其害，差役免役二法均是可行的。苏轼在这一问题上远比司马光通达 徽宗是历史上有名的风流天子，其游冶享乐也别出心裁。他在宫掖设立市肆，让宫女当垆卖酒，自己化装为叫花子行乞其间。后宫声色已圈不住那颗放荡的心，政和以后，徽宗开始微行出游，专设行幸局，凡有微行，就说是有排当（排当原指宫廷宴会，这里是微行的隐语），次日未还，就传旨说生了疮痍不能坐朝。蔡攸进言：“所谓人主，当以四海为家，太平为娱。岁月几何，岂可自苦！”梁师成更是曲解范仲淹的名句说：“也该陛下后天下之乐而乐了！”于是，徽宗毫无顾忌的微行于妓馆酒肆之间，追声逐色，寻花问柳。野史笔记说他嫖娼，说他与名妓李师师那段风流艳事，细节虽未必可靠，但其实却是难以否认的 这里有必要补说一下摩尼教。摩尼教属外来宗教，关于其教义与传来的路径，此处略过不表。仅指出一点，在其流传过程中，佛道色彩越来越浓，倒可以视为外来文化具有中国特色的成功范例。 唐武宗灭佛后，摩尼教转入地下，转而向东南沿海秘密渗透。五代后梁贞明六年（920年），母乙、董乙以摩尼教为旗帜，在陈州（今河南淮阳）起义，据说，其徒“画魔王踞坐，佛为洗足”，宣称“佛是大乘，我法乃上之乘”，也就是说教主摩尼比释迦牟尼还要高明。入宋前后摩尼教改称明教，这种以教主命名改为以教旨命名的更动，似更合乎中国人的习惯 这里有必要补说一下摩尼教。摩尼教属外来宗教，关于其教义与传来的路径，此处略过不表。仅指出一点，在其流传过程中，佛道色彩越来越浓，倒可以视为外来文化具有中国特色的成功范例。唐武宗灭佛后，摩尼教转入地下，转而向东南沿海秘密渗透。五代后梁贞明六年（920年），母乙、董乙以摩尼教为旗帜，在陈州（今河南淮阳）起义，据说，其徒“画魔王踞坐，佛为洗足”，宣称“佛是大乘，我法乃上之乘”，也就是说教主摩尼比释迦牟尼还要高明。入宋前后摩尼教改称明教，这种以教主命名改为以教旨命名的更动，似更合乎中国人的习惯 圣宗的皇后萧菩萨哥是承天太后的侄女，被册封为齐天皇后，生过两个儿子，却都早夭了 道宗绝非治世之君，他用人选官不能决断，竟让候选者掷色子，以胜者命官。耶律俨掷了个头采，道宗说是上相之征，让他迁知枢密院事。 历史上亡国易代几乎都是外患内乱造成的，但又往往内乱先作而外患随至。内乱的可怕，正如古人所谓“天作孽，犹可说，自作孽，不可活 生女真地区的海中出产一种“北珠”，每年十月以后才能从海蚌中获取，但其时北国已冰天雪地，采蚌者绝对难耐此奇寒。当地有一种天鹅，以蚌为食，而藏珠于嗉囊之内。另有一种名为海东青的猛禽，来自五国部以东的海中，专门搏杀天鹅。只要能得到它，也就能够捕到天鹅，剖取北珠了 北宋后期，这种北珠大得东京宫闱和官场的青睐。辽朝在与北宋的榷场贸易中因其身价百倍而大获好处，便把生女真直到海滨的通道称为“鹰路”，每年派出“银牌天使”向生女真索要海东青。这些银牌天使所到之处不仅恣意勒索，还随心所欲的每晚命年轻美貌的女真妇女“荐枕”，而不问其婚嫁与贵贱，因而激起女真民族的同仇敌忾 建炎三年十一月，淮贼刘忠犯蕲州。他也是溃兵出身，后有兵数万，屯据岳州平江县白面山，绍兴二年九月为韩世忠击溃，走降伪齐，次年四月为部下所杀，传首行在 在“群盗”并起的形势下，南宋政府推行了以盗制盗的方针，即任命一些兵强马壮的流寇集团的首领为镇抚使或捉杀使，让他们去消灭其他流寇集团和农民武装。二月，孔彦舟被宋朝任命为荆湖南北路捉杀使，让他去对付钟相。孔彦舟派出间谍，混入义军，里应外合，在三月的一个深夜，偷袭了钟相的大营，俘杀了钟相及其妻儿 作为绍兴和议的交换条件，绍兴十二年八月，金朝把宋徽宗的梓宫与宋高宗的生母韦太后归还给南宋，高宗上演了一场“皇太后回銮”的“孝道”戏。据说，徽宗棺椁里并无尸身，金人只放上了一段朽木，高宗也不敢开棺验尸，他怕再蒙羞辱。而韦氏在金朝也受尽了臣妾之辱，他被金将完颜宗贤占有达十五年之久，生有二子。高宗煞费苦心的把自己母亲被俘时年龄从三十八岁增大到四十八岁，就是为了让世人相信五旬老妇绝不可能有那号事，种种传闻只是金人的“诽谤”而已 李光罢官后曾札记过一些宦海见闻，这在宋代士大夫中原是常事。但从绍兴十四年起，秦桧与高宗唯恐民间私史记下他们的卑劣行径，一再下令查禁野史。绍兴十九年，李光之子李孟坚与其父门客闲谈起此事，不料这门客卖主求荣，孟坚入狱，除名编管峡州。李光也因私撰国史，与胡铨赋诗唱和讥讪朝政，远徙昌化军（今海南新州） 乾道八年二月，虞允文升为左相，但仅过半年，与孝宗在重用潜邸旧人上意见分歧，便辞相再任四川宣抚使。孝宗与他相约分别从东西两路出兵收复中原：“若西路出而朕迟回，即朕负卿；若朕负朕。”允文入川一年，虽然积极筹划北伐，但孝宗密诏询问进兵之期，他深知北伐不是轻率的儿戏，审慎答以军需未备 吴氏命赵汝愚宣布皇子嘉王即皇帝位，尊光宗为太上皇帝。嘉王听了，绕着殿柱逃避不止，连说“做不得”，吴氏大声喝令他站定，亲自取过黄袍给他穿上 开禧三年正月，金方统帅仆散揆病死，左丞相宗浩接替其位，宣称将亲率大军攻打襄阳。韩侂胄大为恐慌，命张岩招募议和使臣，重开与金和谈。弱国无外交，谁都不愿意揽这一差使，好不容易起用了萧山县丞方信孺。 宗浩责问他：为何前日兴兵今日求和？他不卑不亢回答：“前日兴兵复仇为社稷，今日屈己求和为生灵。”宗浩不得不折服于他的辩才，让他带回五款议和条件：割地、称臣、归战俘、罪首谋、增岁币。南宋方面不同意前二款，表示可以接受后三款，当然，首谋是以苏师旦、邓友龙和皇甫斌来顶缸。信孺再使金营，双方距离太大，和谈陷入僵局。 信孺往返折冲，据理力争，宗浩沾不到便宜，下令将他关押起来。但信孺毫不畏惧的表示：“拘禁金国是死，辱没金使也是死，还不如死在这里！”宗浩无奈，只得放他南归复命。他向韩侂胄转达金方议和条件，说到第五条时语气支吾，在侂胄追问下，才慢悠悠说出：“欲得太师头！”韩侂胄恼羞成怒，连夺信孺三官，把这位当时最出色机辩的外交使节贬到临江军居住。他恼恚地决定“有以国毙”，即把整个国家捆绑在战车上同归于尽。这一不负责任的决策，自然引起了广泛的不安。反战派开始结成了联盟，代表人物是杨皇后与史弥远 及至史弥远死后，人们才发现，比起韩侂胄来，史弥远的流毒更深、为害更烈。有人打比方说：韩侂胄专政，“天下之势，如人少壮而得疾，其疗之也易为功”；史弥远专政二十五年，“天下之势，如人垂老而得疾，故其疗之也难为功”。韩侂胄与史弥远前后折腾了近四十年，南宋后期的衰颓走势已不可逆转 章宗在完备汉制方面所颁布的措施，是女真族汉化的总结，在金朝女真封建化过程中具有积极意义。章宗禁止称女真人为“番”，本人也宛然汉家天子。他雅好汉族士人的书画作品，学得一手宋徽宗的瘦金体。他还设立书画院，命应奉翰林文字、汉人王庭筠任都监，为他鉴定王羲之、顾恺之的书画。章宗对汉文诗词有精深的修养，有句云：“三十六宫帘尽卷，东风无处不扬花”，诗风虽纤弱，却是有意境的佳句 中都陷落前后，中原也早如蜩螗沸羹而鱼溃网烂了。山东河北地区爆发了金朝历史上前所未有的人民大起义。起义军大多以红袄为号，史称红袄军 司马光不像左丘明那样“良工灭尽针线迹”，而是煞费苦心的“欲把金针度与人” 贾似道醉生梦死，不管国事，置社稷安危于不顾。每日朝政，自有书吏把三省文书抱到贾似道的葛岭私第，由其门客廖莹中与翁应龙处理，他不过在纸尾画上个押。他每天在葛岭的亭台楼阁里，与姬娼尼妾花天酒地，纵情声色。初秋与群妾趴在地上斗蟋蟀，也是这时的事，赢得了蟋蟀宰相的万古骂名 咸淳八年，元军围困襄阳已经五年。守将吕文焕竭力据守，城中粮食尚有，但食盐、布匹短缺。李庭芝将帅司移至郢州（今湖北钟祥），以便就近救援襄樊。他招募了三千敢死队，派民兵领袖张顺、张贵统领战船百艘，以三舟联为一舫，中间一舟载盐布，左右两舟空其底而有三十名士兵作掩护。 张顺号竹园张，张贵号矮张，出发前，二张发令说：“此行有死而已。如非本心，即可退去，别坏了大事！”人人感奋争先。夜漏三刻，起锚出发，以红灯为号，张贵领先，张顺殿后，乘风破浪，直冲重围 张弘范包围张世杰的次日，恰是元宵，在双方战舰云集的海面上，当地居民依旧举行了每年一度的海上元夕竞渡，喧阗的鼓乐，与密布的战云形成强烈反差。国家兴亡，生活依旧，老百姓该做什么的还是做什么 但张世杰其人，虽是宿将，却不知兵，这时的心态也是有点失常，不是做好打得赢就打，打不赢就走的两手准备，而是孤注一掷，打算与元军一决胜负。当时有人建议他先据海口说：“幸而胜，国家之福；不胜，还可西走。”他不耐烦地说：“连年航海，何日是头，成败就看今日！ 陆秀夫见帝昺的座舰已无法突围，便决定殉国。他仗剑将自己妻子儿女驱入海中，其妻死拉着船舷不肯自尽，他喝道：“都去！还怕我不来！”其妻这才松手沉海。陆秀夫对帝昺说：“国事至此，陛下应为国死。德祐皇帝受辱已甚，陛下不可再辱！”说完，背起八岁的帝昺，跳入大海 崖山之战是蒙元消灭南宋的最后一战，流亡近三年的南宋小朝廷终于灭亡。据载，战罢，“浮尸出于海十余万人”。倘若张世杰部署得当，用好这十万兵，流亡小朝廷何至于这么快覆灭呢！明代张溥说：“陈宜中能逃而不能死，陆秀夫能死而不能站”，还应加上一句：“张世杰能战而不能谋”。由这三个人撑持的行朝，其灭亡只是迟早的事 十二月九日（1283年1月9日），就义那天，文天祥从容不迫的迈向设在柴市的刑场。面对万余名前来送别的百姓，向故国所在的南方拜了两拜，慷慨九义。死后，在他的衣袋里发现了绝笔书上面写着： 孔曰成仁，孟曰取义。 惟其义尽，所以仁至。 读圣贤书，所学何事？ 而今而后，庶几无愧！ 这份绝笔在春天就已写好，文天祥早就视死如归，等待着杀身成仁、舍生求义的那一天。他以自己对民族、社稷、信仰、主义的崇高气节、坚贞操守，为立国三百二十年的宋朝抹上了最后一笔绚丽的亮色 纵观文天祥一生，任相于危难之际，却没能挽狂澜于既倒，其后毁家抗元，兵败被俘，也并没有建立惊天动地的功业。后人纪念他，以为是：“名相烈士，合为一传，三千年间，人不两见”，肯定他的主要不是名相，而是以名相能为烈士，“事业虽无所成，大节亦已无愧”，钦仰他的是节概与操守。他那威武不能屈、富贵不能淫、贫贱不能移的坚贞气节，是中华民族精神遗产的重要组成部分 这三路蒙古军，逢人便杀，逢城必攻。立刻投降的城内的人可以免死。不立刻投降，而抵抗了若干天的；城破之后便一定要屠。这是可汗的所定的规矩(其后在花剌于模也是如此) 岳飞连胜金兵，几乎恢复了中原，高宗听秦桧的话，为了不让岳飞逼得金朝把徽钦二帝送回，就忍心把岳飞杀了，甘心向金朝皇帝称臣纳贡，受金朝的册封，每年进献“岁贡"银二十五万两，绢二十五万匹，割让淮河以北及唐州、邓州、商州、秦州。这是绍兴十一年(1141年)阴历十一月的和约 根据这些片断，我们可以约略了解大札撒的精神：很严，而处刑不分贫富，不分贵贱。偷马的，如果缴不起罚金，便要处死。马在蒙古，当然值得如此重视。杀人的，用不着抵死，能缴罚金就可以了。这不是说死了的人不重要，而是说活着的人更重要，能叫活着的人免死总是好的 大札撒规定了每一壮丁永久属于某一牌子头、百户、千户的麾下。离开了自已的隶属的单位而混到另一单位去的：处死。军官接受不属于自己单位的壮丁的，也要处死。 大札撤也规定了：蒙古人对于可汗，只须在可汗的名字之后，加呼可汗一词，不必像回教国家的人，对他们君主称呼一大串尊号。皇室分子对可汗可以仅仅称呼他的名字，连“可汗"一词都可以省略。而且，皇室分子犯罪，不处死刑，只能处监禁或流放。 留下来的大札撒片断，极少是属于民法范围的。其中有一条很有意思：破产了第三次的人，处死 八刺合回到察合台汗国，当了汗，也和海都打了两仗。但是，不久以后，就变成了海都的同盟者，把锡尔河与阿姆河之间的税收，让海部分享。原来，海都本在对术赤的一个曾孙忙哥·帖木儿作战，却能于八剌合来攻之时，迅速化敌为友，使得忙哥·帖木儿反而派五万兵帮他的忙。结果，吓得八剌合也变成了朋友 武平二年（５７１年），和士开等设法规定琅邪王每五天进宫一次。不得随时进见太后。高俨和亲信定计，令人上表弹劾和士开，要求把他逮捕审讯，由侍中冯子琼（胡太后的妹夫）把表夹杂在其他文书中送到后主面前。后主当作是无关紧要的文书，看都不看就批准了。接着，高俨骗领军库狄伏连，说：“奉敕，令领军逮捕和士开。”伏连向冯子琼请示，并请求复奏。冯子琼说：“琅邪王受敕，何必再奏。”伏连便照命令办事。在宫门口埋伏了兵士。七月二十五日，和士开上朝，到宫门口被伏连抓住，押到御史台，便被高俨杀了。 	 	 下了殿，便有兵把他抓起来，送到华林园的佛院里。力士刘桃枝是个专做这种差使的人，恭候已久，立即把他杀了 珽得势了，官拜秘书监，加仪同三司。但他想做宰相，对此并不满足，便走了一着险棋。天统三年（５６７年），他上疏奏赵彦深、元文遥、和士开罪状。太上皇帝大怒，把祖珽抓来，严词问。他与上皇反复辩论，不肯屈服，声称和、元、赵专弄威权，控制朝廷，卖官胃爵，政以贿成。他又说“陛下有一范增不能用。”上皇听了更火。这次，祖珽吃的苦大了，刀环筑口，鞭子抽打，泥土塞嘴，终被贬滴外地，关在地牢内，仍邢具加身，家属不得探望。由于夜里用芜菁子为烛照明，他两眼也被烟熏得完全丧失了视力 宗室有兰陵王高长恭（一名孝瓘，高澄子），他容貌俊秀，上阵常戴假面，以示凶猛之状，时人为之赋《兰陵王入阵曲》 尽管这样，齐军却很快陷入了困境。连日大雨倾盆（这本是多雨的季节），积水很深（史籍说“平地水丈余，恐怕不是实况，真有那么深，会把人马都冲走），齐军兵士日夜都立在烂泥里，脚趾都烂了，烧东西吃更是困难。台城城里和潮沟（建康城内人工渠道，沟通长江、玄武湖、秦淮河）以北不积水（也可能是积水浅），而且守军可以轮换到室内避雨休息，健康情况比齐军好得多。十一日，天气转好，陈霸先准备出战，要让将士饱餐一顿，但苦于缺粮，只弄到点麦饭，而且数量还不足。幸而陈蒨及时送到二千斛米、一千只鸭。陈霸先大喜，立即命令煮熟，发给每人一包用荷叶裹的饭，中间夹几块鸭肉。十二日拂晓，将士吃饱了，日光亮足后，陈霸先亲自领兵，在幕府山方面发动反击。 陈霸先不肯接受这个局面。他曾派人到建康反复力争，王僧辩都不肯听。九月，他召集侯安都、周文育、徐度、杜棱四将商议，决定袭击王僧辩。徐、侯二将走水路，陈霸先等走陆路，分头进发。侯安都到了石头城北，弃船上岸。石头城北面同山地接连，靠得很近。侯安都身穿甲胄，手执长刀，叫兵士立在离城最近的地方，把他举起来，抛到女墙里面。部下将士也照此办法进城，直抵王僧辩的卧室。陈霸先带的兵也从南门进了城。王僧辩正在厅上办事，外面报进来，说有兵来到（这是陈霸先军），他正惊疑，又有兵从府第里面冲出（这是侯安都的兵），王僧辩与儿子王頠只带得几十个人，在厅上苦战，终于抵敌不过，逃上南面的门楼。陈霸先逼他下楼，说不下来就放火烧楼。王僧辩父子没法，只得下楼，当天夜里都被绞杀 梁元帝承圣三年（５５４年），西魏兵破江陵，梁元帝被俘遇害。城将陷时，元帝烧毁所藏图书，为文化史上一浩劫；王公百姓数万人沦为奴婢，小弱尽遭屠杀。这是台城陷落后的又一次大灾难。文学家庚信身经台城之围，江陵陷落前出使西魏，在长安目睹亲友成为俘囚的惨状，伤心刻骨，因有《哀江南赋》之作，声调激越，为千古之绝唱。而赋中“若江陵之中否，乃金陵之祸始。虽借人之外力，实萧墙之内起”几句，尤见卓识。台城之涡，萧正德开门揖盗，不能辞其咎；江陵陷落，兄弟叔侄的内讧，何尝不是它的远因 侯景本人收拾散兵，有船两百艘、兵数千人。四月，在松江被侯瑱所率追兵打败。侯景只剩下一条船、几十个人。他在沪渎（今上海市西旧青浦的吴淞江）出海，想逃往北方。他再也料不到，杀他的人此时就在身边。他在建康，娶梁武帝的女儿溧阳公主做妻子，霸占羊侃的女儿做妾，用她的哥哥羊鹍做库直都督。羊鹍时时刻刻想复仇，但始终装成忠于他的样子，经常随待身旁。他乘侯景白天睡熟时，令船家改变航向，开往京口。侯景醒来时，见船在长江中，大吃一惊，问江中洲上的居民，说是郭元建仍在广陵。他正想命船家驶往北岸，羊鹍已拔出刀来，命船家不得改变方向，一面用刀指着侯景说：“今天要借你的脑袋去取富贵。”羊鹍在船上已经联络了好几个人，他们一齐亮出兵刃，向侯景砍去。侯景要投水，没有空隙可钻，只得走到船舱里，用佩带的短刀挖船底。这哪里来得及。羊鹍提起矛来，一下便把他了结。他们切开侯景的肚皮，塞进大把大把的盐，以防腐烂。尸体到了建康，王僧辩命把首级送往江陵，把手砍下派人送交北齐，其余部分在建康示众，顷刻之间便被百姓扯得粉碎。 王僧辩从江陵出发时，向湘东王请示，如何对待嗣君（即侯所立萧栋）。湘东王答云：“六门（指台城的六座城门）之内，自极兵威！”这个人心肠何等狠毒！王僧辩其人，虽有统兵无纪律和后来投靠北齐等劣迹，对此也不肯听命，他回答得很妙，说：“讨贼之谋，是臣的责任；成济之事，请另外交给别人。”成济就是为司马昭行凶杀魏帝曹髦的人。湘东王就把这件事交给了一个名叫朱买臣的将军。侯景兵败逃走后，萧栋和两个兄弟从监禁的地方脱身，两个兄弟都说“总算可以免横死了。”萧栋却说：“还很难说。”他预料得不错。朱买臣找到了他们，就请他们上船喝酒，不等席散，弟兄三人都成了落水之鬼。湘东王希望没有人同他争帝位，简直想把弟兄侄儿全杀光。这样狠毒的人是不大会有好下场的，异日在江陵身死之时，不知道会不会略有悔意，可惜后人没有办法知道了 十月，命王伟以上寿为名，劝简文帝饮酒，待其醉后，即用土囊把他压死。 侯景公然提倡烧杀掳掠。他告诫众将：“打开了敌军的营垒城池，要把他们杀光，使天下知道我的威名。”他在石头城立一座大碓，抓了犯他的法的人，就放在碓里舂死。他禁止人们低声说话，违反的连“外族”（母族或妻族）都得治罪 政府方面：战争爆发时，大家怕绝粮，人人出去运米，一共积了四十万斛；各官衙的钱帛，集中起来，共五十万亿。但是没有储备燃料、草料以及鱼盐等物资。结果只能拆了房子当柴烧，把垫床铺的草抽出来饲马，用完了只好给马吃饭。没有菜，军人捉老鼠、麻雀，杀马，甚至煮皮革制的甲，把人肉和马肉混在一起烧吃。城中原有十多万人，其中能够参与战斗的只有两万多人二三个多月下来，许多人浮肿气急，兵士不满四千人，中间还有许多病号，人死了十之八九，横尸满路，无法掩埋 宣阳门外，朱雀航北，原有庚信带的三千多人，位于萧正德部和侯部之间。但庚信只会做诗赋，他和部下都从来没有经过战阵，对岸射来一阵箭，有一支正中庚信身边的门柱，庚信正吃甘蔗，一惊甘蔗落地，就转身逃走。这支兵（本来不是兵，是宫中文武人员杂凑起来的队伍）马上溃散。守石头城的萧大春（武帝孙）听见台城吃紧，便逃往京口去了，接着部将便降了侯景 高欢病重时，高澄用父亲的名义，写信召侯景来洛阳，显然是来后就不让他走了。但是他不知道，高欢与侯景有过约定，来书须有特定暗号。他收到了没有暗号的信，又知道高欢有病，断定在鲜卑小儿手下没有自己生 不久，高欢又使刘贵向尔朱兆提出“就食山东”的要求。理由是：并、肆二州连年受灾，降户在田里挖田鼠吃，人人面黄肌瘦，希望到山东粮食丰富的地方去，等温饱以后再回来听候安排 他字贺六浑，就是一个鲜卑式的名字。他家里很穷，年轻时在城上服役做工，娄家的小姐看中了他，使婢女向他致意，送私房钱给他，叫他向她父母求婚。这个小姐，就是后来北齐的神武明皇后（北齐称高欢高祖神武皇帝）。他自讨了这个老婆，才养得起马，在本镇做了队主，又转为函使。这些都是起码的小差使。 元叉已经死在临头，但是他丝毫没有危机感。胡太后心里起初有点踌躇，他们毕竟是亲戚，左右却劝她赶快动手。孝明帝年已十六岁，前几年已经“还政”，有的动作需要他出手。于是一个宦官（显然是出于太后指使）向深受孝明帝宠爱的潘嫔说元叉要杀她。潘嫔向孝明帝哭诉时又加上一句，说：“元叉非但要害妾，还想谋害陛下。”孝明帝相信了，乘元叉回家住宿的时候，免掉他的侍中一职。次日，元叉要进宫，就被挡驾，进不去了 胡太后常到宗戚勋贵家里，和这些人优游自得，过着无忧无虑的生活。他们生活豪侈，互相争奇斗胜。高阳王雍（孝文帝弟）号为首富，府里有僮仆六千、伎女五百，日日夜夜乐声不停，一餐要花几万钱。大臣李崇财产不比他少，只是生来吝音，常说：“高阳一食，敌我千日。”有一次，胡太后带着王公大臣等一百多人参观绢库，太后叫他们要多少拿多少。李崇、元融两个背得太多太重，跌倒在地，李崇伤腰，元融伤脚，成为一时的笑料。李崇贪多务得的性格在这件事上完全暴露出来了 赵脩原来是宣武帝做太子时的侍从，“不闲书疏”’（《魏书·恩律传·赵格》），大概是个文盲或者半文盲，然而深受宣武帝信任。宣武帝即位后，让他做到从三品的散骑常侍。他在家中宴会，皇帝会带着许多王公贵族官僚去参加。他仗着皇帝宠信，横行不法。父亲落葬时，他毫无悲痛的神情，宾客在路上掳掠奸淫民间妇女，甚至把人家的衣服剥光，观看戏乐。小人得志，总是会忘其所以，他连王公也敢欺凌，积怨日深，一旦爆发起来，就无法招架了。高利用众怒，把赵脩的过恶揭发出来。一向依附他的官僚怕遭连累，也争先恐后告发他的罪恶。景明四年（５０３年），宣武帝不得不把他交给尚书元绍审问，结果下诏打一百鞭，徙敦煌当兵。这一百鞭，由五个力气大的汉子轮流动手，实际打了三百鞭。这个家伙身体十分粗壮，吃了这顿打，还没有死，不过到底走不得路了。接着，把他缚在马鞍子上，加上一鞭，赶马飞跑。浑身是伤的赵脩经过八十里路的颠簸，终于死了。事后，宣武帝还怪元绍为什么不重新奏报一次，意思想免他一死。元绍说：“臣若不借此机会把他除掉，恐怕陛下要受万世之谤。”赵脩在朝廷中积怨之深，由此可见 紧接在立皇后之后，文成帝立三岁的儿子拓跋弘为皇太子。这个拓跋弘就是后来的显祖献文帝。他的母亲李贵人，依照当时宫廷的规矩即被“赐死”。这是极残酷的制度，说是为了防止异日母后干政，然而，只要贵为皇后，就不会受这个规矩约束了 南齐一共不过二十四年。至末代君主东昏侯萧宝卷，他用金子凿成莲花，铺在地上，使潘妃在上面行走，叫做“步步生莲花”，又穷极奢侈了 元徽五年（４７７年）六月，他闯进领军府，看见中领军萧道成赤膊躺着，便叫他站起来，在他肚皮上画了个圈做靶子，张弓要射。道成恭恭敬敬地说：“老臣无罪。”左右王天恩说：“领军肚皮大，是好靶子，一箭射杀了，不能再射，不如用骲箭射（骲箭系去掉镞的箭）。”废帝大喜，果然照办，萧道成才没有死。他从此暗暗地联结废帝的左右杨玉夫等，让他们找机会动手。七月，杨玉夫等乘废帝熟睡时，抽出他的防身刀来，把他杀死。于是萧道成用太后令，立安成王刘准（明帝子、九岁）做皇帝，追封后废帝为苍梧王。刘准就是刘宋的末代皇帝顺帝 前废帝的姐姐山阴公主对兄弟说：“陛下有许多妃殡，我只有一个附马，太不均匀。”他就替姐姐置“面首”三十名。这是历史上有名的奇闻 萧斌想坚守碻磝。沈庆之又劝他不要坐守穷城，以免蹈朱脩之守滑台的覆辙。萧斌想要依他，朝廷使者又到，传达文帝不准退兵的命令。萧斌再和众将商议。沈庆之说：“将在外，君命有所不受。将军有一个范增而不能用，空谈有何益处！”众将知道这个老头子是个文盲，见他引证史事，都笑起来说：“沈公现在大有学问！”庆之厉声答道：“列位虽则通晓古今，其实还不如下官靠耳朵听来的有用！”萧斌接受他的意见，只留王玄谟守碻磝，申坦、垣护之扼守清口（在今山东梁山县东南，参见第十九篇桓温北伐时事），自己率军还历城，以防魏军东进青州。后来因碻磝的位置过于突出，无法防守，又命王玄谟撤出 晋隆安三年（３９９年），他和慧景、道整、慧应、慧嵬从后秦的都城长安出发，西行求经。他的旅伴时有增减，旅途生活极为困难。如隆安四年秋，从敦煌到鄯善的一段，曾在以枯骨为标识的沙碛中走了十七天，至晋元兴元年（４０２年），才越过葱岭，进入北天竺。 孝武帝太元二十一年（３９６年）九月，张贵人因恐色衰被废，用被蒙住孝武帝的头部，使他窒息而死，推说“因魇暴崩”。 为了充实代郡一带，他强迫山东各族人民十多万日迁移到代郡。我们可以想像：这十多万人在魏兵的监督驱赶下，在新修的不见得平坦的山路上长途跋涉的苦况，这其实是一幅流民图啊！移民到代郡后，计口受田，做了国家的农奴 大兵之后，必有大疫。夏秋之间，瘟疫流行。八月初，拓跋珪军在常山的九门县（今河北藁城西北）安营，病号满营，人畜死亡的极多，将士都想回到北方去。拓跋珪查问疫情，部下回答：“十个人中活着的只有四五个。”这种回答一般不会完全真实，推测起来，非战斗减员已在半数以上。拓跋珪却轻描淡写地说：“这是天命，没有办法可想的。好在到处有人，不怕没有百姓的。”群臣听了，都不敢提撤兵的话。这是专制统治者视人命如草芥的口吻！老百姓死了多少，史籍没有提。军人死了一半以上，老百姓死的自然也不 升平三年（３５９年），晋使豫州刺史谢万、徐兖二州刺史郗昙攻燕。谢万是后来成为东晋名相谢安的兄弟，也是个大有名气的名士。王羲之得知了这道任命，就写信劝他“与士卒之下者同甘苦”。谢安也对他说：“你做元帅，必须经常接待众将，使他们心悦诚服。”谢万做不到与士卒同甘苦，便听兄长的话，召集众将会议，他找不出话来，便把手中的铁如意指着大家说：“诸将皆是劲卒。”那时候阶级区别森严，把将校叫作兵卒是有侮辱性的，众将听了，对他十分怨恨。谢安知道这位老弟不可救药，怕他送掉性命，就特地赶到他统率的军中，与各级军官联络感情 石虎为人喜怒无常。石邃有时禀报政事处理情形，他嫌烦，便说：“小事一件，何必禀报！”有时不报，又恨道：“为什么不报！”并加以责打。石邃性格本极残暴，有时将美人斩首，把头上的血洗掉，放在盘上给宾客观赏，还把美人的肉煮了，与宾客同吃。他恨父亲凶恶，对中庶子（东宫官）李颜等说：“我想行冒顿之事〔冒顿杀死父亲，夺单于位），卿等肯跟我吗？”李颜等都吓得不敢开口 有一天下雪，桓温出去打猎，先到刘惔处，刘惔见他一身戎装，就问：“老贼如此装束，意欲何为？”桓温道：“我不做这等事，卿等怎能坐谈？”这是一句意味深长的话，隐含桓温对于清谈家的看法。 其时帝也从长安派了一个第五猗来当荆州刺史，出武关南下。杜曾、郑攀迎第五猗而拒王廙，局势就弄得更复杂了 这个胡亢没有多大能力，杜曾却是一员勇冠三军的猛将，披了甲还能游泳 河间王颙匹马逃到太白山中，百官也都逃到山里，拾橡实充饥 河间王颙的后方一度吃紧，长安险些被刘沈的军队占领，为此他不得不赶紧召回张方。张方掳了洛阳的官私奴婢一万多人西回，途中缺粮，就杀人与牛马同煮，分而食之。到了关中，他派部将打败了刘沈军，又生擒刘沈。河间王颙将刘沈先用鞭打，然后处死 事后，孙秀借此大发淫威，打击素有嫌隙的人士，潘岳、石崇是其中最有名的两个。孙秀地位低微的时候，曾在潘岳手下当差，受过几次责打。又石崇有个爱妾叫绿珠，孙秀曾指名向石崇讨要，石崇不给。石崇的外甥欧阳建又与赵王伦不睦。这时孙秀便诬称这三人是淮南王允的同党，将其三族全部处死。兵士到石家时，石崇对绿珠说：“我是为你得的罪。”绿珠道：“我当为君而死。”她跳楼自杀，孙秀终究得不到这个美人 武帝大概是认为不妨一试，就应允了，任命他做武威太守，让他招兵。公卿大臣都不赞成，认为现有的军队很多，不必再行招募，马隆之言，不可采纳。幸而武帝不听，马隆才得放手干将起来。他立下标准，凡拉得开１２０斤的大弓，能挽九石之重的重弩，就予录取。这是相当高的标准，当时的斤约相当于２５０克，１２０斤约相当于３０公斤；一石为１２０斤，九石即相当于２７０公斤。最终马隆录取了三千五百人。之后，马隆又到武库挑选兵器。武库令不让他挑，双方争吵起来，御史中丞不问情由就弹劾马隆。幸而马隆是“通天”的，他向武帝陈情，说：“臣要带将士到战场上拼命，没有好的兵器，怎么能打胜仗。武库令给臣的是魏朝留下来的旧兵器，柄都快烂了，根本不能使用，如何可以拿去杀贼！”武帝听他讲得有理，立即命令让他自己挑选，并且预先发了三年的军费 魏末参与灭亡蜀汉的卫瓘，还有他的儿子卫恒、侄女卫铄，都以书法著名。卫瓘字伯玉（２２０～２９１年），河东安邑（今山西夏县西北）人，善草书。卫恒字巨山（？～２９１年），草、章草、隶、散隶，四体皆工，并著有《四体书势》。他们父子都在政争中被贾后杀害。卫铄（２７２～３４９年）嫁与江州刺史李矩，世称卫夫人，是“书圣”王羲之的老师 杜预还主持过黄河孟津处的建桥工程。当时有人认为，自殷周以来，历代都曾有建都于此的，而从来没人造桥，此举一定难以成功。可他说：“古人云‘造舟为梁’，就是河桥。”后来他果然造成了河桥 至太康二年（２８１年），他还将原来的吴国宫女三千人也纳进宫里，这时后宫的女子竟有万人之多。在后宫，武帝常好乘羊车游乐，羊在哪里停下不走，他就在哪里留宿过夜。羊要吃草，也爱咸味，有些宫人就在 把孙权的儿子说完以后，也要说说他的女儿。他的女儿有三个：大女儿名字叫做鲁班，称为鲁班公主，又称全公主；乳名却是“大虎”。中间的一个女儿，不知道叫做什么名字。小女儿叫做鲁育，称为鲁育公主，又称朱公主，乳名是“小虎”。大虎与小虎，均为步夫人所生。中间的一个女儿，是谁所生，我们不知道 这叫做，待我以众人，则以众人之身份报之 潘夫人性情很“妒”。妒本是人类的天性，也是一种权利。然而在清朝及其以前的中国，由于一夫多妻是合法的，女人便丧失了妒的权利。善妒，成为一种罪名。 	 曹植与曹丕兄弟之间，处得不好，却也不曾有过那曹丕逼他“七步成诗”的事。《三国演义》厚诬古人，把周瑜、诸葛亮说成互不相容，又把曹丕说成要把曹植害死，这种“反道德性”的潜移默化，养成了明清以来中国人之不能彼此以善意相期，不能合作团结。 张鲁在汉中郡不自称“太守”而自称“师君”(天师兼君主)。他废掉了各县的县令及其他的官吏，只设道教教会的职员，以职员兼管民政。最高级的职员称为“治头”。每一个行政区域称为一个“治”。治头之下，设大祭酒与祭酒。再其次，普通刚入教的教友，称为“鬼卒”。人民犯法，张鲁不肯立刻用刑。第一次犯法，张鲁加以原谅。第二次，也加以原谅。到了第三次，张鲁才肯用刑。张鲁在他所割据的全境，叫祭酒们到处设置“义舍”，义舍里有饭有肉，免费招待来往的旅客。老百姓有病的，张鲁的祭酒们叫他们静坐反省，或公开承认自己所犯的过失，然后，喝下用指头画过符的水，与烧了的用笔在纸上所画的符。张鲁确有他一大套的办法。在他的境内，新的道路极多。因为，他命令犯了罪的人，以出钱、出力来修筑道路，替代坐牢。他在去汉中以前，在巴郡西部收了不少信徒；割据了汉中郡以后，这些巴郡西部的信徒，对他仍旧服从。`,``,`html`,`绝代双骄`,`20250126151610-影摘 人生充满着疑问 人性更是难信任 那你老哥的尊姓大名呢 杀虎太岁蜀山东 前人铺路后人走嘛, 我何必要知道这么多呢 但是, 你总比我幸运, 你裙臣无数 你一定认为我不自量力吧, 论武功我绝不是你对手, 好在我们大家都是斯文人, 不一定要用武, 才能分胜负的, 这儿有两杯酒, 其中一杯有毒, 你和我各挑一杯, 一饮而尽, 生死各安天命 可我真是想不出有什么理由, 什么事要跟你决斗 20250126151822.webp 20250126151823.webp 20250126151824.webp 20250126151825.webp`,``,`html`,`绝色双娇`,`20250121195254-影摘 只会文不会武, 一辈子受人欺负, 只会武不会文, 一辈子狗都不闻 客官要吃要喝, 本店样样俱全, 客官要赌要嫖, 本店一样不缺 男女杂处, 深宵不眠, 言不及义, 成何体统 岂不闻古者民有三疾, 狂也肆, 矜也廉, 愚也直, 但你们如今却是狂也荡, 矜也忿戾, 愚也诈 啊, 这位龙大侠真是诸葛文章, 满腹经纶啊 子曰：“古者民有三疾①，今也或是之亡也②。古之狂也肆，今之狂也荡;古之矜也廉③，今之矜也忿戾④;古之愚也直，今之愚也诈而已矣。” ①　疾：本义是病。这里指气质上的缺点。由于世风日下，今人的缺点毛病也无法同古人的缺点毛病相比了。古人气质上有缺点的尚且朴实可贵，今人则变得更加道德低下，风俗日衰了。 ②　亡：同“无”。 ③　矜(jīn金)：骄傲，自尊自大。　廉：本义是器物的棱角。这里引申为不可触犯，碰不得，惹不得。 ④　忿戾(lì利)：凶恶好争，蛮横无理。 孔子说：“古代的百姓有三种毛病，现在，或者连那样的毛病也没有了。古代狂妄的人不过有些放肆直言，不拘小节，现在狂妄的人却是放荡越礼，毫无顾忌了;古代骄傲的人不过是棱角太露，不可触犯他，现在骄傲的人却是凶恶好争，蛮横无理了;古代愚笨的人不过头脑有些简单直率，现在愚笨的人却是明目张胆地虚伪欺诈罢了。” 来个西子捧心之计不就收场了吗 逢场作戏 你怎么还和十几年前一样这么多鞋啊 你一个女娃娃, 成天蹦蹦跳跳的像什么样子啊 未知生，焉知死？ ... 译文活着的事情都还没有弄清楚，怎么知道死后的事呢？ 吾日三洗吾身 你这个人呐, 仗还没打呢, 你先阵亡啦 我一看就知道, 我们今天要寿终正寝啦 闭上你的嘴啊 他打赢了你, 你就成了他的人啦, 唉呀, 咱们这会儿好像回到了史前蛮荒的时代 什么木已成舟了, 万一船沉了怎么办啦' 我十几年把你养大, 喂水喂饭把屎把尿 谁怕谁？乌龟怕铁锤 猪头啊你, 这一定是坏人嘛, 坏人总比好人有办法嘛 芊芊姑娘, 你的见解果然是独树一帜啊 你我在一条船上, 如果这条船到不了对岸, 你我一起死 以前是干什么的 以前是扬州府知府 啊, 我懂了, 以前在茶馆里说笑话吧 其实没读过书, 也不是什么坏事, 读过书的人, 就没你这么率真可爱了 做人不能认命, 只要还有一口气在, 就去做自己想做的事情 池鱼之殃 我芊芊从来就不是摇尾乞怜的人 老弟如此多才, 老夫失觉啊 无星无月的夜里想起你的温柔 哎呀, 我说龙兄啊, 我知道你嫉恶如仇, 好打抱不平, 可是你现在怎么连红娘的事情也做起来了, 如果你实在闲得没事想见义勇为, 我可以想办法把那些土匪引出来呀 你这个死老头子, 你一直跟我抬杠是不是 真有这等斯文扫地之事 知名不具 写信的一种落款格式，意思是：知道我是谁，因此我就不署名了。 写信的一种落款格式，意思是：知道我是谁，因此我就不署名了 狗咬狗一嘴毛 “齐大非偶”的原义是春秋时，齐是大国，郑为小国，所以两国的人联姻不相匹配；后来辞婚者常用“齐大非偶”表示自己门第或势位卑微，不敢高攀；在句子中可充当作谓语、宾语。 “你听我解释!”“你听我说!” “不听不听我不听。”`,``,`html`,`缅甸岁月`,`20240307183503-书摘 医生像盒中公仔一样从房子里冒了出来——一个小小的黑白剪影。 那个可爱的老士官长说过，如果英国人撤出印度，将不会留下半个卢比和处女 那只鸽子在树枝上来回踱着步子，将胸部的羽毛鼓胀起来，以珊瑚色的嘴喙清理着羽毛。弗罗利心里觉得很痛苦。孤独，孤独，孤独是多么痛苦！在这寂静的森林里，他总是会遇到这些漂亮得难以用言语形容的事物——小鸟、鲜花、树木——而要是有人能和他一起分享该有多好 他的一切烦恼，归根结底就是这么一句话吗？仅仅是毫无男子气概的满腹愁思，就像小家碧玉式的矫揉造作 他是一个温和的秃顶男子，在莎玛丽丹百货公司上班，整个人看起来就像一只为了面包屑而烦恼的小麻雀 昨天我用《纳什杂志》的一页纸装午饭，这样我就可以节省点时间不用洗盘子。这主意真不错！你想要干净的盘子时，只需要撕下一页纸。”诸如此类的话。 我这辈子服侍过很多人，”老萨米说道，“最糟糕的莫过于温普尔上校老爷，他老是叫人把我摁倒在桌子上，然后从后面用厚厚的靴子踢我，因为我老是做香蕉煎饼给他吃。平时他喝醉的时候，会朝仆人的房舍屋顶开枪，子弹就从我们的头顶飞过 两人都穿着蹩脚的军服，戴着大大的遮阳帽，压着瘦削的身子，看上去像两株伞菌的茎秆。 屋里有一股清冷而甜腻的鸦片味，墙上挂着长条形的红色纸条，上面写着黑色的字 [1]，一面墙上挂着一张肖像画，上面是两个神情肃穆的人，穿着刺绣长袍，肖像前供奉着两根焚香。两个中国女人，一个是老妇，一个是女孩，正坐在一张席子上用玉米秸秆和切得像马毛一样细碎的烟草卷香烟。她们穿着黑色的丝绸裤子，双脚的脚背肿胀弓起，勉强塞进红色鞋跟的木屐中，看上去比洋娃娃的脚大不了多少。一个赤身裸体的小孩正在地上慢悠悠地爬来爬去，像一只黄色的大青蛙。 他看着一堆告密信，一直琢磨到深夜，里面包括了五封他本人收到的匿名信，还有两封威斯特菲尔德先生转交给他的匿名信，全部用仙人掌的硬刺钉在一起。 威斯特菲尔德是个警察，深知吴柏金的为人，可能会破坏他的计划。警察和地方法官是水火不容的天敌。但吴柏金知道如何利用这一点达成自己的目的。在匿名信中他指控维拉斯瓦密医生与那个臭名昭著的无耻贪官吴柏金狼狈为奸。这一招摆平了威斯特菲尔德。 那只斗鸡尼禄走出来在小径散步，顶着太阳啄食园丁在喂羊的时候掉下的稻谷 “还有多久到，婆婆？”弗罗利问那个老妇。 老妇把嘴里的雪茄取下来，把桨靠在膝盖上，想了一下，“还有男人吼一嗓子的距离吧。” “还有半英里。”弗罗利翻译给伊丽莎白听。 他们动身了。村庄远离河流的另一边种了一道六尺高、十二尺宽的仙人掌篱笆作为保护。他们沿着一条狭窄的仙人掌小径走着，然后拐进一条印着车辙、布满灰尘的牛车小径 太阳落到了伊洛瓦底江后面，暮光平行地照射着留茬田，为残株镀上了金色，一缕柔和的黄色光线照射在两人的脸上 今晚是满月之夜，月亮像一个烧得白热的硬币，亮得刺眼，在飘着几朵黄云的土蓝色天空中飞升，不见一点星光。那几丛巴豆白天看起来很丑，就像害了黄疸病的月桂，在月光下变成了犬牙交错的黑白图案，像是美妙的木刻画 有头衔的人总是这样，他们不是备受崇拜，就是受人憎恨。如果他们接受某个人，他们就变得朴素而魅力十足；如果他们忽视某个人，他们就变得势利而令人讨厌。只此二端，没有折中的情况。 孤独，孤独地生活在海洋的荒岛里 嫉妒是可怕的。它不像其它的折磨——它无法伪装，也无法升华为悲剧。嫉妒不仅仅带来痛苦，而且让人恶心。 快到火车站的时候她躲在黄包车后面，各掐了自己两边面颊一把，希望恢复一丝血色。`,``,`html`,`翼`,`20240307183503-影摘 空中骑士 对方看到大卫的机枪坏了，于是挥手放他离去`,``,`html`,`自动重合闸`,`20250301223339-电力 20250301223351.webp 20250301223352.webp 20250301223353.webp 20250301223354.webp 20250301223355.webp 20250301223356.webp 20250301223357.webp 20250301223358.webp 20250301223359.webp 20250301223360.webp 20250301223361.webp 20250301223362.webp 20250301223363.webp 20250301223364.webp 20250301223365.webp 20250301223366.webp`,``,`html`,`自定义url协议`,`20240510094910-_工具使用 新建协议 //HKEY_CLASSES_ROOT目录下新建4层文件夹,最外层是协议名称 ida\shell\open\command //最里层新建字符串值设置启动路径 "D:\Dropbox\local\src\guide.bat" "%1" //guide.bat作为向导 //"%1"表示捕获URL中的参数 注册表方式 表头声明不可省略 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\ida] @="ida Protocol" "URL Protocol"="" [HKEY_CLASSES_ROOT\ida\shell] @="" [HKEY_CLASSES_ROOT\ida\shell\open] @="" [HKEY_CLASSES_ROOT\ida\shell\open\command] @="\"D:\\Dropbox\\local\\src\\guide.bat\" \"%1\"" url中文参数解码 decodeURI.js msg = decodeURI(WScript.Arguments(0)); arr = msg.split(':'); switch (arr[1].charAt(0)) { case "1": case "2": case "3": WScript.Echo(arr[2]); break; } 忽略打开外部协议时的弹窗确认 计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome //新建字符串值,名称&数据 AutoLaunchProtocolsFromOrigins [{"allowed_origins": ["http://test1","http://test2"], "protocol": "ida"}] https://stackoverflow.com/questions/75209468/google-chrome-urlallowlist-doesnt-work-on-win-10-pro 向导例 guide.bat @echo off setlocal enabledelayedexpansion @REM D\C\B\A(当前脚本自身所在目录) set "A=%~dp0" pushd "%A%" && cd .. set "B=%CD%" cd .. set "C=%CD%" cd .. set "D=%CD%" popd @REM 确保路径结尾带有 "\" for %%X in (A B C D) do ( if not "!%%X:~-1!"=="\" set "%%X=!%%X!\" ) @REM 不要设%temp%这个变量,跟jar包调用webp-imageio.dll有冲突 set "temp1=%systemroot%\temp\ 1001.txt" set "temp2=%systemroot%\temp\ 1002.txt" cscript -nologo -e:jscript %B%src\decodeURI.js %1 > %temp1% set "jar_path=%B%src\generator.jar" set "jre_path=D:\java\JDK\temurin-1.8\bin\java" set "vscode_path=C:\Users\ida\AppData\Local\Programs\Microsoft VS Code\Code.exe" set "githubdesktop_path=C:\Users\ida\AppData\Local\GitHubDesktop\GitHubDesktop.exe" for /f "tokens=2 delims=:|@" %%i in (%1) do (set code=%%i) if "%code%" == "1" goto case_1 @REM create new page if "%code%" == "2" goto case_2 @REM edit local page if "%code%" == "3" goto case_3 @REM delete if "%code%" == "4" goto case_4 @REM generate volume if "%code%" == "5" goto case_5 @REM generate webp :case_1 @REM create new page @REM ida:1:分类id @REM pdf开头加@ set /p title=Enter the title: echo %title% > %temp2% find "@" %temp2% if %errorlevel% equ 0 ( set type="pdf" goto case_1_a ) else ( setlocal if exist "%B%html\%title%.html" ( echo File exists! pause exit ) endlocal set type="html" goto case_1_b ) :case_1_a for /f "usebackq delims=" %%a in ("%temp1%") do ( set "categery_id=%%a" ) "%jre_path%" -jar -Dfile.encoding=UTF-8 "%jar_path%" 1 "%C2%local" "%title%" "%categery_id%" "%type%" goto end :case_1_b for /f "usebackq delims=" %%a in ("%temp1%") do ( set "categery_id=%%a" ) "%jre_path%" -jar -Dfile.encoding=UTF-8 "%jar_path%" 1 "%C2%local" "%title%" "%categery_id%" "%type%" tasklist /FI "IMAGENAME eq javaw.exe" | findstr /C:"%jar_path%" >nul if %errorlevel% neq 0 ( start "" "%vscode_path%" "%B%html\%title%.html" ) goto end :case_2 @REM edit page @REM ida:2:标题 for /f "usebackq delims=" %%a in ("%temp1%") do ( set "title=%%a" ) "%jre_path%" -jar -Dfile.encoding=UTF-8 "%jar_path%" 2 "%C2%local" "%title%" tasklist /FI "IMAGENAME eq javaw.exe" | findstr /C:"%jar_path%" >nul if %errorlevel% neq 0 start "" "%vscode_path%" "%B%\html\%title%.html" goto end :case_3 @REM delete @REM ida:3:类型@标题 for /f "tokens=1,2 delims=@" %%a in (%temp1%) do ( set "type=%%a" set "title=%%b" ) if "%type%" == "html" move "%B%html\%title%.html" "%B%html\_deleted" if "%type%" == "pdf" move "%B%assets\%title%.pdf" "%B%assets\_deleted" "%jre_path%" -jar -Dfile.encoding=UTF-8 "%jar_path%" 3 "%C2%local" "%type%" "%title%" goto end :case_4 @REM generate volume @REM ida:4 "%jre_path%" -jar -Dfile.encoding=UTF-8 "%jar_path%" 4 "%C2%local" tasklist /FI "IMAGENAME eq javaw.exe" | findstr /C:"%jar_path%" >nul if %errorlevel% neq 0 start "" "%githubdesktop_path%" goto end :case_5 @REM generate webp @REM ida:5 "%jre_path%" -jar -Dfile.encoding=UTF-8 "%jar_path%" 5 "%C2%local" 0.8 pause goto end :end del %temp1% %temp2% exit`,``,`html`,`荒岛余生2000`,`20240307183503-影摘 百折不挠，不固守，敢于冒险`,``,`html`,`莫斯科不相信眼泪`,`20240307183503-影摘 定闹钟`,``,`html`,`萍踪侠影`,`20241022205702-影摘 一口钢刀打遍天下妇孺无敌手 机缘末到而勉强行事, 不到山前, 怎么知道山上路有千条 尘归尘, 土归土, 哪里不是归宿啊 请你不要当着我的面说我哥哥, 是他杀人没错, 可你们身在江湖, 不是成天打打杀杀的吗, 你们每个人都想练成绝世武功, 因为只有武功高的人, 才能杀死武功低的人, 这不是江湖上最频繁的事情吗, 如果我哥哥武功低, 那么今天躺在这儿的就是他 一击得手 冷月在天, 群星相伴 人生一世, 寻知半生`,``,`html`,`营地`,`20240307183503-户外 清除营地四周杂草，周围挖一道排水沟，并且撒一层草木灰，以防蛇虫爬入。 床铺应离开地面30~50厘米，若打地铺，可用树枝、树叶或细竹垫铺，尽量不要用杂草。 临睡前先在地上敲打，捕除爬上的昆虫。 醒来是，应首先仔细地察看身体周围，否则附近若的蛇和昆虫会被突然的活动惊动。 保持遮棚的清洁，所有垃圾必须及时掩埋。因为只要有星点的油脂，就有可能把蚂蚁引来，蚂蚁又会将蜥蜴引来，而蜥蜴则又会把蛇引来。注意不要火烧鱼骨头，这种气味也会把蛇引来。 20221112135836.webp 20221112135829.webp 20221112135850.webp`,``,`html`,`观点`,`20240307183503-_其它 划分问题的边界 需求描述和分解需求 边界条件,特殊输入,异常处理 snake_cased_variables比CamelCasedVariables更容易阅读 从视觉上减轻认知负担是一件小事，但仍然很有用。在阅读文档和听音乐时，人们喜欢代码中的空白 面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可 性能较高，所以单片机、嵌入式开发等一般采用面向过程开发 面向对象是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为 面向对象有封装、继承、多态的特性，所以 易维护、易复用、易扩展。可以设计出低耦合的系统。 程序设计的实质其实是对复杂性的管理;待解决问题的复杂性,以及用来解决问题的工具的复杂性. 汇编是对机器底层的轻微抽象 c等是对汇编语言的抽象 所有的编程语言都提供抽象机制,可以认为,人们所能解决的问题的复杂性直接取决于抽象的类型和质量 开发或理解一个程序设计 当正在试图开发或理解一个程序设计时,最好的方法之一就是将对象想像为"服务提供者". 程序本身将向用户提供报务,它将通过调用其它对象提供的服务来实现这一目的. 你的目标就是去创建(或者最好是在现有代码库中寻找)能够提供理想的服务来解决问题的一系列对象. 着手从事这件事的一种方式就是问一下自己:"如果我可以将问题从表象中抽取出来,那么什么样的对象可以马上解决我的问题呢?" JavaScript 通常,你必须以JavaScript的某种最小公分母形式来编程,以使得你的程序可以在所有的浏览器上运行. 前端传来的数据一律默认不可信`,``,`html`,`观阅记录`,`20250505210310-碎片 电视剧 长河东流 2008 南宋传奇之蟋蟀宰相 2003 新女驸马 2002 正德演义 2005 把酒问青天 2005 七种武器之孔雀翎 2011 绝代双骄 1988 苏樱 绝色双娇 2000 大旗英雄传 2007 三少爷的剑 2000 神医喜来乐 2003 书剑恩仇录 2002 穿越时空的爱恋 2002 武林外史 2001 铁齿铜牙纪晓兰 1,2,3,4 鹿鼎记 1998 萍踪侠影 2004 澹台灭明 喜气洋洋猪八戒 2005 福星高照猪八戒 2004 春光灿烂猪八戒 2000 征服 2003 雪山飞狐 1991 甘十九妹 1996 天蚕变 1979 老友记 小侠龙旋风 1990 搞笑一家人 2006 徐敏静 宰相刘罗锅 1996 大醉侠 2002 玉玲珑 圆月弯刀 1997 武林外传 封神榜 2001 灵镜传奇 水月洞天 2003 上错花轿嫁对郎 2000 小李飞刀 1999 惊鸿仙子 雪花女神龙 聚宝盆 难兄难弟之神探李奇 难兄难弟 插翅难逃 2002 刀锋1937 白眉大侠 1994 风云2 2004 铁狂屠 风云 2002 双响炮 少年王 天不藏奸 雪花神剑 云海玉弓缘 西游记 1986 射雕英雄传 1986 悠长假期 日本 仁医 日本 电影 Zootopia 2016 The Woman in Red 1984 Once Upon a Time In America 1984 My Cousin Vinny 1992 第六感 1999 豪勇七蛟龙 1960 巨蟒与圣杯 白头神探1&2&3 反斗神鹰1&2 当代奸雄 1949 桃色公寓 左拉传 西区故事 炎热的夜晚 1967 桂河大桥 洛奇 1976 一条叫旺达的鱼 汤姆·琼斯 1963 窈窕淑女 1964 君子协定 1947 青山翠谷 1941 失去的周末 卡萨布兰卡 1942 西线无战事 1930 煤气灯下 四季之人 背靠背脸对脸 1994 海蒂和爷爷 2015 活着 1994 环游世界八十天 1956 败家仔 1981 僵尸先生 1985 鬼新娘 斗牛 河南鬼子 红番区 六指琴魔 1994 运财五福星 最佳福星 夏日福星 福星高照 奇谋妙计五福星 蝴蝶梦 1940 埃及艳后 鲁非斯 翼 凡夫俗子 彗星美人 克莱默夫妇 骗中骗 微观世界 野战排 1986 母女情深 1983 走出非洲 1983 雨人 1988 末代皇帝 1987 为黛西小姐开车 1989 与狼共舞 1990 红龙 2002 少年汉尼拔 2007 汉尼拔 2001 沉默的羔羊 1991 不可饶恕 1992 角斗士 2000 莎翁情史 美国丽人 1999 座头市 2003 芝加哥 2002 卖花姑娘 1972 莫斯科不相信眼泪 1979 圣保罗医院之迷 侠盗罗宾汉 1938 猫鼠游戏 阿甘正传 蝴蝶和潜水钟 荒岛余生 2000 兵临城下 我的名字叫罕 六轮枪强盗团 乌龟也会飞 飞屋环游记 狮子王 中华英雄 1999 冰川时代 2002 喜剧之王 1999 指环王 极恶非道123 日本 攻壳机动队 日本 无人知晓 1986 日本 这个男人来自地球 2007 第一滴血 轻松自由 2014 法国 普鲁士蓝的肖像 1986 日本 木乃伊归来 加勒比海盗1-5 夺宝奇兵 苏联女间谍 上帝也疯狂 魔诫坟场 1994 黑猫白猫 南斯拉夫 灿烂人生 意大利 盗钥匙的方法 日本 土拨鼠之日 黄金三镖客 动漫 大力士 1998 在下坂本 假面骑士初代 铁甲小宝 大力士 1998 tv 1-65台配 海绵宝宝 热带雨林的爆笑生活 监狱学园 银魂 校园迷糊大王 高野晶 日常 我的朋友很少 书 中国历史故事集 林汉达 月亮和六便士 缅甸岁月 动物农庄 ISBN 7-208-00425-0 1984 笑林广记 金瓶梅词话 细说中国历史全书 两个意达 源氏物语 静静的顿河`,``,`html`,`访问权限符`,`20240307183503-_java public 同包和跨包任意类 protected 同包任意类和跨包子类 default 同包任意类 private 当前类`,``,`html`,`谷歌地球的使用`,`20250320194610-_工具使用 网页版相比软件版渐变流畅一些,可以直接同步到drive 快捷键 n 返回正北视角 pgUp/pgDown 缩放 ←/→ 左右调整视角 shift+↑/↓ 上下调整视角 ? 显示快捷键列表 小键盘加号代替双击长距离前进 / * - + 7 8 6 5 4 9 3 2 1 0 . numlk enter Left Alt + Left Shift + Num Lock:启用鼠标键 控制面板\轻松使用\轻松使用设置中心\设置鼠标键:调整速度 /:切换为左键 -:切换为右键 *:同时选择左右两个按键 5:单击 +:双击 0:保持按下状态(点按一次,不必长按) .:保持释放状态(点按一次,不必长按)`,``,`html`,`豪勇七蛟龙`,`20240307183503-影摘 卡贝拉不愿杀枪手`,``,`html`,`走出非洲`,`20240307183503-影摘 我一直是一个神游的旅行家`,``,`html`,`递归嵌套`,`20240618093949-_模式算法 10转2进制 public static void main(String[] args) { StringBuffer result = new StringBuffer(); toBinary(11, result); System.out.println(result);//1011 } public static void toBinary(int n, StringBuffer result) { if (n / 2 != 0) toBinary(n / 2, result); result.append(n % 2); } 初始调用 toBinary(11, result)： 11 / 2 != 0 成立，递归调用 toBinary(5, result)。 5 / 2 != 0 成立，递归调用 toBinary(2, result)。 2 / 2 != 0 成立，递归调用 toBinary(1, result)。 1 / 2 != 0 不成立，递归终止。 回溯从最深层的递归调用开始 回溯到 toBinary(1, result)。执行 result.append(n % 2);将 1 % 2 = 1 添加到 StringBuffer result 中。 回溯到 toBinary(2, result)。执行 result.append(n % 2);将 2 % 2 = 0 添加到 StringBuffer result 中。 回溯到 toBinary(5, result)。执行 result.append(n % 2);将 5 % 2 = 1 添加到 StringBuffer result 中。 回溯到 toBinary(11, result)。执行 result.append(n % 2);将 11 % 2 = 1 添加到 StringBuffer result 中。 结束回溯,所有递归调用完成，result 中包含的内容即为 11 的二进制表示即 "1011"。 递归回溯 //第1个人10岁，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大 public void t1() { System.out.println(computeAge(8)); } public static int computeAge(int n) { if (n == 1) return 10; return computeAge(n - 1) + 2; } 初始调用 computeAge(8) 递归调用阶段： computeAge(8) 中 n != 1，因此返回 computeAge(7) + 2。 computeAge(7) 中 n != 1，因此返回 computeAge(6) + 2。 computeAge(6) 中 n != 1，因此返回 computeAge(5) + 2。 computeAge(5) 中 n != 1，因此返回 computeAge(4) + 2。 computeAge(4) 中 n != 1，因此返回 computeAge(3) + 2。 computeAge(3) 中 n != 1，因此返回 computeAge(2) + 2。 computeAge(2) 中 n != 1，因此返回 computeAge(1) + 2。 递归终止： computeAge(1) 中 n == 1，直接返回 10。 回溯阶段： 开始回溯，从最深层的递归调用开始。 computeAge(1) 返回 10。 回溯到 computeAge(2)，计算结果为 12，因为 computeAge(1) + 2 = 10 + 2。 回溯到 computeAge(3)，计算结果为 14，因为 computeAge(2) + 2 = 12 + 2。 回溯到 computeAge(4)，计算结果为 16，因为 computeAge(3) + 2 = 14 + 2。 回溯到 computeAge(5)，计算结果为 18，因为 computeAge(4) + 2 = 16 + 2。 回溯到 computeAge(6)，计算结果为 20，因为 computeAge(5) + 2 = 18 + 2。 回溯到 computeAge(7)，计算结果为 22，因为 computeAge(6) + 2 = 20 + 2。 最终回溯到 computeAge(8)，计算结果为 24，因为 computeAge(7) + 2 = 22 + 2。 跳出多重嵌套 @Test public void 使用标号() { ok: for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { System.out.println("i="+i+", j="+j); if (j==5) break ok; } } System.out.println("over"); } //推荐 @Test public void 不使用标号() { boolean b = false; //外部定义标志 for (int i = 0; i < 10 && !b; i++) { //受外部控制 for (int j = 0; j < 10; j++) { System.out.println("i="+i+", j="+j); if (j==5){ b = true; //改变外部值 break; } } } System.out.println("over"); }`,``,`html`,`金瓶梅词话`,`20240307183503-书摘 二八佳人体似酥，腰间仗剑斩愚夫。虽然不见人头落，暗里教君骨髓枯 一杯竹叶穿肠过，两朵桃花脸上来 朝登紫陌，暮践红尘 	 一洼死水全无浪， 也有春风摆动时 	 这蒋竹山不听便罢， 听了此言， 欢喜的满心痒， 不知搔处 泥佛劝土佛 纵使淘尽西江水,难洗往日一面羞 章台，荐枕 章台：章台街是汉代长安的一条繁华街道名，因位于章台（战国秦宫中台名）之下而得名。旧时这里多妓院，后世用为妓院等地的代称。据唐孟棨《本事诗》和许尧佐《柳氏传》载，唐天宝进士韩翃与名妓柳氏相狎，柳氏原为豪富李生之妾，后因柳氏瞩意韩翃，李生便慷慨“以柳荐枕于韩”为妻了。别后韩翃曾赠柳氏《章台柳》词，以词的首句“章台柳”为词调名。[1] [2] 小厮，帮闲 贼ze囚根子，贼狗骨头儿 若用一句话来描述明代的社会，那就是“男盗女娼”。男人去杀人放火，抢劫来钱财；女人通常和强盗上床的方式来分强盗抢来的一部分财产。有人说这是天然的男女分工。虽然没有人明确地说那个社会是“男盗女娼”，但大家潜意识中都是很明确地明白这一点。《金瓶梅》中的人物，无论男女好像都深知此点，也不管是好人坏人都明白。一个有趣的现象是：越是强盗的男人越喜欢骂别人是强盗；越是娼妇越喜欢骂别人说“淫妇”，连几岁的婴儿都不放过。好像这样他们才觉得是对对方最大的侮辱！ 金瓶梅》中骂男人通常加一“贼”字。《说文解字》中说：“贼，败也。从戈则声。”段玉裁在此注解说：“败者，毁也。左传叔向曰杀人无忌为贼。……，败贼皆从贝。会意。……，而非形声也。”这里是说，贼字是会意字，不是许慎说的形声字。用武器毁坏宝贝东西。用贼字形容人就是强盗。此字做“小偷”解是很晚的事。《金瓶梅》中来旺儿夜晚听见西门庆家喊捉贼，他立即出去帮忙，反倒被捉住，被诬为“贼”就是强盗的意思，不是小偷，说他欲去暗杀西门庆。 西门庆对待女人的骂法是“小油嘴儿”、“怪小油嘴儿”，大概是指会说漂亮话儿的意思。另外，他会说：“怪小肉儿”。这是西门庆被女人喜欢的一个原因。 令翠，汉语词语，旧时称谓，称别人所爱的妓女，出自《金瓶梅词话》 山石穿双龙戏水， 云霞映独鹤朝天。金屏灯、 玉楼灯见一片珠玑；荷花灯、 芙蓉灯散千围锦绣。绣球灯皎皎洁洁， 雪花灯拂拂纷纷。秀才灯揖让进止， 存孔孟之遗风；媳妇灯容德温柔， 效孟姜之节操。和尚灯月明与柳翠相连， 判官灯锺馗共小妹并坐。师婆灯挥羽扇假降邪神， 刘海灯背金蟾戏吞至宝。骆驼灯、 青狮灯驮无价之奇珍；猿猴灯、 白象灯进连城之秘宝。七手八脚螃蟹灯倒戏清波， 巨大口髯鲇鱼灯平吞绿藻。银蛾斗彩， 雪柳争辉。鱼龙沙戏， 七真五老献丹书；吊挂流苏， 九夷八蛮来进宝。村里社鼓， 队队喧阗；百戏货郎， 桩桩斗巧。转灯儿一来一往， 吊灯儿或仰或垂。琉璃瓶映美女奇花， 云母障并瀛州阆苑。王孙争看小栏下， 蹴鞠齐云；仕女相携高楼上， 娇娆炫色。卦肆云集， 相幄星罗：讲新春造化如何， 定一世荣枯有准。又有那站高坡打谈的， 词曲杨恭；到看这扇响钹游脚僧， 演说三藏。卖元宵的高堆果， 粘梅花的齐插枯枝。剪春娥， 鬓边斜插闹东风；祷凉钗， 头上飞金光耀日。围屏画石崇之锦帐， 珠帘绘梅月之双清。虽然览不尽鳌山景， 也应丰登快活年。 常言道：好子弟不嫖一个粉头， 天下钱眼儿都一样。 金炉添兽炭， 宝篆热龙涎。 西门庆只在房里走来走去， 忧上加忧， 闷上加闷， 如热地蜒蚰一般 又见竹山语言活动， 一团谦恭 秦晋之缘 只晓采花成酿蜜， 不知辛苦为谁甜。 正面丈五高， 周围二十板。当先一座门楼， 四下几间台榭。假山真水， 翠竹苍松。高而不尖谓之台， 巍而不峻谓之榭。四时赏玩， 各有风光：春赏燕游堂， 桃李争妍；夏赏临溪馆， 荷莲斗彩；秋赏叠翠， 黄菊舒金；冬赏藏春阁， 白梅横玉。更有那娇花笼浅径， 芳树压雕，弄风杨柳纵蛾眉， 带雨海棠陪嫩脸。燕游堂前， 灯光花似开不开；藏春阁后， 白银杏半放不放。湖山侧才绽金钱， 宝槛边初生石笋。翩翩紫燕穿帘幕， 呖呖黄莺度翠阴。也有那月窗雪洞， 也有那水阁风亭。香棚与荼蘼架相连， 千叶桃与三春柳作对。松墙竹径， 曲水方池， 映阶蕉棕， 向日葵榴。游渔藻内惊人，粉蝶花间对舞。 不想落后爹净手， 到后边亲看见粉头和一个蛮子吃酒， 爹就恼了 金莲道： “贼淫妇！我只道蜜罐儿长年拿的牢牢的， 如何今日也打了？ ” 西门庆把眼观看帘前那雪， 如撏绵扯絮， 乱舞梨花， 下的大了。端的好雪。 刚到仪门夹道内， 撞见西门庆， 说道： “你好人儿， 原来昨日人对你说的话儿， 你就告诉与人。今日教人下落了我恁一顿！我和你说的话儿， 只放在你心里， 放烂了才好。为甚么对人说？干净你这嘴头子就是个走水的槽。有话到明日不告你说了。 ” 西门庆道： “甚么话？我并不知道。 ” 那妇人瞅了一眼，往前边去了。 果然食烹异品， 果献时新。 月娘与众姊妹吃了一回， 但见银河清浅， 珠斗烂斑， 一轮团圆皎月从东而出， 照得院宇犹如白昼。 外作禽荒内色荒， 连沾些子又何妨。 早晨跨得雕鞍去， 日暮归来红粉香。 路上风霜， 多有辛苦！ 雪隐鹭莺飞始见， 柳藏鹦鹉语方知。 平生不作皱眉事， 世上应无切齿人。 数语拨开君子路， 片言提醒梦中人。 于是二人解佩露甄妃之玉， 齐眉点汉署之香， 双凫飞肩， 云雨一席。 世间好物不坚牢， 彩云易散琉璃脆。 歌舞欢娱嫌日短， 故烧高烛照红妆。 自古养儿人家热腾腾， 养女人家冷清清 果然好座庙宇。但见： 青松郁郁， 翠柏森森。金钉朱户， 玉桥低影轩官；碧瓦雕檐，绣幕高悬宝槛。七间大殿， 中悬敕额金书；两庑长廊， 彩画天神帅将。三天门外， 离娄与师旷狰狞， 左右阶前， 自虎与青龙猛勇。八宝殿前， 侍立是长生玉女， 九龙床上， 坐着个不坏金身。金钟撞处，三千世界尽皈依；玉磬鸣时， 万象森罗皆拱极。朝天阁上， 天风下步虚声；演法坛中， 夜月常闻仙佩响。自此便为真紫府， 更于何处觅蓬莱 白露点苍苔 星月当空万烛烧， 人间天上两元宵。 乐和春奏声偏好， 人蹈衣归马亦娇。 易老韶光休浪度， 最公白发不相饶。 千金博得斯须刻， 吩咐谯更仔细敲 穿青衣，抱黑柱 西门庆道：“到那日，好歹把春花儿那奴才收拾起来，牵了来我瞧瞧。” 于是八个人猜枚饮酒。敬济道： “你每休猜枚， 大惊小怪的， 惹后边听见。咱不如悄悄行令儿耍子。每人要一句， 说的出免罚， 说不 出罚一大杯。 ” 该傅伙计先说： “堪笑元宵草物。 ” 贲四道： “人生欢乐有数。 ” 敬济道： “趁此月色灯光。 ” 来保道： “咱且休要辜负。 ” 来兴道： “才约娇儿不在。 ” 书童道： “又学大娘吩咐。 ” 玳安道： “虽然剩酒残灯。 ” 平安道： “也是春风一度。 ” 众人念毕， 呵呵笑了。 得意客来情不厌， 知心人到话相投。 吴月娘众人便回家来。潘金莲路上说： “大姐姐， 你原说咱每送他家去， 怎的又不去了？ ” 月娘笑道： “你也只是个小孩儿， 哄你说耍子儿，你就信了。丽春院是那里， 你我送去？ ” 金莲道： “像人家汉子在院里嫖了来， 家里老婆没曾往那里寻去？寻出没曾打成一锅粥？ ” 月娘道： “你等他爹到明日往院里去， 你寻他寻试试。倒没的教人家汉子当粉头拉了去， 看你——” 两个口里说着， 却说西门庆， 在门首与伯爵众人饮酒将阑。伯爵与希大整吃了一日， 顶颡吃不下去， 见西门庆在椅子上打盹， 赶眼错把果碟儿都倒在袖子里， 和韩道国就走了。只落下贲四， 陪西门庆打发了乐工赏钱。吩咐小厮收家火， 熄灯烛， 归后边去了。只见平安走来， 贲四家叫道： “你们还不起身， 爹进去了。 ” 玉箫听见， 和迎春、 兰香慌的辞也不辞， 都一溜烟跑了。只落下春梅， 拜谢了贲四嫂， 才慢慢走回来。看见兰香在后边脱了鞋赶不上， 因骂道： “你们都抢棺材奔命哩！把鞋都跑脱了， 穿不上， 象甚腔儿！ ” 到后边， 打听西门庆在李娇儿房里， 都来磕头。 大师父见西门庆进入李娇儿房中， 都躲到上房， 和小玉在一处。玉箫进来， 道了万福， 那小玉就说玉箫： “娘那里使小厮来要皮袄， 你就不来管管儿，只教我拿。我又不知那根钥匙开橱门， 及自开了又没有， 落后却在外边大橱拒里寻出来。你放在里头， 怎昏抢了不知道？姐姐每都吃勾来了罢， 几曾见长出块儿来！ ” 玉箫吃的脸红红的， 道： “怪小淫妇儿， 如何狗挝了脸似的？人家不请你， 怎的和俺们使性儿！ ” 小玉道： “我稀罕那淫妇请！ ” 大师父在旁劝道： “姐姐每义让一句儿罢， 你爹在屋里听着。只怕你娘们来家， 顿下些茶儿伺候。 一宿晚景题过。 花枝叶下犹藏刺， 人心怎保不怀毒。 常言道：火到猪头烂， 钱到公事办。 金莲道： “小道士儿， 你也与姐夫亲个嘴儿。 ” 可霎作怪， 那官哥儿便嘻嘻望着他笑。敬济不由分说， 把孩子就搂过来， 一连亲了几个嘴。金莲骂道： “怪短命， 谁家亲孩子， 把人的鬓都抓乱了！ ” 敬济笑戏道： “你还说， 早时我没错亲了哩。 ” 金莲听了， 恐怕奶子瞧科， 便戏发讪， 将手中拿的扇子倒过柄子来， 向他身上打了一下， 打的敬济鲫鱼般跳。骂道： “怪短命， 谁和你那等调嘴调舌的！ ” 敬济道： “不是， 你老人家摸量惜些情儿。人身上穿着恁单衣裳， 就打恁一下！ ” 金莲道： “我平自惜甚情儿？今后惹着我， 只是一味打 公道人情两是非， 人情公道最难为。 若依公道人情失， 顺了人情公道亏。 羞看鸾镜惜朱颜， 手托香腮懒去眠。 瘦损纤腰宽翠带， 泪流粉面落金钿。 薄幸恼人愁切切， 芳心缭乱恨绵绵。 何时借得东风便， 刮得檀郎到枕边。 敬济云情未已， 金莲雨意方浓。 伯爵便道： “多少古人轻财好施， 到后来子孙高大门闾， 把祖宗基业一发增的多了。悭吝的， 积下许多金宝， 后 来子孙不好， 连祖宗坟土也不保。可知天道好还哩！ ” 西门庆道： “兀那东西， 是好动不喜静的， 怎肯埋没在一处！也是天生应人用的， 一个人堆积， 就有一个人缺少了。因此积下财宝， 极有罪的。 ” 慈悲作善豪家事， 保福消灾父母心。 猛抬头儿见了敬济， 就是猫儿见了鱼鲜饭一般， 不觉把一天愁闷都改做春风和气。 但见盘堆异果， 酒泛金波， 十分齐整。 看官听说：潘金莲见李瓶儿有了官哥儿， 西门庆百依百随， 要一奉十， 故行此阴谋之事， 驯养此猫， 必欲唬死其子， 使李瓶儿宠衰， 教西门庆复亲于己。就如昔日屠岸贾养神獒害赵盾丞相一般。正是：花枝叶底犹藏刺， 人心怎保不怀毒。 须臾， 酒过五巡， 食割三道， 下边乐工吹打弹唱， 杂耍百戏过去， 席上觥筹交错。应伯爵、 谢希大飞起大钟来， 杯来盏去。 求人须求大丈夫， 济人须济急时无。 一切万般皆下品， 谁知恩德是良图。 心中无限伤心事， 付与黄鹂叫几声。 天不言而自高， 地不言而自厚。 西门庆不听便罢， 听了如刀剜肝胆、 剑锉身心相似 流泪眼观流泪眼， 断肠人送断肠人。 常言道： ‘宁可折本，休要饥损。 居之齐则齐声， 居之楚则楚声。 月有盈亏， 花有开谢。想人生最苦离别。花谢了， 三春近也；月缺了， 中秋到也；人去了， 何日来也？ 迩者， 安凤山书到， 方知老亲家有鼓盆之叹 人生有酒须当醉， 一滴何曾到九泉。 自古长者赐， 少者不敢辞。 西门庆笑的两眼没缝儿， 伯爵道： “我头里不说的，我愁甚么？死了一个女儿会拣泡螺儿孝顺我， 如今又钻出个女儿会拣了。偏你也会寻， 寻的都是妙人儿。 ” 西门庆笑的两眼没缝儿， 赶着伯爵打， 说： “你这狗才， 单管只胡说。 ” 温秀才道： “二位老先生可谓厚之至极。 ” 伯爵道： “老先儿你不知， 他是你小侄人家。 ” 西门庆道： “我是他家二十年旧孤老。 ” 陈敬济见二人犯言， 就起身走了。那温秀才只是掩口而笑。 西门庆问： “甚么话？ ” 那爱月又想了想说： “我不说罢。若说了， 显的姐妹每恰似我背地说他一般， 不好意思的。 ” 西门庆一面搂着他脖子说道： “怪小油嘴儿， 甚么话？说与我， 不显出你来就是了。 ” 西门庆道： “够了。我明日还要起早， 衙门中有勾当。应二哥他没事， 教他大坐回儿罢。 ” 那伯爵就要跟着起来， 被黄 四使力拦住， 说道： “我的二爷， 你若去了， 就没趣死了。 ” 伯爵道： “不是， 你休拦我。你把温老先生有本事留下， 我就算你好汉。 ” 那温秀才夺门就走， 被黄家小厮来定儿拦腰抱住。 那郑月儿拉着西门庆手儿悄悄捏了一把， 说道： “我说的话， 爹你在心些， 法不传六耳。 ” 家中田连阡陌， 米烂成仓， 西门庆道： “我知道。你明日先去， 不可离寸地， 我也依期而至。 那日太师在内阁还未出来， 府前官吏人等如蜂屯蚁聚， 挤匝不开。 初入芦苇， 不知深浅， 玉宇微茫霜满襟， 疏窗淡月梦魂惊。 凄凉睡到无聊处， 恨杀寒鸡不肯鸣。 管情消不得吹嘘之力，一箭就上垛。 ” 富贵如朝露， 交游似聚沙。不如竹窗里， 对卷自趺跏。 静虑同聆偈， 清神旋煮茶。惟忧晓鸡唱， 尘里事如麻。 风火散时无老少， 溪山磨尽几英雄！ 如今犯夜的倒拿住巡更的。我倒容了人， 人倒不肯容我。 他活埋惯了人， 今日还要活埋我哩。 罗浮仙子临凡世， 月殿婵娟出画堂。 又访得左参议冯廷鹄， 伛偻之形， 桑榆之景， 形若木偶， 尚肆贪婪； 但见灯市中车马轰雷， 灯球灿彩， 游人如蚁，十分热闹 襄王台下水悠悠， 一种相思两样愁。 月色不知人事改， 夜深还到粉墙头。 看官听说， 院中唱的， 以卖俏为活计， 将脂粉作生涯；早辰张风流，晚夕李浪子；前门进老子， 后门接儿子；弃旧怜新， 见钱眼开， 自然之理。饶君千般贴恋， 万种牢笼， 还锁不住他心猿意马。不是活时偷食抹嘴， 就是死后嚷闹离门。不拘几时， 还吃旧锅粥去了。正是：蛇入筒中曲性在， 鸟出笼轻便飞腾。有诗为证： 堪笑烟花不久长， 洞房夜夜换新郎。 两只玉腕千人枕， 一点朱唇万客尝。 造就百般娇艳态， 生成一片假心肠。 饶君总有牢笼计， 难保临时思故乡 势败奴欺主， 时衰鬼弄人。 未免害些木边之目， 田下之心。 洗净了终是染污， 成就了倒是风流 薛嫂道： “他教你回个记色与他， 或写几个字儿稍了去， 方信我送的有个下落 自古好男不吃分时饭， 好女不穿嫁时衣。 小玉道： “你看， 谁人保得常无事！虾蟆、 促织儿， 都是一锹土上人。兔死狐悲， 物伤其类。 到次日， 饭时已后， 月娘埋伏了丫鬟媳妇七八个人， 各拿短棍棒槌。使小厮来安儿请进陈敬济来后边， 只推说话。把仪门关了， 教他当面跪下， 问他： “你知罪么？ ” 那陈敬济也不跪， 转把脸儿高扬， 佯佯不采。月娘大怒， 于是率领雪娥并来兴儿媳妇、 来昭妻一丈青、 中秋儿、小玉、 绣春众妇人， 七手八脚， 按在地下， 拿棒槌短棍打了一顿。西门大姐走过一边， 也不来救。打的这小伙儿急了， 把裤子脱了， 露出那直竖一条棍来。唬的众妇人看见， 却丢下棍棒乱跑了。月娘又是那恼， 又是那笑， 口里骂道： “好个没根基的王八羔子！ ” 敬济口中不言， 心中暗道： “若不是我这个法儿， 怎得脱身。 ” 于是扒起来， 一手兜着裤子， 往前走了 孙雪娥跳上炕， 撅救了半日， 舀姜汤灌下去， 半日苏醒过来。月娘气堵心胸， 只是哽咽， 哭不出声来。奶子如意儿对孟玉楼、 孙雪娥， 将敬济对众人将哥儿戏言之事， 说了一遍： “我好意说他， 又赶着我踢了两脚， 把我也气的发昏在这里。 ” 雪娥扶着月娘， 待的众人散去， 悄悄在房中对月娘说： “娘也不消生气， 气的你有些好歹， 越发不好了。这小厮因卖了春梅， 不得与潘家那淫妇弄手脚， 才发出话来。如今一不做， 二不休， 大姐已是嫁出女， 如同卖出田一般， 咱顾不得他这许多。常言养虾蟆得水蛊儿病， 只顾教 那小厮在家里做甚么！明日哄赚进后边， 下老实打与他一顿， 即时赶离门， 教他家去。然后叫将王妈妈子来， 把那淫妇教他领了去， 变卖嫁人， 如同狗臭尿， 掠将出去， 一天事都没了。平空留着他在家里做甚么！到明日， 没的把咱们也扯下水去了。 ” 月娘道： “你说的也是。 ” 当下计议已定了。 由不的发似人揪， 肉如钩搭。 月娘道： “小肉儿， 还恁说白道黑道。他一个佛家之子， 你也消受不的他这个问讯。 ” 小玉道： “奶奶， 他是佛爷儿子， 谁是佛爷女儿？ ” 月娘道： “相这比丘尼姑僧， 是佛的女儿。 ” 小玉道： “譬若说， 相薛姑子、 王姑子、 大师父， 都是佛爷女儿， 谁是佛爷女婿？ ” 月娘忍不住笑， 骂道： “这贼小淫妇儿， 也学的油嘴滑舌， 见见就说下道儿去了。 ” 小玉道： “奶奶只骂我， 本等这秃和尚贼眉竖眼的只看我。 ” 孟玉楼道： “他看你， 想必认得你， 要度脱你去。 ” 小玉道： “他若度我， 我就去。 ” 说着， 众妇女笑了一回。月娘喝道： “你这小淫妇儿， 专一毁僧谤佛。 ” 那和尚得了布施， 顶着三尊佛扬长而去了。小玉道： “奶奶 还嗔我骂他， 你看这贼秃， 临去还看了我一眼才去了。 ” 行见梅花腊底， 忽逢元旦新正。 不觉艳杏盈枝， 又早新荷贴水。 当下直吃到炎光西坠、 微雨生凉的时分。 风拂烟笼锦绣妆， 太平时节日初长。 能添壮士英雄胆， 善解佳人愁闷肠。 三尺晓垂杨柳岸， 一竿斜插杏花旁。 男儿未遂平生志， 且乐高歌入醉乡。 想必在柳陌花街行踏， 如梦幻泡影， 如电复如露`,``,`html`,`铁齿铜牙纪晓兰`,`20241105185513-影摘 疾风知劲草, 板荡见忠臣 和珅：说实话这酒只能与知音分享。 纪昀：堂堂和大人，你的知音会在牢里？ 和珅：三国时，曹操煮酒论英雄，他对刘备说，天下英雄，唯使君与操耳。今夜和某有同感哪。 纪昀：和大人，大奸与大善岂能并列。你这是夸我呢，还是损我呢。 和珅：行……君忠我奸，君廉我贪，君贤我恶，行吧？天下清名被你占光，天下恶名被我占光。那你我岂能不饮上一杯呀。 纪昀：好，饮上一杯。 纪昀：和大人，咱们还是得说点正事吧。 和珅：说。 纪昀：燕城这帮贪官哪，把人吃的粮食换成了牲口吃的麸糠和草料，这件事儿和大人可知道？ 和珅：我知道。 纪昀：那和大人不觉得惭愧吗？ 和珅：我倍觉欣慰。 纪昀：为什么？ 和珅：纪先生有所不知啊，这一斤口粮啊，可以换三斤麸糠。这就等于原本能救活一个人的粮食现在可以救活三个人了。 纪昀：可麸糠是给牲口吃的不是给人吃的。 和珅：哎呀，灾民还算人吗？ 纪昀：你说什么？ 和珅：你不要把眼镜瞪那么大。你知道不知道，行将饿死的人已经不是人了。那就是畜生，只要能活着，还什么麸糠啊，那是好东西。草根，树皮，泥土都可以吃。 纪昀：此话出自堂堂和大人之口真是令人震惊。 和珅：你当然感到震惊，你是一介书生，你只会在书斋里手捧圣贤书骂骂当朝者而已。 纪昀：当朝者不公自当抨击。 和珅：你干嘛火气这么大？来来来，喝酒，喝酒。 和珅：纪先生，你见过这个吃观音土活活涨死的人吗？ 纪昀：什么是观音土啊？ 和珅：你看看，你不知道，我再问你，你见过这千里平原所有树木的树皮都被啃光的情形吗？易子而食，你当然听说过，那是史书上的四个字而已。我是亲眼见过的呀，这换孩子吃啊，就是锅里的一堆肉。 纪昀：你…… 和珅：你以为我毫无人性是不是？你以为我只知道贪钱敛财是不是？我亲自到灾区去过，到那一看我心都凉了，我这才知道，不管朝廷发下多少救灾的粮食，永远也不够。如果我不设法变通一下，那你在灾区看到的就不是灾民，而是白骨喽。 纪昀：这……赈灾的粮款不够，可以向朝廷再请求拨放吗？ 和珅：朝廷？你知道国库还剩多少银子？你不知道，你根本就不知道，征大小金川，平准噶尔部，眼下国库就是个空壳子了，你知道不知道？ 纪昀：可朝廷还是发了赈灾粮款了。我看了他们的账本，所有的赈灾粮款全都进了这个薛大老板的钱庄了。 和珅：可不能这么说啊！薛大老板可是个神通广大的人，一文钱进去二文钱出来。我这才有足够的钱去救济灾民呐。 纪昀：我看了他们的账本了，大大小小的官员全都在侵吞这救灾的粮款。 和珅：救民先救官，官都活不了，还救什么民？ 纪昀：荒唐。 和珅：这是事实。千千万万的灾民哪。谁去发给他们赈灾粮款？是你发？还是我发？还不是得靠那些大大小小的官员？喂饱了他们，他们才肯给我去卖命。 纪昀：真乃旷古之谬论。贪污受贿既然还有了大道理。 和珅：这是几十年官宦生涯换来的大道理，这是千千万万血淋淋的事实换来的金道理呀纪先生。他……你怎么就不懂呢你？ 纪昀：食君俸，为君分忧，点点滴滴皆是民脂民膏，和大人，你怎么忍心在这饥民的口中去抠出一粒粮食呢。 和珅：又来了，行……喝酒……稍安勿躁，喝酒 和珅：官字怎么写？上下两个口，先要喂饱上面一个口，才能再去喂下面一个口。 纪昀：宋有包公，明有海瑞，康熙朝有施公，代代清官，愧杀大人也。 和珅：对……清官的确令人敬佩，可清官也令人畏呀。 纪昀：和大人，您就是无敬无畏。所以才无法无天了。 和珅：那我问你，古往今来多少清官多少贪官？ 纪昀：清官如凤毛麟角，贪官如黄河之沙。 和珅：对呀，那我不依靠他们我依靠谁呀?我这个军机大臣，要是没有他们撑着，那就是个屁，我容易吗？ 纪昀：好……和大人 和珅：倒酒…… 纪昀：喝酒……喝酒…… 武则天重用狄人杰, 却没有放弃来俊臣, 明嘉靖用海瑞, 却还重用严嵩 都胡子一把的人了还作小女儿状 真是人无伤虎意, 虎有害人心啊 既然你已经上了房了, 那我就该撤梯子了 家父痴龄八十 当断不断, 必受其乱 鹿死谁手, 还未可知 水寒伤马腿, 大雪满弓刀 饮马长城窟，水寒伤马骨 欲将轻骑逐，大雪满弓刀 这就叫做黄瓜找案板, 找拍呢 你真是看西厢流泪, 替古人担忧 苏（拜见）：和大人 和：和某想起与姑娘在湖边初见，恍如隔世。苏姑娘看着有几分清瘦，和某心里很不是滋味啊！ 和某今晚请姑娘来，是想跟你说说真心话。 苏：难道除了我，和大人就不说真心话了吗？ 和：少之又少啊。我何某是个俗人，在官场混了这么多年，所谓真心已经所剩无几了。可叹、可悲呀！ 苏：和大人能这么说，可见并非是俗人啊。 和：多谢姑娘，和某此生还是第一次有人这样来评价我。一般人都说我弄权敛财，是个不学无术之辈，只靠巴结皇上而已啊。 苏：只怕未必如此。 和：知我心者，苏姑娘也。想我和珅儿时到宫里读书。说起来好听，其实也是十年寒窗苦啊！而且穷得叮当山响，时常招人白眼。二十几岁的时候，承蒙皇上恩眷，几年间平步青云，由一个三等侍卫直至军机大臣、户部尚书，兼管内务府，且入阁为大学士。我光靠巴结，行吗？当今皇上可一点儿都不糊涂。 苏：是啊，要会办事，能理财。要有人怕，有人捧，当然就免不了遭人骂了。 和：姑娘说的太对了，而且最主要的是任何一件事都要办得让皇上顺心才是。恕我直言，伴君如伴虎啊！ 苏：说来也真不容易啊！ 和：姑娘说的极是，实在是太不容易了。人生啊，就像是唱戏。每个人都在戏台上扮演着一个角色。要说你该说的话，要唱你该唱的腔，要摆出你该摆的身段。高兴的时候，你得哈哈大笑，甭管你心里有多苦；需要哭的时候，你真得抹眼泪，甭管你心里多高兴。为什么，角色管着你呢。 苏：那么说，比我们这些苦命女子还苦了。 和：可以这样说。真命苦的，因为他知道自己苦，那么万一得了一点点甜头，他都会非常高兴。而我则不然。苦乐我已经分不清了，真假也闹不明了。 苏：和大人的这番表白，想必也是如此了？ 和：透彻，真的是透彻！姑娘，有一部红楼奇书，其中有一副对子这样写的：“假作真时真亦假，无为有处有还无。”其实这真假有无，苦乐生死，本来就是纠缠不清的。 苏：和大人可以学道谈禅了？ 和：姑娘，可别取笑我。我这个人早已是神仙不理，佛祖不收了，只是谈一点人生感受而已。 苏：但不知你和那天来的纪晓岚相比又如何呢？别想，直说。 和：好，好，他比我才学高，我比他本事大，我比他坏，他比我快，斗口舌我常吃亏，不过做起事来…… 苏：他占不到丝毫便宜？ 和：苏姑娘慧眼，真是慧眼哪！ 苏：大人的来意我已经明白了。 和：姑娘别急，我还没有说完……我刚才讲了，在我这，所谓真心已经所剩无几了。那反过来说还有那么一丁点，尽管也已经不明不白了。但是我特别想保住这一丁点真心。怎么说呢？姑娘，何某经常在外边滚了一身泥巴回到家里，却特别想有一个，有一个人能够跟她说说过心的体己话，洗掉我这身臭泥巴。不要以为何某是个贪恋美色之徒啊，如果是那样的话，很容易的。此刻，我只想求一个红颜知己而已呀。 我知道对我和珅而言，要压倒千百个大男人容易，但是要想求得苏姑娘这样一个女子的真心，难呀。苏姑娘如果想更进一步，何某求之不得；如果不情愿，我绝不强求。（完） 阎罗殿前一副对子, 写的是有心为善, 虽善不赏, 无心作恶, 虽恶不罚, 这比人间律令境界高多了, 它直指人心 非让猴子不爬树, 难 山坡远望像馒头, 绿树筷子插上头, 湖水舀来一盆汤, 美景恨不咬一口 燕雀不知鸿鹄之志 瘦田无人耕, 耕开有人争 天下本无事, 庸人自扰之 佛有心渡人, 人无意脱身 礼佛不供佛 交通嘱托贿卖 不错, 我是相信西方极乐, 也相信因果报应, 可是到底是此间乐, 还是西方乐, 这谁也说不清楚, 我总不能拿谁也没见过的东西, 来赌我这一生吧 有过宝山空手而归之叹啊 赠别. 杜牧. 多情却似总无情，惟觉樽前笑不成。蜡烛有心还惜别，替人垂泪到天明 无利不起早 如果给自己找一个合适的理由, 就可以唯私欲是从的话, 那这天底下哪还会有好人呢 令一：【香令人幽】 道是深山静寂处，花开花谢花韵收。 冬日雪尽微香至，清净世界心自幽。 令二：【酒令人远】 樽中之物人皆欢，推杯换盏兴愈酣。 奈何醉后言伤人，纵是兄弟亦破颜。 令三：【石令人隽】 剪罢青田裁寿山，镌磨冲切镂华年。 刀锋斩定乾坤事，朱白辉映天地间。 令四：【琴令人寂】 一掬清香谱入琴，丝竹瑟瑟谁人听？ 子期伯牙成旧忆，断弦总为少知音。 令五：【茶令人爽】 秀地灵天已千年，舌端噙香苦且甘。 轻品笑谈红尘事，一盏清茶沁心间。 令六：【竹令人冷】 傲骨瘦影风中荡，独立林深露凝光。 疏竹摇月炎凉意，一曲情愫乐未央。 令七：【月令人孤】 抚罢清弦曲韵散，一轮孤月徊中天。 有道嫦娥心怀恨，不让人间共婵娟。 令八：【棋令人闲】 信步黑白经纬间，轻敲落子夜阑珊。 茶淡如水生平事，闲棋无争天地宽。 令九：【杖令人轻】 天涯行脚山水程，随云伴月逍遥行。 竹杖芒鞋轻胜马，一蓑烟雨任平生。 令十：【水令人空】 枫叶飘零已入秋，流水落花愁更浓。 匆匆多少红尘客，心若止水万事空。 令十一：【雪令人旷】 千山鸟飞绝，万径人踪灭。 孤舟蓑笠翁，独钓寒江雪。 令十二：【剑令人悲】 疆场遍洒英雄血，弹剑声声如悲咽。 一将成名万骨埋，千秋功册谁评阅？ 令十三:【蒲团令人枯】 红尘禅者多如烟，惟有高僧能涅磐。 世人慨叹修行枯，哪知天地一蒲团。 令十四：【美人令人怜】 美人自古英雄怜，奈何春尽老红颜。 若使卿家怜到底，只须遇上好心人。 或 自古美人让人怜，一幽二叹思华年。 奈何春尽红颜老，只留悲情妆镜前。 令十五：【僧令人淡】 闲看世间百态生，笑谈名利云烟空。 修得宁静淡泊志，佛家偈语留心中。 令十六：【花令人韵】 万物有情便有韵，花韵当为其中尊。 微香暗送风雅味，留与墨客细品评。 令十七：【金石鼎彝令人古】 轻抚鼎彝追前事，展卷若闻金石声。 幽思怀古三分意，便觉人物两沧桑。 大公鸡喔喔叫, 小猫小猫蹦蹦跳 阎王好斗, 小鬼难缠 雪花, 寒友 墙倒众人推, 破鼓万人捶 这死的事儿啊, 活着的人没有一个说得清楚的, 不知死所以不怕死 生者, 寄也. 死者, 归也 纵有千金铁门槛, 终须一个土馒头 抛砖引玉 姑娘，姑娘，别害怕，我跟你说两句话 人生不满百，常怀千岁忧，留得五湖明月在，不愁无处下金钩 总而言之, 言而总之, 未雨绸缪胜过临渴而掘井 出了名的弯弯绕 苦瓜地里种黄连, 苦上加苦 就这么狗占八泡屎似的占着 风流阵里的急先锋 极为自得 破鼓乱捶 敲山震虎 螺丝壳里做道场 张了了 虱子多了不咬, 帐多了不愁 九牛之一毛, 大海之一勺, 天地之间一秋叶 小时不识月, 呼作白玉盘 箭无回头 朝闻道, 夕可死 水可干而不可夺其湿, 火可灭而不可夺其热, 石可破而不可夺其坚 美人美矣, 可您要拿这美当称砣称东西跟别人换, 那就是脏 君子不畏虎, 独畏谗夫之口 这世界若不是纪某看到的那个世界, 那这世界在哪儿呢 市井光棍 众口铄金, 三人市虎 三个人都说街市上有老虎，别人便以为真有老虎。后遂以“三人成市虎”比喻谣言一再反复，就会使人信以为真。 亦简称“市虎”。 先生看的世界是您的世界, 我看的世界是我的世界, 你看的世界跟我看的世界不一样, 我又何必生气呢 唯女子与小人为难养也, 近之则不逊, 远之则怨 你这不睁眼就知道谁来了啊, 您这往后要是眼睛瞎了也不碍事儿啊 时迁之术 时迁，古典小说《水浒传》中的人物。一百单八将之一，绰号“鼓上蚤”，高唐州人氏。盗贼出身，在与杨雄、石秀投奔梁山途中，因偷鸡被祝家庄包围活捉，引出梁山三打祝家庄。 诗三百, 始终于周, 那个时候的人啊, 平和, 单纯, 高兴了就唱, 不高兴了人就发愁, 高兴了写诗, 发愁了也写诗, 写了就大声念出来, 单纯, 敞亮 是啊, 先生说得对, 恨不退回三千年 说实话, 在琳琅小姐这件事上啊, 先生若头顶着雷鸣闪电, 去李树下摘那颗被恶犬看着的西瓜, 我身后头还有十个小人拿刀顶在我腰眼儿上, 先生也是人, 先生要在这夹缝之中把事办成, 有些事不能不做, 有些事又不能寻常地去做, 先生要在这无奈中, 求变量, 说实话, 先生绝不是你的先生 风声, 雨声, 涛声, 溪声, 鸟声, 松声, 读书声, 纺织声, 细心听之, 均是入耳之音 牛背笛声, 伐木声, 采莲歌声 小儿声, 月下歌声, 雪洒窗声 洒槽滴声 四壁虫声 新箍的马桶还香三天呢 大河有水小河满, 大河没水小河干 大觉寺 20241116203212.webp 庙中三日, 尘世半载 不聋不瞎，不配当家 人不要对人太过苛刻，人都是不完美的，要懂得睁一只眼闭一只眼。 足尺加三 秋入郊原粟正肥, 山禽成队啄余晖 三分春色描来易, 一段伤心画出难 江山易主, 国号更张 和: 此话怎讲 赛: 人在地上走时, 总觉得高处有风景, 真要到了高处, 想不到亦步亦趋, 夜夜怕闪失, 天天愁摔死, 又想回到地下了, 多平整, 多辽阔啊, 又想下来了 和: 唉, 这下来也不是那么容易呀 赛: 下倒好下, 只要真要下的时候, 又有些舍不得了 和: 哎呀, 你这话说得可真对心啊, 你把我半辈子想说的话, 一下子全说出来了, 花红姑娘, 我, 一辈子给你扫地如何 别人慢走跟着慢走，别人快走也跟着快走（步：慢走；趋：快走）。比喻没有主见或为了讨好，事事追随或模仿别人。 君子慎独 楼台会 这不是明摆着耗子给猫捋胡子吗 旱的旱死, 涝的涝死 你要是长出毛来, 可真是比猴还精 但有假诗文, 却无假情诗 和大人, 你是怕人家说了真话, 你那点土盖不住屎了吧 大事大约, 小事小心 二桃杀三士 他是出了窑的砖他都定了型了, 他就这样了他`,``,`html`,`镜花缘`,`20240307183503-书摘 将来如有此事，即罚百花仙子在广寒殿打扫落花三年 话说麻姑闻百花仙子之言，不觉笑道：“你既要骗我酒吃，又斗我围旗，偏有这些尖嘴薄舌的话说！我看你只怕未必延龄，反要促寿哩。若讲著棋，我虽喜同你著，却又嫌你……”百花仙子道：“这却为何？”麻姑道：“我喜你者：因你棋不甚高，臭的有趣，同你对著，可以无须用心，即可取胜，所谓‘杀屎棋以作乐’颇可借此消遣。无如你棋品平常，每每下到半盘，看势头不好，不是一掳，就想推故要走。古人云：”未角智，先练品。‘谁知你是未角智，先练掳，又练走。所以我又嫌你。 天下没有场外的举子 归期未卜 原来此处风俗，因正月甚冷，过年无趣，不如八月天高气爽，不冷不热，正好过年，因此把八月初一日改为元旦，中秋改为上元。此时正是元宵佳节，所以热闹。 谦默自守，不求显扬。 风神秀伟，该通经史，允文允武，时论尚之。苻坚委以心膂之任，备历显职，皆有政闻。 昔人云：”无云之月，有目者所快睹也，而盗贼所忌； 那大虫连撺带跳，朝下走来。看看相离不远，眼睛忽然放出红光，把尾竖起，摇了两摇，口内如山崩地裂一般，吼了一声，将身一纵，离地数丈，竟自迎头扑来。二人忙举宝剑，护住头顶。耳内只闻一阵风声，那大虫自从头上撺了过去。二人把头摸了一摸，喜得头在颈上，慌忙扭转身躯看那大虫。原来身后有个山羊在那里吃草，却被大虫看见，扑了过去，就如鹰拿燕雀一般，抱住山羊，张开血盆大口，羊头吃在腹内； 话未说完，只听碗盏一片声响，那妇人早把筵席掀翻，弄了大盗一身酒菜，房中所有器具，撂的满天飞舞。 正是桃杏初开，柳芽吐翠，一派春光，甚觉可爱。 一路晓行夜住，这日到了长安。 ”小春道：“妹子赌个誓：如要骗你，教我日后遇见一只狗把脚咬出血来！” 密密层层，好不热闹。 姊妹六人，都生得丽品疑仙，颖思入慧 个个都是妖同艳雪，慧比灵珠 花开两朵，各表一枝 霄壤之别 文不起草，走笔立就 天时尚早，尽可从容。 掌红珠道：“姐姐莫忙。适因‘成仙了道’之话，倒想起一个笑话：一人最喜饮酒，并且非肉不饱，每日惟以赌钱消遣。一日，遇见仙人，叩求长生之术。 仙人道：“看你骨格，乃有根基之人。我有仙丹一粒，你拿去服过之后，即可长生不老。但有几件禁戒之事必须牢记，设或误犯，虽服仙丹，也是无用。‘此人接过仙丹道：”请教所戒何事？’仙人道：“只得七个字：戒酒除荤莫赌钱。‘此人思忖良久，把仙丹退还道：”这有何趣！’兰言笑道：“以此而论：放著现成仙丹还要退回，你若教他苦修，岂不难么！” 题花道：“我因春辉姐姐才说醉死之话，却想起一个笑话：一人最好贪杯。 这日正吃的烂醉，那知大限已到，就在醉中被小鬼捉去。来立冥官殿上，冥官正要问话，适值他酒性发作，忽然大吐，酒气难闻。冥官掩鼻埋怨小鬼道：“此人如此大醉，为何捉来？急速放他回去。‘此人还阳，只见妻妾儿女都围著恸哭，连忙坐起道：”我已还魂，不必哭了。快拿酒来！’妻妾见他死而复生，不胜之喜，一齐劝道：“你原因贪杯太过，今才活转，岂可又要饮酒！‘此人发急道：’你们不知，只管快些多多拿来，那怕吃的人事不知，越醉越好。‘妻妾道：”这却为何？’此人道：“你不晓得，我如果醒了，就要死了。‘”兰言笑道：“过于明白，原非好事，倒是带些糊涂最好。北方有句俗语，叫做’憨头郎儿增福延寿‘；又道’不痴不聋，不作阿家翁‘。这个笑话，细细想去，却很有意味。” 《庄子》吾惊怖其言，犹河汉而无极也。 紫绡道：“若以人情事务而论：贤妹自直把伯伯寻来，夫妻父子团圆，天伦乐聚，方了人生一件正事。但据咱想来：团圆之后，又将如何？乐聚之后，又将如何？ 再过几十年，无非终归于尽，临期谁又逃过那座荒丘？咱此番同你前去另有痴想，惟愿伯伯不肯回来，不独贤妹可脱红尘，连咱也可逃出苦海了。“闺臣忖道：”怪不得碑记说他‘幼谙剑侠之术，长通元妙之机’，果然竟有道理。“连忙说道：”姐姐即如此立意，与妹子心事相合，就请明日过来，以便同行。`,``,`html`,`长河东流`,`20250505120324-影摘 天上星斗转, 人间演恩仇 五岳刀影, 四海浪险, 全化作豪杰杯中酒 天下将兴, 其积必有源, 天下将亡, 其发必有门 人非生而知之, 而是学而知之 一动风摆柳 做强弓齐射的出头鸟啊 打朱由榔好有一比, 那就是, 胯子里捉鸟, 伸手就玩完哪 阿卡人说过的话, 就像那大盈江的水, 是永不收回的 马都人 都人,明代称宫女 鳌拜呀, 一句打开城门迎闯王, 闯王来了不纳粮的顺口溜, 就把西安一直到北京的城门, 全给唱开了, 逼得朱由检在煤山上上了吊, 你想想, 如果出现类似的口号和顺口溜, 比如为了头发就杀人, 不抗大清活不成, 或者圈地投充绝人命, 赶走清兵求生存, 你想想看, 会是什么样的一个结果呀 摄政王远见哪 万一狡兔杀尽, 哪里还有我们弟兄的立足之地啊 所以要向王爷进言, 万不可永作痴人哪 兵者大凶之事, 若不穷通变化, 断非良帅 人各有志, 你重生张侍郎重义, 你就别枉费心机了 如果全天下的人都像我们阿卡人, 那该有多好啊, 一同种庄稼一起打猎, 然后再把食物和猎物归大伙所有, 在太阳下劳作, 在月光下跳舞, 彼此之间只有关心和照顾, 没有计算和仇恨, 更不会为了什么这个朝那个朝, 而互相残害, 如果彼此之间只有爱, 那该有多好啊`,``,`html`,`集合`,`20240307183503-_java 基于哈希的数据结构 基于哈希的数据结构如 HashMap 和 HashSet 使用 hashCode 方法来确定对象存储的桶，然后使用 equals 方法在桶中查找特定的对象。 如果两个相等的对象具有不同的哈希码，它们可能会被放置在不同的桶中，从而导致逻辑上相等的对象无法在哈希表中找到。 如果两个不相等的对象具有相同的哈希码，它们会被放置在同一个桶中，equals 方法会在桶中进一步区分它们。 于是有了以下总结 如果两个对象根据 equals 方法是相等的，那么它们的 hashCode 也必须相等。 如果两个对象根据 equals 方法不相等，它们的 hashCode 不必不同 一个好的哈希函数能让信息均匀的存入每个桶内 但是哈希冲突永远无法避免，只能减少概率 不同的对象具有相同的 hashCode 值（哈希冲突），它们会被放置在同一个桶中，HashMap 和 HashSet 必须使用 equals 方法在桶中逐个比较对象，从而降低了性能 最坏的哈希函数导致的结果可能是所有的对象都放在同一个桶内，这就跟直接放入数组内没有什么区别了 在程序执行期间，只要对象的状态（参与 equals 和 hashCode 方法计算的字段）不改变，对象的 hashCode 值就必须保持不变。 equals 方法 定义：equals 方法用于比较两个对象是否“逻辑相等”。 默认实现：Object 类中的默认实现是比较对象的引用（即内存地址），只有当两个引用指向同一个对象时，equals 方法才返回 true。 重写：当一个类希望根据其字段来定义相等性时，通常需要重写 equals 方法。 hashCode 方法 定义：hashCode 方法返回对象的散列码（哈希码），这是一个整数值，用于支持基于哈希的数据结构。 默认实现：Object 类中的默认实现是基于对象的内存地址生成的散列码。 重写：当重写 equals 方法时，通常也需要重写 hashCode 方法，以确保哈希码与对象的逻辑相等性保持一致。 重写了equals方法时,同时重写hashCode方法的必要性 如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了 假设有一个 Person 类，它重写了 equals 方法但没有重写 hashCode 方法 在使用 HashMap 或 HashSet 时的问题 如果两个Person对象根据 equals 方法是相等的，但它们的 hashCode 值不同（因为没有重写 hashCode 方法,所以默认继承Object使用了基于对象内存地址生成的hashCode,必然不同），它们可能会被放置在不同的桶中，从而破坏了数据结构的正确性导致无法找到逻辑上相等的对象。 如果我们使用了自定义类作为Map的键, 并且类中的属性值参与了hashCode的运算，那么在删除对象时，就不能再对其属性值进行修改，否则会导致内存泄露问题。 因为当我们尝试删除这个对象，哈希表会根据新的hashCode值进行操作，但由于对象实际存储的位置是根据旧的hashCode值决定的，会导致无法正确删除对象,而对象占用内存无法被垃圾回收。 使用 JDK 提供的不可变类 (immutable class) 作为 Map 的键可以确保对象一旦创建后，其属性值不再改变 不可变类 (immutable class) 已经实现了正确的 hashCode() 和 equals() 方法 String, Integer, Long, Double, BigDecimal, BigInteger, LocalDate、LocalTime、LocalDateTime 或者将自定义类设计为不可变类, 使用final修饰字段和类 public class Demo { public static void main(String[] args) { Map<Person, String> map = new HashMap<>(); Person person = new Person("Alice", 30); map.put(person, "Developer"); System.out.println(map.get(person));//Developer person.setAge(31); System.out.println(map.get(person));//null map.remove(person); System.out.println(map.size());//1,未能成功删除 } } //final class Person { class Person { //private final String name; private String name; //private final int age; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Person person = (Person) obj; return age == person.age && Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } @Override public String toString() { return "Person{" + "name='" + name + '\'' + ", age=" + age + '}'; } } HashMap HashMap为了提高查找效率，在插入的时候对键做了一次哈希算法，这就导致插入的元素是无序的 HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，需要自己处理多线程的安全问题 虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的 使用场景都是单线程 HashTable(key和value都不能为null) 被认为是个遗留的类，在迭代的时候修改 Map应该使用 ConcurrentHashMap。 ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍 因为 ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。 HashMap,LinkedHashMap允许一个 null 键和多个 null 值 reeMap不允许 null 键, 因为 TreeMap 需要对键进行排序，而 null 键无法进行比较 ConcurrentHashMap,Hashtable不允许 null 键和 null 值 putIfAbsent 如果 Map 中不包含指定的键，则 putIfAbsent 方法会插入该键值对，并返回 null 如果 Map 中已经包含了指定的键，则方法不会插入新的键值对，而是返回已有键的值 computeIfAbsent Map<String, List<String>> result = new HashMap<>(); //传统写法 if (result.containsKey("tq1")) { result.get("tq1").add(envelope.getRoutingKey()); } else { List<String> list = new ArrayList<>(); list.add(envelope.getRoutingKey()); result.put("tq1", list); } //简化写法 result.computeIfAbsent("tq1", k -> new ArrayList<>()).add(envelope.getRoutingKey()); //尝试在 Map 中查找指定的键（在这里是 "tq1"）。如果该键存在，它将返回键对应的值；如果键不存在，它将使用提供的函数（在这里是 k -> new ArrayList<>()）来生成一个新的值，并将其放入 Map 中，然后返回这个新值 HashMap扩容时机 当 hashmap 中的元素个数大于loadFactor * capacity(默认0.75)的第一个2的幂的数时，会触发rehash进行数组扩容 也就是说，默认情况下，数组大小为 16，那么当 hashmap 中元素个数超过 16*0.75=12 的时候 就把数组的大小扩展为 2*16=32， 即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作 所以如果我们已经预知 hashmap 中元素的个数，那么预设元素的个数能够避免HashMap扩容, 从而提高 hashmap 的性能 int count = 10000;//预知容量 //不能直接设置成loadFactor * capacity，因为这个数有可能不是2的幂，HashMap规定的容器容量必须是2的幂 int initCapacity = 1 + (int) (count / 0.75);//计算公式 HashMap<Integer, Object> map = new HashMap<>(initCapacity); https://cloud.tencent.com/developer/article/1755828 fail-fast和fail-safe fail-fast 迭代器在遍历集合时，如果检测到集合在迭代过程中被修改（除了通过迭代器自己的 remove 方法），它会立刻抛出 ConcurrentModificationException。 因为迭代器内部会更新结构修改计数器，从而避免检测到并发修改。 这种机制用于早期发现并发修改问题，以避免后续操作产生不一致的结果。 fail-fast 保证了集合的一致性，因为一旦检测到并发修改就终止操作。 java.util包下的集合类都是快速失败机制的 fail-safe 迭代器在遍历集合时，不直接访问集合本身，而是访问集合的一个副本。 因此，即使集合在迭代过程中被修改，也不会抛出 ConcurrentModificationException，因为它遍历的是原集合的一个副本 由于是对副本进行操作，不能保证遍历过程中数据的实时一致性。 java.util.concurrent并发集合类 这些类在迭代时不会抛出 ConcurrentModificationException，因为它们在迭代期间操作的是集合的副本或者使用了其他机制来确保安全迭代 CopyOnWriteArrayList 迭代时创建了一个副本，所以可以安全地进行迭代。适用于读多写少的场景 CopyOnWriteArraySet 基于 CopyOnWriteArrayList 实现，具有相同的 fail-safe 性质。 ConcurrentHashMap 通过细粒度锁和无锁操作确保线程安全。 提供的迭代器是弱一致的（Weakly Consistent），可以容忍并发修改。 ConcurrentSkipListMap 基于跳表实现，适用于需要排序的并发场景。 提供的迭代器是弱一致的。 ConcurrentSkipListSet 基于 ConcurrentSkipListMap 实现，具有相同的 fail-safe 性质。 这些类在迭代时检测到并发修改会抛出 ConcurrentModificationException，尽管它们本身是线程安全的（通过同步或其他机制） ConcurrentLinkedQueue 提供了高效的无锁并发队列。 迭代器是弱一致的，但仍然可能会抛出 ConcurrentModificationException。 ConcurrentLinkedDeque 提供了高效的无锁并发双端队列。 迭代器是弱一致的，但仍然可能会抛出 ConcurrentModificationException LinkedBlockingQueue 基于链表的阻塞队列，提供线程安全的队列操作。 迭代器是弱一致的，但仍然可能会抛出 ConcurrentModificationException 线程安全的集合类 java.util.concurrent 包中的集合类 Collections 工具类提供的方法, 通过包装普通的集合,使其线程安全, 所有的访问方法都被同步 因为在每次访问时都需要加锁，性能较低，适用于低并发环境。 Collections.synchronizedList List<String> list = Collections.synchronizedList(new ArrayList<>()); list.add("one"); Collections.synchronizedSet Collections.synchronizedMap 只读集合 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？ 在作为参数传递之前，我们可以使用 Collections.unmodifiableCollection(Collection c)方法创建一个只读集合 这将确保改变集合的任何操作都会抛出 UnsupportedOperationException ArrayList、Array、LinkedList 和 Vector 使用 Array 当你知道元素数量且不需要动态调整时。 使用 ArrayList 当你需要动态数组且不需要线程安全时。 使用 LinkedList 当你需要频繁插入和删除操作时。 使用 Vector 当你需要线程安全的动态数组时（虽然一般建议使用 Collections.synchronizedList 或 CopyOnWriteArrayList 进行线程安全处理）。 ArrayList适合查找和修改（get/set） ArrayList因为基于数组索引，可以通过其索引值快速定位 而LinkedList按序号索引数据需要进行前向或后向遍历 JDK 1.7 及之前：ArrayList 的无参构造函数会初始化一个容量为 10 的数组。 JDK 1.8 及之后：ArrayList 的无参构造函数会初始化一个容量为 0 的数组。在添加第一个元素时，容量会扩容为 10。 每次约按1.5倍扩容,a = a+a/2,当a为偶数时，才是1.5倍 当元素个数超过容量*加载因子 时，扩容至a+a/2 LinkList适合插入和删除（add/remove） 在LinkedList的中间插入或删除一个元素的开销是固定的，因为双向链表有前后指针，可直接断开指针进行删除和增加。 而在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动 Array可以包含基本类型和对象类型 ArrayList只能包含对象类型 Vector 动态调整大小，初始容量为 10, 超过当前容量的 2 倍时扩容 所有方法都被 synchronized 修饰，线程安全，但性能较低 集合排序 使用 Collections.sort() 方法适用于 List 类型的集合，它直接修改原始集合并进行排序。 使用 Stream API 的 sorted() 方法提供了一种函数式的排序方式，它不修改原始集合而是生成一个新的排序后的集合。 对自定义对象进行排序时，可以实现 Comparable 接口或者提供 Comparator 实现来定义排序规则。 Comparator (java.util) 是一个外部比较器，它与类本身无关，可以用来为不同类型的对象定义排序顺序。 thenComparing用于组合多个比较器 (Comparator 接口中默认方法), 参见本地页面JDK8新增特性,接口的默认方法,Comparator Comparable (java.lang) 是在 Java 类内部实现的，它定义了对象的内部顺序。如果一个类实现了Comparable 接口，就意味着这个类支持排序 List<String> sortedList = list.stream() .sorted((s1, s2) -> s1.length() - s2.length()) //.sorted(Comparator.comparingInt(String::length)) //.sorted((s1, s2) -> Integer.compare(s1.length(), s2.length())) /* .sorted(new Comparator<String>() { @Override public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }) */ .collect(Collectors.toList()); List<Integer> list = Arrays.asList(4, 2, 7, 5, 9); list.sort(Integer::compareTo); /* list.sort(new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return o1.compareTo(o2); } }); */ //map按k,v排序 Map<Integer, String> linkedHashMap = map.entrySet().stream() .sorted(Map.Entry.comparingByValue()) //.sorted(Map.Entry.comparingByKey(new Comparator{..})).reversed() .collect(Collectors.toMap( Map.Entry::getKey, /* new Function<Map.Entry<String, Integer>() { @Override public Integer apply(Map.Entry<String, Integer> entry) { return entry.getKey(); } } */ Map.Entry::getValue, (a, b) -> a, //mergeFunction,key值重复时,保留前者忽略后者 LinkedHashMap::new)); 集合迭代 Iterator 适用于所有集合，主要有三个方法：hasNext()、next() 和 remove() 可以在遍历过程中安全地删除当前元素。 因为 iterator.remove() 会更新 Iterator 的内部状态 Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { String name = iterator.next(); if (name.length() > 5) { iterator.remove(); } } 从JDK1.8开始，removeIf 方法可以作为传统迭代器删除方式的一种替代方案, 它更简洁和直观，同时提供了更好的表达能力和性能优化 //removeIf(Predicate<? super E> filter) list.removeIf(s -> s.length() > 5); 增强 for 循环 简洁易读，适用于所有实现了 Iterable 接口的集合。 不能在遍历集合时直接删除元素。 如果在增强型 for 循环中尝试直接调用集合的 remove 方法，会导致 ConcurrentModificationException 异常。 因为增强型 for 循环的背后是使用了 Iterator，直接修改集合使得 Iterator 检测到集合被并发修改 如果需要在遍历集合时删除符合条件的元素，应该使用显式的 Iterator 进行遍历并通过 iterator.remove() 方法删除元素。 try { for (String name : list) { if (name.length() > 5) { list.remove(name); // 这会导致 ConcurrentModificationException } } } catch (ConcurrentModificationException e) { System.out.println("异常: " + e); } //这种写只能满足循环中刚好只有一个符合条件的数据 for(Cat cat : set){ if("刀疤".equals(cat.getName())){ set.remove(cat); break; //除非找到目标后终止遍历,否则将报错 } } //当剔除多个符合条件的数据时 Set<Cat> temp = new HashSet<>(); //新建一个临时容器 for(pack.Cat cat : set){ if(cat.getMonth() < 5){ temp.add(cat); //将符合条件的数据放入临时容器 } } set.removeAll(temp); //从原set中剔除符合条件的数据 普通 for 循环 在 ArrayList 和 LinkedList 中使用普通 for 循环遍历并删除元素时，都需要处理索引问题(倒序或者remove之后i--) 删除元素时LinkedList 不会像 ArrayList 那样需要移动元素，因此性能更好 for (int i = list.size() - 1; i >= 0; i--) {//倒序 String name = list.get(i); if (name.length() > 5) { list.remove(i); } } for (int i = 0; i < list.size(); i++) { String name = list.get(i); if (name.length() > 5) { list.remove(i); i--; // 调整索引以避免跳过元素 } } Stream API list.forEach(); 是直接在集合上调用 forEach 方法，不会创建额外的流对象, 因此可能略微更高效 Iterable 的 forEach 是一个终端操作，无法链式调用其他集合流操作 list.stream().forEach(); 先创建流对象，然后执行操作，可能稍微慢一些。但可以在需要时链式调用其他流操作，如过滤、映射等，使代码更具灵活性 对于并行流来说，它可以提供更好的并行执行能力处理大量数据。 list.parallelStream().forEach(); ListIterator Iterator 的子接口，提供了额外的方法，如 hasPrevious() 和 previous()，适用于双向遍历 List List<String> list = new ArrayList<>(); list.add("A"); list.add("B"); list.add("C"); ListIterator<String> listIterator = list.listIterator(); while (listIterator.hasNext()) { System.out.println(listIterator.next()); } System.out.println("Reverse order:"); while (listIterator.hasPrevious()) { System.out.println(listIterator.previous()); } /* A B C Reverse order: C B A */ clear()删除当前集合中的所有元素(将集合的大小设置为 0) removeAll()删除集合的一个子集, 清空集合时使用clear()而不要使用removeAll() List<String> list1 = new ArrayList<>(); list1.add("apple"); list1.add("banana"); list1.add("cherry"); List<String> list2 = new ArrayList<>(); list2.add("banana"); list2.add("date"); list1.removeAll(list2); // 删除 list1 中与 list2 相同的元素 Stream 不可变性 Stream API 的操作通常不会改变源数据，而是生成新的数据流。 这种不可变性有助于编写并发程序时避免状态竞争和数据修改的问题。 链式调用 在链式调用中，每个中间操作都会返回一个新的 Stream 对象，这个新的 Stream 对象包含了原始 Stream 对象的数据以及新增的操作信息，但并不会立即对数据执行操作, 而是推迟到需要使用结果的时候再进行计算 惰性求值 惰性求值的概念体现在中间操作上, 它避免了对整个数据集进行多次遍历和计算 中间操作 filter, map, flatMap, sorted, distinct, limit, skip, peek 终端操作 forEach, collect, reduce, count, anyMatch, allMatch, noneMatch, findFirst, findAny, min, max, toArray Stream创建方式 //Stream.of Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6); //通过集合 List<Employee> employees = EmployeeData.getEmployees(); Stream<Employee> stream = employees.stream(); Stream<Employee> parallelStream = employees.parallelStream(); //通过Map Map<String, String> map = new HashMap<>(); Stream<String> keyStream = map.keySet().stream(); Stream<String> valueStream = map.values().stream(); Stream<Map.Entry<String, String>> entryStream = map.entrySet().stream(); //通过数组 int[] arr = new int[]{1,2,3,4,5,6}; IntStream stream = Arrays.stream(arr); Employee e1 = new Employee(1001,"Tom"); Employee e2 = new Employee(1002,"Jerry"); Employee[] arr1 = new Employee[]{e1,e2}; Stream<Employee> stream1 = Arrays.stream(arr1); //无限流 Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println); Stream.generate(Math::random).limit(10).forEach(System.out::println); //对于文本文件，可以Files.newBufferedReader(Path) + BufferedReader.lines() try (BufferedReader reader = Files.newBufferedReader(Paths.get("file.txt"))) { Stream<String> lines = reader.lines(); // 处理文本行的 Stream } catch (IOException e) { e.printStackTrace(); } //不需要额外的异常处理和手动关闭文件时可以Files.lines(Path) Stream<String> lines = Files.lines(Paths.get("file.txt")); //可以使用正则表达式将字符串拆分为 Stream String sentence = "Hello, world! Java Stream API."; Pattern pattern = Pattern.compile("\\s+");//至少一个空格 Stream<String> words = pattern.splitAsStream(sentence); words.forEach(System.out::println); //基于字符序创建流,用于字符加密 String str = "abc汉字"; IntStream stream = str.chars();// 基于字符序创建流 stream.forEach(c -> System.out.print(c + " "));//97 98 99 27721 23383 stream = str.chars();// 流被消耗掉了，需要重新创建 stream.forEach(c -> System.out.print((char) c + " "));//a b c 汉 字 stream = str.chars(); IntStream encryptedStream = stream.map(c -> c + 3);// 演示字符加密（简单的 Caesar cipher，偏移量为 3） encryptedStream.forEach(c -> System.out.print(c + " "));//100 101 102 27724 23386 stream = str.chars().map(c -> c + 3); StringBuilder encryptedStr = new StringBuilder(); stream.forEach(c -> encryptedStr.append((char) c)); System.out.println(encryptedStr.toString());//def汌孚 stream = encryptedStr.toString().chars(); IntStream decryptedStream = stream.map(c -> c - 3);//解密（偏移量为 -3） decryptedStream.forEach(c -> System.out.print(c + " "));//97 98 99 27721 23383 stream = encryptedStr.toString().chars().map(c -> c - 3); StringBuilder decryptedStr = new StringBuilder(); stream.forEach(c -> decryptedStr.append((char) c)); System.out.println(decryptedStr.toString());//abc汉字 Stream与parallelStream Stream 顺序执行，不涉及多线程问题 对于小数据集和简单操作，顺序流性能通常更好，因为线程开销较小 通过parallel()中途切换为并行流 list.stream() .map(String::toUpperCase) // 在map操作后，转换为并行流 .parallel() .forEach(System.out::println); parallelStream 并行执行，多线程处理 对于大数据集和计算密集型任务(不适用于I/O密集型)，并行流性能通常更好，因为能够利用多核处理器的优势并行处理数据 并行流在处理非常小的数据集或简单操作时，可能由于线程管理的开销反而变慢 并行流操作涉及到共享状态的修改，线程安全问题可能会出现 如果需要并行处理但还要保持顺序, 可以使用 forEachOrdered, 但会降低并行处理的性能优势 numbers.parallelStream().forEachOrdered(System.out::println); 对于较大的数据集，并行流通常能够显著减少计算时间 List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 顺序流 long startTime = System.nanoTime(); int sum = numbers.stream() .mapToInt(Integer::intValue) .sum(); long duration = System.nanoTime() - startTime; System.out.println("顺序流计算结果: " + sum + "，耗时: " + duration + " 纳秒");//顺序流计算结果: 55，耗时: 36509200 纳秒 // 并行流 startTime = System.nanoTime(); sum = numbers.parallelStream() .mapToInt(Integer::intValue) .sum(); duration = System.nanoTime() - startTime; System.out.println("并行流计算结果: " + sum + "，耗时: " + duration + " 纳秒");//并行流计算结果: 55，耗时: 2848200 纳秒 map和flatMap map 简单的对流中的数据计算或者转换 List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); List<Integer> doubled = numbers.stream() .map(n -> n * 2) .collect(Collectors.toList());//[2, 4, 6, 8, 10] flatMap 将具有层级结构的数据展平 List<List<String>> listOfLists = Arrays.asList( Arrays.asList("a", "b", "c"), Arrays.asList("d", "e", "f"), Arrays.asList("g", "h", "i") ); List<String> flatList = listOfLists.stream() .flatMap(List::stream) .collect(Collectors.toList());//[a, b, c, d, e, f, g, h, i] List<String> sentences = Arrays.asList( "The quick brown fox", "jumps over the lazy dog", "and runs away" ); List<String> words = sentences.stream() .flatMap(sentence -> Arrays.stream(sentence.split(" "))) .collect(Collectors.toList()); System.out.println(words); //[The, quick, brown, fox, jumps, over, the, lazy, dog, and, runs, away] Stream<String> lines = Files.lines(Paths.get("file.txt")); long words = long words = lines.parallel() // 将串行流改为并行流 .flatMap(line -> Arrays.stream(line.split(" "))) .distinct() .count();//文件中不重复的单词数量 List<String[]> eggs = new ArrayList<>(); @Before public void init() { // 第一箱鸡蛋 eggs.add(new String[]{"鸡蛋_1", "鸡蛋_1", "鸡蛋_1", "鸡蛋_1", "鸡蛋_1"}); // 第二箱鸡蛋 eggs.add(new String[]{"鸡蛋_2", "鸡蛋_2", "鸡蛋_2", "鸡蛋_2", "鸡蛋_2"}); } static int group = 1; static int student = 1; //把二箱鸡蛋分别加工成煎蛋，还是放在原来的两箱，分给2组学生 @Test public void map() { eggs.stream() .map(x -> Arrays.stream(x).map(y -> y.replace("鸡", "煎"))) .forEach(x -> System.out.println("组" + group++ + ":" + Arrays.toString(x.toArray()))); } //组1:[煎蛋_1, 煎蛋_1, 煎蛋_1, 煎蛋_1, 煎蛋_1] //组2:[煎蛋_2, 煎蛋_2, 煎蛋_2, 煎蛋_2, 煎蛋_2] //把二箱鸡蛋分别加工成煎蛋，然后放到一起【10个煎蛋】，分给10个学生 @Test public void flatMap() { eggs.stream() .flatMap(x -> Arrays.stream(x).map(y -> y.replace("鸡", "煎"))) .forEach(x -> System.out.println("学生" + student++ + ":" + x)); } //学生1:煎蛋_1 //学生2:煎蛋_1 //学生3:煎蛋_1 //学生4:煎蛋_1 //学生5:煎蛋_1 //学生6:煎蛋_2 //学生7:煎蛋_2 //学生8:煎蛋_2 //学生9:煎蛋_2 //学生10:煎蛋_2 mergeFunction Collectors.toMap接受一个合并函数（merge function），用于处理键冲突的情况。 合并函数的主要作用是当两个元素的键相同时，决定如何合并这些元素的值。 //假设我们有一组用户数据，每个用户有一个 ID 和一个名字，我们希望将这些用户数据转换为一个 Map，其中 ID 是键，名字是值。 //如果两个用户有相同的 ID，我们需要合并它们的名字。 List<User> users = Arrays.asList( new User(1, "Alice"), new User(2, "Bob"), new User(1, "Charlie"), new User(3, "David"), new User(2, "Eve") ); Map<Integer, String> userMap = users.stream().collect( Collectors.toMap( User::getId,//方法引用,等价(User u) -> u.getId() User::getName, (name1, name2) -> name1 + ", " + name2 ) ); userMap.forEach((id, names) -> System.out.println(id + ": " + names)); /* 1: Alice, Charlie 2: Bob, Eve 3: David */ List<Person> personList = ...; // 获取Person列表 Map<String, Person> personMap = personList.stream() .collect(Collectors.toMap( Person::getName, //提取 Person 的名字作为 Map 的键 Function.identity(),//提取 Person 自身作为 Map 的值 (existing, replacement) -> replacement //处理键冲突时，保留新的值 )); /* Alice: Person{name='Alice', age=28} Bob: Person{name='Bob', age=25} Charlie: Person{name='Charlie', age=35} */ groupingBy List<Person> people = Arrays.asList( new Person("Alice", 20), new Person("Bob", 25), new Person("Charlie", 30), new Person("David", 25) ); //按照对象属性分组 Map<Integer, List<Person>> peopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge)); peopleByAge.forEach((k,v)-> System.out.println(k+":"+v)); /* 20:[Person{name='Alice', age=20}] 25:[Person{name='Bob', age=25}, Person{name='David', age=25}] 30:[Person{name='Charlie', age=30}] */ //按照对象属性分组，并对分组后的元素进行计数 Map<Integer, Long> countByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge, Collectors.counting())); countByAge.forEach((age, count) -> System.out.println("Age " + age + ": " + count + "人")); /* Age 20: 1人 Age 25: 2人 Age 30: 1人 */ //按照对象属性分组，并对分组后的元素进行其它聚合操作 Map<Integer, Double> map = people.stream() .collect(Collectors.groupingBy( Person::getAge, Collectors.summingDouble(Person::getAge)//总龄 )); map.forEach((k, v) -> System.out.println(k+ ":"+v)); /* 20:20.0 25:50.0 30:30.0 */ //按照对象属性分组，并将分组后的元素映射为另一种类型 Map<Integer, List<String>> namesByAge = people.stream() .collect(Collectors.groupingBy( Person::getAge, Collectors.mapping(Person::getName, Collectors.toList()) )); namesByAge.forEach((age, names) -> System.out.println("Age " + age + ": " + names)); /* Age 20: [Alice] Age 25: [Bob, David] Age 30: [Charlie] */ reduce List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .reduce(0, (a, b) -> a + b); List<String> words = Arrays.asList("apple", "banana", "cherry", "date"); String longestWord = words.stream() .reduce((word1, word2) -> word1.length() < word2.length() ? word1 : word2) .orElse("");//orElse 是 Optional 类的一个方法，它用于在 Optional 对象没有值的情况下提供一个默认值 List<String> words = Arrays.asList("Java", "is", "awesome"); String combinedString = words.stream() .reduce("", (a, b) -> a + " " + b); List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); int product = numbers.stream() .reduce(1, (a, b) -> a * b); peek 用于在流处理过程中观察和调试每个元素的状态 peek 方法应该只用于产生副作用（例如打印输出），而不应该用于修改流中的元素 List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); numbers.stream() .peek(e -> System.out.println("Processing element: " + e)) .map(e -> e * 2) .forEach(System.out::println); Stream API的其它方法 //skip(long)：跳过流中的前 N 个元素 stream.skip(5).forEach(System.out::println); //检查流中是否有任意元素匹配、全部元素匹配或没有元素匹配给定条件 boolean anyMatch = stream.anyMatch(x -> x > 5); boolean allMatch = stream.allMatch(x -> x > 5); boolean noneMatch = stream.noneMatch(x -> x > 5); //findFirst() / findAny()：返回流中的第一个元素或任意一个元素（在并行流中更有效） Optional<Integer> first = stream.findFirst(); Optional<Integer> any = stream.findAny(); //最值 Optional<Integer> min = stream.min(Comparator.naturalOrder()); Optional<Integer> max = stream.max(Comparator.naturalOrder()); //流中元素转数组 List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); Integer[] array = numbers.stream().toArray(Integer[]::new); 例 //所有偶数和 List<String> list = Arrays.asList("1", "2", "3", "4", "5", "6"); int sum = list .stream() //.map(s -> Integer.parseInt(s)) //.mapToInt(s -> Integer.parseInt(s)) //使用 .map(s -> Integer.parseInt(s))，它返回的是一个 Stream<Integer>，即将每个字符串转换为整数后，保持为一个 Stream //使用 .mapToInt(s -> Integer.parseInt(s))，它返回的是一个 IntStream，其中的元素都是原始的 int 类型，而不需要进行拆箱操作。 .mapToInt(Integer::parseInt) .filter(i -> i % 2 == 0) //.reduce(0,(a,b)->a+b) .sum(); //所有首字母大写 List<String> list = Arrays.asList("tom", "jerry"); List<String> list2 = list.stream() .map(s -> s.substring(0,1).toUpperCase().concat(s.substring(1))) .collect(Collectors.toList()); //将其中奇数去重倒序 List<String> list = Arrays.asList("1","2","3","3","4","5"); List<Integer> list2 = list.stream() .map(Integer::parseInt) .distinct() .filter(i -> i%2==1) .sorted((o1, o2) -> o2-o1) .collect(Collectors.toList()); //统计字符串中各字符个数 String str = "我爱学java"; Map<Character, Integer> map2 = new HashMap<>(); str.chars() .mapToObj(c -> (char) c) .forEach(character -> map2.put(character, map2.getOrDefault(character, 0) + 1)); map2.forEach((k, v) -> System.out.println(k + ":" + v)); //统计文本中重复姓名并按次数排序 /* 1,aa,28 2,cc,35 4,王五,35 3,aa,28 4,王五,35 5,aa,28 6,cc,35 7,赵六,28 8,田七,35 */ //File file = new File("info.txt"); List<String> list = new ArrayList(); //try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"))) { try (BufferedReader br = Files.newBufferedReader(Paths.get("info.txt"))) { String line; while ((line = br.readLine()) != null) { list.add(line.split(",")[1]); } } catch (IOException e) { e.printStackTrace(); } Map<String, Integer> map = new HashMap<>(); list.forEach(i -> map.put(i, map.getOrDefault(i, 0) + 1)); LinkedHashMap<String, Integer> collect = map.entrySet().stream() .filter(entry -> entry.getValue() > 1) //.sorted(Map.Entry.comparingByValue().reversed()) .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (a, b) -> a, LinkedHashMap::new)); collect.forEach((k,v)-> System.out.println(k+":"+v));`,``,`html`,`青山翠谷`,`20240307183503-影摘 你是教堂的皇帝,我是厨房的皇后`,``,`html`,`风云1`,`20240307183503-影摘 2002 此人杀子存义,老夫佩服 车不同轨,曲不同调 浮世无缘,情难到老,倾城泣别,两皆失声,怨天不公,恨爱无缘 夫亦空兮妻亦空 黄泉路上不相逢 朋亦空兮友亦空 各赴前程路不同 为何世人如此固执 如此地不快乐 名也空,利也空,转眼荒郊土一封 缘起惜缘,缘灭就随它去吧 聂风:真没想到会下这场雨,不知道它还要下多久 独孤梦:下雨更好,若非这场雨令我俩如此共处,只怕你早已像一阵风一样,溜回江湖了 聂风:我一直都向往,日出而作,日落而息的生活,每到傍晚,当我找着锄头回来的时候,她早已把饭菜弄好等我回来,如果碰到雨天,我便不往田里耕作,一家乐意融融 人生苦短,别为尚未发生的事情去烦恼,我看及时行乐比较聪明 聂风最帅，步惊云最酷，雄霸最坏，幽若第二梦最美，颜盈最骚，秦霜最好，无名最棒，剑晨最贱，楚楚最烦，绝无神最狠，绝天最笨，绝心最毒，第三猪皇最色，断浪最阴。`,``,`html`,`风云2`,`20240307183503-影摘 幸福愉快的生活, 总是令人沉溺于平庸, 不思进取, 千古以来, 只有天灾人祸才能令人长进, 发挥无穷威力 老死泉林 玉帛相见 第一种解释为:以礼相待,避免争执. 第二种解释为:宽衣解带,赤身露体相处. 必须要天愁地惨, 家破人亡, 吃尽苦头, 才能成大器 上得山多终遇虎 桩桩件件, 你作何解释 加饭强衣 琵琶别抱 慢着, 有两个字我不想欠你们, 谢谢 20241015182031.webp 事缓则圆 对我而言, 同情, 宽恕, 怜悯, 统统等于是侮辱 织了破, 破了织, 不服输 世人之所以追求子嗣, 就是要追求精神不灭, 想以子嗣来延续自身, 我已经不死不灭了, 何需子嗣来延续`,``,`html`,`飞屋环游记`,`20240307183503-影摘 倒霉的青蛙被当成闹钟 我们拿道格怎么办 他跟丢了大鸟，给他戴耻辱罩 我不喜欢耻辱罩`,``,`html`,`食物`,`20250301184622-户外 按对其依赖的程度来排列的话人体所需要的依次是水、糖、蛋白质、维生素、微量元素 在野外时能为你提供最快最方便的能量的元素是糖, 通过蛋白质和脂肪提供则要经过更长过程, 一块巧克力肯定比一块牛肉更快地给你热量 糖类食物一般情况下是不会浪费的, 它在为人体提供了热量后多余的便成了肝糖元、肌糖元和脂肪储存了起来, 在遇险（尤其是在高寒地区）时维持生命具有重要的意义。 “容易获得”这一条非常重要, 假如我说天上的飞鸟水里的游鱼味道很好, 在野外没东西吃了可以弄些来吃, 那就会招人骂了, 就因为它们不容易获得 昆虫是节肢动物最大的一个纲, 也是动物界中最大的一个纲, 不仅种类繁多, 而且数量惊人。因而它们是野外生存时最容易获得的可靠食物源 蝼蛄 20250307204857.webp 别名蟪蛄、天蝼、蝼蝈、仙姑、石鼠、梧鼠、土狗 蝼蛄属于夜间活动的昆虫, 有很强的趋光性, 宜于夜间用灯光诱捕, 春季到秋季均可在湿润的野地里诱捕, 把小手电放在地上, 不多久就会有成群结队的蝼蛄前来报到, 直接手捉就可以, 蝼蛄善游泳不善飞行, 是很容易捕捉的。蝼蛄的成虫体型比较大, 常见的有３～４ｃｍ。烧沸水烫死后去除短翅和头足即可炒食。 龙虱 20250307204116.webp “水仙”龙虱, 水陆空三栖战舰, 生活在浅水里。龙虱不但会游泳、会潜水(鞘翅之下有一个气囊, 能够充当潜水所用的氧气瓶), 出水还能飞 龙虱的幼虫俗名叫做“水虎”, 以水中一切动物蛋白为食, 即使对体积庞大的小鱼、蝌蚪, 甚至青蛙, 它们也敢于主动攻击。水虎没有明显的嘴, 上颚中空, 连着口腔和食管, 它们不能咀嚼和撕咬。称霸一方的兵器, 依靠的是装有“毒液”的吸管：捕到猎物时, 水虎将毒液和消化液通过空心的上颚注入猎物体内, 肥胖的蝌蚪、小鱼受到偷袭, 用不得挣扎几下, 便不再动弹；用消化液处理后的猎物, 内脏逐渐变成暗淡的液体, 水虎就像喝软包装一样将食物吸尽, 然后将干瘪的表皮弃于水中 https://www.sohu.com/a/213649890_648402 龙虱夜间趋光，可以用灯光吸引 用清水冲洗，去除泥沙和杂质, 浸泡 2-3 小时（如果有条件，可用淡盐水浸泡帮助排出肠道污物）。 一些大型龙虱可能带有微弱毒素（主要用于捕猎），建议去除头部和胸部的唾液腺。 用手或小刀切掉头部，再剖开胸部取出白色唾液腺。 直接烤制： 将龙虱用树枝穿起，明火烤 5-10 分钟，直到外壳变脆发黄。 可直接剥壳食用肉质部分，类似吃甲壳类（如蟋蟀、蝗虫）。 水煮： 沸水煮 5-10 分钟，去除可能存在的寄生虫和细菌。 田螺 田螺是一种带壳的水生软体动物, 在浅水塘、溪流、湿地均可能大量出现。由于田螺行动极其缓慢, 因此是我们在野外非常容易获得的食物源。在野外没有会做饭的田螺姑娘, 有田螺也该知足了。 田螺的躯体分为头部、足部和脏囊三部分, 足部紧贴螺口的膜片上, 爬行时伸出来, 休息或有危险时赶紧缩回去, 拉紧膜片盖住螺口以保护自己。因此田螺足部肌肉非常发达, 为主要食用部位。 在溪流或浅塘边, 能够较容易地捡拾到田螺。吃之前需要把田螺清洗干净, 然后敲破田螺尾部放在沸水中猛煮十几分钟杀菌及寄生生物, 倒出冷却之后剔除螺口膜片, 再将螺肉挑出来, 掐掉腹囊。螺肉再用清水淘沥一遍, 加盐再煮一会儿就可以吃了。 对可食野生植物的识别是野外自下而上知识的主要内容。 山葡萄、笃斯、黑瞎子果、茅莓、沙棘、火把果、桃金娘、胡颓子、乌饭树、余甘子等 苦菜、蒲公英、鱼腥草、马齿苋、刺儿草、荠菜、野苋菜、扫帚菜、菱、莲、芦苇、青苔等 藻类、地衣、蘑菇等。 室内 早 麦片,叶黄素,煮蛋,核桃 中 面条,黑胡椒,姜黄粉,油盐,西兰花,生胡萝卜,芭乐 晚 面条,黑胡椒,姜黄粉,油盐,西兰花 饮 菊茶`,``,`html`,`鹿鼎记`,`20250324210237-影摘 少小须勤学, 文章可立身, 满朝朱紫贵, 尽是读书人 弱女飘零，祸不单行 贴加官 用兵之道, 示之以柔, 而赢之以刚, 示之以弱, 而乘之以强, 张欲西, 而示之以东 蠹众而木折, 隙大而墙坏 心灵丰盛, 已言足矣 冰雪迷人 宁得罪君子, 莫得罪小人 三五七千烦恼丝 迟则生变 祝融之灾 变成人棍之后, 把你种在土里, 有空就帮你浇浇水施施肥的, 说不定一两个月后就会长出胳膊和腿来的 圆圆曲 妻子岂应关大计，英雄无奈是多情。 鼎湖当日弃人间，破敌收京下玉关。 恸哭六军俱缟素，冲冠一怒为红颜。 红颜流落非吾恋，逆贼天亡自荒宴。 电扫黄巾定黑山，哭罢君亲再相见。 相见初经田窦家，侯门歌舞出如花。 许将戚里箜篌伎，等取将军油壁车。 家本姑苏浣花里，圆圆小字娇罗绮。 梦向夫差苑里游，宫娥拥入君王起。 前身合是采莲人，门前一片横塘水。 横塘双桨去如飞，何处豪家强载归。 此际岂知非薄命，此时唯有泪沾衣。 薰天意气连宫掖，明眸皓齿无人惜。 夺归永巷闭良家，教就新声倾坐客。 坐客飞觞红日暮，一曲哀弦向谁诉？ 白晳通侯最少年，拣取花枝屡回顾。 早携娇鸟出樊笼，待得银河几时渡？ 恨杀军书抵死催，苦留后约将人误。 相约恩深相见难，一朝蚁贼满长安。 可怜思妇楼头柳，认作天边粉絮看。 遍索绿珠围内第，强呼绛树出雕阑。 若非壮士全师胜，争得蛾眉匹马还？ 蛾眉马上传呼进，云鬟不整惊魂定。 蜡炬迎来在战场，啼妆满面残红印。 专征萧鼓向秦川，金牛道上车千乘。 斜谷云深起画楼，散关月落开妆镜。 传来消息满江乡，乌桕红经十度霜。 教曲伎师怜尚在，浣纱女伴忆同行。 旧巢共是衔泥燕，飞上枝头变凤凰。 长向尊前悲老大，有人夫婿擅侯王。 当时只受声名累，贵戚名豪竞延致。 一斛明珠万斛愁，关山漂泊腰肢细。 错怨狂风飏落花，无边春色来天地。 尝闻倾国与倾城，翻使周郎受重名。 妻子岂应关大计，英雄无奈是多情。 全家白骨成灰土，一代红妆照汗青。 君不见，馆娃初起鸳鸯宿，越女如花看不足。 香径尘生乌自啼，屧廊人去苔空绿。 换羽移宫万里愁，珠歌翠舞古梁州。 为君别唱吴宫曲，汉水东南日夜流！ 由于世人将吴三桂变节归咎于其爱妾陈圆圆被掳，令吴三桂为夺回陈氏而与满人勾结，诗人吴梅村以西施讽今，谱下七言长诗《圆圆曲》，指出陈圆圆无一丝损害国家之举，责任应在吴三桂，抨击了他“冲冠一怒为红颜”的举动 斩竹莫伤笋 拯救这些被推下火坑的奇女子`,``,`html`,`黑猫白猫`,`20240307183503-影摘 如果事情不能用钱来解决，那就用更多更多的钱`,``,`html`,``,``,`../book/人文地理/【视频】法国飞行员、作家——安托万·德·圣埃克苏佩里的千面人生.pdf`,`pdf`,``,``,`../book/人文地理/太阳地球工程--气候解决方案还是打开了潘多拉魔盒？ ! 科技环境 ! DW ! 30.07.2023.pdf`,`pdf`,``,``,`../book/人文地理/明代荆襄流民的治理史.pdf`,`pdf`,``,``,`../book/人文地理/清军为何要和明朝死磕山海关？绕道不行吗_腾讯新闻.pdf`,`pdf`,``,``,`../book/历史/《中国历史故事集》林汉达.html`,`txt`,``,``,`../book/格斗/摔跤.pdf`,`pdf`,``,``,`../book/讽刺/【CDT百科】“别有用心”是什么梗？为何总与“不明真相”搭配？.pdf`,`pdf`,``,``,`../book/讽刺/【旧文重温】懒得说不得不说｜强制实名制之前没有什么电信诈骗.pdf`,`pdf`,``,``,`../book/讽刺/中国媒体为何没有坏故事？.pdf`,`pdf`,``,``,`../book/讽刺/中国网络观察! 官民争议“历史的垃圾时间”.pdf`,`pdf`,``,``,`../book/讽刺/人文主义与美好生活｜不诚信的一代：外文书中译过程的删改现象.pdf`,`pdf`,``,``,`../book/讽刺/做一个思想清醒的人｜华东师大教授2023毕业致辞：我想说的话越来越多，我能说的话越来越少.pdf`,`pdf`,``,``,`../book/讽刺/德语媒体：奥威尔式的社会信用体系？ – DW – 2024年6月10日.pdf`,`pdf`,``,``,`../book/讽刺/春风拂面啊｜“为什么同意他们抄家？为什么不反抗？”.pdf`,`pdf`,``,``,`../book/讽刺/邻国纷纷与华盛顿做交易 北京有点急.pdf`,`pdf`,``,``,`../book/迪伦马特《老妇还乡》.epub`,`epub`,`hq720.jpg`,`null`,`../gallery/bg/hq720.jpg`,`image`,`2024312-203826.png`,`null`,`../gallery/funny/2024312-203826.png`,`image`,`2412025-下午-120328.png`,`null`,`../gallery/funny/2412025-下午-120328.png`,`image`,`8122024-下午-81421.png`,`null`,`../gallery/funny/8122024-下午-81421.png`,`image`,`GHOzlSnW4AADOQv.jpg`,`null`,`../gallery/funny/GHOzlSnW4AADOQv.jpg`,`image`,`GI0CA9XaMAAtRN1.jpg`,`null`,`../gallery/funny/GI0CA9XaMAAtRN1.jpg`,`image`,`GI9M6uzbAAA_PAr.jpg`,`null`,`../gallery/funny/GI9M6uzbAAA_PAr.jpg`,`image`,`GJB7LFXaEAASpwG.jpg`,`null`,`../gallery/funny/GJB7LFXaEAASpwG.jpg`,`image`,`GKuij_XbQAAKoO3.jpg`,`null`,`../gallery/funny/GKuij_XbQAAKoO3.jpg`,`image`,`GLn6wRqXsAAES8V.jpg`,`null`,`../gallery/funny/GLn6wRqXsAAES8V.jpg`,`image`,`GLQJu7da4AAXBf1.jpg`,`null`,`../gallery/funny/GLQJu7da4AAXBf1.jpg`,`image`,`GLsFZj6WYAAJCbU.jpg`,`null`,`../gallery/funny/GLsFZj6WYAAJCbU.jpg`,`image`,`GLUBkgVXwAAE-1-.jpg`,`null`,`../gallery/funny/GLUBkgVXwAAE-1-.jpg`,`image`,`GOI95qhWIAAOxZx.jpg`,`null`,`../gallery/funny/GOI95qhWIAAOxZx.jpg`,`image`,`GOM6OmlW8AASXU9.jpg`,`null`,`../gallery/funny/GOM6OmlW8AASXU9.jpg`,`image`,`GQdNZX-XcAA34ji.jpg`,`null`,`../gallery/funny/GQdNZX-XcAA34ji.jpg`,`image`,`GQktiEKWQAAqyZO.jpg`,`null`,`../gallery/funny/GQktiEKWQAAqyZO.jpg`,`image`,`GQlpUttX0AAApxW.jpg`,`null`,`../gallery/funny/GQlpUttX0AAApxW.jpg`,`image`,`GQOFX5rXgAAqz7z.jpg`,`null`,`../gallery/funny/GQOFX5rXgAAqz7z.jpg`,`image`,`GQOSexcagAAjqKj.jpg`,`null`,`../gallery/funny/GQOSexcagAAjqKj.jpg`,`image`,`GRNxF3JawAA1vH9.jpg`,`null`,`../gallery/funny/GRNxF3JawAA1vH9.jpg`,`image`,`GTcSwFEWIAA3JmC.jpg`,`null`,`../gallery/funny/GTcSwFEWIAA3JmC.jpg`,`image`,`GUI6TuDXQAECIJi.jpg`,`null`,`../gallery/funny/GUI6TuDXQAECIJi.jpg`,`image`,`GUngeZCWYAAqmY7.jpg`,`null`,`../gallery/funny/GUngeZCWYAAqmY7.jpg`,`image`,`GUPT2XzWYAAuEiI.jpg`,`null`,`../gallery/funny/GUPT2XzWYAAuEiI.jpg`,`image`,`GUqWVZJagAAYZ1t.jpg`,`null`,`../gallery/funny/GUqWVZJagAAYZ1t.jpg`,`image`,`GV7aI-dXQAAtdO8.jpg`,`null`,`../gallery/funny/GV7aI-dXQAAtdO8.jpg`,`image`,`GVewEEUWQAAkjCg.jpg`,`null`,`../gallery/funny/GVewEEUWQAAkjCg.jpg`,`image`,`GVnbWefWkAAgHh4.jpg`,`null`,`../gallery/funny/GVnbWefWkAAgHh4.jpg`,`image`,`阿拔斯末代国王哈里发.webp`,`null`,`../gallery/funny/阿拔斯末代国王哈里发.webp`,`image`,`732025-下午-71806.png`,`null`,`../gallery/tip/732025-下午-71806.png`,`image`,`F5Ov-82bYAAKsVx.jpg`,`null`,`../gallery/tip/F5Ov-82bYAAKsVx.jpg`,`image`,`GFgh9NYW0AAYjFE.jpg`,`null`,`../gallery/tip/GFgh9NYW0AAYjFE.jpg`,`image`,`GHF67imWkAEEiXP.jpg`,`null`,`../gallery/tip/GHF67imWkAEEiXP.jpg`,`image`,`GJ6CYT6a8AAuZQi.jpg`,`null`,`../gallery/tip/GJ6CYT6a8AAuZQi.jpg`,`image`,`GPxox9lbcAAjV_j.jpg`,`null`,`../gallery/tip/GPxox9lbcAAjV_j.jpg`,`image`,`GRj-Qs4W0AAH_fQ.jpg`,`null`,`../gallery/tip/GRj-Qs4W0AAH_fQ.jpg`,`image`,`GTBvHpWWgAAnnYs.jpg`,`null`,`../gallery/tip/GTBvHpWWgAAnnYs.jpg`,`image`,`GVEIsiDWkAAMawI.jpg`,`null`,`../gallery/tip/GVEIsiDWkAAMawI.jpg`,`image`,`GVifgTqbgAUwCdq.jpg`,`null`,`../gallery/tip/GVifgTqbgAUwCdq.jpg`,`image`,`GVmSwCjWoAAEJfm.jpg`,`null`,`../gallery/tip/GVmSwCjWoAAEJfm.jpg`,`image`,`GW7DKsqa8AIrjqI.jpg`,`null`,`../gallery/tip/GW7DKsqa8AIrjqI.jpg`,`image`,`不规则边界比样.png`,`null`,`../gallery/tip/不规则边界比样.png`,`image`,`切割刀膨胀拆卸.png`,`null`,`../gallery/tip/切割刀膨胀拆卸.png`,`image`,`螺栓拆卸.png`,`null`,`../gallery/tip/螺栓拆卸.png`,`image`,`garbage sale follow me.png`,`null`,`../gallery/动物/garbage sale follow me.png`,`image`,`GKa68qObwAQT75F.jpg`,`null`,`../gallery/动物/GKa68qObwAQT75F.jpg`,`image`,`GKRRMfFaEAAphFP.jpg`,`哈哈哈哈`,`../gallery/动物/GKRRMfFaEAAphFP.jpg`,`image`,`GM5BOwUXAAA7x78.jpg`,`null`,`../gallery/动物/GM5BOwUXAAA7x78.jpg`,`image`,`GMJYC5wW4AADCQ8.jpg`,`null`,`../gallery/动物/GMJYC5wW4AADCQ8.jpg`,`image`,`GOVHjKyXcAAyOqI.jpg`,`null`,`../gallery/动物/GOVHjKyXcAAyOqI.jpg`,`image`,`GRARU1IXsAA8uvK.jpg`,`null`,`../gallery/动物/GRARU1IXsAA8uvK.jpg`,`image`,`GSGbycOWkAAketf.jpg`,`null`,`../gallery/动物/GSGbycOWkAAketf.jpg`,`image`,`GTvq-UoXwAEW1tA.jpg`,`null`,`../gallery/动物/GTvq-UoXwAEW1tA.jpg`,`image`,`GUd1lTUbwAAknKZ.jpg`,`null`,`../gallery/动物/GUd1lTUbwAAknKZ.jpg`,`image`,`GULSRhhW4AA4oG_.jpg`,`null`,`../gallery/动物/GULSRhhW4AA4oG_.jpg`,`image`,`GVlIJHGbAAASqXD.jpg`,`null`,`../gallery/动物/GVlIJHGbAAASqXD.jpg`,`image`,`GVrJVuta8AAzQ_o.jpg`,`null`,`../gallery/动物/GVrJVuta8AAzQ_o.jpg`,`image`,`GWHMsDrWUAAIRkO.jpg`,`null`,`../gallery/动物/GWHMsDrWUAAIRkO.jpg`,`image`,`24_127451_439649a79391e69.gif`,`null`,`../gallery/地理人文/24_127451_439649a79391e69.gif`,`image`,`A few seconds before happiness.jpg`,`null`,`../gallery/地理人文/A few seconds before happiness.jpg`,`image`,`GHgCBMoWoAAX6NZ.jpg`,`null`,`../gallery/地理人文/GHgCBMoWoAAX6NZ.jpg`,`image`,`GI-KMmLWYAAl3Q2.jpg`,`null`,`../gallery/地理人文/GI-KMmLWYAAl3Q2.jpg`,`image`,`GI3Hhb9W0AAG-6t.jpg`,`null`,`../gallery/地理人文/GI3Hhb9W0AAG-6t.jpg`,`image`,`GI4EgxhXwAALLs-.png`,`null`,`../gallery/地理人文/GI4EgxhXwAALLs-.png`,`image`,`GI9funwXYAA4zT1.jpg`,`null`,`../gallery/地理人文/GI9funwXYAA4zT1.jpg`,`image`,`GIJhjcVWYAATfD6.jpg`,`null`,`../gallery/地理人文/GIJhjcVWYAATfD6.jpg`,`image`,`GJ2gOssWkAEnxHz.jpg`,`null`,`../gallery/地理人文/GJ2gOssWkAEnxHz.jpg`,`image`,`GJC4kFDXIAAcF_m.jpg`,`null`,`../gallery/地理人文/GJC4kFDXIAAcF_m.jpg`,`image`,`GJtPXABW4AAc6bG.jpg`,`null`,`../gallery/地理人文/GJtPXABW4AAc6bG.jpg`,`image`,`GLD-CRPWsAEHDmU.jpg`,`null`,`../gallery/地理人文/GLD-CRPWsAEHDmU.jpg`,`image`,`GOH-NsmW0AAD_eE.jpg`,`null`,`../gallery/地理人文/GOH-NsmW0AAD_eE.jpg`,`image`,`GPFLqDwXcAAYIeT.jpg`,`null`,`../gallery/地理人文/GPFLqDwXcAAYIeT.jpg`,`image`,`GPoGo9ZaoAAlhuS.jpg`,`null`,`../gallery/地理人文/GPoGo9ZaoAAlhuS.jpg`,`image`,`GQ6iq5kW8AA0akw.jpg`,`null`,`../gallery/地理人文/GQ6iq5kW8AA0akw.jpg`,`image`,`GQaKzjlbMAAkEps.jpg`,`null`,`../gallery/地理人文/GQaKzjlbMAAkEps.jpg`,`image`,`GQNKNRBWkAAiyC_.jpg`,`null`,`../gallery/地理人文/GQNKNRBWkAAiyC_.jpg`,`image`,`GQpVpMsWEAAI75q.jpg`,`null`,`../gallery/地理人文/GQpVpMsWEAAI75q.jpg`,`image`,`GQQpom5acAA7WOg.jpg`,`null`,`../gallery/地理人文/GQQpom5acAA7WOg.jpg`,`image`,`GVCp525WkAAQKBU.jpg`,`null`,`../gallery/地理人文/GVCp525WkAAQKBU.jpg`,`image`,`GVSqrskaoAAGjbl.jpg`,`null`,`../gallery/地理人文/GVSqrskaoAAGjbl.jpg`,`image`,`Lomanstraat Street decorated with symmetrical trees in Amsterdam.jpg`,`null`,`../gallery/地理人文/Lomanstraat Street decorated with symmetrical trees in Amsterdam.jpg`,`image`,`乡村市集通名.webp`,`null`,`../gallery/地理人文/乡村市集通名.webp`,`image`,`山海关.webp`,`null`,`../gallery/地理人文/山海关.webp`,`image`,`山海关2.webp`,`null`,`../gallery/地理人文/山海关2.webp`,`image`,`山海关3.webp`,`null`,`../gallery/地理人文/山海关3.webp`,`image`,`山海关4.webp`,`null`,`../gallery/地理人文/山海关4.webp`,`image`,`弗里德里希·迪伦马特，以笔为矛的批评家.webp`,`null`,`../gallery/地理人文/弗里德里希·迪伦马特，以笔为矛的批评家.webp`,`image`,`朝代年表.png`,`null`,`../gallery/地理人文/朝代年表.png`,`image`,`post-705080-65cdf1c39f15b.png`,`null`,`../gallery/小诗/post-705080-65cdf1c39f15b.png`,`image`,`post-705080-65cdf1c3acc49.webp`,`null`,`../gallery/小诗/post-705080-65cdf1c3acc49.webp`,`image`,`post-705080-65cdf1c3b99a6.webp`,`null`,`../gallery/小诗/post-705080-65cdf1c3b99a6.webp`,`image`,`post-705080-65cdf1c3c767f.webp`,`null`,`../gallery/小诗/post-705080-65cdf1c3c767f.webp`,`image`,`post-705080-65cdf1c3d13fb.webp`,`null`,`../gallery/小诗/post-705080-65cdf1c3d13fb.webp`,`image`,`Sometimes the simplest jobs are the most important..jpg`,`null`,`../gallery/小诗/Sometimes the simplest jobs are the most important..jpg`,`image`,`GJb2zOJaoAAb2h0.jpg`,`null`,`../gallery/心理/GJb2zOJaoAAb2h0.jpg`,`image`,`GKYnE8ba0AA_-Yt.jpg`,`null`,`../gallery/心理/GKYnE8ba0AA_-Yt.jpg`,`image`,`GLfSFLVbkAAMlca.jpg`,`null`,`../gallery/心理/GLfSFLVbkAAMlca.jpg`,`image`,`GP14fMIbAAEAxOW.jpg`,`null`,`../gallery/心理/GP14fMIbAAEAxOW.jpg`,`image`,`GPrhoy8WwAA_d5A.jpg`,`null`,`../gallery/心理/GPrhoy8WwAA_d5A.jpg`,`image`,`GQQGhIkbUAA8X0W.png`,`null`,`../gallery/心理/GQQGhIkbUAA8X0W.png`,`image`,`GRU7ji1WkAAmfzK.jpg`,`null`,`../gallery/心理/GRU7ji1WkAAmfzK.jpg`,`image`,`GTNMi4maYAAGL5j.jpg`,`null`,`../gallery/心理/GTNMi4maYAAGL5j.jpg`,`image`,`GTrbszEX0AAaKL7.png`,`null`,`../gallery/心理/GTrbszEX0AAaKL7.png`,`image`,`GVYWU6VXoAAGuMY.jpg`,`null`,`../gallery/心理/GVYWU6VXoAAGuMY.jpg`,`image`,`20250125201146.webp`,`null`,`../gallery/拍摄/250125_中山_田寮水库/20250125201146.webp`,`image`,`20250125201150.webp`,`null`,`../gallery/拍摄/250125_中山_田寮水库/20250125201150.webp`,`image`,`20250125201154.webp`,`null`,`../gallery/拍摄/250125_中山_田寮水库/20250125201154.webp`,`image`,`20250125201155.webp`,`null`,`../gallery/拍摄/250125_中山_田寮水库/20250125201155.webp`,`image`,`20250125201156.webp`,`null`,`../gallery/拍摄/250125_中山_田寮水库/20250125201156.webp`,`image`,`20250302231149.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231149.webp`,`image`,`20250302231150.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231150.webp`,`image`,`20250302231151.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231151.webp`,`image`,`20250302231152.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231152.webp`,`image`,`20250302231155.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231155.webp`,`image`,`20250302231159.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231159.webp`,`image`,`20250302231160.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231160.webp`,`image`,`20250302231161.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231161.webp`,`image`,`20250302231162.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231162.webp`,`image`,`20250302231163.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231163.webp`,`image`,`20250302231164.webp`,`null`,`../gallery/拍摄/250302_中山_长江水库/20250302231164.webp`,`image`,`PXL_20250302_073157379.PHOTOSPHERE.jpg`,`null`,`../gallery/拍摄/250302_中山_长江水库/PXL_20250302_073157379.PHOTOSPHERE.jpg`,`image`,`20250316213019.webp`,`null`,`../gallery/拍摄/250316_中山_五桂山/20250316213019.webp`,`image`,`20250316213020.webp`,`null`,`../gallery/拍摄/250316_中山_五桂山/20250316213020.webp`,`image`,`20250323100801.webp`,`null`,`../gallery/拍摄/250322_中山_五桂山/20250323100801.webp`,`image`,`20250323100805.webp`,`null`,`../gallery/拍摄/250322_中山_五桂山/20250323100805.webp`,`image`,`20250323100809.webp`,`null`,`../gallery/拍摄/250322_中山_五桂山/20250323100809.webp`,`image`,`20250323100810.webp`,`null`,`../gallery/拍摄/250322_中山_五桂山/20250323100810.webp`,`image`,`20250502192255.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192255.webp`,`image`,`20250502192256.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192256.webp`,`image`,`20250502192257.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192257.webp`,`image`,`20250502192258.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192258.webp`,`image`,`20250502192259.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192259.webp`,`image`,`20250502192260.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192260.webp`,`image`,`20250502192261.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192261.webp`,`image`,`20250502192262.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192262.webp`,`image`,`20250502192263.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192263.webp`,`image`,`20250502192264.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192264.webp`,`image`,`20250502192265.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192265.webp`,`image`,`20250502192266.webp`,`null`,`../gallery/拍摄/250502_中山_黄泥坑/20250502192266.webp`,`image`,`20250505103211.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103211.webp`,`image`,`20250505103212.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103212.webp`,`image`,`20250505103213.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103213.webp`,`image`,`20250505103214.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103214.webp`,`image`,`20250505103215.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103215.webp`,`image`,`20250505103216.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103216.webp`,`image`,`20250505103217.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103217.webp`,`image`,`20250505103218.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103218.webp`,`image`,`20250505103219.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103219.webp`,`image`,`20250505103220.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103220.webp`,`image`,`20250505103221.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103221.webp`,`image`,`20250505103222.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103222.webp`,`image`,`20250505103223.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103223.webp`,`image`,`20250505103224.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103224.webp`,`image`,`20250505103225.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103225.webp`,`image`,`20250505103226.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103226.webp`,`image`,`20250505103227.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103227.webp`,`image`,`20250505103228.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103228.webp`,`image`,`20250505103229.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103229.webp`,`image`,`20250505103230.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103230.webp`,`image`,`20250505103231.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103231.webp`,`image`,`20250505103232.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103232.webp`,`image`,`20250505103233.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103233.webp`,`image`,`20250505103234.webp`,`null`,`../gallery/拍摄/250504_中山_长坑/20250505103234.webp`,`image`,`PXL_20250504_095352501.PHOTOSPHERE.jpg`,`妖婆石`,`../gallery/拍摄/250504_中山_长坑/PXL_20250504_095352501.PHOTOSPHERE.jpg`,`image`,`20220903205655.webp`,`null`,`../gallery/拍摄/婺源_理坑/20220903205655.webp`,`image`,`v2-861fd920d93d3ec02be584a2f3c998c9_720w.gif`,`null`,`../gallery/格斗/v2-861fd920d93d3ec02be584a2f3c998c9_720w.gif`,`image`,`v2-d1ddc22799f665aee9b55df5015cfbb3_720w.gif`,`null`,`../gallery/格斗/v2-d1ddc22799f665aee9b55df5015cfbb3_720w.gif`,`image`,`707.jpg`,`null`,`../gallery/科普/707.jpg`,`image`,`732025-下午-95340.png`,`null`,`../gallery/科普/732025-下午-95340.png`,`image`,`732025-下午-95352.png`,`null`,`../gallery/科普/732025-下午-95352.png`,`image`,`cvt变速原理-通过前后两个可以改变直径的固定盘-来模拟这一齿轮比变化状态.gif`,`null`,`../gallery/科普/cvt变速原理-通过前后两个可以改变直径的固定盘-来模拟这一齿轮比变化状态.gif`,`image`,`GJgZkY7WoAAL6zh.jpg`,`null`,`../gallery/科普/GJgZkY7WoAAL6zh.jpg`,`image`,`GJH5oCDaQAEiI4O.jpg`,`null`,`../gallery/科普/GJH5oCDaQAEiI4O.jpg`,`image`,`GOs_fOtXgAAJJbn.jpg`,`null`,`../gallery/科普/GOs_fOtXgAAJJbn.jpg`,`image`,`GQJj8OYWEAABccV.jpg`,`null`,`../gallery/科普/GQJj8OYWEAABccV.jpg`,`image`,`GQUCc-JXsAAIntv.jpg`,`null`,`../gallery/科普/GQUCc-JXsAAIntv.jpg`,`image`,`GRkfnOIaEAEqBrS.jpg`,`null`,`../gallery/科普/GRkfnOIaEAEqBrS.jpg`,`image`,`GVRHkKzXcAAPZfj.jpg`,`null`,`../gallery/科普/GVRHkKzXcAAPZfj.jpg`,`image`,`柴田车钩.png`,`null`,`../gallery/科普/柴田车钩.png`,`image`,`疯帽匠苦瓜籽.webp`,`null`,`../gallery/科普/疯帽匠苦瓜籽.webp`,`image`,`africa donates.jpg`,`null`,`../gallery/讽刺/africa donates.jpg`,`image`,`GFim1QJWsAEDqvT.jpg`,`null`,`../gallery/讽刺/GFim1QJWsAEDqvT.jpg`,`image`,`GFuaLRLbcAAEA3_.jpg`,`null`,`../gallery/讽刺/GFuaLRLbcAAEA3_.jpg`,`image`,`GFVQn35b0AAN8FM.jpg`,`null`,`../gallery/讽刺/GFVQn35b0AAN8FM.jpg`,`image`,`GGIylexW8AAwpP4.jpg`,`null`,`../gallery/讽刺/GGIylexW8AAwpP4.jpg`,`image`,`GGKy0ZGX0AAdyRS.jpg`,`null`,`../gallery/讽刺/GGKy0ZGX0AAdyRS.jpg`,`image`,`GGqgs9vakAAufqt.jpg`,`null`,`../gallery/讽刺/GGqgs9vakAAufqt.jpg`,`image`,`GH7EimjaMAIggjo.jpg`,`null`,`../gallery/讽刺/GH7EimjaMAIggjo.jpg`,`image`,`GHBj56pacAAnQmG.jpg`,`null`,`../gallery/讽刺/GHBj56pacAAnQmG.jpg`,`image`,`GIJ5K2rXYAAa4Zh.jpg`,`null`,`../gallery/讽刺/GIJ5K2rXYAAa4Zh.jpg`,`image`,`GJ-rJznagAAInT7.jpg`,`null`,`../gallery/讽刺/GJ-rJznagAAInT7.jpg`,`image`,`GJ6IL5HXAAAk8dK.jpg`,`null`,`../gallery/讽刺/GJ6IL5HXAAAk8dK.jpg`,`image`,`GJ9R1_YaAAAFlDh.jpg`,`null`,`../gallery/讽刺/GJ9R1_YaAAAFlDh.jpg`,`image`,`GJARCMbWcAAytmk.jpg`,`null`,`../gallery/讽刺/GJARCMbWcAAytmk.jpg`,`image`,`GJCzyeaXAAAVwFF.jpg`,`null`,`../gallery/讽刺/GJCzyeaXAAAVwFF.jpg`,`image`,`GJphThFbwAA021r.jpg`,`null`,`../gallery/讽刺/GJphThFbwAA021r.jpg`,`image`,`GJr03EmbcAAAJ5D.jpg`,`null`,`../gallery/讽刺/GJr03EmbcAAAJ5D.jpg`,`image`,`GJsNHuNacAAb49b.jpg`,`null`,`../gallery/讽刺/GJsNHuNacAAb49b.jpg`,`image`,`GJVrQOZXwAA1rTT.jpg`,`null`,`../gallery/讽刺/GJVrQOZXwAA1rTT.jpg`,`image`,`GK4g6rDa0AA7B8H.jpg`,`null`,`../gallery/讽刺/GK4g6rDa0AA7B8H.jpg`,`image`,`GKDQaxkbAAATlhj.jpg`,`null`,`../gallery/讽刺/GKDQaxkbAAATlhj.jpg`,`image`,`GKfFafXX0AEi9FX.jpg`,`null`,`../gallery/讽刺/GKfFafXX0AEi9FX.jpg`,`image`,`GKlEjtuW8AA5b8o.jpg`,`null`,`../gallery/讽刺/GKlEjtuW8AA5b8o.jpg`,`image`,`GKS2enZawAEyId5.jpg`,`null`,`../gallery/讽刺/GKS2enZawAEyId5.jpg`,`image`,`GKYVF9zaAAAb4rb.jpg`,`null`,`../gallery/讽刺/GKYVF9zaAAAb4rb.jpg`,`image`,`GLfU4bLbAAAVVPu.jpg`,`null`,`../gallery/讽刺/GLfU4bLbAAAVVPu.jpg`,`image`,`GLKdfhiawAAVZHU.jpg`,`null`,`../gallery/讽刺/GLKdfhiawAAVZHU.jpg`,`image`,`GLkst2WagAAmHsb.jpg`,`null`,`../gallery/讽刺/GLkst2WagAAmHsb.jpg`,`image`,`GLnhiojWQAAOuJU.jpg`,`null`,`../gallery/讽刺/GLnhiojWQAAOuJU.jpg`,`image`,`GLnQ238W8AAtvVj.jpg`,`null`,`../gallery/讽刺/GLnQ238W8AAtvVj.jpg`,`image`,`GLr_WJpbkAAHPYb.jpg`,`null`,`../gallery/讽刺/GLr_WJpbkAAHPYb.jpg`,`image`,`GLwPOY0XMAAi55h.jpg`,`null`,`../gallery/讽刺/GLwPOY0XMAAi55h.jpg`,`image`,`GLYE-_9aEAAz_7H.jpg`,`null`,`../gallery/讽刺/GLYE-_9aEAAz_7H.jpg`,`image`,`GMDOI62WoAANk17.jpg`,`null`,`../gallery/讽刺/GMDOI62WoAANk17.jpg`,`image`,`GPbjklpaIAA4AtD.jpg`,`null`,`../gallery/讽刺/GPbjklpaIAA4AtD.jpg`,`image`,`GPf4vukbEAAoQQW.jpg`,`null`,`../gallery/讽刺/GPf4vukbEAAoQQW.jpg`,`image`,`GPoRqz-asAA3e-v.jpg`,`null`,`../gallery/讽刺/GPoRqz-asAA3e-v.jpg`,`image`,`GPy71Q1b0AAY4kq.jpg`,`null`,`../gallery/讽刺/GPy71Q1b0AAY4kq.jpg`,`image`,`GQ0W7VAawAA2WOC.jpg`,`null`,`../gallery/讽刺/GQ0W7VAawAA2WOC.jpg`,`image`,`GQ42MpxW4AAEOkU.jpg`,`null`,`../gallery/讽刺/GQ42MpxW4AAEOkU.jpg`,`image`,`GQ4vrVNakAAMuMw.jpg`,`null`,`../gallery/讽刺/GQ4vrVNakAAMuMw.jpg`,`image`,`GQ9XI-9bwAACNeK.jpg`,`null`,`../gallery/讽刺/GQ9XI-9bwAACNeK.jpg`,`image`,`GQBfLaMagAA_rD3.jpg`,`null`,`../gallery/讽刺/GQBfLaMagAA_rD3.jpg`,`image`,`GQScKaRWgAEAeZ2.jpg`,`null`,`../gallery/讽刺/GQScKaRWgAEAeZ2.jpg`,`image`,`GQuaAkzawAAE2vA.png`,`null`,`../gallery/讽刺/GQuaAkzawAAE2vA.png`,`image`,`GQV7kI7bQAAVsNT.jpg`,`null`,`../gallery/讽刺/GQV7kI7bQAAVsNT.jpg`,`image`,`GQVIhBnaoAAvFf8.jpg`,`null`,`../gallery/讽刺/GQVIhBnaoAAvFf8.jpg`,`image`,`GR2era6bkAAq9fZ.jpg`,`null`,`../gallery/讽刺/GR2era6bkAAq9fZ.jpg`,`image`,`GR2yxmvacAI8d1G.jpg`,`null`,`../gallery/讽刺/GR2yxmvacAI8d1G.jpg`,`image`,`GRBdB-Aa4AAdxTb.jpg`,`null`,`../gallery/讽刺/GRBdB-Aa4AAdxTb.jpg`,`image`,`GRe48dlb0AEgtO4.jpg`,`null`,`../gallery/讽刺/GRe48dlb0AEgtO4.jpg`,`image`,`GRh7wBfWcAAaJgQ.jpg`,`null`,`../gallery/讽刺/GRh7wBfWcAAaJgQ.jpg`,`image`,`GRkcn3GbYAEQQ9E.jpg`,`null`,`../gallery/讽刺/GRkcn3GbYAEQQ9E.jpg`,`image`,`GRN7vu-b0AEG63q.jpg`,`null`,`../gallery/讽刺/GRN7vu-b0AEG63q.jpg`,`image`,`GRNRusXWgAAr-HC.jpg`,`null`,`../gallery/讽刺/GRNRusXWgAAr-HC.jpg`,`image`,`GRPOtetaEAAs4C3.jpg`,`null`,`../gallery/讽刺/GRPOtetaEAAs4C3.jpg`,`image`,`GRpwQLUbMAQAse7.jpg`,`null`,`../gallery/讽刺/GRpwQLUbMAQAse7.jpg`,`image`,`GRsYQPebMAE8rFu.jpg`,`null`,`../gallery/讽刺/GRsYQPebMAE8rFu.jpg`,`image`,`GRVf7QhWYAAmtsf.jpg`,`null`,`../gallery/讽刺/GRVf7QhWYAAmtsf.jpg`,`image`,`GRvQ3Y4bwAA53iG.jpg`,`null`,`../gallery/讽刺/GRvQ3Y4bwAA53iG.jpg`,`image`,`GT29uMeWwAAKyru.jpg`,`null`,`../gallery/讽刺/GT29uMeWwAAKyru.jpg`,`image`,`GT6LbVfXIAgVgGz.jpg`,`null`,`../gallery/讽刺/GT6LbVfXIAgVgGz.jpg`,`image`,`GTb-5TGWoAAupke.jpg`,`null`,`../gallery/讽刺/GTb-5TGWoAAupke.jpg`,`image`,`GTjd35GaAAAKKYP.jpg`,`null`,`../gallery/讽刺/GTjd35GaAAAKKYP.jpg`,`image`,`GTK0JvwbgAAv-3Z.jpg`,`null`,`../gallery/讽刺/GTK0JvwbgAAv-3Z.jpg`,`image`,`GTLN9VUWYAAUZ7n.jpg`,`null`,`../gallery/讽刺/GTLN9VUWYAAUZ7n.jpg`,`image`,`GTnut5SagAEqwSJ.jpg`,`null`,`../gallery/讽刺/GTnut5SagAEqwSJ.jpg`,`image`,`GTU1sehacAAlSBu.jpg`,`null`,`../gallery/讽刺/GTU1sehacAAlSBu.jpg`,`image`,`GTutDiyaEAAn46B.jpg`,`null`,`../gallery/讽刺/GTutDiyaEAAn46B.jpg`,`image`,`GTvldBVaAAAF66m.jpg`,`null`,`../gallery/讽刺/GTvldBVaAAAF66m.jpg`,`image`,`GUGDdSeXcAAwAXl.jpg`,`null`,`../gallery/讽刺/GUGDdSeXcAAwAXl.jpg`,`image`,`GUgzCEnXYAAkpe9.jpg`,`null`,`../gallery/讽刺/GUgzCEnXYAAkpe9.jpg`,`image`,`GUQHI8KaAAAlzOo.jpg`,`null`,`../gallery/讽刺/GUQHI8KaAAAlzOo.jpg`,`image`,`GUR7J16bIAAg15N.jpg`,`null`,`../gallery/讽刺/GUR7J16bIAAg15N.jpg`,`image`,`GUsRWvYa0AA-N8Q.jpg`,`null`,`../gallery/讽刺/GUsRWvYa0AA-N8Q.jpg`,`image`,`GVgFeX1XQAAhyfb.jpg`,`null`,`../gallery/讽刺/GVgFeX1XQAAhyfb.jpg`,`image`,`GVp6Qs8XMAEojQo.jpg`,`null`,`../gallery/讽刺/GVp6Qs8XMAEojQo.jpg`,`image`,`GVPWiNtbQAAbR7N.jpg`,`null`,`../gallery/讽刺/GVPWiNtbQAAbR7N.jpg`,`image`,`GVRu2C4WsAAWrkU.jpg`,`null`,`../gallery/讽刺/GVRu2C4WsAAWrkU.jpg`,`image`,`GVtZvZ9a8AEN5Gm.jpg`,`null`,`../gallery/讽刺/GVtZvZ9a8AEN5Gm.jpg`,`image`,`GVWMSiMWcAAdy5n.jpg`,`null`,`../gallery/讽刺/GVWMSiMWcAAdy5n.jpg`,`image`,`GVYb65yaMAA84Jm.jpg`,`null`,`../gallery/讽刺/GVYb65yaMAA84Jm.jpg`,`image`,`LL08owik.jpg`,`null`,`../gallery/讽刺/LL08owik.jpg`,`image`,`中国特色社会主义马车。.jpg`,`null`,`../gallery/讽刺/中国特色社会主义马车。.jpg`,`image`,`中国的保险.jpg`,`null`,`../gallery/讽刺/中国的保险.jpg`,`image`,`丰巢柜存骨灰最划算.jpg`,`null`,`../gallery/讽刺/丰巢柜存骨灰最划算.jpg`,`image`,`你怎么没有一个好姑姑.jpg`,`null`,`../gallery/讽刺/你怎么没有一个好姑姑.jpg`,`image`,`元宵除夕.jpg`,`null`,`../gallery/讽刺/元宵除夕.jpg`,`image`,`哪怕是最低限度的一个表达，也会形成一种力量。.jpg`,`null`,`../gallery/讽刺/哪怕是最低限度的一个表达，也会形成一种力量。.jpg`,`image`,`如何反驳“你又不做坏事，把隐私交给国家有何不可？”.jpg`,`null`,`../gallery/讽刺/如何反驳“你又不做坏事，把隐私交给国家有何不可？”.jpg`,`image`,`投资者不要以盈利为唯一目的.jpg`,`null`,`../gallery/讽刺/投资者不要以盈利为唯一目的.jpg`,`image`,`新闻与宣传的区别！.jpg`,`null`,`../gallery/讽刺/新闻与宣传的区别！.jpg`,`image`,`维稳.jpg`,`null`,`../gallery/讽刺/维稳.jpg`,`image`,`网友评五月天假唱事件.png`,`null`,`../gallery/讽刺/网友评五月天假唱事件.png`,`image`,`行行好，能给中医一个面子吗？.jpg`,`null`,`../gallery/讽刺/行行好，能给中医一个面子吗？.jpg`,`image`,`银行卡错误的被冻结之后。.jpg`,`null`,`../gallery/讽刺/银行卡错误的被冻结之后。.jpg`,`image`,`高龄津贴发放调整通知.jpg`,`null`,`../gallery/讽刺/高龄津贴发放调整通知.jpg`,`image`,`8.jpg`,`null`,`../gallery/调侃/8.jpg`,`image`,`F79QYV6awAAY_S6.png`,`null`,`../gallery/调侃/F79QYV6awAAY_S6.png`,`image`,`GFcc-RAWMAAmLsl.jpg`,`null`,`../gallery/调侃/GFcc-RAWMAAmLsl.jpg`,`image`,`GFgIKcdWUAEbxeF.jpg`,`null`,`../gallery/调侃/GFgIKcdWUAEbxeF.jpg`,`image`,`GFYfeaEbgAAfSNn.jpg`,`null`,`../gallery/调侃/GFYfeaEbgAAfSNn.jpg`,`image`,`GG5SLDwbkAAnjL7.jpg`,`null`,`../gallery/调侃/GG5SLDwbkAAnjL7.jpg`,`image`,`GHBs63TboAAKth1.jpg`,`null`,`../gallery/调侃/GHBs63TboAAKth1.jpg`,`image`,`GHCdKepasAE2zpB.jpg`,`null`,`../gallery/调侃/GHCdKepasAE2zpB.jpg`,`image`,`GHEmP_wbYAAXOqK.jpg`,`null`,`../gallery/调侃/GHEmP_wbYAAXOqK.jpg`,`image`,`GI24mPwacAApvuK.jpg`,`null`,`../gallery/调侃/GI24mPwacAApvuK.jpg`,`image`,`GI7vsiCboAAGwfO.jpg`,`null`,`../gallery/调侃/GI7vsiCboAAGwfO.jpg`,`image`,`GIuQGGUWgAAojiV.jpg`,`null`,`../gallery/调侃/GIuQGGUWgAAojiV.jpg`,`image`,`GIzjI7eXMAAtvCr.jpg`,`null`,`../gallery/调侃/GIzjI7eXMAAtvCr.jpg`,`image`,`GJ26uw0aUAA_X-T.jpg`,`null`,`../gallery/调侃/GJ26uw0aUAA_X-T.jpg`,`image`,`GJa7heNboAAdly3.png`,`null`,`../gallery/调侃/GJa7heNboAAdly3.png`,`image`,`GJNnw1-XYAAak24.jpg`,`null`,`../gallery/调侃/GJNnw1-XYAAak24.jpg`,`image`,`GJVgtT3WwAAKAio.jpg`,`null`,`../gallery/调侃/GJVgtT3WwAAKAio.jpg`,`image`,`GK62uPFa4AA_X9l.jpg`,`null`,`../gallery/调侃/GK62uPFa4AA_X9l.jpg`,`image`,`GKAxKDpaoAAb7XS.jpg`,`null`,`../gallery/调侃/GKAxKDpaoAAb7XS.jpg`,`image`,`GKcpE8ibIAAWU_o.jpg`,`null`,`../gallery/调侃/GKcpE8ibIAAWU_o.jpg`,`image`,`GKCtO4Ea4AA0H5B.jpg`,`null`,`../gallery/调侃/GKCtO4Ea4AA0H5B.jpg`,`image`,`GKDq_6ja0AAoJzS.jpg`,`null`,`../gallery/调侃/GKDq_6ja0AAoJzS.jpg`,`image`,`GKH2z8_bQAAQGXS.jpg`,`null`,`../gallery/调侃/GKH2z8_bQAAQGXS.jpg`,`image`,`GL0WhjJawAANYGo.jpg`,`null`,`../gallery/调侃/GL0WhjJawAANYGo.jpg`,`image`,`GLi1rYKa8AEUa6q.jpg`,`null`,`../gallery/调侃/GLi1rYKa8AEUa6q.jpg`,`image`,`GLnIlmSbAAAs-BV.jpg`,`null`,`../gallery/调侃/GLnIlmSbAAAs-BV.jpg`,`image`,`GLQBOZbasAATcXb.jpg`,`null`,`../gallery/调侃/GLQBOZbasAATcXb.jpg`,`image`,`GLQJOBbaAAAc6XL.jpg`,`null`,`../gallery/调侃/GLQJOBbaAAAc6XL.jpg`,`image`,`GM-DzoZWAAAjoyE.jpg`,`null`,`../gallery/调侃/GM-DzoZWAAAjoyE.jpg`,`image`,`GM0SgDyWMAAaXgl.jpg`,`null`,`../gallery/调侃/GM0SgDyWMAAaXgl.jpg`,`image`,`GOfQlITbsAA2sYE.jpg`,`null`,`../gallery/调侃/GOfQlITbsAA2sYE.jpg`,`image`,`GOLI5PRXYAA-Skq.jpg`,`null`,`../gallery/调侃/GOLI5PRXYAA-Skq.jpg`,`image`,`GOQpETkXAAAQgbB.jpg`,`null`,`../gallery/调侃/GOQpETkXAAAQgbB.jpg`,`image`,`GOWDYUpWwAAFRr2.jpg`,`null`,`../gallery/调侃/GOWDYUpWwAAFRr2.jpg`,`image`,`GOWm2ylaEAAMR5x.jpg`,`null`,`../gallery/调侃/GOWm2ylaEAAMR5x.jpg`,`image`,`GOXkugwWYAA0IWk.jpg`,`null`,`../gallery/调侃/GOXkugwWYAA0IWk.jpg`,`image`,`GP0ZDPQXgAAwA_G.jpg`,`null`,`../gallery/调侃/GP0ZDPQXgAAwA_G.jpg`,`image`,`GP6VzuzawAA0MQG.jpg`,`null`,`../gallery/调侃/GP6VzuzawAA0MQG.jpg`,`image`,`GPkdN2UWAAAMZAi.jpg`,`null`,`../gallery/调侃/GPkdN2UWAAAMZAi.jpg`,`image`,`GPoUav-XMAAkB-7.jpg`,`null`,`../gallery/调侃/GPoUav-XMAAkB-7.jpg`,`image`,`GQ4352raQAAGc_o.jpg`,`null`,`../gallery/调侃/GQ4352raQAAGc_o.jpg`,`image`,`GQ43lIba0AAkU-_.jpg`,`null`,`../gallery/调侃/GQ43lIba0AAkU-_.jpg`,`image`,`GQ43qQEagAAgi5B.jpg`,`null`,`../gallery/调侃/GQ43qQEagAAgi5B.jpg`,`image`,`GQ9PkbYbwAIyheg.jpg`,`null`,`../gallery/调侃/GQ9PkbYbwAIyheg.jpg`,`image`,`GQeTCUAaMAAgQrI.jpg`,`null`,`../gallery/调侃/GQeTCUAaMAAgQrI.jpg`,`image`,`GQf2aBOaIAI17zM.jpg`,`null`,`../gallery/调侃/GQf2aBOaIAI17zM.jpg`,`image`,`GQge8n_XoAAMmcn.jpg`,`null`,`../gallery/调侃/GQge8n_XoAAMmcn.jpg`,`image`,`GQhTdX1XUAAqSOT.jpg`,`null`,`../gallery/调侃/GQhTdX1XUAAqSOT.jpg`,`image`,`GQKSEuxbUAA-JdT.jpg`,`null`,`../gallery/调侃/GQKSEuxbUAA-JdT.jpg`,`image`,`GQKVL2OawAACuuU.jpg`,`null`,`../gallery/调侃/GQKVL2OawAACuuU.jpg`,`image`,`GQqKLplakAIFdmk.jpg`,`null`,`../gallery/调侃/GQqKLplakAIFdmk.jpg`,`image`,`GQRxOUKWYAAR5gt.jpg`,`null`,`../gallery/调侃/GQRxOUKWYAAR5gt.jpg`,`image`,`GQSW4lmacAA--Kk.jpg`,`null`,`../gallery/调侃/GQSW4lmacAA--Kk.jpg`,`image`,`GQucSQzacAAbH_4.png`,`null`,`../gallery/调侃/GQucSQzacAAbH_4.png`,`image`,`GQUiL9YbcAAaIGA.jpg`,`null`,`../gallery/调侃/GQUiL9YbcAAaIGA.jpg`,`image`,`GQukpFmbQAAx5mw.jpg`,`null`,`../gallery/调侃/GQukpFmbQAAx5mw.jpg`,`image`,`GQ_sPNHaYAAPjjm.jpg`,`null`,`../gallery/调侃/GQ_sPNHaYAAPjjm.jpg`,`image`,`GQ_v5O1W0AAegU2.jpg`,`null`,`../gallery/调侃/GQ_v5O1W0AAegU2.jpg`,`image`,`GRfKS_OawAAV6po.jpg`,`null`,`../gallery/调侃/GRfKS_OawAAV6po.jpg`,`image`,`GRjqpVabEAAhAqF.jpg`,`null`,`../gallery/调侃/GRjqpVabEAAhAqF.jpg`,`image`,`GRkEKQ4bcAApeI7.jpg`,`null`,`../gallery/调侃/GRkEKQ4bcAApeI7.jpg`,`image`,`GRNaAA_bcAAFwuL.png`,`null`,`../gallery/调侃/GRNaAA_bcAAFwuL.png`,`image`,`GRNci9ma4AAaCu_.jpg`,`null`,`../gallery/调侃/GRNci9ma4AAaCu_.jpg`,`image`,`GRNcWXCbcAA4cYv.jpg`,`null`,`../gallery/调侃/GRNcWXCbcAA4cYv.jpg`,`image`,`GRU2wjHbEAAtVRK.jpg`,`null`,`../gallery/调侃/GRU2wjHbEAAtVRK.jpg`,`image`,`GRVvfzkbsAAG4g5.jpg`,`null`,`../gallery/调侃/GRVvfzkbsAAG4g5.jpg`,`image`,`GRXfj41aUAAGnWq.jpg`,`null`,`../gallery/调侃/GRXfj41aUAAGnWq.jpg`,`image`,`GRyjSzPacAMtoeI.jpg`,`null`,`../gallery/调侃/GRyjSzPacAMtoeI.jpg`,`image`,`GSNQqz0aEAAA8Sw.jpg`,`null`,`../gallery/调侃/GSNQqz0aEAAA8Sw.jpg`,`image`,`GTgBk7zbQAAlcwP.jpg`,`null`,`../gallery/调侃/GTgBk7zbQAAlcwP.jpg`,`image`,`GTiDaleasAAVp7C.jpg`,`null`,`../gallery/调侃/GTiDaleasAAVp7C.jpg`,`image`,`GTnASpeaYAACTFX.jpg`,`null`,`../gallery/调侃/GTnASpeaYAACTFX.jpg`,`image`,`GTo-gXYbEAAS4qv.jpg`,`null`,`../gallery/调侃/GTo-gXYbEAAS4qv.jpg`,`image`,`GU23sKGaIAAm_RL.jpg`,`null`,`../gallery/调侃/GU23sKGaIAAm_RL.jpg`,`image`,`GU2XXqtbUAAaFjm.jpg`,`null`,`../gallery/调侃/GU2XXqtbUAAaFjm.jpg`,`image`,`GU3h4FkbAAA8AF4.jpg`,`null`,`../gallery/调侃/GU3h4FkbAAA8AF4.jpg`,`image`,`GUa9tCRWcAAZFVs.jpg`,`null`,`../gallery/调侃/GUa9tCRWcAAZFVs.jpg`,`image`,`GUdowCtaAAASoFL.jpg`,`null`,`../gallery/调侃/GUdowCtaAAASoFL.jpg`,`image`,`GUH30c4bIAAcvxi.jpg`,`null`,`../gallery/调侃/GUH30c4bIAAcvxi.jpg`,`image`,`GUiQkm9WUAAd4nX.jpg`,`null`,`../gallery/调侃/GUiQkm9WUAAd4nX.jpg`,`image`,`GUJaEmBWcAEEMBv.jpg`,`null`,`../gallery/调侃/GUJaEmBWcAEEMBv.jpg`,`image`,`GUZH_Cfa8AE_MqU.jpg`,`null`,`../gallery/调侃/GUZH_Cfa8AE_MqU.jpg`,`image`,`GV10_mpa8AA2N2R.png`,`null`,`../gallery/调侃/GV10_mpa8AA2N2R.png`,`image`,`GVARo6BbkAAExup.jpg`,`null`,`../gallery/调侃/GVARo6BbkAAExup.jpg`,`image`,`GVjlCT_aQAA1tdT.jpg`,`null`,`../gallery/调侃/GVjlCT_aQAA1tdT.jpg`,`image`,`GVlwRRgW4AA_sbe.jpg`,`null`,`../gallery/调侃/GVlwRRgW4AA_sbe.jpg`,`image`,`GVQp9BvXUAAuq3l.jpg`,`null`,`../gallery/调侃/GVQp9BvXUAAuq3l.jpg`,`image`,`GVST8NSXYAA2tPM.jpg`,`null`,`../gallery/调侃/GVST8NSXYAA2tPM.jpg`,`image`,`GVWgGS5aYAAJeeM.jpg`,`null`,`../gallery/调侃/GVWgGS5aYAAJeeM.jpg`,`image`,`GVZ28MHaMAAvp3x.jpg`,`null`,`../gallery/调侃/GVZ28MHaMAAvp3x.jpg`,`image`,`Meme, Laugh, Like, Follow, and Share.jpg`,`null`,`../gallery/调侃/Meme, Laugh, Like, Follow, and Share.jpg`,`image`,`Which one.jpg`,`null`,`../gallery/调侃/Which one.jpg`,`image`,`抽烟如何防止薰到眼睛.webp`,`null`,`../gallery/调侃/抽烟如何防止薰到眼睛.webp`,`image`,`明史.jpg`,`null`,`../gallery/调侃/明史.jpg`,`image`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/01 雨が空を捨てる日は.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/02 彼女の生き方.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/03 トラックに乗せて.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/04 流浪（さすらい）の詩（うた）.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/05 真直（まっすぐ）な線.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/06 五才（いつつ）の頃.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/07 冬を待つ季節.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/08 夜風の中から.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/09 03時.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/10 うそつきが好きよ.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/11 妬いてる訳じゃないけれど.mp3`,`audio`,``,``,`audio/中島みゆき/1976】みんな去ってしまった/12 忘れられるものならば.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/01 あぶな坂.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/02 あたしのやさしい人.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/03 信じられない頃に.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/04 ボギーボビーの赤いバラ.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/05 海よ.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/06 アザミ嬢のララバイ.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/07 踊り明かそう.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/08 ひとり遊び.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/09 悲しいことはいつもある.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/10 歌をあなたに.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/11 渚便り.mp3`,`audio`,``,``,`audio/中島みゆき/1976】私の声が聞こえますか/12 時代.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/01 遍路.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/02 店の名はライフ.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/03 まつりばやし.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/04 女なんてものに.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/05 朝焼け.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/06 ホームにて.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/07 勝手にしやがれ.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/08 サーチライト.mp3`,`audio`,``,``,`audio/中島みゆき/1977】あ-り-が-と-う/09 時は流れて.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/01 「元気ですか」.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/02 怜子.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/03 わかれうた.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/04 海鳴り.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/05 化粧.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/06 ミルク32.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/07 あほう鳥.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/08 おまえの家.mp3`,`audio`,``,``,`audio/中島みゆき/1978】愛していると云ってくれ/09 世情.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/01 あばよ.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/02 髪.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/03 サヨナラを伝えて.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/04 しあわせ芝居.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/05 雨….mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/06 この空を飛べたら.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/07 世迷い言.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/08 ルージュ.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/09 追いかけてヨコハマ.mp3`,`audio`,``,``,`audio/中島みゆき/1979】おかえりなさい/10 強がりはよせヨ.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/01 裸足で走れ.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/02 タクシードライバー.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/03 泥海の中から.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/04 信じ難いもの.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/05 根雪(ねゆき).mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/06 片想.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/07 ダイヤル117.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/08 小石のように.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/09 狼になりたい.mp3`,`audio`,``,``,`audio/中島みゆき/1979】親愛なる者へ/10 断崖-親愛なる者へ-.mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/01 うらみ-ます.mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/02 泣きたい夜に.mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/03 キツネ狩りの歌.mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/04 蕎麦屋.mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/05 船を出すのなら九月.mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/06 (インストゥルメンタル).mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/07 エレーン.mp3`,`audio`,``,``,`audio/中島みゆき/1980】生きていてもいいですか/08 異国.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/01 あした天気になれ.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/02 あなたが海を見ているうちに.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/03 あわせ鏡.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/04 ひとり上手.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/05 雪.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/06 バス通り.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/07 友情.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/08 成人世代.mp3`,`audio`,``,``,`audio/中島みゆき/1981】臨月/09 夜曲.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/01 悪女.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/02 傾斜.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/03 鳥になって.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/04 捨てるほどの愛でいいから.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/05 B.G.M..mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/06 家出.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/07 時刻表.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/08 砂の船.mp3`,`audio`,``,``,`audio/中島みゆき/1982】寒水魚/09 歌姫.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/01 この世に二人だけ.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/02 夏土産.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/03 髪を洗う女.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/04 ばいばいどくおぶざべい.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/05 誰のせいでもない雨が.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/06 縁.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/07 テキーラを飲みほして.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/08 金魚.mp3`,`audio`,``,``,`audio/中島みゆき/1983】予感/09 ファイト!.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/01 僕は青い鳥.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/02 幸福論.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/03 ひとり.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/04 生まれた時から.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/05 彼女によろしく.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/06 不良.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/07 シニカル-ムーン.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/08 春までなんぼ.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/09 僕たちの将来.mp3`,`audio`,``,``,`audio/中島みゆき/1984】はじめまして/10 はじめまして.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/01 極楽通りへいらっしゃい.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/02 あしたバーボンハウスで.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/03 熱病.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/04 それ以上言わないで.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/05 孤独の肖像.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/06 月の赤ん坊.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/07 忘れてはいけない.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/08 ショウ-タイム.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/09 ノスタルジア.mp3`,`audio`,``,``,`audio/中島みゆき/1985】miss. M_/10 肩に降る雨.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/01 ひとりぽっちで踊らせて.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/02 すずめ.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/03 最愛.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/04 さよならの鐘.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/05 海と宝石.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/06 カム-フラージュ.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/07 煙草.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/08 美貌の都.mp3`,`audio`,``,``,`audio/中島みゆき/1985】御色なおし/09 かもめはかもめ.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/01 あたいの夏休み.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/02 最悪.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/03 F.O..mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/04 毒をんな.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/05 シーサイド-コーポラス.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/06 山猫.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/07 HALF.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/08 見返り美人.mp3`,`audio`,``,``,`audio/中島みゆき/1986】36.5℃/09 白鳥の歌が聞こえる.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/01 アザミ嬢のララバイ.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/02 時代.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/03 こんばんわ.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/04 夜風の中から.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/05 わかれうた.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/06 おもいで河.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/07 りばいばる.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/08 かなしみ笑い.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/09 ひとり上手.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/10 あした天気になれ.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/11 悪女.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/12 誘惑.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/13 横恋慕.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/14 あの娘.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/15 ひとり.mp3`,`audio`,``,``,`audio/中島みゆき/1986】中島みゆき THE BEST/16 孤独の肖像.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-01 やまねこ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-02 シーサイド-コーポラス.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-03 見返り美人.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-04 どこにいても.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-05 あたいの夏休み.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-06 噂.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-07 つめたい別れ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-08 ショウ-タイム.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-09 孤独の肖像.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-10 100人目の恋人.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-11 ひとり.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/1-12 海と宝石.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-01 あの娘.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-02 波の上.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-03 横恋慕.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-04 忘れな草をもう一度.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-05 誘惑.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-06 やさしい女.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-07 悪女.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-08 笑わせるじゃないか.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-09 あした天気になれ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-10 杏村から.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-11 ひとり上手.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-12 悲しみに.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-13 かなしみ笑い.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/2-14 霧に走る.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-01 りばいばる.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-02 ピエロ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-03 おもいで河.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-04 ほうせんか.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-05 わかれうた.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-06 ホームにて.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-07 夜風の中から.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-08 忘れられるものならば.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-09 こんばんわ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-10 強い風はいつも.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-11 時代.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-12 傷ついた翼.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-13 アザミ嬢のララバイ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】Singles/3-14 さよならさよなら.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/01 片想'86.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/02 狼になりたい.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/03 悪女.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/04 HALF.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/05 鳥になって.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/06 クリスマスソングを唄うように.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/07 阿呆鳥.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/08 最悪.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/09 F.O..mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/10 この世に二人だけ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/11 縁.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/12 見返り美人.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/13 やまねこ.mp3`,`audio`,``,``,`audio/中島みゆき/1987】歌暦/14 波の上.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/01 野ウサギのように.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/02 ふらふら.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/03 MEGAMI.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/04 気にしないで.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/05 十二月.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/06 たとえ世界が空から落ちても.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/07 愛よりも.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/08 涙 -Made in tears-.mp3`,`audio`,``,``,`audio/中島みゆき/1988】グッバイガール/09 吹雪.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/01 湾岸24時.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/02 御機嫌如何.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/03 土用波.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/04 泥は降りしきる.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/05 ミュージシャン.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/06 黄色い犬.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/07 仮面.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/08 クレンジング クリーム.mp3`,`audio`,``,``,`audio/中島みゆき/1988】中島みゆき/09 ローリング.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/01 ひとり上手.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/02 横恋慕.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/03 誘惑.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/04 悪女.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/05 あの娘.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/06 見返り美人.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/07 土用波.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/08 あたいの夏休み.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/09 わかれうた.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/10 ホームにて.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/11 かもめはかもめ.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/12 月の赤ん坊.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/13 ミュージシャン.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/14 あした天気になれ.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/15 アザミ嬢のララバイ.mp3`,`audio`,``,``,`audio/中島みゆき/1989】Presents Best Selection 16/16 時代.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/01 黄砂に吹かれて.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/02 肩幅の未来.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/03 あり、か.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/04 群衆.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/05 ロンリー カナリア.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/06 くらやみ乙女.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/07 儀式（セレモニー）.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/08 未完成.mp3`,`audio`,``,``,`audio/中島みゆき/1989】回帰熱/09 春なのに.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/01 夜を往け.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/02 ふたつの炎.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/03 3分後に捨ててもいい.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/04 あした.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/05 新曾根崎心中.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/06 君の昔を.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/07 遠雷.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/08 ふたりは.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/09 北の国の習い.mp3`,`audio`,``,``,`audio/中島みゆき/1990】夜を往け/10 with.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/01 C.Q..mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/02 おだやかな時代.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/03 トーキョー迷子.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/04 Maybe.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/05 渚へ.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/06 永久欠番.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/07 笑ってよエンジェル.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/08 た-わ-わ.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/09 サッポロSNOWY.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/10 南三条.mp3`,`audio`,``,``,`audio/中島みゆき/1991】歌でしか言えない/11 炎と水.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/01 時代.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/02 トーキョー迷子.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/03 涙 -Made in tears-.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/04 春なのに.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/05 黄砂に吹かれて.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/06 まつりばやし.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/07 シュガー.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/08 やまねこ.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/09 With.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/10 Maybe.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/11 あした.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/12 歌姫.mp3`,`audio`,``,``,`audio/中島みゆき/1992】Best Selection II/13 世情.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/01 EAST ASIA.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/02 やばい恋.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/03 浅い眠り.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/04 萩野原.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/05 誕生.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/06 此処じゃない何処かへ.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/07 妹じゃあるまいし.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/08 二隻の舟.mp3`,`audio`,``,``,`audio/中島みゆき/1992】EAST ASIA/09 糸.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/01 時代.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/02 風の姿.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/03 ローリング.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/04 あどけない話.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/05 夢見る勇気（ちから）.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/06 あたし時々おもうの.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/07 流浪（さすらい）の詩（うた）.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/08 雨月の使者.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/09 慟哭.mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/10 孤独の肖像1st..mp3`,`audio`,``,``,`audio/中島みゆき/1993】時代 -Time goes around-/11 かもめの歌.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/01 空と君のあいだに（新録）.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/02 もう桟橋に灯りは点らない.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/03 バラ色の未来.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/04 ひまわり_SUNWARD_.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/05 アンテナの街.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/06 てんびん秤.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/07 流星.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/08 夢だったんだね.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/09 風にならないか.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/10 YOU NEVER NEED ME.mp3`,`audio`,``,``,`audio/中島みゆき/1994】LOVE OR NOTHING/11 眠らないで.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-01 時代.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-02 最後の女神.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-03 ジェラシー-ジェラシー.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-04 兆しのシーズン.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-05 浅い眠り.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-06 親愛なる者へ.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-07 誕生.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-08 Maybe.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-09 トーキョー迷子.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/1-10 見返り美人 (2nd Version).mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-01 with.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-02 笑ってよエンジェル.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-03 あした.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-04 グッバイガール.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-05 涙 -Made in tears-.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-06 空港日誌.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-07 仮面.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-08 熱病 (2nd Version).mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-09 御機嫌如何.mp3`,`audio`,``,``,`audio/中島みゆき/1994】Singles II/2-10 シュガー.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/01 二隻の舟.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/02 思い出させてあげる.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/03 泣かないでアマテラス.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/04 Maybe.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/05 ふたりは.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/06 DIAMOND CAGE.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/07 I love him.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/08 子守歌.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/09 生きてゆくおまえ.mp3`,`audio`,``,``,`audio/中島みゆき/1995】10WINGS/10 人待ち歌.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/01 旅人のうた _2nd Version_.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/02 伝説.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/03 永遠の嘘をついてくれ.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/04 ALONE, PLEASE.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/05 それは愛ではない.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/06 なつかない猫.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/07 SINGLES BAR.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/08 蒼い時代.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/09 たかが愛.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/10 阿檀の木の下で.mp3`,`audio`,``,``,`audio/中島みゆき/1996】パラダイス-カフェ/11 パラダイス-カフェ.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/01 空と君のあいだに (シングル-バージョン).mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/02 悪女.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/03 あした.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/04 最後の女神.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/05 浅い眠り.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/06 ルージュ.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/07 誕生.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/08 時代 ('93シングル-バージョン).mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/09 わかれうた.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/10 ひとり上手.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/11 慟哭.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/12 狼になりたい.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/13 旅人のうた.mp3`,`audio`,``,``,`audio/中島みゆき/1996】大吟醸/14 ファイト!.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/01 わたしの子供になりなさい.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/02 下町の上、山の手の下.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/03 命の別名.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/04 清流.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/05 私たちは春の中で.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/06 愛情物語.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/07 You Don't Know.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/08 木曜の夜.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/09 紅灯の海.mp3`,`audio`,``,``,`audio/中島みゆき/1998】わたしの子供になりなさい/10 4.2.3.mp3`,`audio`,``,``,`audio/中島みゆき/1998】命の別名 _ 糸 - Single/01 命の別名.mp3`,`audio`,``,``,`audio/中島みゆき/1998】命の別名 _ 糸 - Single/02 糸.mp3`,`audio`,``,``,`audio/中島みゆき/1998】命の別名 _ 糸 - Single/03 命の別名 _TV MIX_.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/01 糸.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/02 命の別名.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/03 たかが愛.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/04 愛情物語.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/05 世情.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/06 with.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/07 私たちは春の中で.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/08 眠らないで.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/09 二隻の舟.mp3`,`audio`,``,``,`audio/中島みゆき/1998】大銀幕/10 瞬きもせず.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/01 竹の歌.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/02 NEVER CRY OVER SPLIT MILK.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/03 いつか夢の中へ.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/04 羊の言葉.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/05 異国の女.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/06 あなたの言葉がわからない.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/07 難破船.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/08 知人-友人-愛人-家人.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/09 Good Morning, Ms. Castaway.mp3`,`audio`,``,``,`audio/中島みゆき/1999】日 - WINGS/10 明日なき我等.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/01 1人で生まれて来たのだから.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/02 紅い河.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/03 LAST SCENE.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/04 女という商売.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/05 SMILE, SMILE.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/06 PAIN.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/07 白菊.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/08 時効.mp3`,`audio`,``,``,`audio/中島みゆき/1999】月 - WINGS/09 愛から遠く離れて.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/01 地上の星.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/02 帰省.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/03 夢の通り道を僕は歩いている.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/04 後悔.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/05 MERRY-GO-ROUND.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/06 天使の階段.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/07 過ぎゆく夏.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/08 結婚.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/09 粉雪は忘れ薬.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/10 Tell Me,Sister.mp3`,`audio`,``,``,`audio/中島みゆき/2000】短篇集/11 ヘッドライト-テールライト.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/01 囁く雨.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/02 相席.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/03 樹高千丈　落葉帰根.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/04 あのバスに.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/05 心守歌.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/06 六花.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/07 カーニバルだったね.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/08 ツンドラ-バード.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/09 夜行.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/10 月迎え.mp3`,`audio`,``,``,`audio/中島みゆき/2001】心守歌-こころもりうた/11 LOVERS ONLY.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/01 地上の星.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/02 ヘッドライト-テールライト.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/03 瞬きもせず.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/04 私たちは春の中で.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/05 命の別名.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/06 糸.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/07 愛情物語.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/08 幸せ.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/09 たかが愛.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/10 目を開けて最初に君を見たい.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/11 旅人のうた.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/12 SE-TSU-NA-KU-TE.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/13 空と君のあいだに.mp3`,`audio`,``,``,`audio/中島みゆき/2002】Singles 2000/14 ファイト!.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/01 陽紡ぎ唄.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/02 シャングリラ.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/03 おとぎばなし.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/04 雪-月-花.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/05 匂いガラス～安寿子の靴.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/06 あの人に似ている.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/07 みにくいあひるの子.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/08 愛される花　愛されぬ花.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/09 裸爪（はだし）のライオン.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/10 紫の桜.mp3`,`audio`,``,``,`audio/中島みゆき/2002】おとぎばなし-Fairy Ring-/11 海よ.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/01 ルージュ.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/02 ひとり上手.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/03 やまねこ.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/04 ホームにて.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/05 あわせ鏡.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/06 笑ってよエンジェル.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/07 僕は青い鳥.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/08 見返り美人.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/09 春なのに.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/10 あした.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/11 サッポロSnowy.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/12 シュガー.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/13 忘れな草をもう一度.mp3`,`audio`,``,``,`audio/中島みゆき/2002】美雪集/14 悪女.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/01 銀の龍の背に乗って.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/02 恋とはかぎらない.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/03 川風.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/04 ミラージュ-ホテル.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/05 寄り添う風.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/06 情婦の証言.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/07 ナイトキャップ-スペシャル.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/08 月夜同舟.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/09 恋文.mp3`,`audio`,``,``,`audio/中島みゆき/2003】恋文/10 思い出だけではつらすぎる.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/01 あぶな坂.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/02 わかれうた.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/03 怜子.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/04 信じ難いもの.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/05 この空を飛べたら.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/06 あわせ鏡.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/07 歌姫.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/08 傾斜.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/09 横恋慕.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/10 この世に二人だけ.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/11 はじめまして.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/12 どこにいても.mp3`,`audio`,``,``,`audio/中島みゆき/2004】いまのきもち/13 土用波.mp3`,`audio`,``,``,`audio/中島みゆき/2005】中島みゆきライヴ! Live at Sony Pictures Studios/01 この空を飛べたら.mp3`,`audio`,``,``,`audio/中島みゆき/2005】中島みゆきライヴ! Live at Sony Pictures Studios/02 地上の星.mp3`,`audio`,``,``,`audio/中島みゆき/2005】中島みゆきライヴ! Live at Sony Pictures Studios/03 土用波.mp3`,`audio`,``,``,`audio/中島みゆき/2005】中島みゆきライヴ! Live at Sony Pictures Studios/04 銀の龍の背に乗って.mp3`,`audio`,``,``,`audio/中島みゆき/2005】中島みゆきライヴ! Live at Sony Pictures Studios/05 この世に二人だけ.mp3`,`audio`,``,``,`audio/中島みゆき/2005】中島みゆきライヴ! Live at Sony Pictures Studios/06 夜行.mp3`,`audio`,``,``,`audio/中島みゆき/2005】中島みゆきライヴ! Live at Sony Pictures Studios/07 歌姫.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/01 遺失物預り所.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/02 帰れない者たちへ.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/03 線路の外の風景.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/04 メビウスの帯はねじれる.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/05 フォーチュン-クッキー.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/06 闇夜のテーブル.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/07 我が祖国は風の彼方.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/08 命のリレー.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/09 ミラージュ-ホテル.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/10 サーモン-ダンス.mp3`,`audio`,``,``,`audio/中島みゆき/2005】転　生(TEN-SEI)/11 無限-軌道.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/01 桜らららら.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/02 ただ-愛のためにだけ.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/03 宙船 (そらふね).mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/04 あのさよならにさよならを.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/05 Clavis -鍵-.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/06 水.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/07 あなたでなければ.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/08 五月の陽ざし.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/09 とろ.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/10 お月さまほしい.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/11 重き荷を負いて.mp3`,`audio`,``,``,`audio/中島みゆき/2006】ララバイSINGER/12 ララバイSINGER.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/01 糸.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/02 狼になりたい.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/03 時代.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/04 化粧.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/05 空と君のあいだに.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/06 「元気ですか」.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/07 アザミ嬢のララバイ.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/08 世情.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/09 ファイト!.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/10 後悔.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/11 ヘッドライト-テールライト.mp3`,`audio`,``,``,`audio/中島みゆき/2006】元気ですか/12 恋文.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/01 本日、未熟者.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/02 顔のない街の中で.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/03 惜しみなく愛の言葉を.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/04 一期一会.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/05 サバイバル-ロード.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/06 Nobody Is Right.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/07 アイス-フィッシュ.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/08 ボディ-トーク.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/09 背広の下のロックンロール.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/10 昔から雨が降ってくる.mp3`,`audio`,``,``,`audio/中島みゆき/2007】I Love You, 答えてくれ/11 I Love You, 答えてくれ.mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/01 御機嫌如何 [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/02 ホームにて [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/03 あなたでなければ [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/04 蕎麦屋 [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/05 EAST ASIA [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/06 ボディ-トーク [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/07 昔から雨が降ってくる [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/08 ファイト! [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/09 誕生 [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/10 本日、未熟者 [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/11 背広の下のロックンロール [Live].mp3`,`audio`,``,``,`audio/中島みゆき/2008】歌旅 -中島みゆきコンサートツアー2007-/12 地上の星 (ライブ-カラオケ-バージョン).mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/01 翼をあげて.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/02 こどもの宝.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/03 夜の色.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/04 掌.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/05 愛が私に命ずること.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/06 NOW.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/07 十二天.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/08 らいしょらいしょ.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/09 暦売りの歌.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/10 百九番目の除夜の鐘.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/11 幽霊交差点.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/12 海に絵を描く.mp3`,`audio`,``,``,`audio/中島みゆき/2009】DRAMA!/13 天鏡.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/01 今日以来.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/02 真夜中の動物園.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/03 まるで高速電車のようにあたしたちは擦れ違う.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/04 ハリネズミだって恋をする.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/05 小さき負傷者たちの為に.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/06 夢だもの.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/07 サメの歌.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/08 ごまめの歯ぎしり.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/09 鷹の歌.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/10 負けんもんね.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/11 雪傘.mp3`,`audio`,``,``,`audio/中島みゆき/2010】真夜中の動物園/12 愛だけを残せ.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/01 荒野より.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/02 バクです.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/03 BA-NA-NA.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/04 あばうとに行きます.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/05 鶺鴒.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/06 彼と私と、もう一人.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/07 ばりほれとんぜ.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/08 ギヴ-アンド-テイク.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/09 旅人よ我に帰れ.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/10 帰郷群.mp3`,`audio`,``,``,`audio/中島みゆき/2011】荒野より/11 走.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/01 常夜灯.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/02 ピアニシモ.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/03 恩知らず.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/04 リラの花咲く頃.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/05 倒木の敗者復活戦.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/06 あなた恋していないでしょ.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/07 ベッドルーム.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/08 スクランブル交差点の渡り方.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/09 オリエンタル-ヴォイス.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/10 ランナーズ-ハイ.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/11 風の笛.mp3`,`audio`,``,``,`audio/中島みゆき/2012】常夜灯/12 月はそこにいる.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/01 恩知らず.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/02 時代 -ライヴ2010~11-.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/03 荒野より(remix).mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/04 バクです.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/05 愛だけを残せ(remix).mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/06 闘りゃんせ.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/07 一期一会.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/08 昔から雨が降ってくる.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/09 帰れない者たちへ.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/10 命のリレー _'04夜会ヴァージョン_.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/11 銀の龍の背に乗って.mp3`,`audio`,``,``,`audio/中島みゆき/2013】十二単 ~Singles 4~/12 恋文.mp3`,`audio`,``,``,`audio/南宋传奇之蟋蟀宰相-女人心.mp3`,`audio`,``,``,`audio/宰相刘罗锅-插曲.mp3`,`audio`,``,``,`audio/新女驸马-卖相思.mp3`,`audio`,``,``,`audio/正德演义-片头曲.mp3`,`audio`,``,``,`audio/雪山飞狐/我有一片心.mp3`,`audio`,``,``,`audio/雪山飞狐/追梦人.mp3`,`audio`,``,``,`audio/雪山飞狐/雪中情.mp3`,`audio`,``,``,`../video/animal/1684492312758431745.mp4`,`video`,``,``,`../video/animal/1696480346336833796.mp4`,`video`,``,``,`../video/animal/1707957192413085702.mp4`,`video`,``,``,`../video/animal/1774074114975625613.mp4`,`video`,``,``,`../video/animal/1774368561823097140.mp4`,`video`,``,``,`../video/animal/1775311981064417665.mp4`,`video`,``,``,`../video/animal/1782469647608021358.mp4`,`video`,``,``,`../video/animal/1787256574001471701.mp4`,`video`,``,``,`../video/animal/1793050604786290700.mp4`,`video`,``,``,`../video/animal/1811140894021615720.mp4`,`video`,``,``,`../video/animal/1813548957701927037.mp4`,`video`,``,``,`../video/animal/1814605488446677239.mp4`,`video`,``,``,`../video/animal/1818110263155102190.mp4`,`video`,``,``,`../video/animal/1819982600254951605.mp4`,`video`,``,``,`../video/animal/1828076177719718106.mp4`,`video`,``,``,`../video/animal/A unique wake up!.mp4`,`video`,``,``,`../video/animal/Are you one of us...mp4`,`video`,``,``,`../video/animal/Aweeeeeeeeeeeeee! He brings the ball from the .mp4`,`video`,``,``,`../video/animal/BoopBoopBoopBoop..mp4`,`video`,``,``,`../video/animal/bro didn't even think.mp4`,`video`,``,``,`../video/animal/Busted..mp4`,`video`,``,``,`../video/animal/cat walk.mp4`,`video`,``,``,`../video/animal/change face.mp4`,`video`,``,``,`../video/animal/Checking Sea Otter temperature.mp4`,`video`,``,``,`../video/animal/Come play with us, uncle cat! Come play with us.mp4`,`video`,``,``,`../video/animal/cool cat.mp4`,`video`,``,``,`../video/animal/Different kind of claw machine...mp4`,`video`,``,``,`../video/animal/Do NOT move Let him pass Caturday.mp4`,`video`,``,``,`../video/animal/Dog having its own fun.. .mp4`,`video`,``,``,`../video/animal/Don't taste everything you see!  .mp4`,`video`,``,``,`../video/animal/Don’t challenge a kitten...mp4`,`video`,``,``,`../video/animal/Drama Queen  .mp4`,`video`,``,``,`../video/animal/Eat well, my friend...mp4`,`video`,``,``,`../video/animal/ele descobrindo o rabinho dele .mp4`,`video`,``,``,`../video/animal/Everybody likes a crown!.mp4`,`video`,``,``,`../video/animal/Free shower. .mp4`,`video`,``,``,`../video/animal/HAHAHAHA.mp4`,`video`,``,``,`../video/animal/happy kitten with her mother .mp4`,`video`,``,``,`../video/animal/He was attacking the security camera where he saw .mp4`,`video`,``,``,`../video/animal/Helping its friend out of the rain.mp4`,`video`,``,``,`../video/animal/He’s on ninja class! .mp4`,`video`,``,``,`../video/animal/Homies!  .mp4`,`video`,``,``,`../video/animal/How dare you bark at my baby ...mp4`,`video`,``,``,`../video/animal/How to communicate by ear!.mp4`,`video`,``,``,`../video/animal/I cant get over this videoooo.mp4`,`video`,``,``,`../video/animal/I didn't know they could do that..mp4`,`video`,``,``,`../video/animal/I love animals jealousy .mp4`,`video`,``,``,`../video/animal/I'm still waiting for my letter from Hogwarts..mp4`,`video`,``,``,`../video/animal/I'm sure she's his lover! Real man! .mp4`,`video`,``,``,`../video/animal/Is this how catfishing works_.mp4`,`video`,``,``,`../video/animal/It also needs to walk fast. .mp4`,`video`,``,``,`../video/animal/It didn't like the small fish, it wanted a big fis.mp4`,`video`,``,``,`../video/animal/it was playing dead for a reason .mp4`,`video`,``,``,`../video/animal/Its dinner time.mp4`,`video`,``,``,`../video/animal/It’s Friday! .mp4`,`video`,``,``,`../video/animal/Kids are all the same! .mp4`,`video`,``,``,`../video/animal/Life is the victory of those who never give up ....mp4`,`video`,``,``,`../video/animal/Lil bro got saved by the windshield.mp4`,`video`,``,``,`../video/animal/Little bear says hi...mp4`,`video`,``,``,`../video/animal/Look, what I can do...mp4`,`video`,``,``,`../video/animal/Love attack.mp4`,`video`,``,``,`../video/animal/Me and my cat 3a.m. .mp4`,`video`,``,``,`../video/animal/me at parties.mp4`,`video`,``,``,`../video/animal/Michael Catson .mp4`,`video`,``,``,`../video/animal/Mission Impossible.. .mp4`,`video`,``,``,`../video/animal/Mission possible! .mp4`,`video`,``,``,`../video/animal/Monet's Pond Seki City, Gifu Prefecture, Japan.mp4`,`video`,``,``,`../video/animal/Mufasa said I'm gonna embarrass you then parade yo.mp4`,`video`,``,``,`../video/animal/Natural scissor!  .mp4`,`video`,``,``,`../video/animal/Ninja dog...mp4`,`video`,``,``,`../video/animal/Orange cat always wins .mp4`,`video`,``,``,`../video/animal/Parrotrotti  .mp4`,`video`,``,``,`../video/animal/Penguins chasing a butterfly...mp4`,`video`,``,``,`../video/animal/Pure and unadulterated joy!.mp4`,`video`,``,``,`../video/animal/Real Men.mp4`,`video`,``,``,`../video/animal/Silverback Gorilla responds to instructions for hi.mp4`,`video`,``,``,`../video/animal/Smart dog .mp4`,`video`,``,``,`../video/animal/So cute  (2).mp4`,`video`,``,``,`../video/animal/So cute .mp4`,`video`,``,``,`../video/animal/So nice.mp4`,`video`,``,``,`../video/animal/Social media fights!And don't forget to drink wate.mp4`,`video`,``,``,`../video/animal/Someone is jealous.. .mp4`,`video`,``,``,`../video/animal/Someone's jeaIous...mp4`,`video`,``,``,`../video/animal/Sparrow having a drink on lotus leaf.mp4`,`video`,``,``,`../video/animal/Squirrel brings some dried fruits and leaves to tr.mp4`,`video`,``,``,`../video/animal/That face...mp4`,`video`,``,``,`../video/animal/That look! .mp4`,`video`,``,``,`../video/animal/That smile..wait for it...mp4`,`video`,``,``,`../video/animal/That's extremely intelligent .mp4`,`video`,``,``,`../video/animal/That’s not a dog.. .mp4`,`video`,``,``,`../video/animal/The best actor award goes to...mp4`,`video`,``,``,`../video/animal/The best kind of welcome...mp4`,`video`,``,``,`../video/animal/The dog said nope.. .mp4`,`video`,``,``,`../video/animal/The employer is hungry..mp4`,`video`,``,``,`../video/animal/The hero we all need but don't deserve...mp4`,`video`,``,``,`../video/animal/The jump.. .mp4`,`video`,``,``,`../video/animal/The look.. .mp4`,`video`,``,``,`../video/animal/The mother Squirrel never gave up on her baby. .mp4`,`video`,``,``,`../video/animal/The perfect way to wrap up a business deal..mp4`,`video`,``,``,`../video/animal/The power of belief!.mp4`,`video`,``,``,`../video/animal/Thinking that it scared the cat, it retreats so th.mp4`,`video`,``,``,`../video/animal/This is why I pay internet for.mp4`,`video`,``,``,`../video/animal/Those eyes...mp4`,`video`,``,``,`../video/animal/Trust fall..aIexcotedogtrainer.mp4`,`video`,``,``,`../video/animal/unstoppable force meets an immovable object.mp4`,`video`,``,``,`../video/animal/Very sweet stealing technique..mp4`,`video`,``,``,`../video/animal/Wait for it...mp4`,`video`,``,``,`../video/animal/What a sweet driver. .mp4`,`video`,``,``,`../video/animal/What could be the problem between them_.mp4`,`video`,``,``,`../video/animal/When my diet is finally over! .mp4`,`video`,``,``,`../video/animal/When my wife asks me why I need thermal goggles I .mp4`,`video`,``,``,`../video/animal/When you yourself decide to be happy..mp4`,`video`,``,``,`../video/animal/Who did that...mp4`,`video`,``,``,`../video/animal/Why always orange cat .mp4`,`video`,``,``,`../video/animal/why so sad_.mp4`,`video`,``,``,`../video/animal/Wonderful bird house!Very good idea!.mp4`,`video`,``,``,`../video/animal/would you wear this ring_.mp4`,`video`,``,``,`../video/animal/You must stay with him forever .mp4`,`video`,``,``,`../video/animal/You're their world...mp4`,`video`,``,``,`../video/animal/“Not now Jenny, I’m working” .mp4`,`video`,``,``,`../video/animal/一看就是没暖气的南方喵，苦啊....mp4`,`video`,``,``,`../video/animal/上点难度 是时候展现真正的技术了！！.mp4`,`video`,``,``,`../video/animal/不知道我车后窗有没有玻璃水，开了这么久没用过哎.mp4`,`video`,``,``,`../video/animal/俺都这么凶了，你们这些坏人还敢笑？哼！.mp4`,`video`,``,``,`../video/animal/兽医果然什么风风雨雨都见过，这么淡定.mp4`,`video`,``,``,`../video/animal/冒泡.mp4`,`video`,``,``,`../video/animal/原来河豚是这样变大的。.mp4`,`video`,``,``,`../video/animal/吵不过就动手cat.mp4`,`video`,``,``,`../video/animal/喵了咪！大意了没有闪.mp4`,`video`,``,``,`../video/animal/喵帮火拼，各个都是纹身.mp4`,`video`,``,``,`../video/animal/妈呀，萌翻我了.mp4`,`video`,``,``,`../video/animal/妈妈酱，哇达西自己会洗，斯到普！.mp4`,`video`,``,``,`../video/animal/悟空第一次遇见菩提老祖的时候…….mp4`,`video`,``,``,`../video/animal/日有所吃，夜有所胖。十年瘦骨无人问，一朝变肥天下知。.mp4`,`video`,``,``,`../video/animal/沙蟹.mp4`,`video`,``,``,`../video/animal/狗被拴着是常态猫被拴着是无奈所以要奔走奔向太空.mp4`,`video`,``,``,`../video/animal/猫咪都懵了，没见过这场面，这阵势。猫生不同凡响的经历，人性的光辉。.mp4`,`video`,``,``,`../video/animal/画眉洗澡.mp4`,`video`,``,``,`../video/animal/看看这身手.mp4`,`video`,``,``,`../video/animal/给喵师傅装上了摄像头才发现，原来你在外面还有这一面.mp4`,`video`,``,``,`../video/animal/蜻蜓：你吃饭为啥拿我当饵啊.mp4`,`video`,``,``,`../video/animal/鄰居家的保安系統正在被入侵.mp4`,`video`,``,``,`../video/female/'80s pop stars were built different.mp4`,`video`,``,``,`../video/female/1780377924882801124.mp4`,`video`,``,``,`../video/female/1799901013094089125.mp4`,`video`,``,``,`../video/female/Creativity!.mp4`,`video`,``,``,`../video/female/fraternity.mp4`,`video`,``,``,`../video/female/Hahahaha (2).mp4`,`video`,``,``,`../video/female/Helena Vlahos performing her Nine Quarters belly d.mp4`,`video`,``,``,`../video/female/If women go to sleep first ...So true! .mp4`,`video`,``,``,`../video/female/It’s a good survival strategy. .mp4`,`video`,``,``,`../video/female/She looks like an NPC from Cyberpunk..mp4`,`video`,``,``,`../video/female/She really couldn't hold it.. .mp4`,`video`,``,``,`../video/female/Siblings.mp4`,`video`,``,``,`../video/female/So cute boy..mp4`,`video`,``,``,`../video/female/That's it. She's a Disney princess now I don't mak.mp4`,`video`,``,``,`../video/female/That’s called a perfect shot! .mp4`,`video`,``,``,`../video/female/The effect of a female's kiss! .mp4`,`video`,``,``,`../video/female/The moment I enter a serious relationship .mp4`,`video`,``,``,`../video/female/There's no running away from her.mp4`,`video`,``,``,`../video/female/They say; this is how men and women apologize!.mp4`,`video`,``,``,`../video/female/When forgot that you were at home and not at!.mp4`,`video`,``,``,`../video/female/why.mp4`,`video`,``,``,`../video/female/Y con un banquito le dió!.mp4`,`video`,``,``,`../video/female/一次快速高效坦诚的相亲.mp4`,`video`,``,``,`../video/female/刮大白.mp4`,`video`,``,``,`../video/female/我承认我也是第二遍才看清的.mp4`,`video`,``,``,`../video/female/教大家如何驾驭生气的女朋友！你学会了吗？.mp4`,`video`,``,``,`../video/female/泡妞高招！.mp4`,`video`,``,``,`../video/female/这有点无师自通啊…… 小姐姐就不该答应上台演示玩“陶土”，不管怎么做都是被台下一阵会心哄笑。.mp4`,`video`,``,``,`../video/female/这机器哪里有卖？.mp4`,`video`,``,``,`../video/female/这段子，笑死我了.mp4`,`video`,``,``,`../video/funny/1774308140131012789.mp4`,`video`,``,``,`../video/funny/1814779705465401580.mp4`,`video`,``,``,`../video/funny/@kaguyaareal But still, Chitan loves you❤️I'm Chii.mp4`,`video`,``,``,`../video/funny/@TheFigen_ Las Vegas Sphere in the Morning.mp4`,`video`,``,``,`../video/funny/A man installed a GPS tracker on his cat to find o.mp4`,`video`,``,``,`../video/funny/A touch addicted parrot..mp4`,`video`,``,``,`../video/funny/AI designed gorilla sofas[ inspiringdesignsnet].mp4`,`video`,``,``,`../video/funny/All kids are the same no matter the species...mp4`,`video`,``,``,`../video/funny/Another reason why men don't live long. .mp4`,`video`,``,``,`../video/funny/As a girl Dad, I just have to sayThank God for Asi.mp4`,`video`,``,``,`../video/funny/Automatic bird feeder. .mp4`,`video`,``,``,`../video/funny/Aweeee this is so cute car!.mp4`,`video`,``,``,`../video/funny/Awwww.mp4`,`video`,``,``,`../video/funny/Best friends. .mp4`,`video`,``,``,`../video/funny/Brilliant art..mp4`,`video`,``,``,`../video/funny/Cartoons used to be better..mp4`,`video`,``,``,`../video/funny/Cool.mp4`,`video`,``,``,`../video/funny/Development process of technology. .mp4`,`video`,``,``,`../video/funny/Drunk test! Step bam step bam bam!.mp4`,`video`,``,``,`../video/funny/Engineering marvel sharpeners ....mp4`,`video`,``,``,`../video/funny/Evacuation system in a new Japanese building..mp4`,`video`,``,``,`../video/funny/Formula 2 .mp4`,`video`,``,``,`../video/funny/FREE THE CAT.mp4`,`video`,``,``,`../video/funny/Great Effort .mp4`,`video`,``,``,`../video/funny/Hahahah (2).mp4`,`video`,``,``,`../video/funny/Hahahah.mp4`,`video`,``,``,`../video/funny/Hahahahahahhj Legendx.mp4`,`video`,``,``,`../video/funny/He is in heaven_ .mp4`,`video`,``,``,`../video/funny/Her soul left her body.mp4`,`video`,``,``,`../video/funny/How to keep the fish happy and trained[ yunyun_5.mp4`,`video`,``,``,`../video/funny/I love people with a sense of humor. .mp4`,`video`,``,``,`../video/funny/I want this so much please..mp4`,`video`,``,``,`../video/funny/Immediately saved this.mp4`,`video`,``,``,`../video/funny/It may be the most beautiful calendar leaf you hav.mp4`,`video`,``,``,`../video/funny/It works!.mp4`,`video`,``,``,`../video/funny/It's a mans duty .mp4`,`video`,``,``,`../video/funny/Jackpot.mp4`,`video`,``,``,`../video/funny/Legend Benny Hill  .mp4`,`video`,``,``,`../video/funny/Looking Back At This, These Was A Wild Time .mp4`,`video`,``,``,`../video/funny/Marine biologist..mp4`,`video`,``,``,`../video/funny/marry or not.mp4`,`video`,``,``,`../video/funny/Me driving out from MM2. .mp4`,`video`,``,``,`../video/funny/No way!.mp4`,`video`,``,``,`../video/funny/One of the coolest things I've ever seen..mp4`,`video`,``,``,`../video/funny/Partners in crime .mp4`,`video`,``,``,`../video/funny/Prison break gone terribly wrong.mp4`,`video`,``,``,`../video/funny/Rose from Titanic .mp4`,`video`,``,``,`../video/funny/RT @gunsnrosesgirl3_ The difference just one perso.mp4`,`video`,``,``,`../video/funny/She barely escaped.mp4`,`video`,``,``,`../video/funny/So cool art..mp4`,`video`,``,``,`../video/funny/So cute.mp4`,`video`,``,``,`../video/funny/So good!  (2).mp4`,`video`,``,``,`../video/funny/So good! .mp4`,`video`,``,``,`../video/funny/That's an innovation!.mp4`,`video`,``,``,`../video/funny/The music.. .mp4`,`video`,``,``,`../video/funny/The Yaeyama blenny is a small fish found in coral .mp4`,`video`,``,``,`../video/funny/These glasses turn light into hearts..mp4`,`video`,``,``,`../video/funny/This is so cute art for kids....mp4`,`video`,``,``,`../video/funny/This is your new saving method! .mp4`,`video`,``,``,`../video/funny/This will never get old.mp4`,`video`,``,``,`../video/funny/Very cool!A slightly reddish gold spherical locket.mp4`,`video`,``,``,`../video/funny/What was he thinking_.mp4`,`video`,``,``,`../video/funny/Wrong turn!.mp4`,`video`,``,``,`../video/funny/wrong work.mp4`,`video`,``,``,`../video/funny/_helps women get pregnant_.mp4`,`video`,``,``,`../video/funny/“If anyone is against this marriage, tell me now o.mp4`,`video`,``,``,`../video/funny/“上一边玩去”，这句话是真实的。.mp4`,`video`,``,``,`../video/funny/不要轻易去依赖一个人，它会成为你的习惯，当分别来临，你失去的不是某个人，而是你精神的支柱。无论何时何.mp4`,`video`,``,``,`../video/funny/乗せ毛派祖.mp4`,`video`,``,``,`../video/funny/你知道自己属于哪一款吗？.mp4`,`video`,``,``,`../video/funny/哈哈.mp4`,`video`,``,``,`../video/funny/沪语配音 作为老师 我们要以身作则.mp4`,`video`,``,``,`../video/funny/漂亮。世界上最大单打发烟花，在日本长冈上空燃放.mp4`,`video`,``,``,`../video/funny/解放思想你首先得有思想要不然解放的全是欲望.mp4`,`video`,``,``,`../video/funny/这个金牌榜追逐赛有点儿可爱，马尔尚头像太好笑了.mp4`,`video`,``,``,`../video/funny/这弯儿拿的怎么样.mp4`,`video`,``,``,`../video/idea/A group of psychiatrists studied 400 movies and id.mp4`,`video`,``,``,`../video/idea/Ajajajajajaja.mp4`,`video`,``,``,`../video/idea/Amazing (1).mp4`,`video`,``,``,`../video/idea/An outback road in Australia.mp4`,`video`,``,``,`../video/idea/Arnold in his peak movie days was undefeated.mp4`,`video`,``,``,`../video/idea/Building a fish observation tower using physics pr.mp4`,`video`,``,``,`../video/idea/Cleaning filters with firecrackers..mp4`,`video`,``,``,`../video/idea/Garden ideas[ Speedy Crafts].mp4`,`video`,``,``,`../video/idea/Genius!.mp4`,`video`,``,``,`../video/idea/Good idea..mp4`,`video`,``,``,`../video/idea/Good tip!.mp4`,`video`,``,``,`../video/idea/Great Technology .mp4`,`video`,``,``,`../video/idea/He is a great human! He is feeding street cats v.mp4`,`video`,``,``,`../video/idea/He makes his pet pick up his socks that fell off t.mp4`,`video`,``,``,`../video/idea/Hello .mp4`,`video`,``,``,`../video/idea/How did someone think this was a good idea.mp4`,`video`,``,``,`../video/idea/How to open chips ....mp4`,`video`,``,``,`../video/idea/I don't know how to say this, but these guns must .mp4`,`video`,``,``,`../video/idea/I want one please..mp4`,`video`,``,``,`../video/idea/Incredible art!.mp4`,`video`,``,``,`../video/idea/It’s never this serious.mp4`,`video`,``,``,`../video/idea/lighter.mp4`,`video`,``,``,`../video/idea/Love this cool storage! .mp4`,`video`,``,``,`../video/idea/Love this..mp4`,`video`,``,``,`../video/idea/Making a miter joint A miter joint is a type of jo.mp4`,`video`,``,``,`../video/idea/Making a secret door.mp4`,`video`,``,``,`../video/idea/Next level laziness! .mp4`,`video`,``,``,`../video/idea/Nice technique..mp4`,`video`,``,``,`../video/idea/Nice technique.Farmer uses hydrogen balls to lift .mp4`,`video`,``,``,`../video/idea/Peat extraction for fuel.mp4`,`video`,``,``,`../video/idea/Planting seeds with precision.mp4`,`video`,``,``,`../video/idea/Practical knot-tying method.mp4`,`video`,``,``,`../video/idea/Practical lock systems..mp4`,`video`,``,``,`../video/idea/Really_  You guys made me sit down for this..mp4`,`video`,``,``,`../video/idea/Remote-controlled lifeguard..mp4`,`video`,``,``,`../video/idea/RT @gunsnrosesgirl3_ Mt. Fuji in full 360 degrees..mp4`,`video`,``,``,`../video/idea/Simple but brilliant trap concept.mp4`,`video`,``,``,`../video/idea/Super tip.mp4`,`video`,``,``,`../video/idea/Super tips..mp4`,`video`,``,``,`../video/idea/That’s why Android will always win...mp4`,`video`,``,``,`../video/idea/This looks like a good tip for a garden..mp4`,`video`,``,``,`../video/idea/Useful information..mp4`,`video`,``,``,`../video/idea/Using gunpowder and igniting it to create the artw.mp4`,`video`,``,``,`../video/idea/Very good craftsmanship..mp4`,`video`,``,``,`../video/idea/What do you think of this pizza topping_.mp4`,`video`,``,``,`../video/idea/When you know physics well ....mp4`,`video`,``,``,`../video/idea/中国新疆居民独特的切瓜方式.mp4`,`video`,``,``,`../video/nature/Alguém avisa que as nuvem tão bugada.mp4`,`video`,``,``,`../video/nature/Canada's abraham lake, methane gas bubbles..mp4`,`video`,``,``,`../video/nature/Do you love rainy weather_.mp4`,`video`,``,``,`../video/nature/Frost flowers on frozen water.mp4`,`video`,``,``,`../video/nature/Hearing the sound of nature up close..mp4`,`video`,``,``,`../video/nature/I always wondered what the rain had to say.mp4`,`video`,``,``,`../video/nature/I died 3 times watching this.mp4`,`video`,``,``,`../video/nature/It's a catfish and it knows how to find water in t.mp4`,`video`,``,``,`../video/nature/Nature is awesome.mp4`,`video`,``,``,`../video/nature/paddling on crystal glass lake tahoe, californi.mp4`,`video`,``,``,`../video/nature/Switzerland summer and winter..mp4`,`video`,``,``,`../video/nature/The hunter becomes the victim one day....mp4`,`video`,``,``,`../video/nature/The story of how strawberries grow ....mp4`,`video`,``,``,`../video/nature/Would you dare to swim here_.mp4`,`video`,``,``,`../video/人文/It’s the little things in life.. .mp4`,`video`,``,``,`../video/人文/La tribu Banna camina en zancos como mecanismo par.mp4`,`video`,``,``,`../video/人文/No matter how old you are, don't lose your childho.mp4`,`video`,``,``,`../video/人文/So beautiful..mp4`,`video`,``,``,`../video/人文/Time is a good storyteller.It takes just few years.mp4`,`video`,``,``,`../video/人文/What is life in 52 secs..mp4`,`video`,``,``,`../video/人文/彩蛋.mp4`,`video`,``,``,`../video/恶作剧/1769593322639892793.mp4`,`video`,``,``,`../video/恶作剧/Children are pure lol.mp4`,`video`,``,``,`../video/恶作剧/Historic paintings given expressions.mp4`,`video`,``,``,`../video/恶作剧/How do you deal with unwanted telephone calls_.mp4`,`video`,``,``,`../video/恶作剧/how tf did the phone even get there LMFAOO__.mp4`,`video`,``,``,`../video/恶作剧/Incredible magic! .mp4`,`video`,``,``,`../video/恶作剧/India made me laugh! .mp4`,`video`,``,``,`../video/恶作剧/Lol.mp4`,`video`,``,``,`../video/恶作剧/Me meo, jajajajajajajajajajaja..mp4`,`video`,``,``,`../video/恶作剧/Next level prank.mp4`,`video`,``,``,`../video/恶作剧/Oh that's not- .mp4`,`video`,``,``,`../video/恶作剧/She is good at this! .mp4`,`video`,``,``,`../video/恶作剧/She is so funny. .mp4`,`video`,``,``,`../video/恶作剧/She is very talented! .mp4`,`video`,``,``,`../video/恶作剧/‘You missed a bit’.mp4`,`video`,``,``,`../video/科普/2018年法国汽车制造商雪铁龙，推出的这个没镜片的眼镜，戴上10分能防晕车 。整个眼镜架上，.mp4`,`video`,``,``,`../video/科普/Caliber comparison.mp4`,`video`,``,``,`../video/科普/Evolution of Style.mp4`,`video`,``,``,`../video/科普/Explaining the popular internet phenomenon of _The.mp4`,`video`,``,``,`../video/科普/Fertilization explained_.mp4`,`video`,``,``,`../video/科普/Fishing knots.mp4`,`video`,``,``,`../video/科普/How beautiful!A sunflower placed in a jar absorbs .mp4`,`video`,``,``,`../video/科普/How dam installation reshapes river geomorphology,.mp4`,`video`,``,``,`../video/科普/How food travels through the digestive system.mp4`,`video`,``,``,`../video/科普/How the effect of speed prevents you from falling .mp4`,`video`,``,``,`../video/科普/How these crops are irrigated.mp4`,`video`,``,``,`../video/科普/How this tunnel is made.mp4`,`video`,``,``,`../video/科普/Inflatable motorcycle vest in action.mp4`,`video`,``,``,`../video/科普/Inflatable tanks used during WW2 as decoys..mp4`,`video`,``,``,`../video/科普/Irrigation water slowed down to prevent crop damag.mp4`,`video`,``,``,`../video/科普/Last 100 years of makeup ....mp4`,`video`,``,``,`../video/科普/Like the flexible hands of a human being, this sur.mp4`,`video`,``,``,`../video/科普/Mastering the art of creating silver cups.mp4`,`video`,``,``,`../video/科普/Mini art..mp4`,`video`,``,``,`../video/科普/Muscles of the Back..mp4`,`video`,``,``,`../video/科普/North and South Korea both came back after nearly .mp4`,`video`,``,``,`../video/科普/RT cooltechtipz_ I love these kind of videos..mp4`,`video`,``,``,`../video/科普/Sabe aquela tigela toda decorada que vc usa em cas.mp4`,`video`,``,``,`../video/科普/Spacecraft on Mars, a comparison[deepspacecourie.mp4`,`video`,``,``,`../video/科普/Stone cutting by hand.mp4`,`video`,``,``,`../video/科普/Tevel Aerobotics has developed a drone for fruit p.mp4`,`video`,``,``,`../video/科普/The beauty of physics ....mp4`,`video`,``,``,`../video/科普/The geomorphology of a river.mp4`,`video`,``,``,`../video/科普/The process of a human birth[ ScienceNaturePage.mp4`,`video`,``,``,`../video/科普/This neuroscience medical animation explains the e.mp4`,`video`,``,``,`../video/科普/Understanding how to solve the legendary Rubik's c.mp4`,`video`,``,``,`../video/科普/While each dot moves along a straight line, the co.mp4`,`video`,``,``,`../video/科普/Whoever invented the sewing machine was a genius..mp4`,`video`,``,``,`../video/科普/不看不知道，一看吓一跳，还有这么多讲究呢.mp4`,`video`,``,``,`../video/科普/老年人如何捡掉在地上的东西？当东西掉到地上时，千万别将你的头低于心脏去捡东西，以防突发主动脉剥离而逝.mp4`,`video`,``,``,`../video/调侃/Everyone has someone they are afraid of. .mp4`,`video`,``,``,`../video/调侃/Hilarious .mp4`,`video`,``,``,`../video/调侃/Legend! .mp4`,`video`,``,``,`../video/调侃/Very real love!.mp4`,`video`,``,``,`../video/调侃/不是抽奖机买不起，而是大学生更具性价比.mp4`,`video`,``,``,`../video/调侃/别说持刀持枪，你敢持一匹砖，这个世界待你立刻变得很温柔！.mp4`,`video`,``,``,`../video/调侃/神中神！近日，一段网友恶搞的《猫和老鼠》视频在B站走红，原视频被封禁后引发网友接力补档.mp4`,`video`,``,``,`../video/调侃/老梗了.mp4`,`video`,``,``,`../video/调侃/视频【清华大学政治学教授任剑涛】.mp4`,`video`,``,``,`../video/调侃/这个世界终于癫成了我想要的模样！.mp4`,`video`);