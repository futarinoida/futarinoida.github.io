<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=1920, initial-scale=1.0">
  <link rel="stylesheet" href="../css/content.css"></style>
  <script src="../js/content.js"></script>
  <title>Spring Cloud</title>
</head>
<body><span id="anchor">20240814232713-_微服务</span>
<pre>
<h1>从单体架构到微服务架构</h1>
20240604145527.webp
开发单个应用作为一系列小型服务的套件, 其中每个服务都运行在自己的进程中,并且通过轻量级的机制实现彼此间的通信, 这通常是HTTP资源的API
这些服务是围绕着业务功能构建的, 并且可以通过完全自动化的部署机制进行独立部署
这些服务的集中式管理做到了最小化(例如docker相关技术), 每一种服务都可以通过不同的编程语言进行编写,并且可以使用不同的数据存储技术
微服务特点
    组件以服务形式来提供, 网络延迟比单体高
    产品不是项目, 单体服务容易外包而微服务难以外包
    轻量级通信,独立进程, 如使用消息队列
    分散治理, 去中心化治理
    容错性设计
    会带来组织架构的调整
    20240604153101.webp
    服务简单,便于学习和上手,相对易于维护
    独立部署,灵活扩展
    技术栈丰富
    运维成本过高
    接口可能不匹配
    代码可能重复
    架构复杂度提高
    
<h1>微服务两大门派</h1>
Spring Cloud
    众多子项目
    spring cloud文档更多的是偏向整合
    类似品牌一体机,保证了一整套的兼容可靠
Dubbo
    高性能,轻量级的开源java RPC框架, 它提供了三大核心能力: 面向接口的远程方法调用, 智能容错和负载均衡, 以及服务自动注册和发现
    其它功能需要扩展组合, 类似组装电脑
        RPC（Remote Procedure Call 远程过程调用）框架是一种用于在不同网络节点之间调用服务的方法，使得程序能够像调用本地方法一样调用远程服务
        通信协议对比 RPC vs REST
            RPC通信效率更高(二进制传输), 但服务提供方与调用方接口依赖方式太强
    dubbo提供的能力是Spring Cloud的一部分子集
    dubbo是阿里的, 文档提供了中英两种版本

20240604154425.webp

HTTP和RPC
    IPC主要用于同一台机器上的进程间通信，而RPC则扩展到了网络上不同机器之间的通信
    通信模式：
        HTTP是一种无状态协议，每次请求都是独立的，服务器不会保存客户端的状态信息。
        RPC通常是一种有状态的通信模式，客户端和服务器之间建立了长连接，可以保持一段时间的状态信息，直到连接断开。
    通信方式：
        HTTP(Hypertext Transfer Protocol)是基于文本的协议，通过请求-响应模式进行通信，可以使用浏览器等工具进行调试和查看。
            其中序列化和反序列化导致的耗时是最主要的性能消耗
            负载均衡需要依赖第三方如nginx
        RPC通常是基于二进制的协议，通信效率更高，但不易直观地查看和调试。
            自带负载均衡功能
    使用场景：
        HTTP通常用于Web应用程序之间的通信，例如浏览器与服务器之间的通信。
        RPC通常用于分布式系统中，不同服务之间的通信，例如微服务架构中的服务间调用。

常见的rpc框架, gRPC, Apache Thrift, Apache Dubbo
 
<h1>不适合拆分的情况</h1>
项目的第一阶段的主要目标是快速开发和验证想法
然后进一步增加更多的新特性来吸引更多的目标用户
同时进行开发的人员超过10人,就该考虑进行服务化拆分了
流量不高,压力小,业务变化不大, 如企业内部oa
对延迟很敏感的低延迟高并发系统
小团队,技术基础薄弱

<h1>服务扩展</h1>
水平复制,功能解耦,数据分区(为有价值的vip用户提供更快的响应)
自动按需扩展, 根据cpu负载程度,特定时间例如周末,消息中间件的队列长度, 业务具体规则,预测等来决定是否扩展
自动分配一个新的服务器实例,提高可用性

<h1>微服务的重要模块</h1>
服务描述,注册中心
服务框架 
负载均衡 
熔断和降级
网关

<h1>Spring Cloud核心组件</h1>
20240604161057.webp

<h1>服务的注册与发现</h1>
Eureka 服务发现框架主要用于解决服务之间的动态 IP 地址变化和自动发现。在云计算环境中，特别是在容器化和微服务架构中，服务的 IP 地址可能会频繁变化，例如容器重启、弹性伸缩等情况。这就导致了传统的硬编码 IP 地址的方式不再适用，因此需要一种机制来实现服务之间的动态发现和通信。
Eureka 提供了一个中心化的服务注册表，服务端在启动时会向 Eureka 注册自己的信息，包括 IP 地址、端口号等。客户端则可以向 Eureka 查询服务的地址，而不是直接访问服务端的 IP 地址。这样一来，即使服务的 IP 地址发生变化，客户端仍然可以通过向 Eureka 查询来获取最新的服务地址，从而保证了服务之间的通信不受 IP 地址变化的影响。

Neffix开发的Eureka (尤瑞卡)
20240604222207.webp

集群, 非单点结构的Eureka server
20240604222513.webp

服务端
    注册服务：服务端将自己的服务注册到 Eureka 服务器上。这意味着服务端告诉 Eureka：“我在这里，我可以提供这个服务。”
    健康检查：服务端定期向 Eureka 发送健康检查请求，以确保自己仍然处于可用状态。如果服务端不再可用，它将从 Eureka 服务器中注销自己。
    提供服务信息：服务端向 Eureka 提供自己的元数据，例如主机名、端口号和其他与服务相关的信息。

客户端：
    获取服务：客户端向 Eureka 服务器发送请求，询问特定服务的位置。Eureka 服务器将返回一个或多个可用的服务端地址。
    负载均衡：客户端可以使用获得的多个服务端地址之一来调用服务。通常会使用负载均衡算法来选择其中一个服务端，以确保请求分布在不同的服务端之间。
    动态更新：客户端定期从 Eureka 服务器获取服务端列表的更新。这意味着如果有新的服务注册或现有服务注销，客户端将及时获取到这些变化。

Eureka 服务器：
    服务注册表：Eureka 服务器维护一个服务注册表，其中包含所有已注册的服务的信息。这个注册表是服务发现的核心。
    健康监测：Eureka 服务器负责监测服务的健康状态。如果服务长时间不响应或不可用，Eureka 将从注册表中移除该服务。
    提供服务信息：Eureka 服务器提供给客户端的是服务端的元数据，例如主机名、端口号等。

<h1>Feign和RestTemplate </h1>
Feign 是一个声明式的 HTTP 客户端，它通过接口和注解将方法调用映射到 HTTP 请求，从而简化了与其他微服务的通信, 不需要编写大量的模板代码
没有Feign的情况下，通常使用 RestTemplate 或其他HTTP客户端库来实现微服务之间的通信
Feign 的降级类用于在 Feign 客户端调用远程服务时出现故障时提供备用逻辑。主要用于处理 Feign 客户端的调用失败（例如，超时、服务不可用等）时的降级策略
20240815160709.webp
Feign的作用体现在第三步

<h1>负载均衡的两种类型</h1>
客户端负载均衡
    服务之间互相调用 
    客户端从服务发现系统（如 Eureka、Consul）获取服务实例列表，Ribbon根据负载均衡策略选择一个实例来处理请求
    不经过Nginx以免加长链路

服务端负载均衡
    用户调用
    客户端将请求发送到Nginx，Nginx根据负载均衡策略将请求转发到一个合适的服务实例

负载均衡策略
    RandomRule 随机
    RoundRobinRule 轮询
    ResponseTimeWeightedRule 加权, 根据每一个Server的平均响应时间动态加权

<h1>网关</h1>
网关可以将api请求路由到正确的位置, 还可以起到统一鉴权和其他一些重要作用
zuul需要将自己作为一个client在eureka上注册, 由此也获得了其它模块的服务信息, 其它模块只需记住网关的端口, 由网关根据服务名找到对应端口
通过zuul进行用户检验, 凡是通过检验的, 就可以直接访问后面的模块, 从而省去了各模块的冗余校验逻辑
20240606191306.webp

利用网关实现过滤器
    前置过滤器（Pre Filter）：在请求被转发到后端服务之前执行。
    路由过滤器（Route Filter）：在请求路由到具体服务之前执行（大多数情况下由 Zuul 默认实现，通常不需要自定义）。
    后置过滤器（Post Filter）：在请求从后端服务返回响应之后执行。
    错误过滤器（Error Filter）：当发生错误时执行（例如，服务不可用时）error 过滤器是在其他所有类型的过滤器（pre、route、post）之后执行的
        用来处理在路由、转发、过滤等过程中遇到的错误
ZuulFilter 接口方法：
    filterType(): 返回过滤器的类型（前置、路由、后置或错误）。
    filterOrder(): 同一类型的过滤器中，filterOrder 的数值决定了它们的执行顺序, 数值越小，优先级越高
    shouldFilter(): 返回一个布尔值，指示是否应该执行这个过滤器。
    run(): 过滤器的具体逻辑
</pre>
</body>
</html>
