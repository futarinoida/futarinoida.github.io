<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=1920, initial-scale=1.0">
  <link rel="stylesheet" href="../css/content.css"></style>
  <script src="../js/content.js"></script>
  <title>基本运算</title>
</head>
<body><span id="anchor">20240616183123-_java</span>
<pre>
<h1>数字类型</h1>
int octal = 037; //int类型变量存放八进制数
long longNumber = 0xa2cdf3ffL; //长整型变量存放十六进制数
double d = 47e47 //指数记数4.7E48
float f = 1.39e-43f //1.39E-43
float和double转化为int时,总是对该数字截尾,如需舍入需调用Math.round()

<h1>默认值</h1>
基本数据类型：
    byte: 0
    short: 0
    int: 0
    long: 0L
    float: 0.0f
    double: 0.0d
    char: '\u0000' (空字符)
    boolean: false
引用类型：
    null

<h1>原码</h1>
符号位加上真值的绝对值
[+1]原= 0000 0001
[-1]原= 1000 0001
有符号的8位二进制数的取值范围(第一位不表示值，只表示正负)为[1111 1111 , 0111 1111],即[-127 , 127]

<h1>反码</h1>
正数的反码是其本身
负数的反码是在其原码的基础上，符号位不变，其余各个位取反。
[+1] = [0000 0001]原= [0000 0001]反
[-1] = [1000 0001]原= [1111 1110]反

<h1>补码</h1>
正数的补码就是其本身
负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)
[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补
[-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补

<h1>机器数</h1>
无符号的二进制8位范围从00000000－11111111，即0到255
一位16进制数最多只表示到15（16进制的F,2进制的1111），要表示到255，就还需要第二位

一个数在计算机中的二进制表示形式,叫做这个数的机器数,机器数是带符号的,最高位存放符号,正0负1
计算机字长为8位时,十进制转机器数
+3 为 0000 0011, 真值为 +000 0011
-3 为 1000 0011, 真值为 -000 0011, 真正数值是-3,而非形式值131(1000 0011l转十进制为131)
对于一个数，计算机要使用一定的编码方式进行存储，原码、反码、补码是机器存储一个具体数字的编码方式

计算机可以有三种编码方式表示一个数
对于正数因为三种编码方式结果都相同
[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补
对于负数原码反码和补码是完全不同的
[-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补

原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？
因为人可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。
但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单，计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂
于是人们想出了将符号位也参与运算的方法。
我们知道，根据运算法则减去一个正数等于加上一个负数，即：1-1 = 1 + (-1) = 0， 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。
于是人们开始探索将符号位参与运算，并且只保留加法的方法。

计算十进制的表达式：
    1 - 1 = 0
如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。
    1 - 1
    = 1 + (-1)
    = [0000 0001]原+ [1000 0001]原
    = [1000 0010]原
    = -2

为了解决原码做减法的问题， 出现了反码：
    1 - 1
    = 1 + (-1)
    = [0000 0001]原+ [1000 0001]原
    = [0000 0001]反+ [1111 1110]反
    = [1111 1111]反
    = [1000 0000]原
    = -0
用反码计算减法，结果的真值部分是正确的。
而唯一的问题其实就出现在"0"这个特殊的数值上
虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。

于是补码的出现，解决了0的符号问题以及0的两个编码问题：
    1-1
    = 1 + (-1)
    = [0000 0001]原+ [1000 0001]原
    = [0000 0001]补+ [1111 1111]补
    = [1 0000 0000]补
    = [0000 0000]补
    = [0000 0000]原 注意：进位1不在计算机字长里。
这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。
而且可以用[1000 0000]表示-128：-128的由来如下：
    (-1) + (-127)
    = [1000 0001]原+ [1111 1111]原
    = [1111 1111]补+ [1000 0001]补
    = [1000 0000]补
-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补就是-128，
但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。
(对-128的补码表示[1000 0000]补，算出来的原码是[0000 0000]原，这是不正确的)

使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。
这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。
由于0的特殊情况，没有办法表示128，所以补码的取值范围是[-128, 127]
因为机器使用补码，所以对于编程中常用到的有符号的32位int类型，可以表示范围是: [-231, 231-1]
因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。

<h1>取反</h1>
对n(正数负数和零均适用)按位取反,得到的结果为 -(n+1)

~10
原码 0000 1010
补码 0000 1010
取反 1111 0101
由于符号位是1，系统认为这是一个负数的补码
负数输出时，先将补码减一得1111 0100，再取反得1000 1011
结果为-11

~（-5）
原码 1000 0101
补码 1111 1011
取反 0000 0100
由于符号位是0，系统认为这是一个正数的补码
正数补码即原码，最终输出0000 0100
结果为4

使一个数的最低位为零，可以表示为：n&amp;~1。
~1的值为1111111111111110，再按“与”运算，最低位一定为0。
因为“~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

<h1>除法</h1>
13/5=2 //分子分母均为整数时,结果为整除后的结果
13.0/5=2.6
3*0.1 == 0.3 //false
浮点数不能完全精确的表示出来.
由于小数的运算可能导致精度丢失问题，那么要解决这个问题，可以将其转换为整数后再进行运算，运算后再转换为对应的小数
int a = (int) (3 * 0.1 * 1000);
int b = (int) (0.3 * 1000);
System.out.println(a == b);// true

<h1>移位</h1>
&lt;&lt; 左移位,低位补0
若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。12&lt;&lt;1为24
&gt;&gt; 有符号右移,若符号为正,则高位插入0,负插入1
操作数每右移一位，相当于该数除以2。12&gt;&gt;1为6
&gt;&gt;&gt; 无符号右移,无论正负,都在高位插入0

int型的移位右操作数介于0~31，任何int数移32位还是本身。
long型的移位右操作数介于0~63，任何long数移64位还是本身。

对于char,byte,short类型的数值在移位前会被转为int类型, 并且得到的结果也是一个int类型的值
若对一个long类型值进行处理,最后得到的结果也是long

&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;=,与等号联用,操作符左边的值会移动由右边的值指定的位数,再将得到的结果赋给左边的变量
int n = 2;n&lt;&lt;=3; //n=16
在进行无符号右移位结合赋值操作时,会遇到如果对byte,short值进行这样的移位运算,得到的可能不是正确的结果,
它们会先被转成int,再进行右移操作,然后被截断,赋值给原来的类型

7*8可写为 7&lt;&lt;3; 2的3次方为8
5*16可写为 5&lt;&lt;4; 2的4次方为16

<h1>等号</h1>
+=操作符会进行隐式自动类型转换,会对右边的表达式结果强转匹配左边的数据类型
&amp;=,|=,^=都是合法的,~(取反)由于是一元操作符所以不可与=联用
浮点数与整数进行比较(5.0f和5),只要值相等就返回true
具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。

</pre>
</body>
</html>
